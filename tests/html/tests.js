(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else {
		var a = factory();
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	(function() { /* Start undefined extensions */
/******/ 			function mix(dest, src) { // eslint-disable-line no-unused-vars
/******/ 				for(var n in src) dest[n] = src[n];
/******/ 				return src;
/******/ 			}
/******/
/******/ 			function toUrl(name, referenceModule) {
/******/ 				return loaderScope.require.toUrl(name, referenceModule);
/******/ 			}
/******/
/******/ 			function toAbsMid(name, referenceModule) {
/******/ 				return loaderScope.require.toAbsMid(name, referenceModule);
/******/ 			}
/******/
/******/ 			// dojo require function.
/******/ 			function req(config, dependencies, callback) {
/******/ 				return contextRequire(config, dependencies, callback, 0, req);
/******/ 			};
/******/
/******/ 			function createContextRequire(moduleId) { // eslint-disable-line no-unused-vars
/******/ 				if (req.absMidsById[moduleId]) {
/******/ 					moduleId = req.absMidsById[moduleId];
/******/ 				}
/******/ 				if (!moduleId) return req;
/******/ 				var result = function(a1, a2, a3) {
/******/ 					return contextRequire(a1, a2, a3, moduleId, req);
/******/ 				};
/******/ 				for (var p in req) {
/******/ 					if (req.hasOwnProperty(p)) {
/******/ 						result[p] = req[p];
/******/ 					}
/******/ 				}
/******/ 				result.toUrl = function(name) {
/******/ 					return toUrl(name, moduleId ? {mid: moduleId} : null);
/******/ 				};
/******/ 				result.toAbsMid = function(name) {
/******/ 					return toAbsMid(name, moduleId ? {mid: moduleId} : null);
/******/ 				};
/******/
/******/ 				if (req.undef) {
/******/ 					result.undef = function(mid) {
/******/ 						req.undef(mid, moduleId);
/******/ 					};
/******/ 				}
/******/ 				return result;
/******/ 			}
/******/
/******/ 			function registerAbsMids(absMids) { // eslint-disable-line no-unused-vars
/******/ 				for (var s in absMids) {
/******/ 					req.absMids[s] = absMids[s];
/******/ 					req.absMidsById[absMids[s]] = s;
/******/ 				}
/******/ 			}
/******/
/******/ 			function resolveTernaryHasExpression(expr) { // eslint-disable-line no-unused-vars
/******/ 				// Expects an expression of the form supported by dojo/has.js loader, except that module identifiers are
/******/ 				// integers corresponding to webpack module ids.  Returns a module reference if evaluation of the expression
/******/ 				// using the currently defined features returns a module id, or else undefined.
/******/
/******/ 				var has = req("dojo/has");
/******/ 				var id = has.normalize(expr, function(arg){return arg;});
/******/ 				return id && __webpack_require__(id) || undefined;
/******/ 			}
/******/
/******/ 			function findModule(mid, referenceModule, noInstall, asModuleObj) {
/******/ 				mid = mid.split("!").map(function(segment) {
/******/ 					var isRelative = segment.charAt(0) === '.';
/******/ 					if(isRelative && !referenceModule){
/******/ 						return mid;
/******/ 					}
/******/ 					return toAbsMid(segment, referenceModule ? {mid: referenceModule} : null);
/******/ 				}).join("!");
/******/ 				var result;
/******/ 				if (mid in req.absMids && __webpack_require__.m[req.absMids[mid]]) {
/******/ 					if (noInstall) {
/******/ 						var module = installedModules[req.absMids[mid]];
/******/ 						result = module && module.l && (asModuleObj ? module : module.exports);
/******/ 					} else {
/******/ 						result = __webpack_require__(req.absMids[mid]);
/******/ 					}
/******/ 				}
/******/ 				if (!result) {
/******/ 					throw new Error('Module not found: ' + mid);
/******/ 				}
/******/ 				return result;
/******/ 			}
/******/
/******/ 			function dojoModuleFromWebpackModule(webpackModule) { // eslint-disable-line no-unused-vars
/******/ 				var result = {exports: webpackModule.exports};
/******/ 				var id = webpackModule.i;
/******/ 				if (req.absMidsById[id]) {
/******/ 					id = req.absMidsById[id];
/******/ 				}
/******/ 				result.i = result.id = id;
/******/ 				return result;
/******/ 			}
/******/
/******/ 			function contextRequire(a1, a2, a3, referenceModule, req) { // eslint-disable-line no-shadow
/******/ 				var type = ({}.toString).call(a1);
/******/ 				if (type === '[object String]') {
/******/ 					// a3 is passed by require calls injected into dependency arrays for dependencies specified
/******/ 					// as identifiers (vs. string literals).
/******/ 					var noInstall = !(a3 === false);
/******/ 					return findModule(a1, referenceModule, noInstall);
/******/ 				} else if (type === '[object Object]') {
/******/ 					throw new Error('Require config is not supported by WebPack');
/******/ 				}
/******/ 				if (type === '[object Array]') {
/******/ 					var modules = [], callback = a2, errors = [];
/******/ 					a1.forEach(function (mid) {
/******/ 						try {
/******/ 							modules.push(findModule(mid, referenceModule));
/******/ 						} catch (e) {
/******/ 							errors.push({mid: mid, error: e});
/******/ 						}
/******/ 					});
/******/ 					if (callback && errors.length === 0) {
/******/ 						callback.apply(this, modules);
/******/ 					} else {
/******/ 						var error = new Error("findModules");
/******/ 						error.src = "dojo-webpack-plugin";
/******/ 						error.info = errors;
/******/ 						req.signal("error", error);
/******/ 					}
/******/ 					return req;
/******/ 				} else {
/******/ 					throw new Error('Unsupported require call');
/******/ 				}
/******/ 			}
/******/ 			req.toUrl = toUrl;
/******/ 			req.toAbsMid = toAbsMid;
/******/ 			req.absMids = {};
/******/ 			req.absMidsById = [];
/******/ 			req.async = 1;
/******/ 		var globalObj = this||window;
/******/ 		registerAbsMids({
/******/ 			// /tmp/tmp-18572u2v83c7ofeCs/dojo/dojo.js = "../../../../../tmp/tmp-18572u2v83c7ofeCs/dojo/dojo.js"
/******/ 			// ./Auth = "./Auth.js"
/******/ 			// ./Cache = "./Cache.js"
/******/ 			// ./Context = "./Context.js"
/******/ 			// ./Entry = "./Entry.js"
/******/ 			// ./EntryInfo = "./EntryInfo.js"
/******/ 			// ./EntryStore = "./EntryStore.js"
/******/ 			// ./EntryStoreUtil = "./EntryStoreUtil.js"
/******/ 			// ./File = "./File.js"
/******/ 			// ./Graph = "./Graph.js"
/******/ 			// ./Group = "./Group.js"
/******/ 			// ./List = "./List.js"
/******/ 			// ./Pipeline = "./Pipeline.js"
/******/ 			// ./PrototypeEntry = "./PrototypeEntry.js"
/******/ 			// ./Resource = "./Resource.js"
/******/ 			// ./Rest = "./Rest.js"
/******/ 			// ./SearchList = "./SearchList.js"
/******/ 			// ./SolrQuery = "./SolrQuery.js"
/******/ 			// ./String = "./String.js"
/******/ 			// ./User = "./User.js"
/******/ 			// ./factory = "./factory.js"
/******/ 			// ./html = "./html.js"
/******/ 			// ../ = "./index.js"
/******/ 			'/home/scott/dev/meta/entrystore.js/libs/dojo/_base/array':"./libs/dojo/_base/array.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/libs/dojo/_base/config':"./libs/dojo/_base/config.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/libs/dojo/_base/kernel':"./libs/dojo/_base/kernel.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/libs/dojo/_base/lang':"./libs/dojo/_base/lang.js",
/******/ 			// ../libs/dojo/date/stamp = "./libs/dojo/date/stamp.js"
/******/ 			'/home/scott/dev/meta/entrystore.js/libs/dojo/has':"./libs/dojo/has.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/libs/dojo/sniff':"./libs/dojo/sniff.js",
/******/ 			// blueimp-md5 = "./node_modules/blueimp-md5/js/md5.js"
/******/ 			// component-emitter = "./node_modules/component-emitter/index.js"
/******/ 			// /home/scott/dev/meta/entrystore.js/node_modules/dojo-webpack-plugin/lib/NoModule.js = "./node_modules/dojo-webpack-plugin/lib/NoModule.js"
/******/ 			// dojo/Deferred = "./node_modules/dojo/Deferred.js"
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/Evented':"./node_modules/dojo/Evented.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/_base/array':"./node_modules/dojo/_base/array.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/_base/config':"./node_modules/dojo/_base/config.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/_base/kernel':"./node_modules/dojo/_base/kernel.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/_base/lang':"./node_modules/dojo/_base/lang.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/aspect':"./node_modules/dojo/aspect.js",
/******/ 			// dojo/date/stamp = "./node_modules/dojo/date/stamp.js"
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/errors/CancelError':"./node_modules/dojo/errors/CancelError.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/errors/create':"./node_modules/dojo/errors/create.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/global':"./node_modules/dojo/global.js",
/******/ 			'dojo/has':"./node_modules/dojo/has.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/has':"./node_modules/dojo/has.js",
/******/ 			// dojo/json = "./node_modules/dojo/json.js"
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/on':"./node_modules/dojo/on.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/promise/Promise':"./node_modules/dojo/promise/Promise.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/promise/instrumentation':"./node_modules/dojo/promise/instrumentation.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/promise/tracer':"./node_modules/dojo/promise/tracer.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/dojo/sniff':"./node_modules/dojo/sniff.js",
/******/ 			// rdfjson/Graph = "./node_modules/rdfjson/Graph.js"
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/rdfjson/Statement':"./node_modules/rdfjson/Statement.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/rdfjson/formats/rdfjson/util':"./node_modules/rdfjson/formats/rdfjson/util.js",
/******/ 			'/home/scott/dev/meta/entrystore.js/node_modules/rdfjson/namespaces':"./node_modules/rdfjson/namespaces.js"
/******/ 			// rdfjson/print = "./node_modules/rdfjson/print.js"
/******/ 			// superagent-jsonp = "./node_modules/superagent-jsonp/dist/superagent-jsonp.js"
/******/ 			// ./agent-base = "./node_modules/superagent/lib/agent-base.js"
/******/ 			// superagent = "./node_modules/superagent/lib/client.js"
/******/ 			// ./is-object = "./node_modules/superagent/lib/is-object.js"
/******/ 			// ./request-base = "./node_modules/superagent/lib/request-base.js"
/******/ 			// ./response-base = "./node_modules/superagent/lib/response-base.js"
/******/ 			// ./utils = "./node_modules/superagent/lib/utils.js"
/******/ 			// ./node_modules/webpack/buildin/harmony-module.js = "./node_modules/webpack/buildin/harmony-module.js"
/******/ 			// package.json = "./package.json"
/******/ 			// ./promiseUtil = "./promiseUtil.js"
/******/ 			// ./terms = "./terms.js"
/******/ 			// ./Auth = "./tests/Auth.js"
/******/ 			// ./Cache = "./tests/Cache.js"
/******/ 			// ./Entry = "./tests/Entry.js"
/******/ 			// ./EntryInfo = "./tests/EntryInfo.js"
/******/ 			// ./EntryStore = "./tests/EntryStore.js"
/******/ 			// ./File = "./tests/File.js"
/******/ 			// ./List = "./tests/List.js"
/******/ 			// ./Pipeline = "./tests/Pipeline.js"
/******/ 			// ./config = "./tests/config.js"
/******/ 			// ./tests/executeAllTests.js = "./tests/executeAllTests.js"
/******/ 			// ./solr = "./tests/solr.js"
/******/ 			// ./types = "./types.js"
/******/ 			// ./utils = "./utils.js"
/******/ 		});
/******/
/******/ 		globalObj.require = req;
/******/
/******/ 		// expose the Dojo compatibility functions as a properties of __webpack_require__
/******/ 		if (__webpack_require__.dj) throw new Error("__webpack_require__.dj name collision.")
/******/ 		__webpack_require__.dj = {
/******/ 			r: req,
/******/ 			c: createContextRequire,
/******/ 			m: dojoModuleFromWebpackModule,
/******/ 			h: resolveTernaryHasExpression
/******/ 		};
/******/ 		var loaderScope = {document:globalObj.document};
/******/ 		loaderScope.global = loaderScope.window = loaderScope;
/******/ 		globalObj.dojoConfig = globalObj.dojoConfig || {}
/******/ 		var userConfig = mix(globalObj.dojoConfig, ({'baseUrl':'.','async':true,'has':({'dojo-config-api':0}),'fixupUrl':(function (url) {
/******/ 		      // Load the uncompressed versions of dojo/dijit/dojox javascript files when using the dojo loader.
/******/ 		      // When using a webpack build, the dojo loader is not used for loading javascript files so this
/******/ 		      // property has no effect.  This is only needed because we're loading Dojo from a CDN for this
/******/ 		      // demo.  In a normal development envorinment, Dojo would be installed locally and this wouldn't
/******/ 		      // be needed.
/******/ 		      //if (/\/(dojo|dijit|dojox)\/.*\.js$/.test(url)) {
/******/ 		        //url += '.uncompressed.js';
/******/ 		      //}
/******/ 		      return url;
/******/ 		    })}));
/******/ 		var defaultConfig = ({'hasCache':({'webpack':1,'host-browser':1,'dom':1,'dojo-loader':1,'dojo-has-api':1,'dojo-dom-ready-api':1,'dojo-sniff':1,'dojo-test-sniff':1,'config-deferredInstrumentation':1,'config-tlmSiblingOfDojo':1}),'paths':({'js':'js','theme':'theme','css':'//chuckdumont.github.io/dojo-css-plugin/1.0.0/css','lesspp':'//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min'}),'pathsMapProg':[['lesspp','//cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min',/^lesspp(\/|$)/,6],['theme','theme',/^theme(\/|$)/,5],['css','//chuckdumont.github.io/dojo-css-plugin/1.0.0/css',/^css(\/|$)/,3],['js','js',/^js(\/|$)/,2]],'packs':({'dojo':({'main':'main','name':'dojo','location':'undefined/dojo','lib':'.'}),'spa':({'main':'main','name':'spa','location':'../..'})}),'aliases':[],'mapProgs':[],'cacheBust':undefined,'modules':({}),'cache':({})});
/******/ 		var dojoLoader = __webpack_require__("../../../../../tmp/tmp-18572u2v83c7ofeCs/dojo/dojo.js");
/******/ 		dojoLoader.call(loaderScope, userConfig, defaultConfig, loaderScope, loaderScope);
/******/ 		loaderScope.require.baseUrl = "./";
/******/ 		['baseUrl','has','rawConfig','on','signal'].forEach(function(name) {req[name] = loaderScope.require[name]})
/******/ 	})(); /* End undefined extensions */
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./tests/executeAllTests.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../tmp/tmp-18572u2v83c7ofeCs/dojo/dojo.js":
/*!***********************************************!*\
  !*** /tmp/tmp-18572u2v83c7ofeCs/dojo/dojo.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = function(userConfig, defaultConfig, global, window) { this.loaderVersion = \"1.13.0\"; (function(\n\tuserConfig,\n\tdefaultConfig\n){\n\t// summary:\n\t//\t\tThis is the \"source loader\" and is the entry point for Dojo during development. You may also load Dojo with\n\t//\t\tany AMD-compliant loader via the package main module dojo/main.\n\t// description:\n\t//\t\tThis is the \"source loader\" for Dojo. It provides an AMD-compliant loader that can be configured\n\t//\t\tto operate in either synchronous or asynchronous modes. After the loader is defined, dojo is loaded\n\t//\t\tIAW the package main module dojo/main. In the event you wish to use a foreign loader, you may load dojo as a package\n\t//\t\tvia the package main module dojo/main and this loader is not required; see dojo/package.json for details.\n\t//\n\t//\t\tIn order to keep compatibility with the v1.x line, this loader includes additional machinery that enables\n\t//\t\tthe dojo.provide, dojo.require et al API. This machinery is loaded by default, but may be dynamically removed\n\t//\t\tvia the has.js API and statically removed via the build system.\n\t//\n\t//\t\tThis loader includes sniffing machinery to determine the environment; the following environments are supported:\n\t//\n\t//\t\t- browser\n\t//\t\t- node.js\n\t//\t\t- rhino\n\t//\n\t//\t\tThis is the so-called \"source loader\". As such, it includes many optional features that may be discarded by\n\t//\t\tbuilding a customized version with the build system.\n\n\t// Design and Implementation Notes\n\t//\n\t// This is a dojo-specific adaption of bdLoad, donated to the dojo foundation by Altoviso LLC.\n\t//\n\t// This function defines an AMD-compliant (http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition)\n\t// loader that can be configured to operate in either synchronous or asynchronous modes.\n\t//\n\t// Since this machinery implements a loader, it does not have the luxury of using a load system and/or\n\t// leveraging a utility library. This results in an unpleasantly long file; here is a road map of the contents:\n\t//\n\t//\t 1. Small library for use implementing the loader.\n\t//\t 2. Define the has.js API; this is used throughout the loader to bracket features.\n\t//\t 3. Define the node.js and rhino sniffs and sniff.\n\t//\t 4. Define the loader's data.\n\t//\t 5. Define the configuration machinery.\n\t//\t 6. Define the script element sniffing machinery and sniff for configuration data.\n\t//\t 7. Configure the loader IAW the provided user, default, and sniffing data.\n\t//\t 8. Define the global require function.\n\t//\t 9. Define the module resolution machinery.\n\t//\t10. Define the module and plugin module definition machinery\n\t//\t11. Define the script injection machinery.\n\t//\t12. Define the window load detection.\n\t//\t13. Define the logging API.\n\t//\t14. Define the tracing API.\n\t//\t16. Define the AMD define function.\n\t//\t17. Define the dojo v1.x provide/require machinery--so called \"legacy\" modes.\n\t//\t18. Publish global variables.\n\t//\n\t// Language and Acronyms and Idioms\n\t//\n\t// moduleId: a CJS module identifier, (used for public APIs)\n\t// mid: moduleId (used internally)\n\t// packageId: a package identifier (used for public APIs)\n\t// pid: packageId (used internally); the implied system or default package has pid===\"\"\n\t// pack: package is used internally to reference a package object (since javascript has reserved words including \"package\")\n\t// prid: plugin resource identifier\n\t// The integer constant 1 is used in place of true and 0 in place of false.\n\n\t// define global\n\tvar globalObject = (function(){\n\t\tif (typeof global !== 'undefined' && typeof global !== 'function') {\n\t\t\t// global spec defines a reference to the global object called 'global'\n\t\t\t// https://github.com/tc39/proposal-global\n\t\t\t// `global` is also defined in NodeJS\n\t\t\treturn global;\n\t\t}\n\t\telse if (typeof window !== 'undefined') {\n\t\t\t// window is defined in browsers\n\t\t\treturn window;\n\t\t}\n\t\telse if (typeof self !== 'undefined') {\n\t\t\t// self is defined in WebWorkers\n\t\t\treturn self;\n\t\t}\n\t\treturn this;\n\t})();\n\n\t// define a minimal library to help build the loader\n\tvar\tnoop = function(){\n\t\t},\n\n\t\tisEmpty = function(it){\n\t\t\tfor(var p in it){\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn 1;\n\t\t},\n\n\t\ttoString = {}.toString,\n\n\t\tisFunction = function(it){\n\t\t\treturn toString.call(it) == \"[object Function]\";\n\t\t},\n\n\t\tisString = function(it){\n\t\t\treturn toString.call(it) == \"[object String]\";\n\t\t},\n\n\t\tisArray = function(it){\n\t\t\treturn toString.call(it) == \"[object Array]\";\n\t\t},\n\n\t\tforEach = function(vector, callback){\n\t\t\tif(vector){\n\t\t\t\tfor(var i = 0; i < vector.length;){\n\t\t\t\t\tcallback(vector[i++]);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmix = function(dest, src){\n\t\t\tfor(var p in src){\n\t\t\t\tdest[p] = src[p];\n\t\t\t}\n\t\t\treturn dest;\n\t\t},\n\n\t\tmakeError = function(error, info){\n\t\t\treturn mix(new Error(error), {src:\"dojoLoader\", info:info});\n\t\t},\n\n\t\tuidSeed = 1,\n\n\t\tuid = function(){\n\t\t\t// Returns a unique identifier (within the lifetime of the document) of the form /_d+/.\n\t\t\treturn \"_\" + uidSeed++;\n\t\t},\n\n\t\t// FIXME: how to doc window.require() api\n\n\t\t// this will be the global require function; define it immediately so we can start hanging things off of it\n\t\treq = function(\n\t\t\tconfig,\t\t  //(object, optional) hash of configuration properties\n\t\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before applying callback\n\t\t\tcallback\t  //(function, optional) lambda expression to apply to module values implied by dependencies\n\t\t){\n\t\t\treturn contextRequire(config, dependencies, callback, 0, req);\n\t\t},\n\n\t\t// the loader uses the has.js API to control feature inclusion/exclusion; define then use throughout\n\t\tglobal = globalObject,\n\n\t\tdoc = global.document,\n\n\t\telement = doc && doc.createElement(\"DiV\"),\n\n\t\thas = req.has = function(name){\n\t\t\treturn isFunction(hasCache[name]) ? (hasCache[name] = hasCache[name](global, doc, element)) : hasCache[name];\n\t\t},\n\n\t\thasCache = has.cache = defaultConfig.hasCache;\n\n\tif (isFunction(userConfig)) {\n\t\tuserConfig = userConfig(globalObject);\n\t}\n\n\thas.add = function(name, test, now, force){\n\t\t(hasCache[name]===undefined || force) && (hasCache[name] = test);\n\t\treturn now && has(name);\n\t};\n\n\t 0 && has.add(\"host-node\", userConfig.has && \"host-node\" in userConfig.has ?\n\t\tuserConfig.has[\"host-node\"] :\n\t\t(typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\tif( 0 ){}\n\n\t 0 && has.add(\"host-rhino\", userConfig.has && \"host-rhino\" in userConfig.has ?\n\t\tuserConfig.has[\"host-rhino\"] :\n\t\t(typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\tif( 0 ){ var baseUrl, arg, rhinoArgs, i; }\n\n\t 0 && has.add(\"host-webworker\", ((typeof WorkerGlobalScope !== 'undefined') && (self instanceof WorkerGlobalScope)));\n\tif( 0 ){}\n\n\t// userConfig has tests override defaultConfig has tests; do this after the environment detection because\n\t// the environment detection usually sets some has feature values in the hasCache.\n\tfor(var p in userConfig.has){\n\t\thas.add(p, userConfig.has[p], 0, 1);\n\t}\n\n\t//\n\t// define the loader data\n\t//\n\n\t// the loader will use these like symbols if the loader has the traceApi; otherwise\n\t// define magic numbers so that modules can be provided as part of defaultConfig\n\tvar\trequested = 1,\n\t\tarrived = 2,\n\t\tnonmodule = 3,\n\t\texecuting = 4,\n\t\texecuted = 5;\n\n\tif( 0 ){}\n\n\tvar legacyMode = 0,\n\t\tsync = \"sync\",\n\t\txd = \"xd\",\n\t\tsyncExecStack = [],\n\t\tdojoRequirePlugin = 0,\n\t\tcheckDojoRequirePlugin = noop,\n\t\ttransformToAmd = noop,\n\t\tgetXhr;\n\tif( 0 ){ var XMLHTTP_PROGIDS, progid, i, locationProtocol, locationHost; }else{\n\t\treq.async = 1;\n\t}\n\n\t//\n\t// loader eval\n\t//\n\tvar eval_ =   1  ?\n\t\t// noop eval if there are csp restrictions\n\t\tfunction(){} :\n\t\t// use the function constructor so our eval is scoped close to (but not in) in the global space with minimal pollution\n\t\tundefined;\n\n\treq.eval =\n\t\tfunction(text, hint){\n\t\t\treturn eval_(text + \"\\r\\n//# sourceURL=\" + hint);\n\t\t};\n\n\t//\n\t// loader micro events API\n\t//\n\tvar listenerQueues = {},\n\t\terror = \"error\",\n\t\tsignal = req.signal = function(type, args){\n\t\t\tvar queue = listenerQueues[type];\n\t\t\t// notice we run a copy of the queue; this allows listeners to add/remove\n\t\t\t// other listeners without affecting this particular signal\n\t\t\tforEach(queue && queue.slice(0), function(listener){\n\t\t\t\tlistener.apply(null, isArray(args) ? args : [args]);\n\t\t\t});\n\t\t},\n\t\ton = req.on = function(type, listener){\n\t\t\t// notice a queue is not created until a client actually connects\n\t\t\tvar queue = listenerQueues[type] || (listenerQueues[type] = []);\n\t\t\tqueue.push(listener);\n\t\t\treturn {\n\t\t\t\tremove:function(){\n\t\t\t\t\tfor(var i = 0; i<queue.length; i++){\n\t\t\t\t\t\tif(queue[i]===listener){\n\t\t\t\t\t\t\tqueue.splice(i, 1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\n\t// configuration machinery; with an optimized/built defaultConfig, all configuration machinery can be discarded\n\t// lexical variables hold key loader data structures to help with minification; these may be completely,\n\t// one-time initialized by defaultConfig for optimized/built versions\n\tvar\n\t\taliases\n\t\t\t// a vector of pairs of [regexs or string, replacement] => (alias, actual)\n\t\t\t= [],\n\n\t\tpaths\n\t\t\t// CommonJS paths\n\t\t\t= {},\n\n\t\tpathsMapProg\n\t\t\t// list of (from-path, to-path, regex, length) derived from paths;\n\t\t\t// a \"program\" to apply paths; see computeMapProg\n\t\t\t= [],\n\n\t\tpacks\n\t\t\t// a map from packageId to package configuration object; see fixupPackageInfo\n\t\t\t= {},\n\n\t\tmap = req.map\n\t\t\t// AMD map config variable; dojo/_base/kernel needs req.map to figure out the scope map\n\t\t\t= {},\n\n\t\tmapProgs\n\t\t\t// vector of quads as described by computeMapProg; map-key is AMD map key, map-value is AMD map value\n\t\t\t= [],\n\n\t\tmodules\n\t\t\t// A hash:(mid) --> (module-object) the module namespace\n\t\t\t//\n\t\t\t// pid: the package identifier to which the module belongs (e.g., \"dojo\"); \"\" indicates the system or default package\n\t\t\t// mid: the fully-resolved (i.e., mappings have been applied) module identifier without the package identifier (e.g., \"dojo/io/script\")\n\t\t\t// url: the URL from which the module was retrieved\n\t\t\t// pack: the package object of the package to which the module belongs\n\t\t\t// executed: 0 => not executed; executing => in the process of traversing deps and running factory; executed => factory has been executed\n\t\t\t// deps: the dependency vector for this module (vector of modules objects)\n\t\t\t// def: the factory for this module\n\t\t\t// result: the result of the running the factory for this module\n\t\t\t// injected: (0 | requested | arrived) the status of the module; nonmodule means the resource did not call define\n\t\t\t// load: plugin load function; applicable only for plugins\n\t\t\t//\n\t\t\t// Modules go through several phases in creation:\n\t\t\t//\n\t\t\t// 1. Requested: some other module's definition or a require application contained the requested module in\n\t\t\t//\t  its dependency vector or executing code explicitly demands a module via req.require.\n\t\t\t//\n\t\t\t// 2. Injected: a script element has been appended to the insert-point element demanding the resource implied by the URL\n\t\t\t//\n\t\t\t// 3. Loaded: the resource injected in [2] has been evaluated.\n\t\t\t//\n\t\t\t// 4. Defined: the resource contained a define statement that advised the loader about the module. Notice that some\n\t\t\t//\t  resources may just contain a bundle of code and never formally define a module via define\n\t\t\t//\n\t\t\t// 5. Evaluated: the module was defined via define and the loader has evaluated the factory and computed a result.\n\t\t\t= {},\n\n\t\tcacheBust\n\t\t\t// query string to append to module URLs to bust browser cache\n\t\t\t= \"\",\n\n\t\tcache\n\t\t\t// hash:(mid | url)-->(function | string)\n\t\t\t//\n\t\t\t// A cache of resources. The resources arrive via a config.cache object, which is a hash from either mid --> function or\n\t\t\t// url --> string. The url key is distinguished from the mid key by always containing the prefix \"url:\". url keys as provided\n\t\t\t// by config.cache always have a string value that represents the contents of the resource at the given url. mid keys as provided\n\t\t\t// by configl.cache always have a function value that causes the same code to execute as if the module was script injected.\n\t\t\t//\n\t\t\t// Both kinds of key-value pairs are entered into cache via the function consumePendingCache, which may relocate keys as given\n\t\t\t// by any mappings *iff* the config.cache was received as part of a module resource request.\n\t\t\t//\n\t\t\t// Further, for mid keys, the implied url is computed and the value is entered into that key as well. This allows mapped modules\n\t\t\t// to retrieve cached items that may have arrived consequent to another namespace.\n\t\t\t//\n\t\t\t = {},\n\n\t\turlKeyPrefix\n\t\t\t// the prefix to prepend to a URL key in the cache.\n\t\t\t= \"url:\",\n\n\t\tpendingCacheInsert\n\t\t\t// hash:(mid)-->(function)\n\t\t\t//\n\t\t\t// Gives a set of cache modules pending entry into cache. When cached modules are published to the loader, they are\n\t\t\t// entered into pendingCacheInsert; modules are then pressed into cache upon (1) AMD define or (2) upon receiving another\n\t\t\t// independent set of cached modules. (1) is the usual case, and this case allows normalizing mids given in the pending\n\t\t\t// cache for the local configuration, possibly relocating modules.\n\t\t\t = {},\n\n\t\tdojoSniffConfig\n\t\t\t// map of configuration variables\n\t\t\t// give the data-dojo-config as sniffed from the document (if any)\n\t\t\t= {},\n\n\t\tinsertPointSibling\n\t\t\t// the nodes used to locate where scripts are injected into the document\n\t\t\t= 0;\n\n\tif( 0 ){ var doh, scripts, i, script, dojoDir, src, match, consumePendingCacheInsert, escapeString, computeMapProg, computeAliases, fixupPackageInfo, delayedModuleConfig, config; }else{\n\t\t// no config API, assume defaultConfig has everything the loader needs...for the entire lifetime of the application\n\t\tpaths = defaultConfig.paths;\n\t\tpathsMapProg = defaultConfig.pathsMapProg;\n\t\tpacks = defaultConfig.packs;\n\t\taliases = defaultConfig.aliases;\n\t\tmapProgs = defaultConfig.mapProgs;\n\t\tmodules = defaultConfig.modules;\n\t\tcache = defaultConfig.cache;\n\t\tcacheBust = defaultConfig.cacheBust;\n\n\t\t// remember the default config for other processes (e.g., dojo/config)\n\t\treq.rawConfig = defaultConfig;\n\t}\n\n\n\tif( 0 ){ var comboPending, combosPending, comboPendingTimer; }\n\n\n\t// build the loader machinery iaw configuration, including has feature tests\n\tvar\tinjectDependencies = function(module){\n\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\tguardCheckComplete(function(){\n\t\t\t\tforEach(module.deps, injectModule);\n\t\t\t\tif( false){}\n\t\t\t});\n\t\t},\n\n\t\tcontextRequire = function(a1, a2, a3, referenceModule, contextRequire){\n\t\t\tvar module, syntheticMid;\n\t\t\tif(isString(a1)){\n\t\t\t\t// signature is (moduleId)\n\t\t\t\tmodule = getModule(a1, referenceModule, true);\n\t\t\t\tif(module && module.executed){\n\t\t\t\t\treturn module.result;\n\t\t\t\t}\n\t\t\t\tthrow makeError(\"undefinedModule\", a1);\n\t\t\t}\n\t\t\tif(!isArray(a1)){\n\t\t\t\t// a1 is a configuration\n\t\t\t\tconfig(a1, 0, referenceModule);\n\n\t\t\t\t// juggle args; (a2, a3) may be (dependencies, callback)\n\t\t\t\ta1 = a2;\n\t\t\t\ta2 = a3;\n\t\t\t}\n\t\t\tif(isArray(a1)){\n\t\t\t\t// signature is (requestList [,callback])\n\t\t\t\tif(!a1.length){\n\t\t\t\t\ta2 && a2();\n\t\t\t\t}else{\n\t\t\t\t\tsyntheticMid = \"require*\" + uid();\n\n\t\t\t\t\t// resolve the request list with respect to the reference module\n\t\t\t\t\tfor(var mid, deps = [], i = 0; i < a1.length;){\n\t\t\t\t\t\tmid = a1[i++];\n\t\t\t\t\t\tdeps.push(getModule(mid, referenceModule));\n\t\t\t\t\t}\n\n\t\t\t\t\t// construct a synthetic module to control execution of the requestList, and, optionally, callback\n\t\t\t\t\tmodule = mix(makeModuleInfo(\"\", syntheticMid, 0, \"\"), {\n\t\t\t\t\t\tinjected: arrived,\n\t\t\t\t\t\tdeps: deps,\n\t\t\t\t\t\tdef: a2 || noop,\n\t\t\t\t\t\trequire: referenceModule ? referenceModule.require : req,\n\t\t\t\t\t\tgc: 1 //garbage collect\n\t\t\t\t\t});\n\t\t\t\t\tmodules[module.mid] = module;\n\n\t\t\t\t\t// checkComplete!=0 holds the idle signal; we're not idle if we're injecting dependencies\n\t\t\t\t\tinjectDependencies(module);\n\n\t\t\t\t\t// try to immediately execute\n\t\t\t\t\t// if already traversing a factory tree, then strict causes circular dependency to abort the execution; maybe\n\t\t\t\t\t// it's possible to execute this require later after the current traversal completes and avoid the circular dependency.\n\t\t\t\t\t// ...but *always* insist on immediate in synch mode\n\t\t\t\t\tvar strict = checkCompleteGuard && legacyMode!=sync;\n\t\t\t\t\tguardCheckComplete(function(){\n\t\t\t\t\t\texecModule(module, strict);\n\t\t\t\t\t});\n\t\t\t\t\tif(!module.executed){\n\t\t\t\t\t\t// some deps weren't on board or circular dependency detected and strict; therefore, push into the execQ\n\t\t\t\t\t\texecQ.push(module);\n\t\t\t\t\t}\n\t\t\t\t\tcheckComplete();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn contextRequire;\n\t\t},\n\n\t\tcreateRequire = function(module){\n\t\t\tif(!module){\n\t\t\t\treturn req;\n\t\t\t}\n\t\t\tvar result = module.require;\n\t\t\tif(!result){\n\t\t\t\tresult = function(a1, a2, a3){\n\t\t\t\t\treturn contextRequire(a1, a2, a3, module, result);\n\t\t\t\t};\n\t\t\t\tmodule.require = mix(result, req);\n\t\t\t\tresult.module = module;\n\t\t\t\tresult.toUrl = function(name){\n\t\t\t\t\treturn toUrl(name, module);\n\t\t\t\t};\n\t\t\t\tresult.toAbsMid = function(mid){\n\t\t\t\t\treturn toAbsMid(mid, module);\n\t\t\t\t};\n\t\t\t\tif( 0 ){}\n\t\t\t\tif( 0 ){}\n\n\t\t\t}\n\t\t\treturn result;\n\t\t},\n\n\t\texecQ =\n\t\t\t// The list of modules that need to be evaluated.\n\t\t\t[],\n\n\t\tdefQ =\n\t\t\t// The queue of define arguments sent to loader.\n\t\t\t[],\n\n\t\twaiting =\n\t\t\t// The set of modules upon which the loader is waiting for definition to arrive\n\t\t\t{},\n\n\t\tsetRequested = function(module){\n\t\t\tmodule.injected = requested;\n\t\t\twaiting[module.mid] = 1;\n\t\t\tif(module.url){\n\t\t\t\twaiting[module.url] = module.pack || 1;\n\t\t\t}\n\t\t\tstartTimer();\n\t\t},\n\n\t\tsetArrived = function(module){\n\t\t\tmodule.injected = arrived;\n\t\t\tdelete waiting[module.mid];\n\t\t\tif(module.url){\n\t\t\t\tdelete waiting[module.url];\n\t\t\t}\n\t\t\tif(isEmpty(waiting)){\n\t\t\t\tclearTimer();\n\t\t\t\t 0  && legacyMode==xd && (legacyMode = sync);\n\t\t\t}\n\t\t},\n\n\t\texecComplete = req.idle =\n\t\t\t// says the loader has completed (or not) its work\n\t\t\tfunction(){\n\t\t\t\treturn !defQ.length && isEmpty(waiting) && !execQ.length && !checkCompleteGuard;\n\t\t\t},\n\n\t\trunMapProg = function(targetMid, map){\n\t\t\t// search for targetMid in map; return the map item if found; falsy otherwise\n\t\t\tif(map){\n\t\t\tfor(var i = 0; i < map.length; i++){\n\t\t\t\tif(map[i][2].test(targetMid)){\n\t\t\t\t\treturn map[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t}\n\t\t\treturn 0;\n\t\t},\n\n\t\tcompactPath = function(path){\n\t\t\tvar result = [],\n\t\t\t\tsegment, lastSegment;\n\t\t\tpath = path.replace(/\\\\/g, '/').split('/');\n\t\t\twhile(path.length){\n\t\t\t\tsegment = path.shift();\n\t\t\t\tif(segment==\"..\" && result.length && lastSegment!=\"..\"){\n\t\t\t\t\tresult.pop();\n\t\t\t\t\tlastSegment = result[result.length - 1];\n\t\t\t\t}else if(segment!=\".\"){\n\t\t\t\t\tresult.push(lastSegment= segment);\n\t\t\t\t} // else ignore \".\"\n\t\t\t}\n\t\t\treturn result.join(\"/\");\n\t\t},\n\n\t\tmakeModuleInfo = function(pid, mid, pack, url){\n\t\t\tif( 0 ){ var xd; }else{\n\t\t\t\treturn {pid:pid, mid:mid, pack:pack, url:url, executed:0, def:0};\n\t\t\t}\n\t\t},\n\n\t\tgetModuleInfo_ = function(mid, referenceModule, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate, fromPendingCache){\n\t\t\t// arguments are passed instead of using lexical variables so that this function my be used independent of the loader (e.g., the builder)\n\t\t\t// alwaysCreate is useful in this case so that getModuleInfo never returns references to real modules owned by the loader\n\t\t\tvar pid, pack, midInPackage, mapItem, url, result, isRelative, requestedMid;\n\t\t\trequestedMid = mid;\n\t\t\tisRelative = /^\\./.test(mid);\n\t\t\tif(/(^\\/)|(\\:)|(\\.js$)/.test(mid) || (isRelative && !referenceModule)){\n\t\t\t\t// absolute path or protocol of .js filetype, or relative path but no reference module and therefore relative to page\n\t\t\t\t// whatever it is, it's not a module but just a URL of some sort\n\t\t\t\t// note: pid===0 indicates the routine is returning an unmodified mid\n\n\t\t\t\treturn makeModuleInfo(0, mid, 0, mid);\n\t\t\t}else{\n\t\t\t\t// relative module ids are relative to the referenceModule; get rid of any dots\n\t\t\t\tmid = compactPath(isRelative ? (referenceModule.mid + \"/../\" + mid) : mid);\n\t\t\t\tif(/^\\./.test(mid)){\n\t\t\t\t\tthrow makeError(\"irrationalPath\", mid);\n\t\t\t\t}\n\t\t\t\t// at this point, mid is an absolute mid\n\n\t\t\t\t// map the mid\n\t\t\t\tif(!fromPendingCache && !isRelative && mapProgs.star){\n\t\t\t\t\tmapItem = runMapProg(mid, mapProgs.star[1]);\n\t\t\t\t}\n\t\t\t\tif(!mapItem && referenceModule){\n\t\t\t\t\tmapItem = runMapProg(referenceModule.mid, mapProgs);\n\t\t\t\t\tmapItem = mapItem && runMapProg(mid, mapItem[1]);\n\t\t\t\t}\n\n\t\t\t\tif(mapItem){\n\t\t\t\t\tmid = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t\t\t}\n\n\t\t\t\tmatch = mid.match(/^([^\\/]+)(\\/(.+))?$/);\n\t\t\t\tpid = match ? match[1] : \"\";\n\t\t\t\tif((pack = packs[pid])){\n\t\t\t\t\tmid = pid + \"/\" + (midInPackage = (match[3] || pack.main));\n\t\t\t\t}else{\n\t\t\t\t\tpid = \"\";\n\t\t\t\t}\n\n\t\t\t\t// search aliases\n\t\t\t\tvar candidateLength = 0,\n\t\t\t\t\tcandidate = 0;\n\t\t\t\tforEach(aliases, function(pair){\n\t\t\t\t\tvar match = mid.match(pair[0]);\n\t\t\t\t\tif(match && match.length>candidateLength){\n\t\t\t\t\t\tcandidate = isFunction(pair[1]) ? mid.replace(pair[0], pair[1]) : pair[1];\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif(candidate){\n\t\t\t\t\treturn getModuleInfo_(candidate, 0, packs, modules, baseUrl, mapProgs, pathsMapProg, aliases, alwaysCreate);\n\t\t\t\t}\n\n\t\t\t\tresult = modules[mid];\n\t\t\t\tif(result){\n\t\t\t\t\treturn alwaysCreate ? makeModuleInfo(result.pid, result.mid, result.pack, result.url) : modules[mid];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// get here iff the sought-after module does not yet exist; therefore, we need to compute the URL given the\n\t\t\t// fully resolved (i.e., all relative indicators and package mapping resolved) module id\n\n\t\t\t// note: pid!==0 indicates the routine is returning a url that has .js appended unmodified mid\n\t\t\tmapItem = runMapProg(mid, pathsMapProg);\n\t\t\tif(mapItem){\n\t\t\t\turl = mapItem[1] + mid.substring(mapItem[3]);\n\t\t\t}else if(pid){\n\t\t\t\turl = pack.location + \"/\" + midInPackage;\n\t\t\t}else if( 0 ){}else{\n\t\t\t\turl = mid;\n\t\t\t}\n\t\t\t// if result is not absolute, add baseUrl\n\t\t\tif(!(/(^\\/)|(\\:)/.test(url))){\n\t\t\t\turl = baseUrl + url;\n\t\t\t}\n\t\t\turl += \".js\";\n\t\t\treturn makeModuleInfo(pid, mid, pack, compactPath(url));\n\t\t},\n\n\t\tgetModuleInfo = function(mid, referenceModule, fromPendingCache){\n\t\t\treturn getModuleInfo_(mid, referenceModule, packs, modules, req.baseUrl, mapProgs, pathsMapProg, aliases, undefined, fromPendingCache);\n\t\t},\n\n\t\tresolvePluginResourceId = function(plugin, prid, referenceModule){\n\t\t\treturn plugin.normalize ? plugin.normalize(prid, function(mid){return toAbsMid(mid, referenceModule);}) : toAbsMid(prid, referenceModule);\n\t\t},\n\n\t\tdynamicPluginUidGenerator = 0,\n\n\t\tgetModule = function(mid, referenceModule, immediate){\n\t\t\t// compute and optionally construct (if necessary) the module implied by the mid with respect to referenceModule\n\t\t\tvar match, plugin, prid, result;\n\t\t\tmatch = mid.match(/^(.+?)\\!(.*)$/);\n\t\t\tif(match){\n\t\t\t\t// name was <plugin-module>!<plugin-resource-id>\n\t\t\t\tplugin = getModule(match[1], referenceModule, immediate);\n\n\t\t\t\tif( false){}\n\n\n\n\t\t\t\tif(plugin.executed === executed && !plugin.load){\n\t\t\t\t\t// executed the module not knowing it was a plugin\n\t\t\t\t\tpromoteModuleToPlugin(plugin);\n\t\t\t\t}\n\n\t\t\t\t// if the plugin has not been loaded, then can't resolve the prid and  must assume this plugin is dynamic until we find out otherwise\n\t\t\t\tif(plugin.load){\n\t\t\t\t\tprid = resolvePluginResourceId(plugin, match[2], referenceModule);\n\t\t\t\t\tmid = (plugin.mid + \"!\" + (plugin.dynamic ? ++dynamicPluginUidGenerator + \"!\" : \"\") + prid);\n\t\t\t\t}else{\n\t\t\t\t\tprid = match[2];\n\t\t\t\t\tmid = plugin.mid + \"!\" + (++dynamicPluginUidGenerator) + \"!waitingForPlugin\";\n\t\t\t\t}\n\t\t\t\tresult = {plugin:plugin, mid:mid, req:createRequire(referenceModule), prid:prid};\n\t\t\t}else{\n\t\t\t\tresult = getModuleInfo(mid, referenceModule);\n\t\t\t}\n\t\t\treturn modules[result.mid] || (!immediate && (modules[result.mid] = result));\n\t\t},\n\n\t\ttoAbsMid = req.toAbsMid = function(mid, referenceModule){\n\t\t\treturn getModuleInfo(mid, referenceModule).mid;\n\t\t},\n\n\t\ttoUrl = req.toUrl = function(name, referenceModule){\n\t\t\tvar moduleInfo = getModuleInfo(name+\"/x\", referenceModule),\n\t\t\t\turl= moduleInfo.url;\n\t\t\treturn fixupUrl(moduleInfo.pid===0 ?\n\t\t\t\t// if pid===0, then name had a protocol or absolute path; either way, toUrl is the identify function in such cases\n\t\t\t\tname :\n\t\t\t\t// \"/x.js\" since getModuleInfo automatically appends \".js\" and we appended \"/x\" to make name look like a module id\n\t\t\t\turl.substring(0, url.length-5)\n\t\t\t);\n\t\t},\n\n\t\tnonModuleProps = {\n\t\t\tinjected: arrived,\n\t\t\texecuted: executed,\n\t\t\tdef: nonmodule,\n\t\t\tresult: nonmodule\n\t\t},\n\n\t\tmakeCjs = function(mid){\n\t\t\treturn modules[mid] = mix({mid:mid}, nonModuleProps);\n\t\t},\n\n\t\tcjsRequireModule = makeCjs(\"require\"),\n\t\tcjsExportsModule = makeCjs(\"exports\"),\n\t\tcjsModuleModule = makeCjs(\"module\"),\n\n\t\trunFactory = function(module, args){\n\t\t\treq.trace(\"loader-run-factory\", [module.mid]);\n\t\t\tvar factory = module.def,\n\t\t\t\tresult;\n\t\t\t 0  && syncExecStack.unshift(module);\n\t\t\tif( 0 ){}else{\n\t\t\t\tresult= isFunction(factory) ? factory.apply(null, args) : factory;\n\t\t\t}\n\t\t\tmodule.result = result===undefined && module.cjs ? module.cjs.exports : result;\n\t\t\t 0  && syncExecStack.shift(module);\n\t\t},\n\n\t\tabortExec = {},\n\n\t\tdefOrder = 0,\n\n\t\tpromoteModuleToPlugin = function(pluginModule){\n\t\t\tvar plugin = pluginModule.result;\n\t\t\tpluginModule.dynamic = plugin.dynamic;\n\t\t\tpluginModule.normalize = plugin.normalize;\n\t\t\tpluginModule.load = plugin.load;\n\t\t\treturn pluginModule;\n\t\t},\n\n\t\tresolvePluginLoadQ = function(plugin){\n\t\t\t// plugins is a newly executed module that has a loadQ waiting to run\n\n\t\t\t// step 1: traverse the loadQ and fixup the mid and prid; remember the map from original mid to new mid\n\t\t\t// recall the original mid was created before the plugin was on board and therefore it was impossible to\n\t\t\t// compute the final mid; accordingly, prid may or may not change, but the mid will definitely change\n\t\t\tvar map = {};\n\t\t\tforEach(plugin.loadQ, function(pseudoPluginResource){\n\t\t\t\t// manufacture and insert the real module in modules\n\t\t\t\tvar prid = resolvePluginResourceId(plugin, pseudoPluginResource.prid, pseudoPluginResource.req.module),\n\t\t\t\t\tmid = plugin.dynamic ? pseudoPluginResource.mid.replace(/waitingForPlugin$/, prid) : (plugin.mid + \"!\" + prid),\n\t\t\t\t\tpluginResource = mix(mix({}, pseudoPluginResource), {mid:mid, prid:prid, injected:0});\n\t\t\t\tif(!modules[mid] || !modules[mid].injected /*for require.undef*/){\n\t\t\t\t\t// create a new (the real) plugin resource and inject it normally now that the plugin is on board\n\t\t\t\t\tinjectPlugin(modules[mid] = pluginResource);\n\t\t\t\t} // else this was a duplicate request for the same (plugin, rid) for a nondynamic plugin\n\n\t\t\t\t// pluginResource is really just a placeholder with the wrong mid (because we couldn't calculate it until the plugin was on board)\n\t\t\t\t// mark is as arrived and delete it from modules; the real module was requested above\n\t\t\t\tmap[pseudoPluginResource.mid] = modules[mid];\n\t\t\t\tsetArrived(pseudoPluginResource);\n\t\t\t\tdelete modules[pseudoPluginResource.mid];\n\t\t\t});\n\t\t\tplugin.loadQ = 0;\n\n\t\t\t// step2: replace all references to any placeholder modules with real modules\n\t\t\tvar substituteModules = function(module){\n\t\t\t\tfor(var replacement, deps = module.deps || [], i = 0; i<deps.length; i++){\n\t\t\t\t\treplacement = map[deps[i].mid];\n\t\t\t\t\tif(replacement){\n\t\t\t\t\t\tdeps[i] = replacement;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tfor(var p in modules){\n\t\t\t\tsubstituteModules(modules[p]);\n\t\t\t}\n\t\t\tforEach(execQ, substituteModules);\n\t\t},\n\n\t\tfinishExec = function(module){\n\t\t\treq.trace(\"loader-finish-exec\", [module.mid]);\n\t\t\tmodule.executed = executed;\n\t\t\tmodule.defOrder = defOrder++;\n\t\t\t 0  && forEach(module.provides, function(cb){ cb(); });\n\t\t\tif(module.loadQ){\n\t\t\t\t// the module was a plugin\n\t\t\t\tpromoteModuleToPlugin(module);\n\t\t\t\tresolvePluginLoadQ(module);\n\t\t\t}\n\t\t\t// remove all occurrences of this module from the execQ\n\t\t\tfor(i = 0; i < execQ.length;){\n\t\t\t\tif(execQ[i] === module){\n\t\t\t\t\texecQ.splice(i, 1);\n\t\t\t\t}else{\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// delete references to synthetic modules\n\t\t\tif (/^require\\*/.test(module.mid)) {\n\t\t\t\tdelete modules[module.mid];\n\t\t\t}\n\t\t},\n\n\t\tcircleTrace = [],\n\n\t\texecModule = function(module, strict){\n\t\t\t// run the dependency vector, then run the factory for module\n\t\t\tif(module.executed === executing){\n\t\t\t\treq.trace(\"loader-circular-dependency\", [circleTrace.concat(module.mid).join(\"->\")]);\n\t\t\t\treturn (!module.def || strict) ? abortExec :  (module.cjs && module.cjs.exports);\n\t\t\t}\n\t\t\t// at this point the module is either not executed or fully executed\n\n\n\t\t\tif(!module.executed){\n\t\t\t\tif(!module.def){\n\t\t\t\t\treturn abortExec;\n\t\t\t\t}\n\t\t\t\tvar mid = module.mid,\n\t\t\t\t\tdeps = module.deps || [],\n\t\t\t\t\targ, argResult,\n\t\t\t\t\targs = [],\n\t\t\t\t\ti = 0;\n\n\t\t\t\tif( 0 ){}\n\n\t\t\t\t// for circular dependencies, assume the first module encountered was executed OK\n\t\t\t\t// modules that circularly depend on a module that has not run its factory will get\n\t\t\t\t// the pre-made cjs.exports===module.result. They can take a reference to this object and/or\n\t\t\t\t// add properties to it. When the module finally runs its factory, the factory can\n\t\t\t\t// read/write/replace this object. Notice that so long as the object isn't replaced, any\n\t\t\t\t// reference taken earlier while walking the deps list is still valid.\n\t\t\t\tmodule.executed = executing;\n\t\t\t\twhile((arg = deps[i++])){\n\t\t\t\t\targResult = ((arg === cjsRequireModule) ? createRequire(module) :\n\t\t\t\t\t\t\t\t\t((arg === cjsExportsModule) ? module.cjs.exports :\n\t\t\t\t\t\t\t\t\t\t((arg === cjsModuleModule) ? module.cjs :\n\t\t\t\t\t\t\t\t\t\t\texecModule(arg, strict))));\n\t\t\t\t\tif(argResult === abortExec){\n\t\t\t\t\t\tmodule.executed = 0;\n\t\t\t\t\t\treq.trace(\"loader-exec-module\", [\"abort\", mid]);\n\t\t\t\t\t\t 0  && circleTrace.pop();\n\t\t\t\t\t\treturn abortExec;\n\t\t\t\t\t}\n\t\t\t\t\targs.push(argResult);\n\t\t\t\t}\n\t\t\t\trunFactory(module, args);\n\t\t\t\tfinishExec(module);\n\t\t\t\t 0  && circleTrace.pop();\n\t\t\t}\n\t\t\t// at this point the module is guaranteed fully executed\n\n\t\t\treturn module.result;\n\t\t},\n\n\n\t\tcheckCompleteGuard = 0,\n\n\t\tguardCheckComplete = function(proc){\n\t\t\ttry{\n\t\t\t\tcheckCompleteGuard++;\n\t\t\t\tproc();\n\t\t\t}catch(e){\n\t\t\t\t// https://bugs.dojotoolkit.org/ticket/16617\n\t\t\t\tthrow e;\n\t\t\t}finally{\n\t\t\t\tcheckCompleteGuard--;\n\t\t\t}\n\t\t\tif(execComplete()){\n\t\t\t\tsignal(\"idle\", []);\n\t\t\t}\n\t\t},\n\n\t\tcheckComplete = function(){\n\t\t\t// keep going through the execQ as long as at least one factory is executed\n\t\t\t// plugins, recursion, cached modules all make for many execution path possibilities\n\t\t\tif(checkCompleteGuard){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tguardCheckComplete(function(){\n\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\tfor(var currentDefOrder, module, i = 0; i < execQ.length;){\n\t\t\t\t\tcurrentDefOrder = defOrder;\n\t\t\t\t\tmodule = execQ[i];\n\t\t\t\t\texecModule(module);\n\t\t\t\t\tif(currentDefOrder!=defOrder){\n\t\t\t\t\t\t// defOrder was bumped one or more times indicating something was executed (note, this indicates\n\t\t\t\t\t\t// the execQ was modified, maybe a lot (for example a later module causes an earlier module to execute)\n\t\t\t\t\t\tcheckDojoRequirePlugin();\n\t\t\t\t\t\ti = 0;\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// nothing happened; check the next module in the exec queue\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tfixupUrl= typeof userConfig.fixupUrl == \"function\" ? userConfig.fixupUrl : function(url){\n\t\t\turl += \"\"; // make sure url is a Javascript string (some paths may be a Java string)\n\t\t\treturn url + (cacheBust ? ((/\\?/.test(url) ? \"&\" : \"?\") + cacheBust) : \"\");\n\t\t};\n\n\n\n\tif( 0 ){}\n\n\tif( false ){ var injectPlugin, cached, injectingModule, injectingCachedModule, evalModuleText, injectModule, defineModule, runDefQ; }\n\n\tvar timerId = 0,\n\t\tclearTimer = noop,\n\t\tstartTimer = noop;\n\tif( 0 ){}\n\n\tif ( 0 ) {}\n\n\tif( false){ var scripts, i, script, domOn, windowOnLoadListener; }\n\n\tif( 0 ){}else{\n\t\treq.log = noop;\n\t}\n\n\tif( 0 ){ var trace; }else{\n\t\treq.trace = noop;\n\t}\n\n\tvar def = function(\n\t\tmid,\t\t  //(commonjs.moduleId, optional)\n\t\tdependencies, //(array of commonjs.moduleId, optional) list of modules to be loaded before running factory\n\t\tfactory\t\t  //(any)\n\t){\n\t\t///\n\t\t// Advises the loader of a module factory. //Implements http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition.\n\t\t///\n\t\t//note\n\t\t// CommonJS factory scan courtesy of http://requirejs.org\n\n\t\tvar arity = arguments.length,\n\t\t\tdefaultDeps = [\"require\", \"exports\", \"module\"],\n\t\t\t// the predominate signature...\n\t\t\targs = [0, mid, dependencies];\n\t\tif(arity==1){\n\t\t\targs = [0, (isFunction(mid) ? defaultDeps : []), mid];\n\t\t}else if(arity==2 && isString(mid)){\n\t\t\targs = [mid, (isFunction(dependencies) ? defaultDeps : []), dependencies];\n\t\t}else if(arity==3){\n\t\t\targs = [mid, dependencies, factory];\n\t\t}\n\n\t\tif( false){}\n\n\t\treq.trace(\"loader-define\", args.slice(0, 2));\n\t\tvar targetModule = args[0] && getModule(args[0]),\n\t\t\tmodule;\n\t\tif(targetModule && !waiting[targetModule.mid]){\n\t\t\t// given a mid that hasn't been requested; therefore, defined through means other than injecting\n\t\t\t// consequent to a require() or define() application; examples include defining modules on-the-fly\n\t\t\t// due to some code path or including a module in a script element. In any case,\n\t\t\t// there is no callback waiting to finish processing and nothing to trigger the defQ and the\n\t\t\t// dependencies are never requested; therefore, do it here.\n\t\t\tinjectDependencies(defineModule(targetModule, args[1], args[2]));\n\t\t}else if(true){\n\t\t\t// not IE path: anonymous module and therefore must have been injected; therefore, onLoad will fire immediately\n\t\t\t// after script finishes being evaluated and the defQ can be run from that callback to detect the module id\n\t\t\tdefQ.push(args);\n\t\t}else{ var i; }\n\t};\n\tdef.amd = {\n\t\tvendor:\"dojotoolkit.org\"\n\t};\n\n\tif( 0 ){}\n\n\t// allow config to override default implementation of named functions; this is useful for\n\t// non-browser environments, e.g., overriding injectUrl, getText, log, etc. in node.js, Rhino, etc.\n\t// also useful for testing and monkey patching loader\n\tmix(mix(req, defaultConfig.loaderPatch), userConfig.loaderPatch);\n\n\t// now that req is fully initialized and won't change, we can hook it up to the error signal\n\ton(error, function(arg){\n\t\ttry{\n\t\t\tconsole.error(arg);\n\t\t\tif(arg instanceof Error){\n\t\t\t\tfor(var p in arg){\n\t\t\t\t\tconsole.log(p + \":\", arg[p]);\n\t\t\t\t}\n\t\t\t\tconsole.log(\".\");\n\t\t\t}\n\t\t}catch(e){}\n\t});\n\n\t// always publish these\n\tmix(req, {\n\t\tuid:uid,\n\t\tcache:cache,\n\t\tpacks:packs\n\t});\n\n\n\tif( 0 ){}\n\n\t// the loader can be defined exactly once; look for global define which is the symbol AMD loaders are\n\t// *required* to define (as opposed to require, which is optional)\n\tif(global.define){\n\t\tif( 0 ){}\n\t\treturn;\n\t}else{\n\t\tglobal.define = def;\n\t\tglobal.require = req;\n\t\tif( 0 ){}\n\t}\n\n\tif( false){ var plugins, pluginName; }\n\n\tif( 0 ){ var bootDeps, bootCallback; }\n\tif(false ){}\n})\n.call(this, userConfig, defaultConfig);};\n\n//# sourceURL=webpack:////tmp/tmp-18572u2v83c7ofeCs/dojo/dojo.js?");

/***/ }),

/***/ "./Auth.js":
/*!*****************!*\
  !*** ./Auth.js ***!
  \*****************/
/*! exports provided: Auth */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Auth\", function() { return Auth; });\n  let _listenerCounter = 0;\n\n  /**\n   * EntryStore is the main class that is used to connect to a running server-side\n   * EntryStore repository.\n   * @exports store/Auth\n   */\n  const Auth = class {\n    /**\n     * @param {store/EntryStore} entrystore - a repository instance.\n     */\n    constructor(entrystore) {\n      this.entrystore = entrystore;\n      this._listenerCounter = 0;\n      this._listenersIdx = {};\n    }\n\n    messageListeners(topic, obj) {\n      Object.keys(this._listenersIdx).forEach((alid) => {\n        this._listenersIdx[alid](topic, obj);\n      });\n    }\n\n    /**\n     * Adds an authentification listener, it will be notified of login and logout events.\n     * @param {authListener} listener\n     */\n    addAuthListener(listener) {\n      if (listener.__alid == null) {\n        listener.__alid = `idx_${_listenerCounter}`;\n        _listenerCounter += 1;\n      }\n      this._listenersIdx[listener.__alid] = listener;\n    }\n\n    /**\n     * Removes an authentification listener.\n     * @param {authListener} listener\n     */\n    removeAuthListener(listener) {\n      if (listener.__alid != null) {\n        delete this._listenersIdx[listener.__alid];\n      }\n    }\n\n    /**\n     * Yields information about who currently is authenticated against the EntryStore repository.\n     * @returns {userInfoPromise} - upon success an object containing attributes \"user\" being\n     * the username, \"id\" of the user entry,\n     * and \"homecontext\" being the entry-id of the home context is provided.\n     * @see {@link store/EntryStore#auth auth}\n     * @see {@link store/EntryStore#logout logout}\n     */\n    getUserInfo(forceLookup) {\n      if (this.userInfo && forceLookup !== true) {\n        return new Promise(resolve => resolve(this.userInfo));\n      }\n      if (!this._uiDef) {\n        const self = this;\n        delete this.userInfo;\n        this._uiDef = this.entrystore._rest.get(`${this.entrystore._baseURI}auth/user`, null, true).then((userinfo) => {\n          self.userInfo = userinfo;\n          delete self._uiDef;\n          return userinfo;\n        });\n        this.entrystore.handleAsync(this._uiDef, 'getUserInfo');\n      }\n      return this._uiDef;\n    }\n\n    /**\n     * @returns {entryPromise} on success the entry for the currently signed in user is provided.\n     */\n    getUserEntry(forceLookup) {\n      if (this.userEntry && forceLookup !== true) {\n        return new Promise(resolve => resolve(this.userEntry));\n      }\n      if (!this._ueDef) {\n        const self = this;\n        delete this.userEntry;\n        this._ueDef = this.getUserInfo(forceLookup)\n          .then(data => self.entrystore.getEntry(self.entrystore.getEntryURI('_principals', data.id), { asyncContext: 'getUserEntry' }))\n          .then((userEntry) => {\n            self.userEntry = userEntry;\n            delete self._ueDef;\n            return userEntry;\n          });\n      }\n      return this._ueDef;\n    }\n\n    /**\n     * Authenticate using credentials containing a user, a password and an optional maxAge\n     * given in seconds.\n     *\n     * @param user\n     * @param password\n     * @param maxAge\n     * @returns {xhrPromise}\n     */\n    login(user, password, maxAge) {\n      if (this.userInfo && this.userInfo.user === user) {\n        return this.getUserInfo();\n      }\n      const self = this;\n      const credentials = {\n        base: this.entrystore.getBaseURI(),\n        user,\n        password,\n        maxAge,\n      };\n      return this.entrystore.handleAsync(this.entrystore.getREST().auth(credentials)\n        .then((data) => {\n          if (typeof data === 'object' && data.user) {\n            return data;\n          }\n          return self.entrystore._rest.get(`${self.entrystore._baseURI}auth/user`, null, true);\n        })\n        .then((data) => {\n          if (self._uiDef) {\n            self._uiDef.cancel();\n          }\n          if (self._ueDef) {\n            self._ueDef.cancel();\n          }\n          self.userInfo = data;\n          delete self.userEntry;\n          self.entrystore.getCache().allNeedRefresh();\n          self.messageListeners('login', data);\n          return data;\n        }), 'login');\n    }\n\n    /**\n     * Logout the currently authorized user.\n     * @returns {xhrPromise}\n     */\n    logout() {\n      if (this.userInfo && this.userInfo.user === 'guest') {\n        return this.getUserInfo();\n      }\n      const credentials = { base: this.entrystore.getBaseURI(), logout: true };\n      const self = this;\n      return this.entrystore.handleAsync(this.entrystore.getREST().auth(credentials).then(() => {\n        self.userInfo = { user: 'guest', id: '_guest' };\n        delete self.userEntry;\n        self.entrystore.getCache().allNeedRefresh();\n        self.messageListeners('logout', self.userInfo);\n        return self.userInfo;\n      }), 'logout');\n    }\n  };\n  \n\n/**\n * @name userInfoPromise\n * @extends xhrPromise\n * @class\n */\n/**\n * @name userInfoPromise#then\n * @param {userInfoCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n/**\n * @callback userInfoCallback\n * @param {userInfo} resource\n */\n/**\n * @name userInfo\n * @namespace\n * @property {string}  user                   - the username\n * @property {string}  id                     - the entry id of the users entry\n * @property {string}  homecontext            - the entry id of the users home context.\n */\n\n/**\n * @callback authListener\n * @param {string} topic - either login or logout.\n * @param {userInfo} userInfo - an object with the current user information\n */\n\n\n//# sourceURL=webpack:///./Auth.js?");

/***/ }),

/***/ "./Cache.js":
/*!******************!*\
  !*** ./Cache.js ***!
  \******************/
/*! exports provided: Cache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Cache\", function() { return Cache; });\n  /**\n   * Caches loaded entries and keeps track of which entries that need to be updated (refreshed).\n   * The cache also provides a listener functionality that allows you to be notified of\n   * when entries are updated.\n   *\n   * @exports store/Cache\n   */\n  const Cache = class {\n    constructor() {\n      this._listenerCounter = 0;\n      this._listenersIdx = {};\n      this._cacheIdx = {};\n      this._cacheIdxResource = {};\n      this._cacheCtrl = {};\n    }\n\n    /**\n     * Add or update the entry to the cache.\n     * All listeners will be notified unless silently is specified.\n     *\n     * @param {store/Entry} entry\n     * @param {Boolean=} silently - listeners will be notified unless true is specified.\n     */\n    cache(entry, silently) {\n      const previouslyCached = this._cacheIdx[entry.getURI()] != null;\n      this._cacheIdx[entry.getURI()] = entry;\n      let resArr = this._cacheIdxResource[entry.getResourceURI()];\n      if (typeof resArr === 'undefined') {\n        resArr = [];\n        this._cacheIdxResource[entry.getResourceURI()] = resArr;\n      }\n      if (resArr.indexOf(entry) === -1) {\n        resArr.push(entry);\n      }\n      this._cacheCtrl[entry.getURI()] = { date: new Date().getTime() };\n      if (previouslyCached && silently !== true) {\n        this.messageListeners('refreshed', entry);\n      }\n    }\n\n    /**\n     * Removes a single entry from the cache.\n     * @param {store/Entry} entry the entry to remove.\n     */\n    unCache(entry) {\n      delete this._cacheIdx[entry.getURI()];\n      const resArr = this._cacheIdxResource[entry.getResourceURI()];\n      if (typeof resArr !== 'undefined') {\n        for (let i = 0; i < resArr.length; i++) {\n          if (resArr[i].getURI() === entry.getURI()) {\n            resArr.splice(i, 1);\n          }\n          if (resArr.length === 0) {\n            delete this._cacheIdxResource[entry.getResourceURI()];\n          }\n        }\n      }\n    }\n\n    /**\n     * Marks an entry as in need of refresh from the store.\n     * All listeners are notified of the entry now being in need of refreshing unless\n     * silently is set to true.\n     *\n     * @param {store/Entry} entry\n     * @param {Boolean=} silently\n     */\n    setRefreshNeeded(entry, silently) {\n      const ctrl = this._cacheCtrl[entry.getURI()];\n      if (ctrl == null) {\n        throw new Error(`No cache control of existing entry: ${entry.getURI()}`);\n      }\n      ctrl.stale = true;\n      if (silently !== true) {\n        this.messageListeners('needRefresh', entry);\n      }\n    }\n\n    /**\n     * A convenience method for caching multiple entries.\n     *\n     * @param {store/Entry[]} entryArr\n     * @param {Boolean=} silently\n     * @see store/Cache#cache\n     */\n    cacheAll(entryArr, silently) {\n      for (let i = 0; i < entryArr.length; i++) {\n        this.cache(entryArr[i], silently);\n      }\n    }\n\n    /**\n     * Retrieve the entry from it's URI.\n     *\n     * @param {String} entryURI\n     * @returns {store/Entry|undefined}\n     */\n    get(entryURI) {\n      return this._cacheIdx[entryURI];\n    }\n\n    /**\n     * Retrieve all entries that have the specified uri as resource.\n     * Note that since several entries (e.g. links) may have the same uri\n     * as resource this method returns an array. However, in many situations\n     * there will be zero or one entry per uri.\n     *\n     * @param {String} resourceURI\n     * @returns {store/Entry[]} always returns an array, may be empty though.\n     */\n    getByResourceURI(uri) {\n      const arr = this._cacheIdxResource[uri];\n      if (typeof arr !== 'undefined' && typeof arr.slice === 'function') {\n        return arr.slice(0);\n      }\n      return [];\n    }\n\n    /**\n     * Tells wheter the entry is in need of a refresh from the repository.\n     *\n     * @param {store/Entry} entry\n     * @returns {boolean}\n     */\n    needRefresh(entry) {\n      const ctrl = this._cacheCtrl[entry.getURI()];\n      if (ctrl == null) {\n        throw new Error(`No cache control of existing entry: ${entry.getURI()}`);\n      }\n      return ctrl.stale === true;\n    }\n\n    /**\n     * @param {Function} listener\n     */\n    addCacheUpdateListener(listener) {\n      if (listener.__clid != null) {\n        listener.__clid = `idx_${this._listenerCounter}`;\n        this._listenerCounter += 1;\n      }\n      this._listenersIdx[listener.__clid] = listener;\n    }\n\n    /**\n     * @param {Function} listener\n     */\n    removeCacheUpdateListener(listener) {\n      if (listener.__clid != null) {\n        delete this._listenersIdx[listener.__clid];\n      }\n    }\n\n    /**\n     * Agreed topics are:\n     * allEntriesNeedRefresh - all entries are now in need of refresh,\n     * typically happens after a change of user(sign in)\n     * needRefresh - the specified entry need to be refreshed.\n     * refreshed - the specified entry have been refreshed.\n     *\n     * @param {String} topic\n     * @param {store/Entry=} affectedEntry\n     */\n    messageListeners(topic, affectedEntry) {\n      Object.keys(this._listenersIdx).forEach((clid) => {\n        this._listenersIdx[clid](topic, affectedEntry);\n      });\n    }\n\n    /**\n     * Marks all entries as in need of refresh and consequently messages all listeners\n     * with the allEntriesNeedRefresh topic.\n     */\n    allNeedRefresh() {\n      Object.keys(this._cacheIdx).forEach((uri) => {\n        // Do not messageListeners for every entry.\n        this.setRefreshNeeded(this._cacheIdx[uri], true);\n      });\n      this.messageListeners('allEntriesNeedRefresh');\n    }\n\n    /**\n     * Clears the cache from all cached entries.\n     * Warning: all references to entries needs to be discarded as they will not be\n     * kept in sync with changes.\n     */\n    clear() {\n      this._cacheIdx = {};\n      this._cacheIdxResource = {};\n      this._cacheCtrl = {};\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./Cache.js?");

/***/ }),

/***/ "./Context.js":
/*!********************!*\
  !*** ./Context.js ***!
  \********************/
/*! exports provided: Context */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Context\", function() { return Context; });\n/* harmony import */ var _String__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./String */ \"./String.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./types.js\");\n/* harmony import */ var _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PrototypeEntry */ \"./PrototypeEntry.js\");\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Graph */ \"./Graph.js\");\n/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Pipeline */ \"./Pipeline.js\");\n/* global define*/\n  \n  \n  \n  \n  \n  \n\n  /**\n   * Methods for interacting with the EntryStore repository scoped to a specific context.\n   *\n   * @exports store/Context\n   */\n  const Context = class extends _Resource__WEBPACK_IMPORTED_MODULE_3__[\"Resource\"] {\n    /**\n     * Retrieves a list of entries in the context.\n     *\n     * @param {Object} sort - same sort object as provided in the optionalLoadParams to\n     * {@see store/EntryStore#getEntry getEntry} method.\n     * @param {Object} limit - same limit as provided in the optionalLoadParams to\n     * {@see store/EntryStore#getEntry getEntry} method.\n     * @param {integer} page - unless limit is set to -1 (no pagination) we need to specify\n     * which page to load, first page is 0.\n     * @returns {entryArrayPromise} upon success the promise returns an array of entries.\n     * @see store/EntryStore#getListEntries\n     */\n    listEntries(sort, limit, page) {\n      return this.getEntryStore().getListEntries(`${this._resourceURI}/entry/_all`,\n        sort, limit, page);\n    }\n\n    /**\n     * Convenience method, to retrieve an entry from this context.\n     *\n     * @param {string} entryId\n     * @param {object} optionalLoadParams same parameter as in {@see store/EntryStore#getEntry}\n     * @returns {entryPromise}\n     * @see store/EntryStore#getEntry\n     */\n    getEntryById(entryId, optionalLoadParams) {\n      return this.getEntryStore().getEntry(this.getEntryURIbyId(entryId), optionalLoadParams);\n    }\n\n    /**\n     * Expands the given entry id into a full URI.\n     *\n     * @param {string} entryId\n     * @returns {string} the URI for an entry in this context with the given id.\n     */\n    getEntryURIbyId(entryId) {\n      return this.getEntryStore().getEntryURI(this.getId(), entryId);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry that has the current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it\n     * (returns a promise).\n     *\n     * @param {string=} id - id for the entry, fails after commit if an entry exists already with\n     * this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newEntry(id) {\n      return new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry that corresponds to a local named resource that\n     * has the current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it\n     * (returns a promise).\n     *\n     * @param {string=} id - id for the entry, fails after commit if an entry exists already\n     * with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newNamedEntry(id) {\n      return (new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id)).setResourceType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].RT_NAMEDRESOURCE);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry that corresponds to a link that has the\n     * current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create\n     * it (returns a promise).\n     *\n     * @param {string} link - the URI for the resource we are making a link to, mandatory.\n     * @param {string=} id - id for the entry, fails after commit if an entry exists already\n     * with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newLink(link, id) {\n      return new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setResourceURI(link).setEntryType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].ET_LINK);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry that is a linkref that has the current context\n     * as container. Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to\n     * actually create it (returns a promise).\n     *\n     * @param {string} link - is the URI for the resource we are making a link to, mandatory.\n     * @param {string} metadatalink - is the URI for the metadata are referring to, mandatory.\n     * @param {string=} id - id for the entry, fails after commit if an entry exists already\n     * with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newLinkRef(link, metadatalink, id) {\n      return new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setResourceURI(link)\n        .setExternalMetadataURI(metadatalink).setEntryType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].ET_LINKREF);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry that is a reference and has the current\n     * context as container. Call {@link store/PrototypeEntry#commit commit} on the\n     * PrototypeEntry to actually create it (returns a promise).\n     * The only difference to the newLinkRef method is that the EntryType is Reference instead\n     * of LinkReference which implies that there is no local metadata.\n     *\n     * @param {string} link - the URI for the resource we are making a link to, mandatory.\n     * @param {string} metadatalink - the URI for the metadata are referring to, mandatory.\n     * @param {string=} id for the entry, fails after commit if an entry exists already with\n     * this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newRef(link, metadatalink, id) {\n      return new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setResourceURI(link)\n        .setExternalMetadataURI(metadatalink).setEntryType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].ET_REF);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry whose resource is a {@link store/List List)\n     * and has the current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create\n     * it (returns a promise).\n     *\n     * @param {string} id an optional id for the entry, fails on commit if an entry exists already\n     * with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newList(id) {\n      return new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_LIST);\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry whose resource is a {@link store/Graph Graph}\n     * and has the current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it\n     * (returns a promise).\n     *\n     * @param {rdfjson.Graph} graph - graph to store as a resource.\n     * @param {string=} id - id for the entry, fails upon commit if an entry exists already\n     * with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newGraph(graph, id) {\n      const pe = new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_GRAPH);\n      const ei = pe.getEntryInfo();\n      pe._resource = new _Graph__WEBPACK_IMPORTED_MODULE_4__[\"GraphResource\"](ei.getEntryURI(), ei.getResourceURI(),\n        this.getEntryStore(), graph || {});\n      return pe;\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry whose resource is a {@link store/String String}\n     * that has the current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create\n     * it (returns a promise).\n     *\n     * @param {string=} str an optional string for the String Resource.\n     * @param {String} id an optional id for the entry, fails upon commit if an entry exists\n     * already with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newString(str, id) {\n      const pe = new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_STRING);\n      const ei = pe.getEntryInfo();\n      pe._resource = new _String__WEBPACK_IMPORTED_MODULE_0__[\"StringResource\"](ei.getEntryURI(),\n        ei.getResourceURI(), this.getEntryStore(), str);\n      return pe;\n    }\n\n    /**\n     * Factory method to create a PrototypeEntry whose resource is a\n     * {@link store/Pipeline pipeline} that has the current context as container.\n     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it\n     * (returns a promise).\n     *\n     * @param {String} id an optional id for the entry, fails upon commit if an entry exists\n     * already with this id.\n     * @returns {store/PrototypeEntry}\n     */\n    newPipeline(id) {\n      const pe = new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_2__[\"PrototypeEntry\"](this, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_PIPELINE);\n      const ei = pe.getEntryInfo();\n      pe._resource = new _Pipeline__WEBPACK_IMPORTED_MODULE_5__[\"Pipeline\"](ei.getEntryURI(), ei.getResourceURI(), this.getEntryStore(), {});\n      return pe;\n    }\n\n    /**\n     * The name for this context.\n     *\n     * @returns {string}\n     */\n    getName() {\n      return this._name;\n    }\n\n    /**\n     * Change of context name, succeds if name is not in use already by another context.\n     * @param {string} name\n     * @returns {xhrPromise}\n     */\n    setName(name) {\n      const oldname = this._name;\n      this._name = name;\n      return this._entryStore.handleAsync(this._entryStore.getREST().put(`${this.getEntryURI()}/name`, json.stringify({ name })).then((data) => {\n        const e = this.getEntry(true);\n        if (e) {\n          e.getEntryInfo()._name = data;\n        }\n        return data;\n      }, (e) => {\n        this._name = oldname;\n        throw e;\n      }), 'setContextName');\n    }\n\n    /**\n     * Finds the user or group that has this context as homecontext if any.\n     *\n     * @returns {entryPromise} if succeeds if context a homecontext of some user or group.\n     */\n    getHomeContextOf() {\n      return this.getEntry().then((ctxtEntry) => {\n        const es = ctxtEntry.getEntryStore();\n        const groupResourceArr = ctxtEntry.getReferrers('store:homeContext');\n        if (groupResourceArr.length > 0) {\n          return es.getEntry(es.getEntryURIFromURI(groupResourceArr[0]));\n        }\n        throw new Error('No user or group that has this context as home context');\n      });\n    }\n\n    _update(data) {\n      this._name = data.alias || data.name; // TODO, change to only name after clean-up\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./Context.js?");

/***/ }),

/***/ "./Entry.js":
/*!******************!*\
  !*** ./Entry.js ***!
  \******************/
/*! exports provided: Entry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Entry\", function() { return Entry; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.js\");\n  const Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n  \n\n  /**\n   * Entrys are at the center of this API. Entrys holds together metadata, external metadata,\n   * resources, access control, and provenance. Hence, entrys appear in the majority of methods,\n   * either directly or in callbacks via promises. Each entry has a simple identifier within a\n   * context and a globally unique URI that can be used to load, store and index the entry.\n   *\n   * Many of the methods in this class are convenience methods that allows the developer to interact\n   * with the information retrieved from the repository without digging through the RDF graphs.\n   * For instance, all methods starting with _can_ or _is_ are convenience methods for working\n   * with access control or the type information available in the associated\n   * {@link store/EntryInformation} class. The same is true for the majority of the get methods,\n   * only those that have corresponding set methods are really unique for this class.\n   *\n   * @exports store/Entry\n   */\n  const Entry = class {\n    /**\n     * @param {store/Context} context container for this entry\n     * @param {store/EntryInfo} entryInfo defines the basics of this entry\n     */\n    constructor(context, entryInfo) {\n      this._context = context;\n      this._entryInfo = entryInfo;\n      this._entryInfo._entry = this;\n    }\n\n    /**\n     * @returns {store/EntryStore}\n     */\n    getEntryStore() {\n      return this._context.getEntryStore();\n    }\n\n    /**\n     * @returns {store/EntryInfo}\n     */\n    getEntryInfo() {\n      return this._entryInfo;\n    }\n\n    /**\n     * Convenience method, same as calling entry.getEntryInfo().getEntryURI()\n     * @return {string} the entry uri.\n     * @see store/EntryInfo#getEntryURI\n     */\n    getURI() {\n      return this._entryInfo.getEntryURI();\n    }\n\n    /**\n     * Convenience method, same as calling entry.getEntryInfo().getId()\n     * @returns {string} the id of the entry\n     * @see store/EntryInfo#getId\n     */\n    getId() {\n      return this._entryInfo.getId();\n    }\n\n    /**\n     * Convenience method, same as calling entry.getEntryInfo().getResourceURI()\n     * @returns {string} a URI to the resource of this entry.\n     */\n    getResourceURI() {\n      return this._entryInfo.getResourceURI();\n    }\n\n    /**\n     * @returns {store/Context}\n     */\n    getContext() {\n      return this._context;\n    }\n\n    /**\n     * Provides an RDF graph as an {@link rdfjson/Graph} instance.\n     * @return {rdfjson/Graph} a RDF graph with metadata, typically containing statements about\n     * the resourceURI. The returned graph may be empty but never null or undefined.\n     */\n    getMetadata() {\n      if (this._metadata == null) {\n        this._metadata = new Graph();\n      }\n      return this._metadata;\n    }\n\n    /**\n     * Sets a new metadata graph for this entry without pushing it to the repository.\n     * In many cases this method is not needed since you can get the metadata graph,\n     * modify it and then commit the changes directly.\n     *\n     * However, in some cases you need to set a new metadata graph, e.g.\n     * you want to overwrite the metadata with a new graph retrieved from another source or the\n     * entry have been refreshed with new information and you want to commit the merged results.\n     * In these cases you need to discard the current metadata graph with help of this method.\n     *\n     * @param {rdfjson/Graph} graph is an RDF graph with metadata, if it is not provided the current\n     * metadata graph is saved (there is currently no check whether it has been modified or not).\n     * @return store/Entry - to allow chaining with other methods, e.g. with commitMetadata.\n     */\n    setMetadata(graph) {\n      this._metadata = graph;\n      return this;\n    }\n\n    /**\n     * Will push the metadata for this entry to the repository.\n     * If metadata has been set for an entry with EntryType 'reference'\n     * the entrytype will change to 'linkreference' upon a successful commit.\n     * @params {boolean} ignoreIfUnmodifiedSinceCheck if explicitly set to true no check is done\n     * if information is stale, also it will not automatically refresh with the latest date\n     * @return {entryPromise} a promise that on success will contain the current updated entry.\n     */\n    commitMetadata(ignoreIfUnmodifiedSinceCheck) {\n      let p;\n      const es = this.getEntryStore();\n      if (this.isReference()) {\n        p = Promise.reject(`Entry \"${this.getURI()}\" is a reference and have no local metadata that can be saved.`);\n      } else if (!this.canWriteMetadata()) {\n        p = Promise.reject(`You do not have sufficient access rights to save metadata on entry \"${this.getURI()}\".`);\n      } else if (this.needRefresh()) {\n        p = Promise.reject(`The entry \"${this.getURI()}\" need to be refreshed before its local metadata can be saved.\\n` +\n          'This message indicates that the client is written poorly, this case should have been taken into account.');\n      } else if (this._metadata == null) {\n        p = Promise.reject(`The entry \"${this.getURI()}\" should allow local metadata to be saved, but there is no local metadata.\\nThis message is a bug in the storejs API.`);\n      } else {\n        if (ignoreIfUnmodifiedSinceCheck) {\n          p = es.getREST().put(this.getEntryInfo().getMetadataURI(),\n            JSON.stringify(this._metadata.exportRDFJSON())).then(() => this);\n        }\n        const mod = this.getEntryInfo().getModificationDate();\n        p = es.getREST().put(this.getEntryInfo().getMetadataURI(),\n          JSON.stringify(this._metadata.exportRDFJSON()), mod)\n          .then(() => {\n            this.setRefreshNeeded(true);\n            return this.refresh().then(() => this, () => {\n              // Failed refreshing, but succeded at saving metadata,\n              // at least send out message that it needs to be refreshed.\n              this.getEntryStore().getCache().message('refreshed', this);\n              return this;\n            });\n          });\n      }\n      return es.handleAsync(p, 'commitMetadata');\n    }\n\n    /**\n     * Same as entry.getMetadata().add(entry.getResourceURI(), pred, o)\n     * but instead of returning the created statement it returns the entry itself,\n     * allowing chained method calls.\n     *\n     * @param {string} pred the predicate\n     * @param {object} o the object\n     * @returns {module:store/Entry}\n     */\n    add(pred, o) {\n      this.getMetadata().add(this.getResourceURI(), pred, o);\n      return this;\n    }\n\n    /**\n     * Same as entry.getMetadata().addL(entry.getResourceURI(), pred, lit, lang)\n     * but instead of returning the created statement it returns the entry itself,\n     * allowing chained method calls.\n     *\n     * @param {string} pred the predicate\n     * @param {string} lit the literal value\n     * @param {string} language an optional language\n     * @returns {module:store/Entry}\n     */\n    addL(pred, lit, langugage) {\n      this.getMetadata().addL(this.getResourceURI(), pred, lit, langugage);\n      return this;\n    }\n\n    /**\n     * Same as entry.getMetadata().addD(entry.getResourceURI(), pred, lit, lang)\n     * but instead of returning the created statement it returns the entry itself,\n     * allowing chained method calls.\n     *\n     * @param {string} pred the predicate\n     * @param {string} lit the literal value\n     * @param {string} dt the datatype (should be a string)\n     * @returns {module:store/Entry}\n     */\n    addD(pred, lit, dt) {\n      this.getMetadata().addD(this.getResourceURI(), pred, lit, dt);\n      return this;\n    }\n\n    /**\n     * Cached external metadata can only be provided for entries with entrytype\n     * reference or linkreference.\n     *\n     * @return {rdfjson/Graph} - a RDF graph with cached external metadata, typically containing\n     * statements about the resourceURI. The returned graph may be empty but never null\n     * or undefined.\n     */\n    getCachedExternalMetadata() {\n      if (this._cachedExternalMetadata == null) {\n        this._cachedExternalMetadata = new Graph();\n      }\n\n      return this._cachedExternalMetadata;\n    }\n\n    getInferredMetadata() {\n      return this._inferredMetadata;\n    }\n\n    /**\n     * Sets a new cached external metadata graph for this entry without pushing\n     * it to the repository.\n     *\n     * @param {rdfjson/Graph} graph is an RDF graph with metadata.\n     * @return store/Entry - to allow chaining with other methods,\n     * e.g. with commitCachedExternalMetadata.\n     */\n    setCachedExternalMetadata(graph) {\n      this._cachedExternalMetadata = graph || this._cachedExternalMetadata;\n      return this;\n    }\n\n    /**\n     * Pushes the current cached external metadata graph for this entry to the repository.\n     *\n     * @return {entryPromise} a promise that on success will contain the current updated entry.\n     */\n    commitCachedExternalMetadata() {\n      const self = this;\n      const es = this.getEntryStore();\n      const mod = this.getEntryInfo().getModificationDate();\n      const d = es.getREST().put(this.getEntryInfo().getCachedExternalMetadataURI(),\n        JSON.stringify(this._cachedExternalMetadata.exportRDFJSON()), mod)\n        .then(() => {\n          self.setRefreshNeeded(true);\n          return self.refresh().then(() => self, () => {\n            // Failed refreshing, but succeded at saving metadata,\n            // at least send out message that it needs to be refreshed.\n            self.getEntryStore().getCache().message('refreshed', self);\n            return self;\n          });\n        });\n      return es.handleAsync(d, 'commitCachedExternalMetadata');\n    }\n\n    /**\n     * @todo remains to be supported in repository\n     * @returns {rdfjson/Graph}\n     */\n    getExtractedMetadata() {\n      if (this._extractedMetadata == null) {\n        this._extractedMetadata = new Graph();\n      }\n      return this._extractedMetadata;\n    }\n\n    /**\n     * Provides the resource for this entry if it exists in a promise,\n     * e.g. if the graph-type is not none.\n     * It is also possible to request the resource directly, i.e. get the resource rather\n     * than a promise. This is achieved by specifying the \"direct\" parameter as true.\n     * This always work for Lists, Groups, and Context resources.\n     * For all other resources it will work if the resource, e.g. a Graph,\n     * a String etc. is already loaded. If it is not loaded null will be returned.\n     *\n     * @returns {store/Resource|resourcePromise}\n     */\n    getResource(direct) {\n      if (direct) {\n        return this._resource;\n      }\n      const es = this.getEntryStore();\n      let p;\n      if (this._resource) {\n        p = Promise.resolve(this._resource);\n      } else {\n        p = es.getREST().get(this.getResourceURI()).then((data) => {\n          es.getFactory().updateOrCreateResource(this, { resource: data }, true);\n          return this._resource;\n        });\n      }\n      return es.handleAsync(p, 'getResource');\n    }\n\n    /**\n     * @returns {rdfjson/Graph}\n     */\n    getReferrersGraph() {\n      return this._relation;\n    }\n\n    /**\n     * a list of URIs that has referred to this Entry using various properties.\n     *\n     * @param {string} prop\n     * @returns {string[]}\n     */\n    getReferrers(prop) {\n      return this._relation.find(null, prop, null).map(stmt => stmt.getSubject());\n    }\n\n    /**\n     * a list of entry URIs corresponding to list entries where this entry is contained.\n     * @returns {string[]}\n     */\n    getParentLists() {\n      const listResourceURIArr = this.getReferrers('http://entrystore.org/terms/hasListMember');\n      return listResourceURIArr.map(resURI =>\n        this.getEntryStore().getFactory().getEntryURIFromURI(this.getEntryStore(), resURI), this);\n    }\n\n    /**\n     * a list of entry URIs corresponding to groups where this user entry is member.\n     * @returns {string[]}\n     */\n    getParentGroups() {\n      const groupResourceURIArr = this.getReferrers('http://entrystore.org/terms/hasGroupMember');\n      return groupResourceURIArr.map(resURI =>\n        this.getEntryStore().getFactory().getEntryURIFromURI(this.getEntryStore(), resURI), this);\n    }\n\n    /**\n     * a list of comments (i.e. their URIs) of this entry.\n     * @returns {string[]}\n     */\n    getComments() {\n      return this.getReferrers('http://ontologi.es/like#regarding');\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType list?\n     * @returns {boolean}\n     */\n    isList() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_LIST;\n    }\n\n    /**\n     * Is the resource of this entry of the Graphtype resultlist?\n     * @returns {boolean}\n     */\n    isResultList() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_RESULTLIST;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType context?\n     * @returns {boolean}\n     */\n    isContext() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_CONTEXT;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType systemcontext?\n     * @returns {boolean}\n     */\n    isSystemContext() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_SYSTEMCONTEXT;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType user?\n     * @returns {boolean}\n     */\n    isUser() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_USER;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType group?\n     * @returns {boolean}\n     */\n    isGroup() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_GROUP;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType graph?\n     * @returns {boolean}\n     */\n    isGraph() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_GRAPH;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType pipeline?\n     * @returns {boolean}\n     */\n    isPipeline() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_PIPELINE;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType pipelineresult?\n     * @returns {boolean}\n     */\n    isPipelineResult() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_PIPELINERESULT;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType string?\n     * @returns {boolean}\n     */\n    isString() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_STRING;\n    }\n\n    /**\n     * Is the resource of this entry of the GraphType none?\n     * @returns {boolean}\n     */\n    isNone() {\n      return this.getEntryInfo().getGraphType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_NONE;\n    }\n\n    /**\n     * Is this entry of the EntryType link?\n     * @returns {boolean}\n     */\n    isLink() {\n      return this.getEntryInfo().getEntryType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LINK;\n    }\n\n    /**\n     * Is this entry of the EntryType reference?\n     * @returns {boolean}\n     */\n    isReference() {\n      return this.getEntryInfo().getEntryType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_REF;\n    }\n\n    /**\n     * Is this entry of the EntryType linkreference?\n     * @returns {boolean}\n     */\n    isLinkReference() {\n      return this.getEntryInfo().getEntryType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LINKREF;\n    }\n\n    /**\n     * Is the entry of the EntryType link, linkreference or reference?\n     * That is, the resource can be controlled via {@link store/EntryInfo#setResourceURI}.\n     *\n     * @returns {boolean} true if entrytype is NOT local.\n     */\n    isExternal() {\n      return this.getEntryInfo().getEntryType() !== _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LOCAL;\n    }\n\n    /**\n     * Is the EntryType local, i.e. the resources URI is maintained\n     * automatically by the repository for this entry.\n     * Opposite to {@link store/Entry#isLinkLike}.\n     *\n     * @returns {boolean}\n     */\n    isLocal() {\n      return this.getEntryInfo().getEntryType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LOCAL;\n    }\n\n    /**\n     * Is the entry a local link/linkreference/reference to another entry in the repository.\n     * That is, true if the entry is a link, linkreference or reference AND the resource URI\n     * belongs to another entry in the same repository.\n     *\n     * @returns {boolean}\n     */\n    isLinkToEntry() {\n      const base = this.getEntryStore().getBaseURI();\n      return this.isExternal() && this.getResourceURI().substr(0, base.length) === base;\n    }\n\n    /**\n     * Is the entry is a link to another entry (as either a link, linkreference or reference) the\n     * linked to entry is returned in a promise.\n     *\n     * @returns {entryPromise|undefined} undefined only if the entry does not link to another entry.\n     */\n    getLinkedEntry() {\n      if (this.isLinkToEntry()) {\n        // In case the link is to the resoure URI rather than the entry URI, we extract\n        // the entry id and context id and rebuild the entry URI.\n        const es = this.getEntryStore();\n        let uri = this.getResourceURI();\n        const eid = es.getEntryId(uri);\n        const cid = es.getContextId(uri);\n        uri = es.getEntryURI(cid, eid);\n        return es.handleAsync(this.getEntryStore().getEntry(uri), 'getLinkedEntry');\n      }\n      return undefined;\n    }\n\n    /**\n     * Is the entry an information resource?\n     * @returns {boolean}\n     */\n    isInformationResource() {\n      return this.getEntryInfo().getResourceType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_INFORMATIONRESOURCE;\n    }\n\n    /**\n     * Is the entry a named resource?\n     * @returns {boolean}\n     */\n    isNamedResource() {\n      return this.getEntryInfo().getResourceType() === _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_NAMEDRESOURCE;\n    }\n\n    /**\n     * Is the current user an owner of this entry?\n     * @returns {boolean}\n     */\n    canAdministerEntry() {\n      return this._rights.administer || false;\n    }\n\n    /**\n     * Is the current user authorized to read the resource of this entry?\n     * @returns {boolean}\n     */\n    canReadResource() {\n      return this._rights.administer || this._rights.readresource\n        || this._rights.writeresource || false;\n    }\n\n    /**\n     * Is the current user authorized to write the resource of this entry?\n     * @returns {boolean}\n     */\n    canWriteResource() {\n      return this._rights.administer || this._rights.writeresource || false;\n    }\n\n    /**\n     * Is the current user authorized to read the metadata of this entry?\n     * @returns {boolean}\n     */\n    canReadMetadata() {\n      return this._rights.administer || this._rights.readmetadata\n        || this._rights.writemetadata || false;\n    }\n\n    /**\n     * Is the current user authorized to write the metadata of this entry?\n     * @returns {boolean}\n     */\n    canWriteMetadata() {\n      return this._rights.administer || this._rights.writemetadata || false;\n    }\n\n    /**\n     * Whether this entry is available publically or not.\n     * To make sure this method returns a boolean make sure the contexts entry is loaded, e.g. via:\n     * entry.getContext().getEntry().then(function() {\n     *    if (entry.isPublic()) {...} //Or whatever you need to do with the isPublic method.\n     * }\n     *\n     * @returns {boolean|undefined} undefined only if the entry has no ACL and the contexts entry\n     * which specifies the default access is not cached, otherwise a boolean is returned.\n     */\n    isPublic() {\n      const guestprincipal = this.getEntryStore().getResourceURI('_principals', '_guest');\n      let acl = this.getEntryInfo().getACL();\n      if (acl.contextOverride) {\n        return ['rwrite', 'rread', 'mwrite', 'mread'].some(key =>\n          acl[key].indexOf(guestprincipal) !== -1);\n      }\n      const ce = this.getContext().getEntry(true);\n      if (ce == null) {\n        return undefined;\n      }\n      acl = ce.getEntryInfo().getACL();\n      return ['rwrite', 'rread'].some(key => acl[key].indexOf(guestprincipal) !== -1);\n    }\n\n    /**\n     * Whether this entry is available to the specified user.\n     * To make sure this method returns a boolean and not undefined,\n     * make sure that the contexts entry is loaded, e.g. via:\n     *\n     * entry.getContext().getEntry().then(function() {\n     *    //And then do you check, e.g.:\n     *    entry.getEntryStore().getUserEntry().then(function(currentUserEntry) {\n     *       if (entry.isPrivateTo(currentUserEntry) {...}\n     *    })\n     * }\n     *\n     * @returns {boolean|undefined} undefined if the contexts entry which\n     * specifies the default access is not cached, otherwise a boolean is returned.\n     */\n    isPrivateTo(userEntry) {\n      const userPrincipal = userEntry.getResourceURI();\n      const acl = this.getEntryInfo().getACL();\n      const ce = this.getContext().getEntry(true);\n      if (ce == null) {\n        return undefined;\n      }\n      const cacl = ce.getEntryInfo().getACL();\n      if (cacl.admin.length !== 1 || acl.admin[0] !== userPrincipal) {\n        return false;\n      }\n      if (acl.contextOverride) {\n        return acl.admin.length === 1 && acl.admin[0] === userPrincipal;\n      }\n      return true;\n    }\n\n    /**\n     * Deletes this entry without any option to recover it.\n     * @param {boolean} recursive if true and the entry is a list it will delete the entire tree of\n     * lists and all entries that is only contained in the current list or any of its child lists.\n     * @return {dojo/promise/Promise} which on success indicates that the deletion has succeded.\n     */\n    del(recursive) {\n      const es = this.getEntryStore();\n      const unCache = () => {\n        es.getCache().unCache(this);\n      };\n      if (recursive === true) {\n        return es.handleAsync(es.getREST().del(`${this.getURI()}?recursive=true`)\n          .then(unCache), 'delEntry');\n      }\n      return es.handleAsync(es.getREST().del(this.getURI()).then(unCache), 'delEntry');\n    }\n\n    /**\n     * That an entry needs to be refreshed typically means that it contains stale data\n     * (with respect to what is available in the store).\n     * The entry should be refresh before it is further used.\n     *\n     * @param {boolean=} silently the cache will send out a stale message (to all registered\n     * listeners of the cache) for this entry if the value is false or undefined.\n     * @see store.Entry#refresh.\n     */\n    setRefreshNeeded(silently) {\n      this.getEntryStore().getCache().setRefreshNeeded(this, silently);\n    }\n\n    /**\n     * Tells whether an entry needs to be refreshed.\n     *\n     * @return {boolean} true if the entry need to be refreshed before used.\n     * @see store/Entry#refresh.\n     */\n    needRefresh() {\n      return this.getEntryStore().getCache().needRefresh(this);\n    }\n\n    /**\n     * Refreshes an entry if needed, that is, if it has been marked as invalid.\n     * @param {boolean=} silently the cache will send out a refresh message for this entry\n     * if a refresh was needed AND if the value of silently is false or undefined. If force is true\n     * it will send out a refresh message anyhow.\n     * @param {force=} if true the entry will be refreshed independent if it was marked in need\n     * of a refresh or not.\n     */\n    refresh(silently, force) {\n      const es = this.getEntryStore();\n      let p;\n      if (force === true || es.getCache().needRefresh(this)) {\n        const entryURI = this.getURI();\n        const factory = this.getEntryStore().getFactory();\n        p = es.getREST().get(factory.getEntryLoadURI(entryURI)).then((data) => {\n          factory.update(this, data);\n          es.getCache().cache(this, silently);\n          return this;\n        });\n      } else {\n        p = Promise.resolve(this);\n      }\n      return es.handleAsync(p, 'refresh');\n    }\n  };\n\n  \n\n/**\n * Promise that provides an {@link store/Entry} on success.\n *\n * @name entryPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name entryPromise#then\n * @param {entryCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n/**\n * This is a successful callback method to be provided as first argument in a {@link entryPromise}\n *\n * @callback entryCallback\n * @param {store/Entry} entry\n */\n\n\n//# sourceURL=webpack:///./Entry.js?");

/***/ }),

/***/ "./EntryInfo.js":
/*!**********************!*\
  !*** ./EntryInfo.js ***!
  \**********************/
/*! exports provided: EntryInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntryInfo\", function() { return EntryInfo; });\n/* harmony import */ var _terms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./terms */ \"./terms.js\");\n/* global define*/\n\nconst Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\nconst stamp = __webpack_require__(/*! dojo/date/stamp */ \"./node_modules/dojo/date/stamp.js\");\n\n  /**\n   * EntryInfo is a class that contains all the administrative information of an entry.\n   * @exports store/EntryInfo\n   */\n  const EntryInfo = class {\n    /**\n     * @param {String} entryURI must be provided unless the graph contains a statement with\n     * the store:resource property which allows us to infer the entryURI.\n     * @param {rdfjson/Graph} graph corresponds to a rdfjson.Graph class with the entryinfo as\n     * statements\n     * @param {store/EntryStore} entryStore\n     */\n    constructor(entryURI, graph, entryStore) {\n      this._entryURI = entryURI || graph.find(null, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].resource)[0].getSubject();\n      this._graph = graph || new Graph();\n      this._entryStore = entryStore;\n    }\n\n    /**\n     * @returns {store/Entry}\n     */\n    getEntry() {\n      return this._entry;\n    }\n\n    /**\n     * @param {rdfjson/Graph} graph\n     */\n    setGraph(graph) {\n      this._graph = graph;\n    }\n\n    /**\n     * @return {rdfjson/Graph}\n     */\n    getGraph() {\n      return this._graph;\n    }\n\n    /**\n     * Pushes the entry information to the repository, e.g. posts to\n     * basepath/store/{contextId}/entry/{entryId}\n     * @params {boolean} ignoreIfUnmodifiedSinceCheck if explicitly set to true no check is done\n     * if information is stale, also it will not automatically refresh with the latest date\n     * @returns {entryInfoPromise}\n     */\n    commit(ignoreIfUnmodifiedSinceCheck) {\n      const es = this._entry.getEntryStore();\n      const mod = ignoreIfUnmodifiedSinceCheck === true ? undefined : this.getModificationDate();\n      const p = es.getREST().put(this.getEntryURI(),\n        JSON.stringify(this._graph.exportRDFJSON()), mod)\n        .then(() => {\n          if (ignoreIfUnmodifiedSinceCheck !== true) {\n            this._entry.setRefreshNeeded(true);\n            return this._entry.refresh().then(() => this, () => {\n              // Failed refreshing, but succeded at saving metadata,\n              // at least send out message that it needs to be refreshed.\n              es.getCache().message('refreshed', this);\n              return this;\n            });\n          }\n          return this;\n        });\n      return es.handleAsync(p, 'commitEntryInfo');\n    }\n\n    /**\n     * @returns {String}\n     */\n    getEntryURI() {\n      return this._entryURI;\n    }\n\n    /**\n     * @returns {String} the id of the entry\n     */\n    getId() {\n      return this._entryStore.getFactory().getEntryId(this._entryURI);\n    }\n\n    /**\n     * If the entry is a user, group or context there can be a name.\n     * In general the name is accessed on the resource, but in certain\n     * situations we do not have the resource yet(not loaded) but we still\n     * have the name (from a search where the name is provided but not the resource),\n     * in this case we can access this name here.\n     *\n     * @returns {String} a username, groupname or contextname of the entry\n     */\n    getName() {\n      return this._name;\n    }\n\n    /**\n     * @returns {String}\n     */\n    getMetadataURI() {\n      return this._entryStore.getFactory().getMetadataURI(this._entryURI);\n    }\n\n    /**\n     * @returns {String}\n     */\n    getExternalMetadataURI() {\n      // TODO will only exist for LinkReferences and References.\n      return this._graph.findFirstValue(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].externalMetadata);\n    }\n\n    /**\n     * @param {String} uri\n     */\n    setExternalMetadataURI(uri) {\n      this._graph.findAndRemove(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].externalMetadata);\n      this._graph.create(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].externalMetadata, { type: 'uri', value: uri });\n    }\n\n    /**\n     * @returns {String}\n     */\n    getCachedExternalMetadataURI() {\n      return this._entryStore.getFactory().getCachedExternalMetadataURI(this._entryURI);\n    }\n\n    /**\n     * @returns {String}\n     */\n    getResourceURI() {\n      return this._graph.findFirstValue(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].resource);\n    }\n\n    /**\n     * @param {String} uri\n     */\n    setResourceURI(uri) {\n      const oldResourceURI = this.getResourceURI();\n      this._graph.findAndRemove(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].resource);\n      this._graph.create(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].resource, { type: 'uri', value: uri });\n      if (oldResourceURI) {\n        const stmts = this._graph.find(oldResourceURI);\n        for (let i = 0; i < stmts.length; i++) {\n          stmts[i].setSubject(uri);\n        }\n      }\n    }\n\n    /**\n     * @returns {String} one of the entryTypes\n     * @see store/terms#entryType\n     */\n    getEntryType() {\n      const et = this._graph.findFirstValue(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].rdf.type);\n      return _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].entryType[et || 'default'];\n    }\n\n    static getResourceTypeHelper(entry, vocab) {\n      const stmts = entry._graph.find(entry.getResourceURI(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].rdf.type);\n      for (let i = 0; i < stmts.length; i++) {\n        const t = vocab[stmts[i].getValue()];\n        if (t != null) {\n          return t;\n        }\n      }\n      return vocab.default;\n    }\n\n    /**\n     * the resource type of the entry, e.g. \"Information\", \"Resolvable\" etc.\n     * The allowed values are available in store/types beginning with 'RT_'.\n     * E.g. to check if the entry is an information resource:\n     * if (ei.getResourceType() === types.RT_INFORMATIONRESOURCE) {...}\n     *\n     * @returns {String}\n     */\n    getResourceType() {\n      return this.constructor.getResourceTypeHelper(this, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].resourceType);\n    }\n\n    /**\n     * the graph type of the entry, e.g. \"User\", \"List\", \"String\", etc.\n     * The allowed values are available in store/types beginning with 'GT_'.\n     * E.g. to check if the entry is a list:\n     * if (ei.getGraphType() === types.GT_LIST) {...}\n     *\n     * @returns {String}\n     */\n    getGraphType() {\n      return this.constructor.getResourceTypeHelper(this, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].graphType);\n    }\n\n    // TODO: change to entryURI instead of resourceURI for principalURIs.\n    /**\n     * The acl object returned looks like:\n     * {\n     *   admin:  [principalURI1, principalURI2, ...],\n     *   rread:  [principalURI3, ...],\n     *   rwrite: [principalURI4, ...],\n     *   mread:  [principalURI5, ...],\n     *   mwrite: [principalURI6, ...]\n     * }\n     *\n     * There will always be an array for each key, it might be empty though.\n     * The principalURI* will always be an URI to the resource of a user or group entry.\n     *\n     * Please note that a non empty acl overrides any defaults from the surrounding context.\n     *\n     * @param {boolean} asIds - if true the principalURIs are shortened to entry identifiers.\n     * @return {Object} an acl object.\n     */\n    getACL(asIds) {\n      const factory = this._entryStore.getFactory();\n      const f = function (stmt) {\n        if (asIds) {\n          return factory.getEntryId(stmt.getValue());\n        }\n        return stmt.getValue();\n      };  // Statement > object value.\n      const ru = this.getResourceURI();\n      const mu = this.getMetadataURI();\n      const acl = {\n        admin: this._graph.find(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.write).map(f),\n        rread: this._graph.find(ru, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.read).map(f),\n        rwrite: this._graph.find(ru, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.write).map(f),\n        mread: this._graph.find(mu, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.read).map(f),\n        mwrite: this._graph.find(mu, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.write).map(f),\n      };\n      acl.contextOverride = acl.admin.length !== 0 || acl.rread.length !== 0\n        || acl.rwrite.length !== 0 || acl.mread.length !== 0 || acl.mwrite.length !== 0;\n      return acl;\n    }\n\n    /**\n     * if the entry has an explicit ACL or if the containing contexts ACL is used.\n     *\n     * @returns {boolean}\n     */\n    hasACL() {\n      return this.getACL().contextOverride;\n    }\n\n    /**\n     * Replaces the current acl with the provided acl.\n     * The acl object is the same as you get from the getACL call.\n     * The first difference is that the acl object from this method is allowed to be empty\n     * or leave out some keys that are not to be set.\n     * The second difference is that it allows entryIds as values in the arrays,\n     * not only full resource URIs, both have to refer to principals though.\n     *\n     * @param {Object} acl same kind of object you get from getACL.\n     */\n    setACL(acl) {\n      const g = this._graph;\n      const f = function (subj, pred, principals, base) {\n        g.findAndRemove(subj, pred);\n        (principals || []).forEach((principal) => {\n          if (principal.length < base.length || principal.indexOf(base) !== 0) {\n            // principal is entry id.\n            g.add(subj, pred, { type: 'uri', value: base + principal });\n          } else {\n            // principal is a full entry resource uri.\n            g.add(subj, pred, { type: 'uri', value: principal });\n          }\n        });\n      };\n      const _acl = acl || {};\n      const ru = this.getResourceURI();\n      const mu = this.getMetadataURI();\n      const base = this._entryStore.getFactory().getResourceBase(this._entry.getEntryStore(), '_principals');\n      f(this._entryURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.write, _acl.admin, base);\n      f(ru, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.read, _acl.rread, base);\n      f(ru, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.write, _acl.rwrite, base);\n      f(mu, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.read, _acl.mread, base);\n      f(mu, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].acl.write, _acl.mwrite, base);\n    }\n\n    /**\n     * Checks if there are any metadata revisions for this entry,\n     * in practise this is always true if provenance is enabled for this entry.\n     *\n     * @return {boolean} true if there is at least one metadata revision.\n     */\n    hasMetadataRevisions() {\n      const mdURI = this.getMetadataURI();\n      return this._graph.findFirstValue(null, 'owl:sameAs', mdURI) != null;\n    }\n\n    /**\n     * Extracts an array of metadata revisions from the graph.\n     * Each revision is an object that contains:\n     *   * time - when the change was made (Date)\n     *   * by   - the user who performed the change (entryURI)\n     *   * rev  - the revision number (string)\n     *   * uri  - an URI to this revision (string)\n     *\n     * The uri of the revision can be used by the method getMetadataRevisionGraph\n     * to get a hold of the actual new graph that caused the revision.\n     *\n     * @return {object[]} a sorted array of revisions, latest revision first.\n     */\n    getMetadataRevisions() {\n      const revs = [];\n      const mdURI = this.getMetadataURI();\n      const stmts = this._graph.find(null, 'owl:sameAs', mdURI);\n      if (stmts.length !== 1) {\n        return revs;\n      }\n      let uri = stmts[0].getSubject();\n      const es = this._entryStore;\n      while (uri) {\n        revs.push({\n          uri,\n          rev: uri.substr(mdURI.length + 5),\n          time: stamp.fromISOString(this._graph.findFirstValue(uri, 'prov:generatedAtTime')),\n          by: es.getEntryURIFromURI(this._graph.findFirstValue(uri, 'prov:wasAttributedTo')),\n        });\n        uri = this._graph.findFirstValue(uri, 'prov:wasRevisionOf');\n      }\n      revs.sort((r1, r2) => {\n        if (r1.time > r2.time) {\n          return -1;\n        } else if (r1.time < r2.time) {\n          return 1;\n        }\n        return 0;\n      });\n      return revs;\n    }\n\n    /**\n     * Retrieves the metadata graph of a certain revision from its graph.\n     * @param revisionURI\n     * @return {graphPromise}\n     */\n    getMetadataRevisionGraph(revisionURI) {\n      return this._entryStore.getREST().get(revisionURI).then(data => new Graph(data));\n    }\n\n    /**\n     * @returns {string} the label of the resource of this entry,\n     * typically set when uploading a file.\n     */\n    getLabel() {\n      return this._graph.findFirstValue(this.getResourceURI(), 'http://www.w3.org/2000/01/rdf-schema#label');\n    }\n\n    /**\n     * Sets a new label of the resource in the graph, call\n     * {@link store/EntryInfo#commit commit} to push\n     * the updated graph to the repository.\n     *\n     * @param {string} label - a new label for the resource.\n     */\n    setLabel(label) {\n      this._graph.findAndRemove(this.getResourceURI(), 'http://www.w3.org/2000/01/rdf-schema#label');\n      if (label != null && label !== '') {\n        this._graph.add(this.getResourceURI(), 'http://www.w3.org/2000/01/rdf-schema#label', {\n          type: 'literal',\n          value: label,\n        });\n      }\n    }\n\n    /**\n     * @returns {string} the format of the resource of this entry.\n     */\n    getFormat() {\n      return this._graph.findFirstValue(this.getResourceURI(), 'http://purl.org/dc/terms/format');\n    }\n\n    /**\n     * Sets a new format of the resource in the graph, call {@link store/EntryInfo#commit commit}\n     * to push the updated graph to the repository.\n     *\n     * @param {string} format - a format in the form application/json or text/plain.\n     */\n    setFormat(format) {\n      this._graph.findAndRemove(this.getResourceURI(), 'http://purl.org/dc/terms/format');\n      if (format != null && format !== '') {\n        this._graph.addL(this.getResourceURI(), 'http://purl.org/dc/terms/format', format);\n      }\n    }\n\n    /**\n     * @returns {string} the status of this entry, always a URI.\n     */\n    getStatus() {\n      return this._graph.findFirstValue(this.getEntryURI(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].status.property);\n    }\n\n    /**\n     * Sets a new format of the resource in the graph, call {@link store/EntryInfo#commit commit}\n     * to push the updated graph to the repository.\n     *\n     * @param {string} format - a format in the form application/json or text/plain.\n     */\n    setStatus(status) {\n      this._graph.findAndRemove(this.getEntryURI(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].status.property);\n      if (status != null && status !== '' && status.indexOf('http') === 0) {\n        this._graph.add(this.getEntryURI(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].status.property, status);\n      }\n    }\n\n    /**\n     * @returns {Date} the date when the entry was created.\n     */\n    getCreationDate() {\n      const d = this._graph.findFirstValue(this.getEntryURI(), 'http://purl.org/dc/terms/created');\n      return stamp.fromISOString(d); // Must always exist.\n    }\n\n    /**\n     * @returns {Date} the date of last modification (according to the repository,\n     * local changes are not reflected).\n     */\n    getModificationDate() {\n      const d = this._graph.findFirstValue(this.getEntryURI(), 'http://purl.org/dc/terms/modified');\n      if (d != null) {\n        return stamp.fromISOString(d);\n      }\n      return this.getCreationDate();\n    }\n\n    /**\n     * @returns {String} a URI to creator, the user Entrys resource URI is used, e.g. \"http://somerepo/store/_principals/resource/4\", never null.\n     */\n    getCreator() {\n      return this._graph.findFirstValue(this.getEntryURI(), 'http://purl.org/dc/terms/creator');\n    }\n\n    /**\n     * @returns {String} a URI to creator, the user Entrys resource URI is used, e.g. \"http://somerepo/store/_principals/resource/4\", never null.\n     */\n    getSize() {\n      const extent = this._graph.findFirstValue(this.getResourceURI(), 'http://purl.org/dc/terms/extent');\n// eslint-disable-next-line eqeqeq\n      if (parseInt(extent, 10) == extent) {\n        return parseInt(extent, 10);\n      }\n      return undefined;\n    }\n\n    /**\n     * @returns {Array} an array of URIs to the contributors using their Entrys resource URIs,\n     * e.g. [\"http://somerepo/store/_principals/resource/4\"], never null although the array might be empty.\n     */\n    getContributors() {\n      return this._graph.find(this.getEntryURI(),\n        'http://purl.org/dc/terms/contributor').map(statement => statement.getValue());\n    }\n  };\n\n\n\n/**\n * Promise that provides an {@link store/Entry} on success.\n *\n * @name entryInfoPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name entryInfoPromise#then\n * @param {entryInfoCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n/**\n * This is a successful callback method to be provided as first argument in a\n * {@link entryInfoPromise}\n *\n * @callback entryInfoCallback\n * @param {store/EntryInfo} entry\n */\n\n/**\n * Promise that provides an {@link rdfjson/Graph} on success.\n *\n * @name graphPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name graphPromise#then\n * @param {graphCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n/**\n * This is a successful callback method to be provided as first argument in a {@link graphPromise}\n *\n * @callback graphCallback\n * @param {rdfjson/Graph} graph\n */\n\n\n//# sourceURL=webpack:///./EntryInfo.js?");

/***/ }),

/***/ "./EntryStore.js":
/*!***********************!*\
  !*** ./EntryStore.js ***!
  \***********************/
/*! exports provided: EntryStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntryStore\", function() { return EntryStore; });\n/* harmony import */ var _SolrQuery__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SolrQuery */ \"./SolrQuery.js\");\n/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Cache */ \"./Cache.js\");\n/* harmony import */ var _Rest__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Rest */ \"./Rest.js\");\n/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./factory */ \"./factory.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./types */ \"./types.js\");\n/* harmony import */ var _PrototypeEntry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./PrototypeEntry */ \"./PrototypeEntry.js\");\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\n/* harmony import */ var _User__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./User */ \"./User.js\");\n/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Auth */ \"./Auth.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils */ \"./utils.js\");\n/* eslint-disable class-methods-use-this */\n const Deferred = __webpack_require__(/*! dojo/Deferred */ \"./node_modules/dojo/Deferred.js\");\n \n \n \n \n \n \n \n \n \n\n const has = __webpack_require__(/*! dojo/has */ \"./node_modules/dojo/has.js\");\n\n  /**\n   * EntryStore is the main class that is used to connect to a running server-side EntryStore\n   * repository.\n   * @exports store/EntryStore\n   */\n  const EntryStore = class {\n    /**\n     * @param {String=} baseURI - URL to the EntryStore repository we should communicate with,\n     * may be left out and\n     * guessed if run in a browser environment (appends \"/store/\" to the window.location.origin)\n     * @param {Object=} credentials - same as provided in the {@link store/EntryStore#auth auth}\n     * method.\n     */\n    constructor(baseURI, credentials) {\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_9__[\"isBrowser\"])() && baseURI == null) {\n        this._baseURI = `${window.location.origin}/store/`;\n      } else {\n        this._baseURI = baseURI;\n        if (this._baseURI[this._baseURI.length - 1] !== '/') {\n          this._baseURI = `${this._baseURI}/`;\n        }\n      }\n\n      this._cache = new _Cache__WEBPACK_IMPORTED_MODULE_1__[\"Cache\"]();\n      this._auth = new _Auth__WEBPACK_IMPORTED_MODULE_8__[\"Auth\"](this);\n      if (credentials) {\n        this.auth(credentials);\n      }\n      this._contexts = {};\n      this._rest = new _Rest__WEBPACK_IMPORTED_MODULE_2__[\"Rest\"]();\n    }\n\n    /**\n     * Provides a listener that will be called for every asynchronous call being made.\n     * The handler is invoked with the promise from the asynchrounous call\n     * and a callType parameter indicating which asynchronous call that has been made.\n     *\n     * The callType parameter can take the following values:\n     * - getEntry        - an entry is retrieved (EntryStore.getEntry)\n     * - createEntry     - an entry is created   (EntryStore.createEntry)\n     * - createGroupAndContext - a group and context pair is created\n     * (EntryStore.createGroupAndContext)\n     * - loadViaProxy    - data is requested via repository proxy (EntryStore.loadViaProxy)\n     * - commitMetadata  - changes to metadata is pushed (Entry.commitMetadata)\n     * - commitCachedExternalMetadata - changes to cached external metadata is pushed\n     * (Entry.commitCachedExternalMetadata)\n     * - getResource     - the entrys resource has been requested (Entry.getResource)\n     * - getLinkedEntry  - a linked entry is requested (Entry.getLinkedEntry)\n     * - delEntry        - an entry is deleted (Entry.del)\n     * - refresh         - an entry is refreshed (Entry.refresh)\n     * - setContextName  - the name of a context is changed (Context.setName)\n     * - getUserInfo     - the user information is requested (auth.getUserInfo)\n     * - getUserEntry    - the user entry is requested (auth.getUserEntry)\n     * - login           - logging in (auth.login)\n     * - logout          - logging out (auth.logout)\n     * - commitEntryInfo - pushing changes in entry information (EntryInfo.commit)\n     * - getFile         - the contents of a file resource is requested (File.get*)\n     * - putFile         - the contents of a file is pushed (File.put*)\n     * - commitGraph     - a graph resource is pushed (Graph.commit)\n     * - commitString    - a string resource is pushed (String.commit)\n     * - setGroupName    - a new name of a group is pushed (Group.setName)\n     * - setUserName     - a new name of a user is pushed (User.setName)\n     * - setUserLanguage - a new preferred language of the user is pushed (User.setLanguage)\n     * - setUserPassword - a new password for the user is pushed (User.setPassword)\n     * - setUserHomeContext - a new homecontext for the user is pushed (User.setHomeContext)\n     * - setUserCustomProperties - new custom properties for the user (User.setCustomProperties)\n     * - loadListEntries - members of a list are requested (List.getEntries)\n     * - setList         - the list members are changed via a list\n     * - addToList       - See List.addEntry\n     * - removeFromList  - See List.removeEntry\n     * .removeEntry)\n     * - search          - a search is being performed (SearchList.getEntries)\n     * - execute         - a pipeline is executed (Pipeline.execute)\n     *\n     * @param {asyncListener} listener\n     */\n    addAsyncListener(listener) {\n      if (this.asyncListeners) {\n        this.asyncListeners.push(listener);\n      } else {\n        this.asyncListeners = [listener];\n      }\n    }\n\n    /**\n     * Removes a previously added listener for asynchronous calls.\n     * @param listener\n     */\n    removeAsyncListener(listener) {\n      if (this.asyncListeners) {\n        this.asyncListeners.splice(this.asyncListeners.indexOf(listener), 1);\n      }\n    }\n\n    handleAsync(promise, context) {\n      if (this.asyncListeners) {\n        for (let i = 0; i < this.asyncListeners.length; i++) {\n          this.asyncListeners[i](promise, context);\n        }\n      }\n      return promise;\n    }\n\n    /**\n     * @returns {store/Auth} where functionality related to authorization are located,\n     * including a listener infrastructure.\n     */\n    getAuth() {\n      return this._auth;\n    }\n\n    /**\n     * Yields information about who currently is authenticated against the EntryStore repository.\n     * @returns {userInfoPromise} - upon success an object containing attributes \"user\" being\n     * the username, \"id\" of the user entry, and \"homecontext\" being the entry-id of the\n     * home context is provided.\n     * @see {@link store/EntryStore#auth auth}\n     * @see {@link store/EntryStore#logout logout}\n     * @deprecated use corresponding method on auth object instead.\n     */\n    getUserInfo() {\n      return this._auth.getUserInfo();\n    }\n\n    /**\n     * @returns {entryPromise} on success the entry for the currently signed in user is provided.\n     * @deprecated use corresponding method on auth object instead.\n     */\n    getUserEntry() {\n      return this._auth.getUserEntry();\n    }\n\n    /**\n     * Authenticate using credentials containing a user, a password and an optional maxAge given\n     * in seconds.\n     *\n     * @param {object} credentials as a parameter object\n     * @deprecated use corresponding method on auth object instead.\n     */\n    auth(credentials) {\n      if (credentials == null) {\n        return this._auth.logout();\n      }\n      return this._auth.login(credentials.user, credentials.password, credentials.maxAge);\n    }\n\n    /**\n     * Logout the currently authorized user.\n     * @returns {xhrPromise}\n     * @deprecated use corresponding method on auth object instead.\n     */\n    logout() {\n      return this._auth.logout();\n    }\n\n    /**\n     * Fetches an entry given an entryURI. If the entry is already loaded and available in the\n     * cache it will be returned directly, otherwise it will be loaded from the repository.\n     * If the entry is already loaded but marked as in need of a refresh it will be refreshed\n     * first.\n     *\n     * The optional load parameters are provided in a single parameter object with six possible\n     * attributes. Below we outline these attributes, the first two (forceLoad and direct) applies\n     * to all kind of entries while the following three (limit, offset and sort) only applies if\n     * the entry is a list:\n     *\n     * forceLoad - ignores if the entry is already in cache and fetches from the repository\n     * loadResource - makes sure that entry.getResource(true) will not return null\n     *     (does not work in combination with direct).\n     * direct - returns the entry from the cache directly rather than returning a promise,\n     *    if the entry is not in the cache an undefined value will be returned.\n     * limit - only a limited number of children are loaded, -1 means no limit, 0, undefined\n     *    or if the attribute is not provided means that the default limit of 20 is used.\n     * offset - only children from offest and forward is returned, must be positive.\n     * sort - information on how to sort the children:\n     *     * if sort is not provided at all or an empty object is provided the members of the\n     *       list will not be sorted, instead the list's natural order will be used\n     *     * if sort is given as null the defaults will be used ({sortBy: \"title\", prio: \"List\"}).\n     *     * if sort is given as a non emtpy object the following attributes are considered:\n     *       ** sortBy - the attribute instructs which metadata field to sort the children by,\n     *          i.e., title, created, modified, or size.\n     *       ** lang - if sort is title and the title is provided in several languages a\n     *          prioritized language can be given.\n     *       ** prio - allows specific graphtypes to be prioritized\n     *          (e.g. show up in the top of the list).\n     *       ** descending - if true the children are shown in descending order.\n     *\n     *\n     * **Note** - in the case where the entry is a list it is possible to change the limit,\n     * offset and sort later by calling the corresponding methods on the {@link store/List}\n     * resource, e.g. {@link store/List#setSort}. However, setting the values already in this\n     * method call has as a consequence that one less request to the repository is made as you\n     * will get members (in the right amount and order) in the same request as you get metadata\n     * and other information.\n     *\n     * A request of a list entry can look like:\n     *\n     *     var euri = entrystore.getEntryURI(\"1\", \"1\");\n     *     entrystore.getEntry(euri, {\n     *          forceLoad: true,\n     *          limit: 10,\n     *          offset: 20,\n     *          sort: {\n     *             sortBy: \"modified\",\n     *             prio: types.GT_LIST\n     *          }\n     *      });\n     *\n     * The optional params here says that we force a load from the repository, that we want the\n     * results to be paginated with a limit of 10 entries per page and that we want page 3.\n     * We also indicate that we want the list to be sorted by latest modification date and that\n     * if there are member entries that are lists they should be sorted to the top.\n     *\n     * @param {string} entryURI - the entryURI for the entry to retrieve.\n     * @param {Object=} optionalLoadParams - parameters for how to load an entry.\n     * @return {entryPromise | store/Entry | undefined} - by default a promise is returned,\n     * if the direct parameter is specified the entry is returned directly or undefined if the\n     * entry is not in cache.\n     * @see {@link store/EntryStore#getEntryURI getEntryURI} for help to construct entry URIs.\n     * @see {@link store/Context#getEntryById} for loading entrys relative to a context.\n     */\n    getEntry(entryURI, optionalLoadParams) {\n      const forceLoad = optionalLoadParams ? optionalLoadParams.forceLoad === true : false;\n      const e = this._cache.get(entryURI);\n      let asyncContext = 'getEntry';\n      if (optionalLoadParams != null) {\n        if (optionalLoadParams.asyncContext) {\n          asyncContext = optionalLoadParams.asyncContext;\n        }\n        if (optionalLoadParams.direct === true) {\n          return e;\n        }\n      }\n      const checkResourceLoaded = (entry) => {\n        if (optionalLoadParams != null && optionalLoadParams.loadResource\n          && entry.getResource() == null) {\n          return entry.getResource().then(() => entry);\n        }\n        return entry;\n      };\n      if (e && !forceLoad) {\n        if ((e.isList() || e.isGroup()) && optionalLoadParams != null) {\n          const list = e.getResource(true); // Direct access works for lists and groups.\n          list.setLimit(optionalLoadParams.limit);\n          list.setSort(optionalLoadParams.sort);\n        }\n\n        // Will only refresh if needed, a promise is returned in any case\n        return this.handleAsync(e.refresh().then(checkResourceLoaded), asyncContext);\n      }\n      const self = this;\n      const entryLoadURI = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getEntryLoadURI(entryURI, optionalLoadParams);\n      return this.handleAsync(this._rest.get(entryLoadURI).then((data) => {\n        // The entry, will always be there.\n        const entry = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].updateOrCreate(entryURI, data, self);\n        return checkResourceLoaded(entry);\n      }, (err) => {\n        throw new Error(`Failed fetching entry. ${err}`);\n      }), asyncContext);\n    }\n\n    /**\n     * Retrieves entries from a list. One way to see it is that this is a convenience method\n     * that retrieves a list entry, its member entries and returns those in an array.\n     *\n     * @param {string} entryURI - URI of the list entry to load entries from.\n     * @param {Object} sort - same sort object as provided in the optionalLoadParams to\n     * {@see store/EntryStore#getEntry getEntry} method.\n     * @param {Object} limit - same limit as provided in the optionalLoadParams to\n     * {@see store/EntryStore#getEntry getEntry} method.\n     * @param {integer} page - unless limit is set to -1 (no pagination) we need to specify which\n     * page to load, first page is 0.\n     * @returns {entryArrayPromise} upon success the promise returns an array of entries.\n     */\n    getListEntries(entryURI, sort, limit, page) {\n      const d = new Deferred();\n      const op = {};\n      if (sort != null) {\n        op.sort = sort;\n      }\n      if (limit % 1 === 0) {\n        op.limit = limit;\n      }\n      if (page % 1 === 0) {\n        if (limit % 1 === 0) {\n          op.offset = limit * page;\n        } else {\n          op.offset = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getDefaultLimit() * page;\n        }\n      }\n      this.getEntryStore().getEntry(entryURI, op).then((entry) => {\n        const list = entry.getResource(true);\n        list.getEntries(page).then((entries) => {\n          d.resolve(entries, list);\n        }, (err) => {\n          d.reject(err);\n        });\n      }, (err) => {\n        d.reject(err);\n      });\n      return d.promise;\n    }\n\n    /**\n     * Retrieves a Context instance via its id. Note that this method returns directly without\n     * checking with the EntryStore repository that the context exists. Hence successive\n     * operations via this context instance may fail if the context does not exist in the\n     * EntryStore\n     * repository.\n     *\n     * Note that in EntryStore everything is connected to entries. Hence a context is nothing else\n     * than a special kind of resource maintained by an entry. This entry provides metadata about\n     * the context as well as the default ownership and access control that applies to all entries\n     * inside of this context.\n     *\n     * To get a hold of the contexts own entry use the {@link store/Resource#getEntry}\n     * method on the context (inherited from the generic {@link store/Resource} class.\n     *\n     * Advanced: Entrys corresponding to contexts are stored in the special _contexts\n     * context which, since it is a context, contains its own entry.\n     *\n     * @param {string} contextId - identifier for the context (not necessarily the same as the\n     * alias/name for the context)\n     * @return {store/Context}\n     */\n    getContextById(contextId) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getContext(this, `${this._baseURI}_contexts/entry/${contextId}`);\n    }\n\n    /**\n     * Retrieves a Context instance via its entry's URI.\n     *\n     * @param {String} contextEntryURI - URI to the context's entry, e.g. base/_contexts/entry/1.\n     * @returns {store/Context}\n     * @see {@link store/EntryStore#getContextById getContextById}\n     */\n    getContext(contextEntryURI) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getContext(this, contextEntryURI);\n    }\n\n    /**\n     * Retrieves a paginated list of all contexts in the EntryStore repository.\n     * @return {store/List} - the list contains entries which have contexts as resources.\n     */\n    getContextList() {\n      return this.newSolrQuery().graphType(_types__WEBPACK_IMPORTED_MODULE_4__[\"types\"].GT_CONTEXT).list();\n    }\n\n    /**\n     * Retrieves a paginated list of all users and groups in the EntryStore repository\n     * @return {store/List} the list contains entries that have principals as resources.\n     * @todo May include folders and other entries as well...\n     */\n    getPrincipalList() {\n      return this.newSolrQuery().graphType([_types__WEBPACK_IMPORTED_MODULE_4__[\"types\"].GT_USER, _types__WEBPACK_IMPORTED_MODULE_4__[\"types\"].GT_GROUP]).list();\n    }\n\n    /**\n     * Creates a new entry according to information in the provided {@link store/PrototypeEntry}.\n     * The information specifies the type of entry, which context it should reside in,\n     * initial metadata etc. This method is seldom called explicitly, instead it is called\n     * indirectly via the {@link store/PrototypeEntry#commit} method. E.g.:\n     *\n     *     context.newEntry().commit().then(function(newlyCreatedEntry) {...}\n     *\n     * @param {store/PrototypeEntry} prototypeEntry - information about the entry to create.\n     * @return {dojo/promise/Promise}\n     * @see store/PrototypeEntry#commit\n     * @see store/EntryStore#newContext\n     * @see store/EntryStore#newUser\n     * @see store/EntryStore#newGroup\n     * @see store/Context#newEntry\n     * @see store/Context#newLink\n     * @see store/Context#newLinkRef\n     * @see store/Context#newRef\n     * @see store/Context#newList\n     * @see store/Context#newGraph\n     * @see store/Context#newString\n     */\n    createEntry(prototypeEntry) {\n      const postURI = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getEntryCreateURI(prototypeEntry, prototypeEntry.getParentList());\n      const postParams = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getEntryCreatePostData(prototypeEntry);\n      return this.handleAsync(this._rest.create(postURI, postParams).then((euri) => {\n        // var euri = factory.getURIFromCreated(data, prototypeEntry.getContext());\n        const plist = prototypeEntry.getParentList();\n        if (plist != null) {\n          const res = plist.getResource(true);\n          if (res != null && res.needRefresh) {\n            plist.getResource(true).needRefresh();\n          }\n        }\n        return this.getEntry(euri);\n      }), 'createEntry');\n    }\n\n    /**\n     * Provides a PrototypeEntry for creating a new context.\n     * @param {string=} contextname - optional name for the context, can be changed later,\n     * must be unique in the _principals context\n     * @param {string=} id - optional requested identifier (entryId) for the context,\n     * cannot be changed later, must be unique in the _principals context\n     * @returns {store/PrototypeEntry}\n     */\n    newContext(contextname, id) {\n      const _contexts = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getContext(this, `${this._baseURI}_contexts/entry/_contexts`);\n      const pe = new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_5__[\"PrototypeEntry\"](_contexts, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_4__[\"types\"].GT_CONTEXT);\n      if (contextname != null) {\n        const ei = pe.getEntryInfo();\n        const resource = new _Resource__WEBPACK_IMPORTED_MODULE_6__[\"Resource\"](ei.getEntryURI(), ei.getResourceURI(), this);\n        resource._update({ name: contextname });\n        pe._resource = resource;\n      }\n      return pe;\n    }\n\n    createGroupAndContext(name) {\n      let uri = `${this._baseURI}_principals/groups`;\n      if (name != null) {\n        uri += `?name=${encodeURIComponent(name)}`;\n      }\n      return this.handleAsync(this._rest.create(uri).then(lang.hitch(this, location => this.getEntry(location))), 'createGroupAndContext');\n    }\n\n    /**\n     * Provides a PrototypeEntry for creating a new user.\n     * @param {string=} username - the name the user will use to authenticate himself\n     * @param {string=} password - the password the user will use to authenticate himself\n     * @param {string=} homeContext - a specific context the user will consider his own home\n     * @param {string=} id - requested identifier for the user\n     * @returns {store/PrototypeEntry}\n     */\n    newUser(username, password, homeContext, id) {\n      const _principals = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getContext(this, `${this._baseURI}_contexts/entry/_principals`);\n      const pe = new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_5__[\"PrototypeEntry\"](_principals, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_4__[\"types\"].GT_USER);\n      const ei = pe.getEntryInfo();\n      const data = {};\n      if (username != null) {\n        data.name = username;\n      }\n      if (password != null) {\n        data.password = password;\n      }\n      if (homeContext != null) {\n        data.homecontext = homeContext;\n      }\n      const user = new _User__WEBPACK_IMPORTED_MODULE_7__[\"User\"](ei.getEntryURI(), ei.getResourceURI(), this, data);\n      pe._resource = user;\n      return pe;\n    }\n\n    /**\n     * @param {string=} groupname - optional name for the group, can be changed later,\n     * must be unique in the _principals context\n     * @param {string=} id - optional requested identifier (entryId) for the group,\n     * cannot be changed later, must be unique in the _principals context\n     * @returns {store/PrototypeEntry}\n     */\n    newGroup(groupname, id) {\n      const _principals = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getContext(this, `${this._baseURI}_contexts/entry/_principals`);\n      const pe = new _PrototypeEntry__WEBPACK_IMPORTED_MODULE_5__[\"PrototypeEntry\"](_principals, id).setGraphType(_types__WEBPACK_IMPORTED_MODULE_4__[\"types\"].GT_GROUP);\n      if (groupname != null) {\n        const ei = pe.getEntryInfo();\n        const resource = new _Resource__WEBPACK_IMPORTED_MODULE_6__[\"Resource\"](ei.getEntryURI(), ei.getResourceURI(), this);\n        resource._update({ name: groupname });\n        pe._resource = resource;\n      }\n      return pe;\n    }\n\n    /**\n     * Move an entry from one list to another.\n     *\n     * @param {store/Entry} entry - entry to move\n     * @param {store/Entry} fromList - source list where the entry is currently residing.\n     * @param {store/Entry} toList - destination list where the entry is supposed to end up.\n     * @returns {xhrPromise}\n     */\n    moveEntry(entry, fromList, toList) {\n      const uri = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getMoveURI(entry, fromList, toList, this._baseURI);\n      return this.handleAsync(this._rest.post(uri, ''), 'moveEntry');\n    }\n\n    /**\n     * Loads data via the EntryStore repository's own proxy.\n     *\n     * @param {string} uri indicates the resource to load.\n     * @param {string} formatHint indicates that you want data back in the format specified\n     * (e.g. by specifiying a suitable accept header).\n     * @returns {xhrPromise}\n     */\n    loadViaProxy(uri, formatHint) {\n      const url = _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getProxyURI(this._baseURI, uri);\n      return this.handleAsync(this._rest.get(url, formatHint, true), 'loadViaProxy');\n    }\n\n    /**\n     * Pushes a file to the server and gets the result back immediately.\n     * Since browser environments cannot access the local filesystem, the only way to get the\n     * contents of a file is to \"upload\" it and get the contents back from the server.\n     * EntryStore provides the \"echo\" resource to provide this workaround.\n     *\n     * In a browser environment a file is represented via an input element which references\n     * the file to be uploaded via its value attribute. E.g.:\n     *\n     *       <input type=\"file\" name=\"uploadFile\"/>\n     *\n     * During the uploading process the input tag will be moved temporarily in the DOM tree,\n     * it will be restored to its original position afterwards (both upon success and failure).\n     *\n     * @param {node} data - input element corresponding to the file to upload (echo).\n     * @returns {xhrPromise}\n     */\n    echoFile(data) {\n      // noinspection AmdModulesDependencies\n      if (!(data instanceof Node)) {\n        throw new Error('Argument needs to be an input element.');\n      }\n      if (data.name == null || data.name === '') {\n        throw new Error('Failure, cannot upload resource from input element unless a name' +\n          ' attribute is provided.');\n      }\n\n      return this.handleAsync(this.getREST().putFile(`${this.getBaseURI()}echo`, data, 'text')\n        .then((rawData) => {\n          const idx = rawData.indexOf('\\n');\n          const status = parseInt(rawData.substr(0, idx).split(':')[1], 10);\n          if (status !== 200) {\n            const err = new Error(`HTTP status code: ${status}`);\n            err.status = status;\n            throw err;\n          }\n          return rawData.substr(idx + 1);\n        }), 'echoFile');\n    }\n\n    /**\n     * Performing searches against an EntryStore repository is achieved by creating a\n     * {@link store/SearchList} which is similar to a regular {@link store/List}.\n     * From this list it is possible to get paginated results in form of matching entries.\n     * For example:\n     *\n     *     var personType = \"http://xmlns.com/foaf/0.1/Person\";\n     *     var searchList = entrystore.newSolrQuery().rdfType(personType).list();\n     *     searchList.setLimit(20).getEntries().then(function(results) {...});\n     *\n     * @returns {store/SolrQuery}\n     */\n    newSolrQuery() {\n      return new _SolrQuery__WEBPACK_IMPORTED_MODULE_0__[\"SolrQuery\"](this);\n    }\n\n    /**\n     * @deprecated use {@link #newSolrQuery} instead.\n     */\n    createSearchList(query) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].createSearchList(this, query);\n    }\n\n    /**\n     * Constructs an entry URI from the id for the context and the specific entry.\n     * @param {string} contextId - an identifier for the context the entry belongs to\n     * @param {string} entryId - an identifier for the entry\n     * @returns {String} - an entry URI\n     */\n    getEntryURI(contextId, entryId) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getEntryURI(this, contextId, entryId);\n    }\n\n    /**\n     * Constructs an entry URI from a normal repository URI, e.g. any URI from which is possible\n     * to deduce a contextId and an entryId. Equivalent to calling:\n     * es.getEntryURI(es.getContextId(uri), es.getEntryId(uri))\n     *\n     * @param {string} uri - a URI for the entry, can be a entryURI (obviously), resourceURI\n     * (if local), metadataURI, or relationsURI.\n     * @returns {String} - an entry URI\n     */\n    getEntryURIFromURI(uri) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getEntryURIFromURI(this, uri);\n    }\n\n    /**\n     * Constructs an entry resource URI (local URI, not a link obviously) from the id for the\n     * context and the specific entry.\n     *\n     * @param {string} contextId - an identifier for the context the resource belongs to\n     * @param {string} entryId - an identifier for the entry the resource belongs to\n     * @returns {String} a resource URI\n     */\n    getResourceURI(contextId, entryId) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getResourceURI(this, contextId, entryId);\n    }\n\n    /**\n     * The base URI of the EntryStore repository we have connected to.\n     *\n     * @returns {String}\n     */\n    getBaseURI() {\n      return this._baseURI;\n    }\n\n    /**\n     * The entry id of this entry, resource or metadata uri.\n     *\n     * @param {string} uri\n     * @returns {string}\n     */\n    getEntryId(uri) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getEntryId(uri, this.getBaseURI());\n    }\n\n    /**\n     * The context id of this entry, resource or metadata uri.\n     *\n     * @param {string} uri\n     * @returns {string}\n     */\n    getContextId(uri) {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"].getContextId(uri, this.getBaseURI());\n    }\n\n    /**\n     *  To get status resource\n     *\n     * @param {string} uri\n     * @returns {Object}\n     */\n    getStatus() {\n      const uri = `${this._baseURI}management/status?extended`;\n      return this.handleAsync(this._rest.get(uri));\n    }\n\n    /**\n     * The cache where all entries are cached after loading.\n     *\n     * @returns {store/Cache}\n     */\n    getCache() {\n      return this._cache;\n    }\n\n    /**\n     * The loading mechanism are performed via REST calls, this REST module can be\n     * used for doing manual lookups outside of the scope of this API.\n     *\n     * @returns {store/Rest}\n     */\n    getREST() {\n      return this._rest;\n    }\n\n    //= =============Non-public methods==============\n\n    /**\n     * @returns {Object}\n     */\n    getCachedContextsIdx() {\n      return this._contexts;\n    }\n\n    /**\n     * Provides information about version of EntryStore repository, the javascript API,\n     * status of services etc.\n     * @todo Needs support from EntryStore REST API\n     * @todo Document promise\n     * @returns {dojo/promise/Promise}\n     */\n    info() {\n      const packageJSON = __webpack_require__(/*! package.json */ \"./package.json\");\n      return { version: packageJSON.version };\n    }\n\n    getFactory() {\n      return _factory__WEBPACK_IMPORTED_MODULE_3__[\"factory\"];\n    }\n  };\n  \n\n/**\n * @callback asyncListener\n * @param {dojo/promise/Promise} promise\n * @param {string} callType\n */\n\n/**\n * @name entryArrayPromise\n * @extends xhrPromise\n * @class\n */\n/**\n * @name entryArrayPromise#then\n * @param {entryArrayCallback} onSuccess provides an array of Entries\n * @param {xhrFailureCallback} onError\n */\n/**\n * @callback entryArrayCallback\n * @param {store/Entry[]} arr\n */\n\n\n//# sourceURL=webpack:///./EntryStore.js?");

/***/ }),

/***/ "./EntryStoreUtil.js":
/*!***************************!*\
  !*** ./EntryStoreUtil.js ***!
  \***************************/
/*! exports provided: EntryStoreUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntryStoreUtil\", function() { return EntryStoreUtil; });\n  /**\n   * EntryStoreUtil provides utility functionality for working with entries.\n   * @exports store/EntryStoreUtil\n   */\n  const EntryStoreUtil = class {\n    /**\n     * @param {store/EntryStore} entrystore\n     */\n    constructor(entrystore) {\n      this._entrystore = entrystore;\n      this._preloadIdx = {};\n    }\n\n    /**\n     * @returns {store/EntryStore}\n     */\n    getEntryStore() {\n      return this._entrystore;\n    }\n\n    /**\n     * Preload entries of a specific type.\n     * Not strictly needed, used for optimization reasons.\n     * Up to a maximum of 100 entries are preloaded.\n     *\n     * @param {string} typeURI\n     * @param {store/context} inContext if provided limits the preload to a specific context.\n     * @returns {store/Entry}\n     */\n    preloadEntries(ofType, inContext) {\n      let preloadForType = this._preloadIdx[ofType];\n      let promise;\n      if (preloadForType) {\n        if (inContext) {\n          promise = preloadForType[inContext.getEntryURI()];\n          if (promise) {\n            return promise;\n          }\n        } else if (preloadForType.noContext) {\n          return preloadForType.noContext;\n        }\n      } else {\n        preloadForType = {};\n        this._preloadIdx[ofType] = preloadForType;\n      }\n\n      const searchObj = this._entrystore.newSolrQuery().resourceType(ofType).limit(100);\n      if (inContext) {\n        searchObj.context(inContext);\n      }\n      const list = searchObj.list();\n      promise = list.getEntries(0);\n      if (inContext) {\n        preloadForType[inContext.getEntryURI()] = promise;\n      } else {\n        preloadForType.noContext = promise;\n      }\n      return promise;\n    }\n\n    clearPreloadEntriesDuplicateCheck(ofType, inContext) {\n      if (ofType) {\n        const preloadForType = this._preloadIdx[ofType];\n        if (preloadForType && inContext) {\n          delete preloadForType[inContext.getEntryURI()];\n        } else {\n          delete this._preloadIdx[ofType];\n        }\n      } else {\n        this._preloadIdx = {};\n      }\n    }\n\n    /**\n     * Retrieves an entry for a resource URI, note that if there are several entries that all\n     * have the same resource URI it is unclear which of these entries that are returned.\n     * Hence, only use this function if you expect there to be a single entry per resource URI.\n     *\n     * @param {string} resourceURI is the URI for the resource.\n     * @param {store/Context=} context only look for entries in this context, may be left out.\n     * @param {string} asyncCallType the callType used when making the search.\n     * @returns {entryPromise}\n     */\n    getEntryByResourceURI(resourceURI, context, asyncCallType) {\n      const cache = this._entrystore.getCache();\n      let entryArr = cache.getByResourceURI(resourceURI);\n      if (context) {\n        entryArr = entryArr.filter(e => e.getContext().getId() === context.getId());\n      }\n      if (entryArr.length > 0) {\n        return Promise.resolve(entryArr[0]);\n      }\n      const query = this._entrystore.newSolrQuery().resource(resourceURI).limit(1);\n      if (context) {\n        query.context(context);\n      }\n      return query.list(asyncCallType).getEntries(0).then((arr) => {\n        if (arr.length > 0) {\n          return arr[0];\n        }\n        throw new Error(`No entries for resource with URI: ${resourceURI}`);\n      });\n    }\n\n    /**\n     * @param {string} resourceURI is the URI for the resource.\n     * @returns {store/Entry}\n     */\n    getEntryListByResourceURI(resourceURI) {\n      return this._entrystore.newSolrQuery().resource(resourceURI).list();\n    }\n\n    /**\n     * Attempting to find a unique entry for a specific type,\n     * if multiple entries exists with the same type the returned promise fails.\n     * You may restrict to a specific context.\n     *\n     * @param {string} typeURI is the rdf:type URI for the entry to match.\n     * @param {store/Context} context restrict to finding the entry in this context\n     * @param {string} asyncCallType the callType used when making the search.\n     * @returns {entryPromise}\n     */\n    getEntryByType(typeURI, context, asyncCallType) {\n      const query = this._entrystore.newSolrQuery().rdfType(typeURI).limit(2);\n      if (context) {\n        query.context(context);\n      }\n      return query.list(asyncCallType).getEntries(0).then((entryArr) => {\n        if (entryArr.length === 1) {\n          return entryArr[0];\n        }\n        throw new Error('Wrong number of entrys in context / repository');\n      });\n    }\n\n    /**\n     * Attempting to find one entry for a specific graph type,\n     * if multiple entries exists with the same type the returned promise fails.\n     * You may restrict to a specific context.\n     *\n     * @param {string} graphType is the graph type for the entry to match, e.g. use\n     * {@see store/types#GT_USER}.\n     * @param {store/Context} context restrict to finding the entry in this context\n     * @param {string} asyncCallType the callType used when making the search.\n     * @returns {entryPromise}\n     */\n    getEntryByGraphType(graphType, context, asyncCallType) {\n      const query = this._entrystore.newSolrQuery().graphType(graphType).limit(2);\n      if (context) {\n        query.context(context);\n      }\n      return query.list(asyncCallType).getEntries(0).then((entryArr) => {\n        if (entryArr.length > 0) {\n          return entryArr[0];\n        }\n        if (context) {\n          throw new Error(`No entrys in context with graphType ${graphType}`);\n        } else {\n          throw new Error(`No entrys in repository with graphType ${graphType}`);\n        }\n      });\n    }\n\n    /**\n     * Removes all entries matched by a search in a serial manner,\n     * also empties the cache from loaded entries so it should not overflow\n     * if the searchlist is big.\n     *\n     * The removal is accomplished by first iterating through the searchlist and collecting\n     * uris to all entries that should be removed. After that the entries are removed.\n     *\n     * @param {store/SearchList} list\n     * @returns {successOrFailPromise}\n     */\n    removeAll(list) {\n      const uris = [];\n      const es = this._entrystore;\n      const cache = es.getCache();\n      const rest = es.getREST();\n      const f = () => {\n        if (uris.length > 0) {\n          const uri = uris.pop();\n          return rest.del(uri).then(f, () => {\n            console.log(`Could not remove entry with uri: ${uri} continuing anyway.`);\n            return f();\n          });\n        }\n        return undefined;\n      };\n      return list.forEach((entry) => {\n        uris.push(entry.getURI());\n        cache.unCache(entry);\n      }).then(() => f());\n    }\n  };\n\n  \n\n/**\n * @name successOrFailPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name successOrFailPromise#then\n * @param {function} onSuccess\n * @param {function} onError\n */\n\n\n//# sourceURL=webpack:///./EntryStoreUtil.js?");

/***/ }),

/***/ "./File.js":
/*!*****************!*\
  !*** ./File.js ***!
  \*****************/
/*! exports provided: FileResource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FileResource\", function() { return FileResource; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./utils.js\");\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\n/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./factory */ \"./factory.js\");\n\n\n  \n  \n\n  /**\n   * File resources are resources located in the Entrystore repository that have a graph type of\n   * none, e.g. none of the special cases for which there are special treatment in EntryStore.\n   *\n   * @exports store/File\n   */\n  const FileResource = class extends _Resource__WEBPACK_IMPORTED_MODULE_1__[\"Resource\"] {\n    /**\n     * Pushes a file to the server for this resource.\n     * In a browser environment a file is represented via an input tag which references\n     * the file to be uploaded via its value attribute. E.g.:\n     *\n     *       <input type=\"file\" name=\"uploadFile\"/>\n     *\n     * During the uploading process the input tag will be moved temporarily in the DOM tree,\n     * it will be restored to its original position afterwards (both upon success and failure).\n     *\n     * In a nodejs environments the file is leveraged as a stream, i.e.:\n     * res.putFile(fs.createReadStream('file.txt'));\n     *\n     * @param {node|fileHandle} data - input tag or file handle that corresponds to a file.\n     * @param {text} format - indicates the mimetype of the data\n     * @todo fix-if-modified-since\n     * @returns {xhrPromise}\n     */\n    putFile(data, format) {\n      let url;\n      // noinspection AmdModulesDependencies\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBrowser\"])() && data instanceof Node) {\n        if (data.name == null || data.name === '') {\n          throw new Error('Failure, cannot upload resource from input element unless a name' +\n            ' attribute is provided.');\n        }\n        url = _factory__WEBPACK_IMPORTED_MODULE_2__[\"factory\"].getPutFileURI(this.getResourceURI());\n      } else {\n        url = this.getResourceURI();\n      }\n      const es = this.getEntryStore();\n      return es.handleAsync(es.getREST().putFile(url, data, format).then((res) => {\n        this.getEntry(true).setRefreshNeeded();\n        return res;\n      }), 'putFile');\n    }\n\n    /**\n     * Pushes data to the server for this resource.\n     *\n     * @param {string} data - to be stored as a file.\n     * @param {string} format - the format of the data as a mimetype.\n     * @returns {xhrPromise}\n     */\n    put(data, format) {\n      const es = this.getEntryStore();\n      return es.handleAsync(es.getREST().put(this.getResourceURI(), data, null, format), 'putFile');\n    }\n\n    /**\n     * Pushes text content to the server for this resource.\n     *\n     * @param {string} text - to be stored as a file, format will be set to text/plain.\n     * @returns {xhrPromise}\n     */\n    putText(text) {\n      return this.put(text, 'text/plain');\n    }\n\n    /**\n     * Pushes JSON content to the server for this resource.\n     *\n     * @param {Object} obj - to be stored as a json object, format will be set to application/json.\n     * @returns {xhrPromise}\n     */\n    putJSON(obj) {\n      return this.put(JSON.stringify(obj));\n    }\n\n    /**\n     * Pushes xml content to the server for this resource.\n     *\n     * @param {string|Document} xml - to be stored as a xml object, format will be set to\n     * application/json.\n     * @returns {xhrPromise}\n     * @todo not finished or tested\n     */\n    putXML(xml) {\n      let _xml = xml;\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBrowser\"])() && _xml instanceof Document) {\n        try {\n          // Gecko- and Webkit-based browsers (Firefox, Chrome), Opera.\n          _xml = (new XMLSerializer()).serializeToString(_xml);\n        } catch (e) {\n          try {\n            // Internet Explorer.\n            _xml = _xml.xml;\n          } catch (ee) {\n            throw new Error('Xmlserializer not supported');\n          }\n        }\n      } else if ((typeof _xml) !== \"string\") {\n        throw new Error('Unsupported format of parameter xml to method putAsXML');\n      }\n      return this.put(_xml, 'text/xml');\n    }\n\n    /**\n     * @returns {xhrPromise} which format the resource is returned in the promise (string, json or\n     * xml) depends on what is specified in the mimetype. Xml is only returned in a browser\n     * environment, if not in a browser a string is returned.\n     */\n    get() {\n      const format = this.getEntry(true).getEntryInfo().getFormat();\n      const es = this.getEntryStore();\n      return es.handleAsync(es.getREST().get(this.getResourceURI(), format), 'getFile');\n    }\n\n    /**\n     * @returns {xhrPromise} ignores what is specified in the mimetype and returns the resource\n     * as a string in the promise.\n     */\n    getText() {\n      const es = this.getEntryStore();\n      return es.handleAsync(this.getEntryStore().getREST().get(this.getResourceURI(), 'text/plain'), 'getFile');\n    }\n\n    /**\n     * @returns {xhrPromise} ignores what is specified in the mimetype and returns the resource\n     * as a javascript object in the promise.\n     */\n    getJSON() {\n      const es = this.getEntryStore();\n      return es.handleAsync(es.getREST().get(this.getResourceURI(), 'application/json'), 'getFile');\n    }\n\n    /**\n     * @returns {xhrPromise} ignores what is specified in the mimetype and returns the resource\n     * in the promise as a XML Document or a string (depending on if you are in browser or not).\n     */\n    getXML() {\n      const es = this.getEntryStore();\n      return es.handleAsync(es.getREST().get(this.getResourceURI(), 'text/xml'), 'getFile');\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./File.js?");

/***/ }),

/***/ "./Graph.js":
/*!******************!*\
  !*** ./Graph.js ***!
  \******************/
/*! exports provided: GraphResource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GraphResource\", function() { return GraphResource; });\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\nconst Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n\n\n\n  /**\n   * Graph is a resource for handling RDF graphs relying on the {@link rdfjson/Graph} API.\n   *\n   * @exports store/Graph\n   */\n  const GraphResource = class extends _Resource__WEBPACK_IMPORTED_MODULE_0__[\"Resource\"] {\n    /**\n     * @param {string} entryURI - URI to an entry where this resource is contained.\n     * @param {string} resourceURI - URI to the resource.\n     * @param {store/EntryStore} entryStore - the API's repository instance.\n     * @param {rdfjson/Graph | Object} data - is an RDF graph of some sort\n     */\n    constructor(entryURI, resourceURI, entryStore, data) {\n      super(entryURI, resourceURI, entryStore); // Call the super constructor.\n      console.log(data instanceof Graph);\n      this._graph = data instanceof Graph ? data : new Graph(data);\n    }\n\n    /**\n     * Get the rdf Graph. The returned graph is not a copy, subsequent getGraph calls will return\n     * the same instance as long as the entry has not been refreshed or a new instance set via\n     * {@link store/Graph#setGraph setGraph}.\n     *\n     * @returns {rdfjson/Graph} will never be null or undefined, although the graph may be empty.\n     */\n    getGraph() {\n      return this._graph;\n    }\n\n    /**\n     * Set the rdf Graph. To update the graph in the repository call the\n     * {@link store/EntryStore#commit commit}.\n     *\n     * @param {rdfjson/Graph} graph - the new graph, if null or undefined a new empty graph will\n     * be set.\n     * @returns store/Graph - to allow chaining with commit.\n     */\n    setGraph(graph) {\n      this._graph = graph || new Graph();\n      return this;\n    }\n\n    /**\n     * Pushes the current graph back to repository.\n     *\n     * @todo fix ifModifiedSince.\n     * @param {rdfjson/Graph} graph\n     * @returns {xhrPromise}\n     */\n    commit() {\n      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI,\n        JSON.stringify(this._graph.exportRDFJSON())), 'commitGraph');\n    }\n\n    /**\n     * Provides a JSON representation of the graph as rdf/json.\n     *\n     * @returns {Object}\n     */\n    getSource() {\n      return this._graph.exportRDFJSON();\n    }\n\n    _update(data) {\n      this._graph = new Graph(data);\n    }\n  };\n\n\n\n\n//# sourceURL=webpack:///./Graph.js?");

/***/ }),

/***/ "./Group.js":
/*!******************!*\
  !*** ./Group.js ***!
  \******************/
/*! exports provided: Group */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Group\", function() { return Group; });\n/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ \"./List.js\");\n/* harmony import */ var _terms__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./terms */ \"./terms.js\");\n\n\n\n  /**\n   * Group is a subclass of the List resource and contains a list of users.\n   * The group resource URI can be referred to from access control lists.\n   *\n   * @exports store/Group\n   */\n  const Group = class extends _List__WEBPACK_IMPORTED_MODULE_0__[\"List\"] {\n    /**\n     * Get the name of the group, this is a a unique name (username) in the current\n     * repository's _principals context.\n     * @returns {string}\n     */\n    getName() {\n      return this._name;\n    }\n\n    /**\n     * Set a new name of the group, it will not succeed if it is already in use, for instance by\n     * another user or group.\n     * @param {string} name\n     * @returns {xhrPromise}\n     */\n    setName(name) {\n      const oldname = this._name;\n      this._name = name;\n      return this._entryStore.handleAsync(this._entryStore.getREST().put(\n        `${this.getEntryURI()}/name`, json.stringify({ name }))\n        .then((data) => {\n          const e = this.getEntry(true);\n          if (e) {\n            e.getEntryInfo()._name = data;\n          }\n          return data;\n        }, (e) => {\n          this._name = oldname;\n          throw e;\n        }), 'setGroupName');\n    }\n\n    /**\n     * Get the home context for this user.\n     *\n     * @returns {string} - a context id (not the full resource URI).\n     */\n    getHomeContext() {\n      const es = this.getEntryStore();\n      const entry = this.getEntry(true);\n      const contextResourceURI = entry.getEntryInfo().getGraph().findFirstValue(\n        entry.getResourceURI(), _terms__WEBPACK_IMPORTED_MODULE_1__[\"terms\"].homeContext);\n      if (contextResourceURI != null) {\n        return es.getEntryId(contextResourceURI);\n      }\n      return undefined;\n    }\n\n    /**\n     * Set a new home context for this group.\n     * Note that the home context is stored in the entryinformation, hence, all other changes made\n     * to the entryinformation will be saved unless the doNotPushToRepository flag is set to true.\n     *\n     * @param {string} contextId - a context id (not the full resource URI).\n     * @param {boolean} doNotPushToRepository if true the changes will be made in the\n     * entryinformation but it will not be pushed to the respository. To do this you need to get\n     * a hold of the entryinformation and call commit.\n     * @returns {entryInfoPromise|undefined}\n     */\n    setHomeContext(contextId, doNotPushToRepository) {\n      const es = this.getEntryStore();\n      const newContextURI = es.getResourceURI('_contexts', contextId);\n      const entry = this.getEntry(true);\n      const graph = entry.getEntryInfo().getGraph();\n      graph.findAndRemove(entry.getResourceURI(), _terms__WEBPACK_IMPORTED_MODULE_1__[\"terms\"].homeContext);\n      graph.add(entry.getResourceURI(), _terms__WEBPACK_IMPORTED_MODULE_1__[\"terms\"].homeContext, { type: 'uri', value: newContextURI });\n      if (doNotPushToRepository !== true) {\n        return entry.getEntryInfo().commit();\n      }\n      return undefined;\n    }\n\n    // Data contains allUnsorted array, size, and children.\n    _update(data, children) {\n      super._update(data, children);\n      this._name = data.name;\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./Group.js?");

/***/ }),

/***/ "./List.js":
/*!*****************!*\
  !*** ./List.js ***!
  \*****************/
/*! exports provided: List */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"List\", function() { return List; });\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\nconst json = __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\");\n\n\n  /**\n   * List is a container for other entries in the same context.\n   * A single entry may appear in multiple lists (multiple parent lists) unless if it is\n   * a list itself. To avoid circular references list entries are only allowed to appear\n   * in one parent list.\n   *\n   * @exports store/List\n   */\n  const List = class extends _Resource__WEBPACK_IMPORTED_MODULE_0__[\"Resource\"] {\n    /**\n     * @param {string} entryURI - URI to an entry where this resource is contained.\n     * @param {string} resourceURI - URI to the resource.\n     * @param {store/EntryStore} entryStore - the API's repository instance.\n     */\n    constructor(entryURI, resourceURI, entryStore) {\n      super(entryURI, resourceURI, entryStore);\n      this._cache = entryStore.getCache();\n      this._sortedChildren = [];\n    }\n\n    /**\n     * Set the max amount of entries to include in each page during pagination.\n     *\n     * @param {integer} limit\n     * @returns {store/List} allows chaining of set-operations.\n     */\n    setLimit(limit) {\n      this._limit = limit;\n      return this;\n    }\n\n    /**\n     * Get the max amount of entries to include in each page during pagination.\n     *\n     * @returns {integer}\n     */\n    getLimit() {\n      return this._limit || this.getEntryStore().getFactory().getDefaultLimit();\n    }\n\n    /**\n     * Sets the sort order when loading entries contained in this list.\n     *\n     * @param {Object} sortParams - same object structure as the sort parameter in\n     * optionalLoadParameters in {@link store/EntryStore#getEntry} method.\n     * @returns {store/List} allows chaining of set-operations.\n     */\n    setSort(sortParams) {\n      this._clearSortedEntries();\n      this._sortParams = sortParams;\n      return this;\n    }\n\n    /**\n     * Retrieves an array of entries contained in this list according to the current page and\n     * pagination settings.\n     * @param {integer} page - the page to request an array of entries for,\n     * first page is numbered 0.\n     * @returns {entryArrayPromise} the promise will return an entry-array.\n     */\n    getEntries(page) {\n      const results = this._getEntries(page);\n      if (results != null) {\n        return Promise.resolve(results);\n      }\n      return this._forceLoadEntries(page);\n    }\n\n    /**\n     * Executes a callback on each list members in the order provided by the list.\n     * If the provided function return false for one entry the iteration is stopped and\n     * the function is not called for consecutive entries.\n     *\n     * @param {listEntryCallback} func\n     * @return {promise} called with two parameters, the first a boolean saying if all entries\n     * where passed, the second an index telling how many entrys iterated over.\n     */\n    forEach(func) {\n      let page = 0;\n      let idx = 0;\n      let g;\n      let h;\n      const limit = this.getLimit();\n      const self = this;\n\n      const f = (entries) => {\n        const entriesLength = entries.length;\n        g = (res) => {\n          if (res === false) {\n            return Promise.resolve(false);\n          }\n          return h();\n        };\n        h = () => {\n          if (entries.length === 0) {\n            return Promise.resolve(true);\n          }\n          const res = func(entries.pop(), idx);\n          idx += 1;\n          if (typeof res !== 'undefined' && typeof res.then === 'function') {\n            return res.then(g);\n          }\n          return g(res);\n        };\n        return h().then((cont) => {\n          if (cont !== false && entriesLength === limit) {\n            page += 1;\n            return self.getEntries(page).then(f);\n          }\n          return Promise.resolve(idx);\n        });\n      };\n\n      return this.getEntries(0).then(f);\n    }\n\n    /**\n     * Adds an entry to this list, on success the List entry will be returned (updated with\n     * latest modification date). The added entry will be marked as in need of a\n     * refresh due to stale inv-rel cache. However,since List entry is loaded it may be refreshed\n     * already when method is resolved, it depends if it is in the first page of the list.\n     *\n     * @param {store/Entry} entry - entry to add to the list.\n     * @returns {xhrPromise}\n     */\n    addEntry(entry) {\n      const self = this;\n      return this.getAllEntryIds().then((entries) => {\n        entries.push(entry.getId());\n        return this.setAllEntryIds(entries, 'addToList').then(() => {\n          entry.setRefreshNeeded();\n          return self.getEntry();\n        });\n      });\n    }\n\n    /**\n     * Removes an entry from this list, on success the List entry will be returned (updated with\n     * latest modification date). The removed entry will not be updated but marked as in need\n     * of a refresh due to stale inv-rel cache. However,since List entry is loaded it may be\n     * refreshed already when method is resolved, it depends if it is in the first page of the list.\n     *\n     * @param {store/Entry} entry - entry to be removed from the list.\n     * @returns {xhrPromise}\n     */\n    removeEntry(entry) {\n      return this.getAllEntryIds().then((entries) => {\n        entries.splice(entries.indexOf(entry.getId()), 1);\n        return this.setAllEntryIds(entries, 'removeFromList').then(() => {\n          entry.setRefreshNeeded();\n        });\n      });\n    }\n\n    /**\n     * Will unset things since the cache is stale...\n     */\n    needRefresh() {\n      delete this._unsortedChildren;\n      this._sortedChildren = [];\n      delete this._size;\n    }\n\n    /**\n     * Get a list of entry ids contained in this list.\n     *\n     * @returns {stringArrayPromise} the promise will deliver an array of children entries in this\n     * list as ids\n     * (strings, not full URIs).\n     */\n    getAllEntryIds() {\n      if (this._unsortedChildren != null) {\n        return Promise.resolve(this._unsortedChildren);\n      }\n      return this.getEntries().then(() => this._unsortedChildren);\n    }\n\n    /**\n     * Set a list of entry ids to be contained in this list.\n     *\n     * @param {string[]} entries - array of entry ids (as strings, not full URIs).\n     * @returns {entryPromise}\n     */\n    setAllEntryIds(entries, callType) {\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI, json.stringify(entries))\n        .then(() => {\n          this.needRefresh();\n          return es.getEntry(this.getEntryURI()).then((oentry) => {\n            oentry.setRefreshNeeded();\n            return oentry;\n          });\n        }), callType || 'setList');\n    }\n\n    /**\n     * Get size of list.\n     *\n     * @returns {integer} the amount of entries in the list, -1 if unknown.\n     */\n    getSize() {\n      return typeof this._size === 'number' ? this._size : -1;\n    }\n\n    //= ========Helper methods===============\n\n    _clearSortedEntries() {\n      this._sortedChildren = [];\n    }\n\n    _getEntries(page, careAboutFresh) {\n      if (this._size == null) {\n        return null;\n      }\n      const limit = this.getLimit();\n      const offset = (page || 0) * limit;\n\n      let needRefresh = false;\n      const results = [];\n      let entryURI;\n      for (let i = offset; i < offset + limit && i < this._size; i++) {\n        entryURI = this._sortedChildren[i];\n        if (entryURI) {\n          const e = this._entryStore.getCache().get(entryURI);\n          if (careAboutFresh === false || (e != null && !e.needRefresh())) {\n            results.push(e);\n          } else {\n            needRefresh = true;\n            break;\n          }\n        } else {\n          needRefresh = true;\n          break;\n        }\n      }\n      if (needRefresh) {\n        return null;\n      }\n      return results;\n    }\n\n    _forceLoadEntries(page) {\n      const limit = this.getLimit();\n      const offset = (page || 0) * limit;\n      return this._entryStore.getEntry(this._entryURI, {\n        forceLoad: true,\n        offset,\n        limit,\n        sort: this._sort,\n        asyncContext: 'loadListEntries',\n      }).then(() => this._getEntries(page, false));\n    }\n\n    // Data contains allUnsorted array, size, and children.\n    _update(data, children) {\n      const offset = data.offset || 0;\n      for (let i = 0; i < children.length; i++) {\n        this._sortedChildren[offset + i] = children[i].getURI();\n      }\n      this._size = data.size || children.length;\n      this._unsortedChildren = data.allUnsorted || children.map(entry => entry.getId());\n    }\n  };\n  \n  \n\n/**\n * Promise that provides an array of entry ids (not full URIs) on success.\n *\n * @name stringArrayPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name stringArrayPromise#then\n * @param {stringArrayCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n/**\n * @callback stringArrayCallback\n * @param {string[]} idArray\n */\n\n/**\n * Callback in list forEach method.\n *\n * @callback listEntryCallback\n * @param {store/Entry} entry\n * @param {number} index\n */\n\n\n//# sourceURL=webpack:///./List.js?");

/***/ }),

/***/ "./Pipeline.js":
/*!*********************!*\
  !*** ./Pipeline.js ***!
  \*********************/
/*! exports provided: Pipeline */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Pipeline\", function() { return Pipeline; });\n/* harmony import */ var _terms__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./terms */ \"./terms.js\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Graph */ \"./Graph.js\");\n\n\n\n  /**\n   * Pipeline is a Graph that contains an ordered list of transforms, each transform is of a\n   * specific type and takes a set of arguments.\n   *\n   * @exports store/Pipeline\n   */\n  const Pipeline = class extends _Graph__WEBPACK_IMPORTED_MODULE_1__[\"GraphResource\"] {\n    /**\n     * The destination where the result (in the form of a single RDF graph) should\n     * end up (within the specified entry's graph resource).\n     * If empty string, a new entry will be created to store the results.\n     * If undefined, the result will not go to a single destination, see getDetectDestination\n     * instead. Some transform types does not respect the destination, e.g. currently ROWSTORE\n     * which always creates a new entry containing the results.\n     *\n     * @returns {String|undefined} an entry URI where the result should go, empty string for new\n     * entries for every execution or undefined if no destination has been specified.\n     */\n    getDestination() {\n      return this._graph.findFirstValue(null, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformDestination);\n    }\n\n    /**\n     * @see store/Pipeline#getDestination\n     * @param {String} entryOrEntryURI entry URI, empty string for new entries every time,\n     * use undefined to remove destination setting altogether.\n     */\n    setDestination(entryOrEntryURI) {\n      this._graph.findAndRemove(null, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformDestination);\n      const uri = typeof entryOrEntryURI === 'object' && entryOrEntryURI.getURI ?\n        entryOrEntryURI.getURI() : entryOrEntryURI;\n      this._graph.add(this._resourceURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformDestination, uri);\n    }\n\n    /**\n     * Detect destination means that the result of the last transform (a graph) should be attempted\n     * to be split into multiple entries according to markings in the graph.\n     *\n     * I.e. it detects and adds a set of entries from the graph via the anonymous closure\n     * algorithm starting from blank nodes resources\n     * with either one of the two following properties that both indicate which entryId to use:<ul>\n     * <li>http://entrystore.org/terms/mergeResourceId or the</li>\n     * <li>http://entrystore.org/terms/referenceResourceId</li>\n     * </ul>\n     * The mergeResourceId indicates that the corresponding entry should be merged or created if it\n     * does not exist.\n     * The referenceResourceId only indicates that another entry (via its resource id) should be\n     * referenced from\n     * the graph (which might be inside an entry indicated by mergeResourceId).\n     *\n     *\n     * @returns {boolean} true if destination should be detected.\n     */\n    getDetectDestination() {\n      const val = this._graph.findFirstValue(null, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformDetectDestination);\n      if (typeof val !== 'undefined') {\n        return val.toLowerCase().indexOf('true') === 0;\n      }\n      return false;\n    }\n\n    /**\n     *\n     * @see store/Pipeline#getDetectDestination\n     * @param {boolean} detect if true detection of entry references in the graph is attempted.\n     */\n    setDetectDestination(detect) {\n      this._graph.findAndRemove(null, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformDetectDestination);\n      if (detect === true) {\n        this._graph.add(this._resourceURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformDetectDestination, {\n          type: 'literal', value: 'true', datatype: _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].xsd.boolean,\n        });\n      }\n    }\n\n    /**\n     * @returns {String[]} of transform ids, typically blank node ids, hence, they are not\n     * preserved between saves / loads so take care.\n     */\n    getTransforms() {\n      const stmts = this._graph.find(null, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transform);\n      const arr = stmts.map(stmt => stmt.getValue());\n      const self = this;\n      arr.sort((tr1, tr2) => {\n        const pr1 = self.getPriority(tr1);\n        const pr2 = self.getPriority(tr2);\n        return pr1 - pr2;\n      });\n      return arr;\n    }\n\n    /**\n     * Finds a transform with the given type and returns its id.\n     *\n     * @param transformType the transform type to look for\n     * @returns {string} transform id, undefined if no transform was found for the given type\n     */\n    getTransformForType(transformType) {\n      let transformId;\n      const trIds = this.getTransforms();\n      trIds.forEach((trId) => {\n        // get transform type and check for fetch and get url\n        if (this.getTransformType(trId) === transformType) {\n          transformId = trId;\n        }\n      }, this);\n      return transformId;\n    }\n\n    /**\n     * Adds a new transform.\n     *\n     * @param {String} type one of the [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @param {Object} args a hash of key value pairs for this transform.\n     * @returns {String} the newly transforms id (for this session, may change after save / load\n     * so take care).\n     */\n    addTransform(type, args) {\n      const transforms = this.getTransforms();\n      const priority = transforms.length > 0 ?\n        this.getPriority(transforms[transforms.length - 1]) : 0;\n      const stmt = this._graph.add(this._resourceURI, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transform);\n      const id = stmt.getValue();\n      this.setTransformType(id, type);\n      this.setPriority(id, priority + 1);\n      this.setTransformArguments(id, args);\n      return id;\n    }\n\n    /**\n     * Removes a transform.\n     *\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @see store/Pipeline#getTransforms\n     */\n    removeTransform(transformId) {\n      this.setTransformArguments(transformId, {});\n      this._graph.findAndRemove(transformId);\n      this._graph.findAndRemove(null, null, { type: 'bnode', value: transformId });\n    }\n\n    /**\n     * Changes the order of the transforms by changing their priority properties.\n     *\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @see store/Pipeline#getTransforms\n     */\n    setOrderOfTransforms(transforms) {\n      for (let i = 0; i < transforms.length; i++) {\n        this._graph.findAndRemove(transforms[i], _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformPriority);\n        this._graph.add(transforms[i], _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformPriority, {\n          type: 'literal', value: `${i}`, datatype: _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].xsd.integer,\n        });\n      }\n    }\n\n    /**\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @returns {float} the priority as a float.\n     */\n    getPriority(transformId) {\n      let prio = this._graph.findFirstValue(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformPriority);\n      if (typeof prio === 'string') {\n        prio = parseFloat(prio);\n        if (!isNaN(prio)) {\n          return prio;\n        }\n      }\n      return 0;\n    }\n\n    /**\n     * It is recommended to use setOrderOfTransforms instead.\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @returns {float} the priority as a float.\n     * @see store/Pipeline#setOrderOfTransforms\n     */\n    setPriority(transformId, prio) {\n      this._graph.findAndRemove(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformPriority);\n      this._graph.add(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformPriority, {\n        type: 'literal', value: `${prio}`, datatype: _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].xsd.integer,\n      });\n    }\n\n    /**\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @returns {String} one of the values specified in {@link store/Pipeline#transformTypes}.\n     */\n    getTransformType(transformId) {\n      return this._graph.findFirstValue(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformType);\n    }\n\n    /**\n     *\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @param {String} transformType one of the options in {@link store/Pipeline#transformTypes}.\n     */\n    setTransformType(transformId, transformType) {\n      this._graph.findAndRemove(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformType);\n      this._graph.addL(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformType, transformType);\n    }\n\n    /**\n     * @param {String} transformId the blank node of a specific transform as retrieved\n     * by [getTransforms]{@link store/Pipeline#getTransforms}.  If no id is provided\n     * arguments from all transforms will be returned in a single merged object.\n     * @returns {Object} the arguments for a transform (or all transforms) as an object\n     * hash with property value pairs.\n     */\n    getTransformArguments(transformId) {\n      let args;\n      const stmts = this._graph.find(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgument);\n      stmts.forEach((stmt) => {\n        const key = this._graph.findFirstValue(stmt.getValue(),\n          _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentKey);\n        const value = this._graph.findFirstValue(stmt.getValue(),\n          _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentValue);\n        args = args || {};\n        args[key] = value;\n      }, this);\n      return args;\n    }\n\n    /**\n     * @param {String} transformId the blank node of a specific transform as retrieved\n     * by [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @returns {Array} of arguments' keys\n     */\n    getTransformArgumentsKeys(transformId = null) {\n      const args = [];\n      if (transformId) {\n        const stmts = this._graph.find(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgument);\n        stmts.forEach((stmt) => {\n          const keys = this._graph.find(stmt.getValue(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentKey);\n          args.push(keys.map(key => key.getValue()));\n        }, this);\n      }\n      return args;\n    }\n\n    /**\n     * Replaces the current arguments with those provided.\n     * @param {String} transformId the blank node of a specific transform as retrieved by\n     * [getTransforms]{@link store/Pipeline#getTransforms}.\n     * @param {Object} the arguments for the transform as an object hash with property value pairs.\n     */\n    setTransformArguments(transformId, args) {\n      const stmts = this._graph.find(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgument);\n      stmts.forEach((stmt) => {\n        this._graph.findAndRemove(stmt.getValue(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentKey);\n        this._graph.findAndRemove(stmt.getValue(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentValue);\n        this._graph.remove(stmt);\n      }, this);\n      Object.keys(args).forEach((key) => {\n        const newarg = this._graph.add(transformId, _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgument);\n        this._graph.addL(newarg.getValue(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentKey, key);\n        this._graph.addL(newarg.getValue(), _terms__WEBPACK_IMPORTED_MODULE_0__[\"terms\"].pipeline.transformArgumentValue, args[key]);\n      });\n    }\n\n    /**\n     * Retrieves a transform argument value for a specific transform type and property (key).\n     * @param {string} transformType\n     * @param {string} property\n     * @returns {string}\n     */\n    getTransformProperty(transformType, property) {\n      const tid = this.getTransformForType(transformType);\n      if (tid) {\n        const obj = this.getTransformArguments(tid);\n        if (obj && obj[property]) {\n          return obj[property];\n        }\n      }\n      return undefined;\n    }\n\n    /**\n     * Sets or updates an individual property (key-value pair in arguments) of a transform.\n     * The transform is identified either explicitly by an id or via a transformType (assumed\n     * unique).\n     * @param {string} transformIdOrType corresponds to the transform to change the property for\n     * @param {string} key\n     * @param {string} value\n     */\n    setTransformProperty(transformIdOrType, key, value) {\n      let obj = this.getTransformArguments(transformIdOrType);\n      if (obj != null) {\n        obj[key] = value;\n        this.setTransformArguments(transformIdOrType, obj);\n      } else {\n        const tid = this.getTransformForType(transformIdOrType);\n        obj = this.getTransformArguments(tid);\n        if (obj != null) {\n          obj[key] = value;\n          this.setTransformArguments(tid, obj);\n        }\n      }\n    }\n\n    /**\n     * Executes the pipeline with the given source entry as input, if not provided the pipeline\n     * will be used as sourceentry.\n     *\n     * @param {store/Entry} sourceEntry an optional entry containing some data that is to be\n     * transformed, e.g. can be a CSV file.\n     * @param {object} params additional parameters used in the execution of the pipeline, e.g.\n     * action (with value create, replace or append) and datasetURL pointing to the existing\n     * dataset in rowstore.\n     * @returns {entryURIArrayPromise} an array of entry URIs that where created/modified by\n     * this execution.\n     */\n    execute(sourceEntry, params) {\n      let executeURI;\n      const es = this.getEntryStore();\n      const _params = params || {};\n      _params.pipeline = this.getEntryURI();\n      if (sourceEntry == null) {\n        executeURI = `${es.getBaseURI() + es.getContextId(this.getEntryURI())}/execute`;\n      } else {\n        _params.source = sourceEntry.getURI();\n        executeURI = `${sourceEntry.getContext().getResourceURI()}/execute`;\n      }\n      return es.handleAsync(es.getREST().post(executeURI, JSON.stringify(_params)), 'execute')\n        .then((resultStr) => {\n          const obj = JSON.parse(resultStr);\n          return obj.result;\n        }, (err) => {\n          throw err;\n        });\n    }\n  };\n  /**\n   * Available transforms (types).\n   *\n   * @type {{TABULAR: string, ROWSTORE: string}}\n   */\n  Pipeline.prototype.transformTypes = {\n    TABULAR: 'tabular',\n    ROWSTORE: 'rowstore',\n    EMPTY: 'empty',\n    FETCH: 'fetch',\n    VALIDATE: 'validate',\n    MERGE: 'merge',\n  };\n\n  \n\n/**\n * Promise that provides an array of entry URIs on success.\n *\n * @name entryURIArrayPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name entryURIArrayPromise#then\n * @param {entryURIArrayCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n/**\n * @callback entryURIArrayCallback\n * @param {string[]} entryURIArray\n */\n\n\n//# sourceURL=webpack:///./Pipeline.js?");

/***/ }),

/***/ "./PrototypeEntry.js":
/*!***************************!*\
  !*** ./PrototypeEntry.js ***!
  \***************************/
/*! exports provided: PrototypeEntry */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PrototypeEntry\", function() { return PrototypeEntry; });\n/* harmony import */ var Entry__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Entry */ \"./Entry.js\");\n/* harmony import */ var EntryInfo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! EntryInfo */ \"./EntryInfo.js\");\n/* harmony import */ var terms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! terms */ \"./terms.js\");\n\n\n\n\n  /**\n   * A PrototypeEntry is used to create new entries by collecting information about the initial\n   * state of the entry to send along to the repository upon creation.\n   *\n   * All access and utility methods from Entry is just inherited. Some methods have been moved over\n   * from EntryInformation to allow easier method chaining. Finally some information cannot be\n   * changed in an entry, e.g. the entry, graph and resource types, but are crucial before creation.\n   * Hence, some methods have been introduced to cover for this need.\n   *\n   * @exports store/PrototypeEntry\n   */\n  const PrototypeEntry = class extends Entry__WEBPACK_IMPORTED_MODULE_0__[\"Entry\"] {\n    /**\n     * @param {store/Context} context where this prototypeEntry belongs.\n     * @param {string} id - entry identifier, if not unique in the context the subsequent commit\n     * will fail.\n     */\n    constructor(context, id) {\n      const _id = id || '_newId';\n      const cru = context.getResourceURI();\n      const entryInfo = new EntryInfo__WEBPACK_IMPORTED_MODULE_1__[\"EntryInfo\"](`${cru}/entry/${_id}`, null, context.getEntryStore());\n      if (context.getId() === '_contexts') {\n        entryInfo._resourceURI = context.getEntryStore().getBaseURI() + _id;\n      } else {\n        entryInfo._resourceURI = `${cru}/resource/${_id}`;\n      }\n      const oldSetResourceURI = entryInfo.setResourceURI;\n      entryInfo.setResourceURI = function (uri) {\n        this._resourceURI = uri;\n        oldSetResourceURI.call(this, uri);\n      };\n      entryInfo.getResourceURI = function () {\n        return this._resourceURI;\n      };\n\n      super(context, entryInfo); // Call the super constructor.\n      if (id != null) {\n        this.specificId = _id;\n      }\n    }\n\n    /**\n     * Direct access method for the resource instance for prorotypeEntries.\n     * @returns {store/Resource}\n     */\n    getResource() {\n      return this._resource;\n    }\n\n    /**\n     * Exposes the {@link store/EntryInfo#setACL setACL} method from {@link store/EntryInfo}\n     * on PrototypeEntry\n     * and makes it chainable.\n     *\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setACL() {\n      EntryInfo__WEBPACK_IMPORTED_MODULE_1__[\"EntryInfo\"].prototype.setACL.apply(this._entryInfo, arguments);\n      return this;\n    }\n\n    /**\n     * Exposes the {@link store/EntryInfo#setResourceURI setResourceURI} method from\n     * {@link store/EntryInfo} on this class\n     * and makes it chainable.\n     *\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setResourceURI() {\n      this._entryInfo.setResourceURI(...arguments);\n      return this;\n    }\n\n    /**\n     * Exposes the {@link store/EntryInfo#setExternalMetadataURI setExternalMetadataURI} method\n     * from {@link store/EntryInfo} on this class\n     * and makes it chainable.\n     *\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setExternalMetadataURI() {\n      EntryInfo__WEBPACK_IMPORTED_MODULE_1__[\"EntryInfo\"].prototype.setExternalMetadataURI.apply(this._entryInfo, arguments);\n      return this;\n    }\n\n    /**\n     * Makes it possible to change the EntryType (which is not allowed on existing entries).\n     *\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setEntryType(et) {\n      const uri = terms__WEBPACK_IMPORTED_MODULE_2__[\"terms\"].invEntryType[et];\n      if (uri) {\n        this._entryInfo.getGraph().create(this._entryInfo.getEntryURI(), terms__WEBPACK_IMPORTED_MODULE_2__[\"terms\"].rdf.type, {\n          type: 'uri',\n          value: uri,\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Makes it possible to change the GraphType (which is not allowed on existing entries).\n     *\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setGraphType(gt) {\n      this._gt = gt;\n      const uri = terms__WEBPACK_IMPORTED_MODULE_2__[\"terms\"].invGraphType[gt];\n      if (uri) {\n        this._entryInfo.getGraph().create(this._entryInfo.getResourceURI(), terms__WEBPACK_IMPORTED_MODULE_2__[\"terms\"].rdf.type, {\n          type: 'uri',\n          value: uri,\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Makes it possible to change the ResourceType (which is not allowed on existing entries).\n     *\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setResourceType(rt) {\n      const uri = terms__WEBPACK_IMPORTED_MODULE_2__[\"terms\"].invResourceType[rt];\n      if (uri) {\n        this._entryInfo.getGraph().create(this._entryInfo.getResourceURI(), terms__WEBPACK_IMPORTED_MODULE_2__[\"terms\"].rdf.type, {\n          type: 'uri',\n          value: uri,\n        });\n      }\n      return this;\n    }\n\n    /**\n     * When creating new entries a single parent list can be specified, hence we need a way to set\n     * it in PrototypeEntry.\n     *\n     * @param {store/Entry} parentListEntry\n     * @returns {store/PrototypeEntry} - to allow the method call to be chained.\n     */\n    setParentList(parentListEntry) {\n      this.parentListEntry = parentListEntry;\n      return this;\n    }\n\n    /**\n     * Get the parent list (as an entry) for this PrototypeEntry.\n     * @returns {store/Entry}\n     */\n    getParentList() {\n      return this.parentListEntry;\n    }\n\n    /**\n     * Get the suggested entry id for this PrototypeEntry\n     * @returns {string}\n     */\n    getSpecificId() {\n      return this.specificId;\n    }\n\n    /**\n     * Allowed as a way to save metadata for an\n     * entry that is assumed to exist with a given entry id.\n     * @override\n     */\n    commitMetadata() {\n      if (!this.specificId) {\n        throw new Error('The entryId must have been specified for allowing metadata to be saved.');\n      }\n      const es = this.getEntryStore();\n\n      return es.handleAsync(es.getREST().put(this.getEntryInfo().getMetadataURI(),\n        json.stringify(this.getMetadata().exportRDFJSON())), 'commitMetadata');\n    }\n\n    /**\n     * Allowed as a way to save cached external metadata for an entry that is assumed to\n     * exist with a given entry id.\n     * @override\n     */\n    commitCachedExternalMetadata() {\n      if (!this.specificId) {\n        throw new Error('The entryId must have been specified for allowing cached external metadata to be saved.');\n      }\n      const es = this.getEntryStore();\n      return es.handleAsync(es.getREST().put(this.getEntryInfo().getCachedExternalMetadataURI(),\n        json.stringify(this._cachedExternalMetadata.exportRDFJSON())), 'commitCachedExternalMetadata');\n    }\n\n    /**\n     * @deprecated use {@link store/PrototypeEntry#commit commit} instead.\n     * @returns {entryPromise}\n     */\n    create() {\n      return this._context.getEntryStore().createEntry(this);\n    }\n\n    /**\n     * Create a new entry according to the information specified in the prototype entry.\n     *\n     * @returns {entryPromise}\n     * @see store/EntryStore#createEntry\n     */\n    commit() {\n      return this._context.getEntryStore().createEntry(this);\n    }\n  };\n  \n\n\n//# sourceURL=webpack:///./PrototypeEntry.js?");

/***/ }),

/***/ "./Resource.js":
/*!*********************!*\
  !*** ./Resource.js ***!
  \*********************/
/*! exports provided: Resource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Resource\", function() { return Resource; });\n  /**\n   * This is the base class for resources contained by entries, do not use directly,\n   * instead use a subclass.\n   *\n   * @exports store/Resource\n   * @see subclass {@link store/Context}\n   * @see subclass {@link store/List}\n   * @see subclass {@link store/Graph}\n   * @see subclass {@link store/String}\n   * @see subclass {@link store/File}\n   * @see subclass {@link store/User}\n   * @see subclass {@link store/Group}\n   */\n   class Resource {\n    /**\n     * @param {string} entryURI - URI to an entry where this resource is contained.\n     * @param {string} resourceURI - URI to the resource.\n     * @param {store/EntryStore} entryStore - the API's repository instance.\n     */\n    constructor(entryURI, resourceURI, entryStore) {\n      this._entryURI = entryURI;\n      this._resourceURI = resourceURI;\n      this._entryStore = entryStore;\n    }\n\n    /**\n     * Retrieves the API's repository instance\n     *\n     * @returns {store/EntryStore}\n     */\n    getEntryStore() {\n      return this._entryStore;\n    }\n\n    /**\n     * Retrieves the entry that contains this resource. Asking for the entry directly\n     * (direct=true, rather than getting\n     * it asynchronously via a promise) should work for all resources except context resources.\n     *\n     * > _**Advanced explanation:**\n     * > Context resources are often created opportunistically by the API without also\n     * > loading the context entry along with it, e.g. when loading entries during a search\n     * > operation. The reason why the context entries are not loaded along with the context\n     * > resource is that such an approach, depending on the use-case, may lead to dramatic\n     * > increases in the amount of requests to the repository._\n     *\n     * @return {entryPromise|store/Entry} if direct=true an Entry is returned (or undefined if not\n     * in cache, only happens sometimes for Contexts) otherwise a promise is returned that on\n     * success provides the entry for this resource.\n     */\n    getEntry(direct) {\n      return this._entryStore.getEntry(this._entryURI, { direct });\n    }\n\n    /**\n     * The resources own URI.\n     *\n     * @returns {string}\n     */\n    getResourceURI() {\n      return this._resourceURI;\n    }\n\n    /**\n     * The URI to the entry containing this resource.\n     *\n     * @returns {string}\n     */\n    getEntryURI() {\n      return this._entryURI;\n    }\n\n    /**\n     * The id for the entry containing this resource.\n     *\n     * @returns {string}\n     */\n    getId() {\n      return this._entryStore.getFactory().getEntryId(this._entryURI);\n    }\n\n    _update(data) {\n      this._data = data;\n    }\n\n    getSource() {\n      return this._data;\n    }\n  };\n\n  \n\n/**\n * @name resourcePromise\n * @extends dojo/promise/Promise\n * @class\n */\n\n/**\n * @name resourcePromise#then\n * @param {entryCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n\n/**\n * This is a successful callback method to be provided as first argument in a\n * {@link resourcePromise}\n *\n * @callback resourceCallback\n * @param {store/Resource} resource\n */\n\n\n//# sourceURL=webpack:///./Resource.js?");

/***/ }),

/***/ "./Rest.js":
/*!*****************!*\
  !*** ./Rest.js ***!
  \*****************/
/*! exports provided: Rest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Rest\", function() { return Rest; });\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils */ \"./utils.js\");\n/* harmony import */ var superagent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! superagent */ \"./node_modules/superagent/lib/client.js\");\n/* harmony import */ var superagent__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(superagent__WEBPACK_IMPORTED_MODULE_1__);\n\n\nconst jsonp = __webpack_require__(/*! superagent-jsonp */ \"./node_modules/superagent-jsonp/dist/superagent-jsonp.js\");\n\n  /**\n   * Check if requests will be to the same domain, i.e. no CORS.\n   * Must be used in a browser environment.\n   *\n   * @param url\n   * @returns {boolean}\n   */\n  const sameOrigin = (url) => {\n    const a1 = document.createElement('a');\n    const a2 = document.createElement('a');\n    a1.href = url;\n    a2.href = window.location.href;\n\n    return a1.hostname === a2.hostname &&\n      a1.port === a2.port &&\n      a1.protocol === a2.protocol &&\n      a2.protocol !== 'file:';\n  };\n\n  /**\n   * This class encapsulates functionality for communicating with the repository via Ajax calls.\n   * Authentication is done via cookies and accept headers are in general set to\n   * application/json behind the scenes.\n   *\n   * @exports store/Rest\n   */\n  const Rest = class {\n    constructor() {\n      this.timeout = 30000; // 30 seconds\n      this.headers = {\n        Accept: 'application/json',\n        'Content-Type': 'application/json; charset=UTF-8',\n        'X-Requested-With': null,\n      };\n\n      const rest = this;\n\n      if (Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBrowser\"])()) {\n          rest.putFile = (uri, data, format) => {\n            if (!data.value) {\n              return undefined;\n            }\n            let _newForm;\n            if ( Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isIE\"])() ) {\n              // just to reiterate, IE is a steaming pile of shit.\n              _newForm = document.createElement('<form enctype=\"multipart/form-data\" method=\"post\">');\n              _newForm.encoding = 'multipart/form-data';\n            } else {\n              // this is how all other sane browsers do it\n              _newForm = document.createElement('form');\n              _newForm.setAttribute('enctype', 'multipart/form-data');\n              _newForm.setAttribute('method', 'post');\n              _newForm.style.display = 'none';\n            }\n\n            const oldParent = data.parentElement;\n            const nextSibling = data.nextSibling;\n            _newForm.appendChild(data);\n            document.body.appendChild(_newForm);\n            const cleanUp = () => {\n              if (nextSibling) {\n                oldParent.insertBefore(data, nextSibling);\n              } else {\n                oldParent.appendChild(data);\n              }\n              document.body.removeChild(_newForm);\n            };\n\n            const stubForm = new FormData();\n            const files = data.files;\n\n            Object.entries(files).map( keyVal => {\n              // is the item a File?\n              if (keyVal[1] instanceof File) {\n                stubForm.append(keyVal[0], keyVal[1]);\n              }\n            });\n\n            const res = superagent__WEBPACK_IMPORTED_MODULE_1___default.a.put(uri)\n              .query( {preventCache: parseInt(Math.random() * 10000, 10)} )\n              .accept(format || 'application/json')\n              .send( stubForm )\n              .then( () => {\n                cleanUp();\n                return res;\n              })\n              .catch( (e) => {\n                cleanUp();\n                throw e;\n              });\n\n            // TODO @scazan should this be the return value?\n            return res;\n        };\n      }\n    }\n    /**\n     * @param {object} credentials should contain attributes \"user\", \"password\", and \"maxAge\".\n     * MaxAge is the amount of seconds the authorization should be valid.\n     * @returns {xhrPromise}\n     */\n    auth(credentials) {\n      delete this.headers.cookie;\n      if (credentials.logout !== true) {\n        const data = {\n          auth_username: credentials.user,\n          auth_password: credentials.password,\n          // in seconds, 86400 is default and corresponds to a day.\n          auth_maxage: credentials.maxAge != null ? credentials.maxAge : 604800,\n        };\n        if ( Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBrowser\"])() ) {\n          return this.post(`${credentials.base}auth/cookie`, data);\n        }\n        const p = this.post(`${credentials.base}auth/cookie`, data);\n        return p.then((response) => {\n          const cookies = response.headers['set-cookie'];\n          cookies.some((c) => {\n            if (c.substring(0, 11) === 'auth_token=') {\n              this.headers.cookie = [c];\n              return true;\n            }\n            return false;\n          });\n        });\n      }\n\n      const logoutRequestResult = superagent__WEBPACK_IMPORTED_MODULE_1___default.a.get(`${credentials.base}auth/logout`)\n        .query( {preventCache: parseInt(Math.random() * 10000, 10)} )\n        .accept('application/json')\n        .withCredentials()\n        .timeout({ response: this.timeout });\n\n      Object.entries(this.headers).map( keyVal => logoutRequestResult.set(keyVal[0], keyVal[1]) );\n\n      return logoutRequestResult;\n    }\n\n    /**\n     * Fetches data from the provided URI.\n     * If a cross-domain call is made and we are in a browser environment a jsonp call is made.\n     *\n     * @param {string} uri - URI to a resource to fetch.\n     * @param {string} format - the format to request as a mimetype.\n     * @param {boolean} nonJSONP - stop JSONP handling (default false)\n     * @returns {xhrPromise}\n     */\n    get(uri, format, nonJSONP = false) {\n      const locHeaders = Object.assign({}, this.headers);\n      delete locHeaders['Content-Type'];\n\n      let _uri = uri;\n      let handleAs = 'json';\n      if (format != null) {\n        locHeaders.Accept = format;\n        switch (format) {\n          case 'application/json': // This is the default in the headers.\n            break;\n          case 'appplication/xml':\n          case 'text/xml':\n            handleAs = 'xml';\n            break;\n          default: // All other situations, including text/plain.\n            handleAs = 'text';\n        }\n      }\n\n      // Use jsonp instead of CORS for GET requests when doing cross-domain calls, it is cheaper\n      if ( Object(_utils__WEBPACK_IMPORTED_MODULE_0__[\"isBrowser\"])() && !sameOrigin(_uri) && !nonJSONP) {\n        return new Promise((resolve, reject) => {\n          const queryParameter = new RegExp('[?&]format=');\n          if (!queryParameter.test(_uri)) {\n            _uri += `${_uri.includes('?') ? '&' : '?'}format=application/json`;\n          }\n\n          superagent__WEBPACK_IMPORTED_MODULE_1___default.a.get(_uri)\n            .use(jsonp({\n                timeout: 160,\n              })\n            ) // Need this timeout to prevent an issue with superagent-jsonp: https://github.com/lamp/superagent-jsonp/issues/31\n            .then( data => {\n              resolve(data.body);\n            }, (err) => {\n              reject(err);\n            });\n\n        });\n      }\n      const getRequest = superagent__WEBPACK_IMPORTED_MODULE_1___default.a.get(_uri)\n        .accept(handleAs)\n        .timeout({ response: this.timeout })\n        .query( {preventCache: parseInt(Math.random() * 10000, 10)} )\n        .withCredentials();\n\n      Object.entries(locHeaders).map( keyVal => getRequest.set(keyVal[0], keyVal[1]) );\n\n      return getRequest\n        .then((response) => {\n          if (response.status === 200) {\n            return response.body;\n          }\n          throw new Error(`Resource could not be loaded: ${response.text}`);\n        });\n    }\n\n    /**\n     * Posts data to the provided URI.\n     *\n     * @param {String} uri - an URI to post to.\n     * @param {String|Object} data - the data to post. If an object the data is sent as form data.\n     * @param {Date=} modDate a date to use for the HTTP if-unmodified-since header.\n     * @param {string=} format - indicates the content-type of the data, default is\n     * application/json, except if the data is an object in which case the default is\n     * multipart/form-data.\n     * @return {xhrPromise}\n     */\n    post(uri, data, modDate, format) {\n      const locHeaders = Object.assign({}, this.headers);\n      if (modDate) {\n        locHeaders['If-Unmodified-Since'] = modDate.toUTCString();\n      }// multipart/form-data\n      if (format) {\n        locHeaders['Content-Type'] = format;\n      }\n\n      const postRequest = superagent__WEBPACK_IMPORTED_MODULE_1___default.a.post(uri)\n        .query( {'request.preventCache': parseInt(Math.random() * 10000, 10)} )\n        .send( data )\n      // serialize the object into a format that the backend is used to (no JSON strings)\n        .serialize(obj =>\n          Object.entries(obj)\n          .map( keyVal =>\n            keyVal[0] + \"=\" + keyVal[1] + \"&\"\n          )\n          .join(\"\")\n        )\n        .withCredentials()\n        .timeout({ response: this.timeout });\n\n      Object.entries(locHeaders).map( keyVal => postRequest.set(keyVal[0], keyVal[1]) );\n\n      return postRequest;\n    }\n\n    /**\n     * Posts data to a factory resource with the intent to create a new resource.\n     * That is, it posts data and expects a Location header back with information on the created\n     * resource.\n     *\n     * @param {string} uri - factory resource, may include parameters.\n     * @param {string|Object} data - the data that is to be posted as a string,\n     * if an object is provided it will be serialized as json.\n     * @returns {createPromise}\n     */\n    create(uri, data) {\n      return this.post(uri, data).then((response) => {\n        //let location = response.getHeader('Location');\n        let location = response.headers['location'];\n        // In some weird cases, like when making requests from file:///\n        // we do not have access to headers.\n        if (!location && response.body) {\n          const idx = uri.indexOf('?');\n          if (idx !== -1) {\n            location = uri.substr(0, uri.indexOf('?'));\n          } else {\n            location = uri;\n          }\n          location += `/entry/${JSON.parse(response.body).entryId}`;\n        }\n        return location;\n      });\n    }\n\n    /**\n     * Replaces a resource with a new representation.\n     *\n     * @param {string} uri the address to put to.\n     * @param {string|Object} data - the data to put. If an object the data is sent as form data.\n     * @param {Date=} modDate a date to use for the HTTP if-unmodified-since header.\n     * @param {string=} format - indicates the content-type of the data, default is\n     * application/json, except if the data is an object in which case the default is\n     * multipart/form-data.\n     * @return {xhrPromise}\n     */\n    put(uri, data, modDate, format) {\n      const locHeaders = Object.assign({}, this.headers);\n      if (modDate) {\n        locHeaders['If-Unmodified-Since'] = modDate.toUTCString();\n      }\n      if (format) {\n        locHeaders['Content-Type'] = format;\n      } else if (typeof data === 'object') {\n        locHeaders['Content-Type'] = 'application/json';\n      }\n\n      const putRequest = superagent__WEBPACK_IMPORTED_MODULE_1___default.a.put(uri)\n        .query( {preventCache: parseInt(Math.random() * 10000, 10)} )\n        .send( data )\n        .withCredentials()\n        .timeout({ response: this.timeout });\n\n      Object.entries(locHeaders).map( keyVal => putRequest.set(keyVal[0], keyVal[1]) );\n\n      return putRequest;\n    }\n\n    /**\n     * Deletes a resource.\n     *\n     * @param {String} uri of the resource that is to be deleted.\n     * @param {Date=} modDate a date to use for the HTTP if-unmodified-since header.\n     * @return {xhrPromise}\n     */\n    del(uri, modDate) {\n      const locHeaders = Object.assign({}, this.headers);\n      delete locHeaders['Content-Type'];\n      if (modDate) {\n        locHeaders['If-Unmodified-Since'] = modDate.toUTCString();\n      }\n\n      const deleteRequest = superagent__WEBPACK_IMPORTED_MODULE_1___default.a.del(uri)\n        .query( {preventCache: parseInt(Math.random() * 10000, 10)} )\n        .withCredentials()\n        .timeout({ response: this.timeout });\n\n      Object.entries(locHeaders).map( keyVal => deleteRequest.set(keyVal[0], keyVal[1]) );\n\n      return deleteRequest;\n    }\n\n    /**\n     * Put a file to a URI.\n     * In a browser environment a file is represented via an input tag which references\n     * the file to be uploaded via its value attribute.\n     * In node environments the file is represented as a stream constructed via\n     * fs.createReadStream('file.txt').\n     *\n     * > _**Under the hood** the tag is moved into a form in an invisible iframe\n     * which then is submitted. If there is a response it is provided in a textarea which\n     * can be looked into since we are on the same domain._\n     *\n     * @param {string} uri the URI to which we will put the file.\n     * @param {data} data - input tag or stream that may for instance correspond to a file\n     * in a nodejs setting.\n     * @param {string} format the format to handle the response as, either text, xml, html or json\n     * (json is default).\n     */\n    putFile(uri, data, format) {\n      return this.put(uri, data, null, format);\n    }\n  };\n\n\n\n/**\n * @name xhrPromise\n * @extends dojo/promise/Promise\n * @class\n */\n\n/**\n * @name xhrPromise#then\n * @param {xhrSuccessCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n\n/**\n * This is a succesfull callback method to be provided as first argument in a {@link entrypromise}\n *\n * @callback xhrSuccessCallback\n * @param {string|object|node}\n */\n\n/**\n * This is a callback that will be called upon failure, it is supposed to be provided as second\n * argument in a {@link entrypromise}\n *\n * @callback xhrFailureCallback\n * @param {string} error\n * @param {object} ioArgs\n */\n\n/**\n * @name createPromise\n * @extends xhrPromise\n * @class\n */\n\n/**\n * @name xhrPromise#then\n * @param {createSuccessCallback} onSuccess\n * @param {xhrFailureCallback} onError\n */\n\n/**\n * This is a succesfull callback method that provides a reference to the newly created object.\n *\n * @callback createSuccessCallback\n * @param {string} uri the URI of the newly created resource.\n */\n\n\n//# sourceURL=webpack:///./Rest.js?");

/***/ }),

/***/ "./SearchList.js":
/*!***********************!*\
  !*** ./SearchList.js ***!
  \***********************/
/*! exports provided: SearchList */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SearchList\", function() { return SearchList; });\n/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./List */ \"./List.js\");\n  \n\n  /**\n   * @exports store/SearchList\n   */\n  const SearchList = class {\n    /**\n     * @param {store/EntryStore} entryStore\n     * @param {Object} query\n     * @param {string} callType parameter provided to asyncListeners on query execution,\n     * assumed to be 'search' if left out\n     */\n    constructor(entryStore, query, callType) {\n      this._entryStore = entryStore;\n      this._query = query;\n      this._callType = callType || 'search';\n      this._sortedChildren = [];\n    }\n\n    /**\n     * the query instance, e.g. an instance of store/SolrQuery, associated with this SearchList.\n     * @returns {Object}\n     */\n    getQuery() {\n      return this._query;\n    }\n\n    setLimit(limit) {\n      this._query.limit(limit);\n    }\n\n    getLimit() {\n      return this._query.getLimit() || this._entryStore.getFactory().getDefaultLimit();\n    }\n\n    /**\n     * Array of facets, each facet is an object which contains the following fields:\n     *\n     *  name       - the solr search field this facet corresponds to\n     *  valueCount - the number of values this facet matches\n     *  values     - an array of values matching this facet, with name and count each.\n     *\n     * In addition, when asking for facets for arbitrary predicates there is two additional fields:\n     *\n     *  predicate - the full URI of the predicate this facet corresponds to\n     *  type - the type of the facet values, currently only literal, uri and integer are supported\n     *\n     * Note that you can ask for facets for solr fields like \"tags\", in this case the above two\n     * fields will be not be present as the \"tags\" solr field corresponds to a mix of different\n     * predicates and possibly different types.\n     *\n     * Here is an example of a facet for dcat:keyword:\n     * {\n     *   name:  \"metadata.predicate.literal_s.a6424133\",\n     *   predicate: \"http://www.w3.org/ns/dcat#keyword\",\n     *   type: \"literal\",\n     *   valueCount: 3,\n     *   values: [\n     *      {name: \"elektrictet\", count: 1},\n     *      {name: \"finans\", count: 1},\n     *      {name: \"skatt\", count: 1}\n     *   ]\n     * }\n     *\n     * @return {Array} never null or undefined, may be an array of length 0 though.\n     */\n    getFacets() {\n      return this.facets;\n    }\n\n    setFacets(facetFields) {\n      if (!Array.isArray(facetFields) || facetFields.length === 0) {\n        this.facets = [];\n      } else {\n        this.facets = facetFields;\n        const f2p = this._query.facet2predicate;\n        facetFields.forEach((ff) => {\n          if (f2p && f2p[ff.name]) {\n            ff.predicate = f2p[ff.name];\n          }\n          if (ff.name.indexOf('metadata.predicate') === 0) {\n            ff.type = ff.name.split('.')[2];\n          }\n        });\n      }\n    }\n\n    _forceLoadEntries(page) {\n      const offset = (page || 0) * this.getLimit();\n      this._query.offset(offset);\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().get(this._query.getQuery(es)).then((data) => {\n        this.setFacets(data.facetFields);\n        return es.getFactory().extractSearchResults(data, this, es);\n      }), this._callType);\n    }\n  };\n\n  /**\n   * Get size of list.\n   *\n   * @returns {integer} the amount of entries in the list, -1 if unknown.\n   */\n  SearchList.prototype.getSize = _List__WEBPACK_IMPORTED_MODULE_0__[\"List\"].prototype.getSize;\n\n  /**\n   * Retrieves an array of entries contained in this list according to the current page and\n   * pagination settings.\n   *\n   * @param {integer} page - the page to request an array of entries for, first page is numbered 0.\n   * @returns {entryArrayPromise} the promise will return an entry-array.\n   * @method\n   */\n  SearchList.prototype.getEntries = _List__WEBPACK_IMPORTED_MODULE_0__[\"List\"].prototype.getEntries;\n\n  /**\n   * Executes a callback on each list members in the order provided by the solr-search.\n   * If the provided function return false for one entry the iteration is stopped and\n   * the function is not called for consecutive matched entries.\n   *\n   * @param {listEntryCallback} func\n   */\n  SearchList.prototype.forEach = _List__WEBPACK_IMPORTED_MODULE_0__[\"List\"].prototype.forEach;\n  SearchList.prototype._getEntries = _List__WEBPACK_IMPORTED_MODULE_0__[\"List\"].prototype._getEntries;\n  SearchList.prototype._update = _List__WEBPACK_IMPORTED_MODULE_0__[\"List\"].prototype._update;\n\n  \n\n\n//# sourceURL=webpack:///./SearchList.js?");

/***/ }),

/***/ "./SolrQuery.js":
/*!**********************!*\
  !*** ./SolrQuery.js ***!
  \**********************/
/*! exports provided: SolrQuery */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SolrQuery\", function() { return SolrQuery; });\n/* harmony import */ var _SearchList__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SearchList */ \"./SearchList.js\");\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Context */ \"./Context.js\");\n/* harmony import */ var EntryStore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! EntryStore */ \"./EntryStore.js\");\n/* harmony import */ var blueimp_md5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blueimp-md5 */ \"./node_modules/blueimp-md5/js/md5.js\");\n/* harmony import */ var blueimp_md5__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(blueimp_md5__WEBPACK_IMPORTED_MODULE_3__);\nconst namespaces = __webpack_require__(/*! rdfjson/namespaces */ \"./node_modules/rdfjson/namespaces.js\");\n\n\n\n\n\n  const encodeStr = str => encodeURIComponent(str.replace(/:/g, '\\\\:'));\n  const shorten = predicate => blueimp_md5__WEBPACK_IMPORTED_MODULE_3___default()(namespaces.expand(predicate)).substr(0, 8);\n  const ngramLimit = 15;\n  const isNgram = key => key.indexOf('title') === 0\n    || key.indexOf('tag.literal') === 0\n    || (key.indexOf('metadata.predicate.literal') === 0 &&\n      key.indexOf('metadata.predicate.literal_s') !== 0);\n  /**\n   * Empty spaces in search term should be interpreted as AND instead of the default OR.\n   * In addition, fields indexed as text_ngram will have to be shortened to the ngram max limit\n   * as they will not match otherwise.\n   *\n   * @param key\n   * @param term\n   * @return {*}\n   */\n  const solrFriendly = (key, term) => {\n    let and = term.trim().replace(/\\s\\s+/g, ' ').split(' ');\n    if (isNgram(key)) {\n      and = and.map(t => (t.length < ngramLimit ? encodeStr(t) :\n        encodeStr(t.substr(0, ngramLimit))));\n    }\n    return and.length === 1 ? encodeStr(and[0]) : `(${and.join('+AND+')})`;\n  };\n  const buildQuery = (struct, isAnd) => {\n    const terms = [];\n    Object.keys(struct).forEach((key) => {\n      let val = struct[key];\n      val = Array.isArray(val) ? val.map(v => namespaces.expand(v)) : namespaces.expand(val);\n      switch (key) {\n        case 'or':\n          terms.push(buildQuery(val, false));\n          break;\n        case 'and':\n          terms.push(buildQuery(val, true));\n          break;\n        default:\n          if (typeof val === 'string') {\n            terms.push(`${key}:${solrFriendly(key, val)}`);\n          } else if (Array.isArray(val)) {\n            const or = [];\n            val.forEach((o) => {\n              or.push(`${key}:${solrFriendly(key, o)}`);\n            });\n            if (or.length > 1) {\n              terms.push(`(${or.join('+OR+')})`);\n            } else {\n              terms.push(`${or.join('+OR+')}`);\n            }\n          } else if (typeof val === 'object') {\n            // TODO\n          }\n      }\n    });\n    if (terms.length > 1) {\n      return `(${terms.join(isAnd ? '+AND+' : '+OR+')})`;\n    }\n    return terms.join(`${isAnd ? '+AND+' : '+OR+'}`);\n  };\n\n  /**\n   * The SolrQuery class provides a way to create a query by chaining method calls according to\n   * the builder pattern. For example:\n   *\n   *     const sq = es.newSolrQuery().title(\"some title\").type(\"http://example.com/Person\")\n   *\n   * The example yields a search for entries that have a title that contains \"some title\"\n   * and a rdf:type of \"http://example.com/Person\" expressed in the metadata.\n   * To execute the query you can either ask for a {@link store/SearchList} and then call\n   * getEntries (or forEach):\n   *\n   *     const sl = sq.list();\n   *     sl.getEntries().then((entryArr) => {// Do something })\n   *\n   * Or you use the abbreviated version where you just call getEntries directly (or forEach)\n   * on the SolrQuery:\n   *\n   *     sq.getEntries()\n   *\n   * The majority of the methods work the same way, that is they take two values, a value and a\n   * possible negation flag. The value can be an array corresponding to a disjunction and if the\n   * flag is set true the search string will be constructed to search for the negatation of the\n   * provided value. For example, if a graph type in the form of an array containing List and User\n   * is provided together with a negation boolean set to true, the query will search for anything\n   * but lists and users:\n   *\n   *     sq.graphType([types.GT_LIST, types.GT_USER], true)\n   *\n   * Supported methods on the solr object correspond in large to the available solr fields\n   * documentet at, some method names are different to avoid dots:\n   * {@link https://code.google.com/p/entrystore/wiki/KnowledgeBaseSearch}\n   *\n   * There is also a special method ({@link store/SolrQuery#getQuery getQuery}) for getting the\n   * query as a string that is used by EntryStore API behind the scenes, you can safely ignore\n   * this method.\n   *\n   * @exports store/SolrQuery\n   */\n  const SolrQuery = class {\n    /**\n     * @param {store/EntryStore} entrystore\n     */\n    constructor(entrystore) {\n      this._entrystore = entrystore;\n      this.properties = [];\n      this.params = {};\n      this.modifiers = {};\n      this._and = [];\n      this._or = [];\n    }\n\n    /**\n     * @private\n     */\n    _q(key, val, modifier) {\n      this.params[key] = val;\n      if (typeof modifier !== 'undefined') {\n        this.modifiers[key] = modifier;\n      }\n      return this;\n    }\n\n    /**\n     * Matches all titles in all languages, multivalued, cannot be sorted on.\n     * Includes dc:title, dcterms:title, skos:prefLabel, skos:altLabel, skos:hiddenLabel,\n     * rdfs:label, foaf:name.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    title(val, modifier) {\n      return this._q('title', val, modifier);\n    }\n    /**\n     * Matches all descriptions in all languages, multivalued, cannot be sorted on.\n     * Includes dc:description, dcterms:description, rdfs:comment\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    description(val, modifier) {\n      return this._q('description', val, modifier);\n    }\n    /**\n     * Matches all tags literals in all languages, multivalued, cannot be sorted on.\n     * Includes dc:subject, dcterms:subject, dcat:keyword and lom:keyword\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    tagLiteral(val, modifier) {\n      return this._q('tag.literal', val, modifier);\n    }\n    /**\n     * Matches all tag URIs, multivalued, cannot be sorted on.\n     * Includes dc:subject, dcterms:subject\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    tagURI(val, modifier) {\n      return this._q('tag.uri', val, modifier);\n    }\n    /**\n     * Matches the language (as a literal) of the resource, single value, can be used for sorting?\n     * Includes dc:language, dcterms:language\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    lang(val, modifier) {\n      return this._q('lang', val, modifier);\n    }\n    /**\n     * Matches title, description and tags, multivalue, cannot be sorted on.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    all(val, modifier) {\n      return this._q('all', val, modifier);\n    }\n    /**\n     * Matches all URIs in subject position in the metadata, except the resourceURI.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    subject(val, modifier) {\n      return this._q('metadata.subject', val, modifier);\n    }\n    /**\n     * Matches all URIs in predicate position in the metadata.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    predicate(val, modifier) {\n      return this._q('metadata.predicate', val, modifier);\n    }\n    /**\n     * Matches all literals in object position in the metadata.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    objectLiteral(val, modifier) {\n      return this._q('metadata.object.literal', val, modifier);\n    }\n    /**\n     * Matches all URIs in object position in the metadata.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    objectUri(val, modifier) {\n      return this._q('metadata.object.uri', val, modifier);\n    }\n    /**\n     * Matches the resourceURI of the entry.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    resource(val, modifier) {\n      return this._q('resource', val, modifier);\n    }\n    /**\n     * Matches the entryURI of the entry.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    uri(val, modifier) {\n      return this._q('uri', val, modifier);\n    }    /**\n     * Matches all types of the resourceURI, i.e.\n     * all URIs pointed to via rdf:type from the resourceURI.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    rdfType(rdfType, modifier) {\n      if (Array.isArray(rdfType)) {\n        return this._q('rdfType', array.map(rdfType, t => namespaces.expand(t)), modifier);\n      }\n      return this._q('rdfType', namespaces.expand(rdfType), modifier);\n    }\n    /**\n     * Matches all creators (in the entry information graph) expressed via their resourceURIs.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    creator(val, modifier) {\n      return this._q('creator', val, modifier);\n    }\n    /**\n     * Matches all contributors (in the entry information graph) expressed via their resourceURIs.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    contributors(val, modifier) {\n      return this._q('contributors', val, modifier);\n    }\n    /**\n     * Matches only entries that are part of the given lists, identified via their resourceURIs.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    lists(val, modifier) {\n      return this._q('lists', val, modifier);\n    }\n    /**\n     * Matches entries that are created at the specific date, most useful for sorting.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    created(val, modifier) {\n      return this._q('created', val, modifier);\n    }\n    /**\n     * Matches entries that are modified at the specific date, most useful for sorting.\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    modified(val, modifier) {\n      return this._q('modified', val, modifier);\n    }\n    /**\n     * Matches entries with the given entry type, use the values in {@link store/types}, e.g.\n     * sq.entryType(types.ET_LINK).\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    entryType(val, modifier) {\n      return this._q('entryType', val, modifier);\n    }\n    /**\n     * Matches entries with the given graph type, use the values in {@link store/types}, e.g.\n     * sq.entryType(types.GT_USER).\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    graphType(val, modifier) {\n      return this._q('graphType', val, modifier);\n    }\n    /**\n     * Matches entries with the given resource type, use the values in {@link store/types}, e.g.\n     * sq.entryType(types.RT_INFORMATIONRESOURCE).\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    resourceType(val, modifier) {\n      return this._q('resourceType', val, modifier);\n    }\n    /**\n     * Matches only public entries. Warning, individual entrys public flag is inherited from\n     * surrounding context and if the context ACL is updated the entrys are not reindexed\n     * automatically. Hence, this flag may be incorrect.\n     *\n     * @param {true|false} isPublic\n     * @return {store/SolrQuery}\n     */\n    publicRead(isPublic = true) {\n      return this._q('public', isPublic === true ? 'true' : 'false', modifier);\n    }\n    /**\n     * Matches only entries with explicitly ACL stating user(s) has admin rights\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    admin(val, modifier) {\n      return this._q('acl.admin', val, modifier);\n    }\n    /**\n     * Matches only entries with explicitly ACL stating user(s) has metadata read rights\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    metadataRead(val, modifier) {\n      return this._q('acl.metadata.r', val, modifier);\n    }\n    /**\n     * Matches only entries with explicitly ACL stating user(s) has metadata write (and read) rights\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    metadataWrite(val, modifier) {\n      return this._q('acl.metadata.rw', val, modifier);\n    }\n    /**\n     * Matches only entries with explicitly ACL stating user(s) has resource read rights\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    resourceRead(val, modifier) {\n      return this._q('acl.resource.r', val, modifier);\n    }\n    /**\n     * Matches only entries with explicitly ACL stating user(s) has resource write (and read) rights\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    resourceWrite(val, modifier) {\n      return this._q('acl.resource.rw', val, modifier);\n    }\n    /**\n     * Matches entries with with specific status (expressed in entry information graph)\n     *\n     * @param {string|array} val\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    status(val, modifier) {\n      return this._q('status', val, modifier);\n    }\n    /**\n     * Matches only entries within specified context(s)\n     *\n     * @param {string|store/Context} context either a store/Context instance or a string. If it\n     * is a string and it starts with 'http' it is assumed it is the resourceURI of the context,\n     * otherwise the context is assumed to be a contextId.\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    context(context, modifier = false) {\n      if (context && context.getResourceURI) {\n        return this._q('context', context.getResourceURI(), modifier);\n      } else if (((typeof context) === 'string') && context !== '') {\n        if (context.indexOf('http') === 0) {\n          return this._q('context', context, modifier);\n        }\n        return this._q('context', this._entrystore.getContextById(context)\n          .getResourceURI(), modifier);\n      }\n      return this;\n    }\n\n    /**\n     * Provide a query in the form of an object structure where the toplevel attributes\n     * are disjunctive (OR:ed together). The following example will query for things that\n     * are typed as vedgetables AND have the word 'tomato' in either the title OR description:\n     * query.rdfType('ex:Vedgetable).or({\n     *   title: 'tomato',\n     *   description: 'tomato'\n     * });\n     *\n     * Note, the name of the method ('or') does not refers to how the object structure is\n     * combined with the rest of the query, only how the inner parts of the object structure\n     * is combined. To change the toplevel behaviour of the query from an and to an or,\n     * use the disjunctive method.\n     *\n     * @param {object} struct\n     * @return {store/SolrQuery}\n     */\n    or(struct) {\n      this._or.push(struct);\n      return this;\n    }\n\n    /**\n     * Provide a query in the form of an object structure where the toplevel attributes\n     * are conjunctive (AND:ed together). The following example will query for things that\n     * are typed as vedgetables OR typed as fruit AND has a title that contains the word 'orange':\n     * query.disjunctive().rdfType('ex:Vedgetable).and({\n     *   rdfType: 'ex:Fruit',\n     *   title: 'Orange',\n     * });\n     *\n     * Note, the name of the method ('and') does not refers to how the object structure is\n     * combined with the rest of the query, only how the inner parts of the object structure\n     * is combined. In this example we have change the toplevel behaviour of the query to\n     * become disjunctive (being OR:ed together), this is to make the query more representative\n     * since there is no need for the grouping of the object structure otherwise.\n     *\n     * @param {object} struct\n     * @return {store/SolrQuery}\n     */\n    and(struct) {\n      this._and.push(struct);\n      return this;\n    }\n\n    /**\n     * @deprecated\n     */\n//eslint-disable-next-line\n    title_lang(title, language) {\n    }\n    /**\n     * If a title has a language set, a dynamic field is created with the pattern \"title.en\",\n     * without multi value support. This is used in the context of sorting.\n     * @param title {String} the title to search for\n     * @param language {String} the language of the title for instance \"en\".\n     * @return {store/SolrQuery}\n     */\n    titleWithLanguage(title, language) {\n      this._title_lang = { value: title, language };\n      return this;\n    }\n    /**\n     * Matches specific property value combinations.\n     *\n     * @param {string} predicate\n     * @param {string|array} object\n     * @param {true|false|string} modifier\n     * @param {text|string|ngram} indexType text is default and corresponds to matching words,\n     * string corresponds to exact string matching and ngram corresponds to partial string matching\n     * @return {store/SolrQuery}\n     */\n    literalProperty(predicate, object, modifier, indexType = 'text') {\n      const key = shorten(predicate);\n      let it;\n      switch (indexType) {\n        case 'ngram':\n          it = 'litera_ng';\n          break;\n        case 'string':\n          it = 'literal_s';\n          break;\n        case 'text':\n        default:\n          it = 'literal';\n      }\n      this.properties.push({\n        md5: key,\n        object,\n        modifier,\n        nodetype: it,\n      });\n      return this;\n    }\n    /**\n     * Matches specific property value combinations when the value is an integer.\n     * Note that the integer values are single value per property and can be used for sorting.\n     *\n     * @param {string} predicate\n     * @param {string|array} object\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    integerProperty(predicate, object, modifier) {\n      const key = shorten(predicate);\n      this.properties.push({\n        md5: key,\n        object,\n        modifier,\n        nodetype: 'integer',\n      });\n      return this;\n    }\n    /**\n     * Matches specific property value combinations when the value is an integer.\n     * Note that the integer values are single value per property and can be used for sorting.\n     *\n     * @param {string} predicate\n     * @param {string|array} object\n     * @param {true|false|string} modifier\n     * @return {store/SolrQuery}\n     */\n    uriProperty(predicate, object, modifier) {\n      const key = shorten(predicate);\n\n      this.properties.push({\n        md5: key,\n        object: Array.isArray(object) ? object.map(o => namespaces.expand(o)) :\n          namespaces.expand(object),\n        modifier,\n        nodetype: 'uri',\n      });\n      return this;\n    }\n    /**\n     * Sets the pagination limit.\n     *\n     * @param {string|integer} limit\n     * @return {store/SolrQuery}\n     */\n    limit(limit) {\n      this._limit = limit;\n      return this;\n    }\n    /**\n     * Gets the pagination limit if it set.\n     *\n     * @param {string|integer} limit\n     * @return {store/SolrQuery}\n     */\n    getLimit() {\n      return this._limit;\n    }\n    /**\n     * The parameter \"sort\" can be used for Solr-style sorting, e.g. \"sort=title+asc,modified+desc\".\n     * The default sorting value is to sort after the score (relevancy) and the modification date.\n     * All string and non-multi value fields can be used for sorting, this basically excludes title,\n     * description and keywords,\n     * but allows sorting after e.g. title.en.\n     * If no sort is explicitly given the default sort string used is \"score+asc\".\n     * @param sort {String} a list of fields together with '+asc' or '+desc', first field has the\n     * highest priority when sorting.\n     * @return {store/SolrQuery}\n     */\n    sort(sort) {\n      this._sort = sort;\n      return this;\n    }\n    /**\n     * Set an explicit offset.\n     *\n     * @param {string|integer} offset\n     * @return {store/SolrQuery}\n     */\n    offset(offset) {\n      this._offset = offset;\n      return this;\n    }\n\n    /**\n     * @private\n     * @param {string} facet\n     * @param {string} predicate\n     * @return {store/SolrQuery}\n     */\n    facet(facet, predicate) {\n      this.facets = this.facets || [];\n      if (predicate) {\n        this.facet2predicate = this.facet2predicate || {};\n        this.facet2predicate[facet] = namespaces.expand(predicate);\n      }\n      this.facets.push(facet);\n      return this;\n    }\n    /**\n     * Request to include literal facets for the given predicate\n     * @param {string} predicate\n     * @return {store/SolrQuery}\n     */\n    literalFacet(predicate) {\n      this.facet(`metadata.predicate.literal_s.${shorten(predicate)}`, predicate);\n      return this;\n    }\n    /**\n     * Request to include URI facets for the given predicate\n     * @param {string} predicate\n     * @return {store/SolrQuery}\n     */\n    uriFacet(predicate) {\n      this.facet(`metadata.predicate.uri.${shorten(predicate)}`, predicate);\n      return this;\n    }\n    /**\n     * Request to include integer facets for the given predicate\n     * @param {string} predicate\n     * @return {store/SolrQuery}\n     */\n    integerFacet(predicate) {\n      this.facet(`metadata.predicate.integer.${shorten(predicate)}`, predicate);\n      return this;\n    }\n    /**\n     * Tell the query construction to make the fields added via the property methods\n     * (uriProperty, literalProperty and integerProperty) to be disjunctive rather than\n     * conjunctive. For example:\n     *\n     *     es.newSolrQuery().disjuntiveProperties().literalProperty(\"dcterms:title\", \"banana\")\n     *          .uriProperty(\"dcterms:subject\", \"ex:Banana\");\n     *\n     * Will search for entries that have either a \"banana\" in the title or a relation to\n     * ex:Banana via dcterms:subject. The default, without disjunctiveProperties being called\n     * is to create a conjunction, i.e. AND them together.\n     *\n     * @return {store/SolrQuery}\n     */\n    disjuntiveProperties() {\n      this.disjunctiveProperties = true;\n      return this;\n    }\n    /**\n     * Tell the query construction to make top level fields disjunctive rather than\n     * conjunctive. For example\n     *\n     *     es.newSolrQuery().disjuntive().title(\"banana\").description(\"tomato\")\n     *\n     * Will search for entries that have either a \"banana\" in the title or \"tomato\" in the\n     * description rather than entries that have both which is the default.\n     *\n     * @return {store/SolrQuery}\n     */\n    disjuntive() {\n      this.disjunctive = true;\n      return this;\n    }\n    /**\n     * Construct a SearchList fro this SolrQuery.\n     *\n     * @param asyncCallType\n     * @returns {store/SearchList}\n     */\n    list(asyncCallType) {\n      return new _SearchList__WEBPACK_IMPORTED_MODULE_0__[\"SearchList\"](this._entrystore, this, asyncCallType);\n    }\n\n    /**\n     * Produces the actual query to the EntryStore API.\n     * @return {string}\n     * @protected\n     */\n    getQuery() {\n      const and = [];\n      if (this._title_lang != null) {\n        and.push(`title.${this._title_lang.lang}:${solrFriendly(this._title_lang.lang,\n          this._title_lang.value)}`);\n      }\n      Object.keys(this.params).forEach((key) => {\n        const v = this.params[key];\n        const modifier = this.modifiers[key];\n        if ((typeof v === 'string') && v !== '') {\n          if (modifier === true || modifier === 'not') {\n            and.push(`NOT(${key}:${solrFriendly(key, v)})`);\n          } else {\n            and.push(`${key}:${solrFriendly(key, v)}`);\n          }\n        } else if (Array.isArray(v) && v.length > 0) {\n          const or = [];\n          v.forEach((ov) => {\n            if ((typeof ov === 'string') ) {\n              or.push(`${key}:${solrFriendly(key, ov)}`);\n            }\n          });\n          if (modifier === true || modifier === 'not') {\n            and.push(`NOT(${or.join('+OR+')})`);\n          } else if (modifier === 'and') {\n            and.push(`(${or.join('+AND+')})`);\n          } else {\n            and.push(`(${or.join('+OR+')})`);\n          }\n        }\n      });\n\n      if (this.disjunctiveProperties || this.disjunctive) {\n        const or = [];\n        array.forEach(this.properties, (prop) => {\n          const obj = prop.object;\n          const key = `metadata.predicate.${prop.nodetype}.${prop.md5}`;\n          if (typeof obj === 'string') {\n            or.push(`${key}:${solrFriendly(key, obj)}`);\n          } else if (Array.isArray(obj) && obj.length > 0) {\n            array.forEach(obj, (o) => {\n              or.push(`${key}:${solrFriendly(key, o)}`);\n            });\n          }\n        });\n        if (or.length > 0) {\n          and.push(`(${or.join('+OR+')})`);\n        }\n      } else {\n        this.properties.forEach((prop) => {\n          const obj = prop.object;\n          const key = `metadata.predicate.${prop.nodetype}.${prop.md5}`;\n          if (typeof obj === 'string') {\n            if (prop.modifier === true || prop.modifier === 'not') {\n              and.push(`NOT(${key}:${solrFriendly(key, obj)})`);\n            } else {\n              and.push(`${key}:${solrFriendly(key, obj)}`);\n            }\n          } else if (Array.isArray(obj) && obj.length > 0) {\n            const or = [];\n            array.forEach(obj, (o) => {\n              or.push(`${key}:${solrFriendly(key, o)}`);\n            }, this);\n            if (prop.modifier === true || prop.modifier === 'not') {\n              and.push(`NOT(${or.join('+OR+')})`);\n            } else if (prop.modifier === 'and') {\n              and.push(`(${or.join('+AND+')})`);\n            } else {\n              and.push(`(${or.join('+OR+')})`);\n            }\n          }\n        }, this);\n      }\n      this._and.forEach((struct) => {\n        and.push(buildQuery(struct, true));\n      });\n      this._or.forEach((struct) => {\n        and.push(buildQuery(struct, false));\n      });\n\n      let trail = '';\n      if (this._limit != null) {\n        trail = `&limit=${this._limit}`;\n      }\n      if (this._offset) {\n        trail = `${trail}&offset=${this._offset}`;\n      }\n      if (this._sort) {\n        trail = `${trail}&sort=${this._sort || 'score+asc'}`;\n      }\n      if (this.facets) {\n        trail += `&facetFields=${this.facets.join(',')}`;\n      }\n      return `${this._entrystore.getBaseURI()}search?type=solr&query=${and.join(this.disjunctive ? '+OR' : '+AND+')}${trail}`;\n    }\n    /**\n     * @param page\n     * @returns {entryArrayPromise} the promise will return an entry-array.\n     * @see {store/List.getEntries}\n     */\n    getEntries(page) {\n      return this.list().getEntries(page);\n    }\n    /**\n     * @param func\n     * @return {promise}\n     * @see {store/List.forEach}\n     */\n    forEach(func) {\n      return this.list().forEach(func);\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./SolrQuery.js?");

/***/ }),

/***/ "./String.js":
/*!*******************!*\
  !*** ./String.js ***!
  \*******************/
/*! exports provided: StringResource */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StringResource\", function() { return StringResource; });\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\n\n  /**\n   * String is a resource for handling simple strings of data.\n   *\n   * @exports store/String\n   */\n  const StringResource = class extends _Resource__WEBPACK_IMPORTED_MODULE_0__[\"Resource\"] {\n    /**\n     * @param {string} entryURI - URI to an entry where this resource is contained.\n     * @param {string} resourceURI - URI to the resource.\n     * @param {store/EntryStore} entryStore - the API's repository instance.\n     * @param {string} data - the actual string, may the empty string, but not null or undefined.\n     */\n    constructor(entryURI, resourceURI, entryStore, data) {\n      super(entryURI, resourceURI, entryStore); // Call the super constructor.\n      this._data = data;\n    }\n\n    /**\n     * @returns {string} may be an empty string, never null or undefined.\n     */\n    getString() {\n      return this._data;\n    }\n\n    /**\n     * Set a new string, does not save it to the repository, use commit for that. E.g.\n     *\n     *     stringresource.setString(\"New value\").commit().then(function() {...});\n     *\n     * @param {string} string - the new string\n     * @returns {store/String} allows chaining with commit.\n     * @see store/String#commit\n     */\n    setString(string) {\n      this._data = string || '';\n      return this;\n    }\n\n    /**\n     * Pushes the string back to the repository.\n     *\n     * @returns {xhrPromise}\n     * @see store/String#setString\n     */\n    commit() {\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI, this._data), 'commitString');\n    }\n\n    getSource() {\n      return this._data;\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./String.js?");

/***/ }),

/***/ "./User.js":
/*!*****************!*\
  !*** ./User.js ***!
  \*****************/
/*! exports provided: User */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"User\", function() { return User; });\n/* harmony import */ var Resource__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! Resource */ \"./Resource.js\");\n  const json = __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\");\n  \n\n  /**\n   * User instances are resources corresponding to users that can be authenticated to access\n   * the EntryStore repository. The user resource URI can be referred to from access control lists.\n   *\n   * @exports store/User\n   */\n  class User extends Resource__WEBPACK_IMPORTED_MODULE_0__[\"Resource\"] {\n    /**\n     * @param {string} entryURI - URI to an entry where this resource is contained.\n     * @param {string} resourceURI - URI to the resource.\n     * @param {store/EntryStore} entryStore - the API's repository instance.\n     * @param {Object} data - information about the user, e.g. object with name and homecontext.\n     */\n    constructor(entryURI, resourceURI, entryStore, data) {\n      super(entryURI, resourceURI, entryStore);\n      this._data = data;\n    }\n\n    /**\n     * Get the name of the user, this is a a unique name (username) in the current repository's\n     * _principals context.\n     * @returns {string}\n     */\n    getName() {\n      return this._data.name;\n    }\n\n    /**\n     * Set a new name (username), it will not succeed if it is already in use, for instance by\n     * another user or group.\n     * @param {string} name\n     * @returns {xhrPromise}\n     */\n    setName(name) {\n      const oldname = this._data.name;\n      this._data.name = name;\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI, json.stringify({ name }))\n        .then((data) => {\n          const e = this.getEntry(true);\n          if (e) {\n            e.getEntryInfo()._name = data;\n          }\n          return data;\n        }, (e) => {\n          this._data.name = oldname;\n          throw e;\n        }), 'setUserName');\n    }\n\n    /**\n     * Get the preferred language of the user.\n     * @returns {string}\n     */\n    getLanguage() {\n      return this._data.language;\n    }\n\n    /**\n     * Sets the preferred language of a user.\n     * @param {string} language\n     * @returns {xhrPromise}\n     */\n    setLanguage(language) {\n      const oldlanguage = this._data.language;\n      this._data.language = language;\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI, json.stringify({ language }))\n        .then(data => data, (e) => {\n          this._data.language = oldlanguage;\n          throw e;\n        }), 'setUserLanguage');\n    }\n\n    /**\n     * Set a new password for the user.\n     *\n     * @param {string} password - a new password, should be at least 8 characters long.\n     * @returns {xhrPromise}\n     */\n    setPassword(password) {\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI,\n        json.stringify({ password })), 'setUserPassword');\n    }\n\n    /**\n     * Get the home context for this user.\n     *\n     * @returns {string} - a context id (not the full resource URI).\n     */\n    getHomeContext() {\n      return this._data.homecontext;\n    }\n\n    /**\n     * Set a new home context for this user.\n     *\n     * @param {string} contextId - a context id (not the full resource URI).\n     * @returns {xhrPromise}\n     */\n    setHomeContext(contextId) {\n      const oldhc = this._data.homecontext;\n      this._data.homecontext = contextId;\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI,\n        json.stringify({ homecontext: contextId }))\n        .then(data => data, (e) => {\n          this._data.homecontext = oldhc;\n          throw e;\n        }), 'setUserHomeContext');\n    }\n\n    /**\n     * Get custom properties.\n     *\n     * @returns {object} - key value pairs of custom properties.\n     */\n    getCustomProperties() {\n      return this._data.customProperties || {};\n    }\n\n    /**\n     * Set a new home context for this user.\n     *\n     * @param {string} contextId - a context id (not the full resource URI).\n     * @returns {xhrPromise}\n     */\n    setCustomProperties(customProperties) {\n      const oldcp = this._data.customProperties;\n      this._data.customProperties = customProperties;\n      const es = this._entryStore;\n      return es.handleAsync(es.getREST().put(this._resourceURI,\n        json.stringify({ customProperties }))\n        .then(data => data, (e) => {\n          this._data.customProperties = oldcp;\n          throw e;\n        }), 'setUserCustomProperties');\n    }\n\n    getSource() {\n      return this._data;\n    }\n  };\n\n  \n\n\n//# sourceURL=webpack:///./User.js?");

/***/ }),

/***/ "./factory.js":
/*!********************!*\
  !*** ./factory.js ***!
  \********************/
/*! exports provided: factory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"factory\", function() { return factory; });\n/* harmony import */ var _String__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./String */ \"./String.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./types.js\");\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Context */ \"./Context.js\");\n/* harmony import */ var _EntryInfo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EntryInfo */ \"./EntryInfo.js\");\n/* harmony import */ var _Entry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Entry */ \"./Entry.js\");\n/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./List */ \"./List.js\");\n/* harmony import */ var _Group__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Group */ \"./Group.js\");\n/* harmony import */ var _SearchList__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./SearchList */ \"./SearchList.js\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Graph */ \"./Graph.js\");\n/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./File */ \"./File.js\");\n/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./Pipeline */ \"./Pipeline.js\");\n/* harmony import */ var _User__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./User */ \"./User.js\");\n  \n  \n  const json = __webpack_require__(/*! dojo/json */ \"./node_modules/dojo/json.js\");\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  const Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n  \n\n  /**\n   * This module contains utility methods that encapsulates EntryStores REST layer from the rest\n   * of the code. It is intended to be used internally by the EntryStore.js API,\n   * not by application developers.\n   *\n   * Hence, **you should avoid using factory methods directly in application code as there are\n   * most probably other ways to achieve the same thing. Most likely by using method in\n   * {@link store/EntryStore}!**\n   *\n   * The utility methods are currently not visible as they are not documented yet.\n   * (The methods cannot be marked as private as they need to be used throughout the API.)\n   *\n   * @exports store/factory\n   * @namespace\n   */\n  const factory = {};\n\n  let sortObj = { sortBy: 'title', prio: 'List' };\n  let defaultLimit = 50;\n\n  const getContextForEntry = (entryURI, entryStore) => {\n    const baseURI = entryStore.getBaseURI();\n    const contextId = entryURI.substr(baseURI.length, entryURI.indexOf('/', baseURI.length)\n      - baseURI.length);\n    const contexts = entryStore.getCachedContextsIdx();\n    let context = contexts[contextId];\n    if (!context) {\n      context = new _Context__WEBPACK_IMPORTED_MODULE_2__[\"Context\"](`${baseURI}_contexts/entry/${contextId}`, baseURI\n        + contextId, entryStore);\n      contexts[contextId] = context;\n    }\n    return context;\n  };\n\n  const transformRights = (rights) => {\n    const o = {};\n    const r = rights || [];\n    for (let n = 0; n < r.length; n++) {\n      o[r[n]] = true;\n    }\n    return o;\n  };\n\n  const fixName = (resource, data) => {\n    // Special case of searches and similar when name is provided but not full resource.\n    if (typeof data.name === 'string' && resource != null) {\n      if (resource instanceof _User__WEBPACK_IMPORTED_MODULE_11__[\"User\"]) {\n        resource._data = resource._data || {};\n        resource._data.name = data.name;\n      } else { // Context and Group\n        resource._name = data.name;\n      }\n    }\n  };\n\n  const _updateOrCreateResource = (entry, data, force) => {\n    const _data = data || {};\n    let resource = entry.getResource(true);\n    const uri = entry.getURI();\n    const ruri = entry.getResourceURI();\n    const cruri = entry.getContext().getResourceURI();\n    const es = entry.getEntryStore();\n    const ei = entry.getEntryInfo();\n    if (!resource && ei.getEntryType() === _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].ET_LOCAL\n      && ei.getResourceType() === _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].RT_INFORMATIONRESOURCE) {\n      switch (entry.getEntryInfo().getGraphType()) {\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_CONTEXT: // Synchronous resource, asynchronous methods.\n          // Dummy URL to find the right context.\n          resource = getContextForEntry(`${es.getBaseURI() + entry.getId()}/`,\n            entry.getEntryStore());\n          resource._update(_data);\n          break;\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_LIST: // Synchronous resource, asynchronous methods.\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_GROUP: // Synchronous resource, asynchronous methods.\n          if (entry.isGroup()) {\n            resource = new _Group__WEBPACK_IMPORTED_MODULE_6__[\"Group\"](uri, ruri, es);\n          } else {\n            resource = new _List__WEBPACK_IMPORTED_MODULE_5__[\"List\"](uri, ruri, es);\n          }\n          if (_data.resource && _data.resource.children) {\n            resource._update(_data.resource, _data.resource.children.map(child =>\n              factory.updateOrCreate(`${cruri}/entry/${child.entryId}`, child, es)));\n          }\n          break;\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_USER: // Asynchronous resource, synchronous getters.\n          if (force || _data.resource != null) {\n            resource = new _User__WEBPACK_IMPORTED_MODULE_11__[\"User\"](uri, ruri, es, _data.resource || {});\n          }\n          break;\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_STRING:\n          if (force || _data.resource != null) {\n            resource = new _String__WEBPACK_IMPORTED_MODULE_0__[\"StringResource\"](uri, ruri, es, _data.resource || '');\n          }\n          break;\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_GRAPH: // Sync or Async?\n          if (force || _data.resource != null) {\n            resource = new _Graph__WEBPACK_IMPORTED_MODULE_8__[\"GraphResource\"](uri, ruri, es, _data.resource || {});\n          }\n          break;\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_PIPELINE: // Sync or Async?\n          if (force || _data.resource != null) {\n            resource = new _Pipeline__WEBPACK_IMPORTED_MODULE_10__[\"Pipeline\"](uri, ruri, es, _data.resource || {});\n          }\n          break;\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_PIPELINERESULT: // If local, Pipelineresult resource is a file.\n        case _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_NONE: // Uploaded file.\n          resource = new _File__WEBPACK_IMPORTED_MODULE_9__[\"FileResource\"](uri, ruri, es);\n          break;\n        default:\n      }\n      entry._resource = resource;\n      fixName(resource, _data);\n      return;\n    }\n\n    if (resource == null || _data.resource == null) {\n      fixName(resource, _data);\n      return;\n    }\n\n    if (resource._update) {\n      if (entry.isList() || entry.isGroup()) {\n        if (_data.resource && _data.resource.children) {\n          resource._update(_data.resource, _data.resource.children.map(child =>\n            factory.updateOrCreate(`${cruri}/entry/${child.entryId}`,\n              child, entry.getEntryStore())));\n        }\n      } else {\n        resource._update(_data.resource);\n      }\n    }\n  };\n\n  const _updateEntry = (entry, data) => {\n    entry._metadata = data.metadata ? new Graph(data.metadata) : null;\n    entry._cachedExternalMetadata = data['cached-external-metadata'] ? new Graph(data['cached-external-metadata']) : null;\n    entry._inferredMetadata = data.inferred ? new Graph(data.inferred) : null;\n    entry._extractedMetadata = data['extracted-metadata'] ? new Graph(data['extracted-metadata']) : null;\n    entry._relation = data.relations ? new Graph(data.relations) : new Graph();\n    entry._rights = transformRights(data.rights);\n    // Sometimes we get the name that is really part of the resource without getting the full\n    // resource, in this case we store this in the entryinfo.\n    if (data.name || (data.resource && data.resource.name)) {\n      const ei = entry.getEntryInfo();\n      // ei._alias = data.alias;\n      ei._name = data.name || data.resource.name;\n    }\n    return entry;\n  };\n\n  factory.getContext = (entryStore, contextEntryURI) => {\n    const baseURI = entryStore.getBaseURI();\n    const contextsBaseURI = `${baseURI}_contexts/entry/`;\n    const contextId = contextEntryURI.substr(contextsBaseURI.length);\n    const contexts = entryStore.getCachedContextsIdx();\n    let context = contexts[contextId];\n    if (!context) {\n      context = new _Context__WEBPACK_IMPORTED_MODULE_2__[\"Context\"](contextEntryURI, baseURI + contextId, entryStore);\n      contexts[contextId] = context;\n    }\n    return context;\n  };\n\n  factory.getList = (entryStore, entryURI) => {\n    const cache = entryStore.getCache();\n    let entry = cache.get(entryURI);\n    if (!entry) {  // If no entry is in cache, create an empty entry\n      // Assuming there is an info object... TODO check so not info_stub remains in rest layer.\n      const ei = new _EntryInfo__WEBPACK_IMPORTED_MODULE_3__[\"EntryInfo\"](entryURI, new Graph(), entryStore);\n      entry = new _Entry__WEBPACK_IMPORTED_MODULE_4__[\"Entry\"](getContextForEntry(entryURI, entryStore), ei, entryStore);\n      const resourceURI = entryURI.replace('/entry/', '/resource/');\n      entry._resource = new _List__WEBPACK_IMPORTED_MODULE_5__[\"List\"](entryURI, resourceURI, entryStore);\n      cache.cache(entry, true); // Add to cache silently.\n      entry.setRefreshNeeded(true);  // Make sure it needs to be updated before accessed.\n    }\n    // Returning only the list which has no reference to the entry isolates the entry from\n    // beeing accessed before refreshed.\n    return entry._resource;\n  };\n\n  factory.updateOrCreate = (entryURI, data, entryStore) => {\n    const cache = entryStore.getCache();\n    let entry = cache.get(entryURI);\n    if (entry) {\n      entry.getEntryInfo().setGraph(new Graph(data.info));\n    } else {\n      // Assuming there is an info object... TODO check so not info_stub remains in rest layer.\n      const ei = new _EntryInfo__WEBPACK_IMPORTED_MODULE_3__[\"EntryInfo\"](entryURI, new Graph(data.info), entryStore);\n      entry = new _Entry__WEBPACK_IMPORTED_MODULE_4__[\"Entry\"](getContextForEntry(entryURI, entryStore), ei);\n    }\n    _updateEntry(entry, data);\n    _updateOrCreateResource(entry, data);\n    cache.cache(entry); // Add to or refresh the cache.\n    return entry;\n  };\n\n  factory.updateOrCreateResource = _updateOrCreateResource;\n\n  factory.update = (entry, data) => {\n    entry.getEntryInfo().setGraph(new Graph(data.info));\n    _updateOrCreateResource(entry, data);\n    _updateEntry(entry, data);\n    entry.getEntryStore().getCache().cache(entry); // Add to or refresh the cache.\n  };\n\n  factory.createSearchList = (entryStore, query) => new _SearchList__WEBPACK_IMPORTED_MODULE_7__[\"SearchList\"](entryStore, query);\n\n  factory.extractSearchResults = (data, list, entryStore) => {\n    // Update or create all entries recieved.\n    // TODO change rest api so offset is inside of resource.\n    data.resource.offset = data.resource.offset || data.offset;\n    // TODO change rest api so size is inside of resource.\n    data.resource.size = data.resource.size || data.results;\n    const baseURI = entryStore.getBaseURI();\n    const entries = data.resource.children.map(child => factory.updateOrCreate(\n      `${baseURI + child.contextId}/entry/${child.entryId}`, child, entryStore));\n    list._update(data.resource, entries);\n    return entries;\n  };\n\n  factory.getMetadataURI = entryURI => entryURI.replace('/entry/', '/metadata/');\n\n  factory.getCachedExternalMetadataURI = entryURI => entryURI.replace('/entry/',\n    '/cached-external-metadata/');\n\n  /**\n   * @deprecated in favor of {@link store/factory#getEntryId}\n   */\n  factory.getId = uri => uri.substr(uri.lastIndexOf('/') + 1);\n\n  factory.getEntryId = (uri, base) => {\n    let _uri = uri;\n    if (base) {\n      _uri = _uri.substr(base.length - 1); // include the / before.\n    }\n    const res = _uri.match(/\\/([^/]+)\\/(entry|resource|metadata|relation)\\/([^?/]+)(\\?.*)?$/);\n    if (res) {\n      return res[3];\n    } else if (_uri.lastIndexOf('/') === 0) {\n      return _uri.substr(1);\n    } else if (!base) {\n      return _uri.substr(_uri.lastIndexOf('/') + 1);\n    }\n    return undefined;\n  };\n\n  factory.getContextId = (uri, base) => {\n    let _uri = uri;\n    if (base) {\n      _uri = _uri.substr(base.length - 1); // include the / before.\n    }\n    const res = _uri.match(/\\/([^/]+)\\/(entry|resource|metadata|relation)\\/([^?/]+)(\\?.*)?$/);\n    if (res) {\n      return res[1];\n    } else if (_uri.indexOf('/') === -1 || !base) {\n      return '_contexts';\n    }\n    return undefined;\n  };\n\n  factory.getEntryURIFromURI = (entryStore, uri) => {\n    const base = entryStore.getBaseURI();\n    return `${base + factory.getContextId(uri, base)}/entry/${factory.getEntryId(uri, base)}`;\n  };\n\n  factory.getEntryURI = (entryStore, contextId, entryId) =>\n    `${entryStore.getBaseURI() + contextId}/entry/${entryId}`;\n\n  factory.getResourceBase = (entryStore, contextId) =>\n    `${entryStore.getBaseURI() + contextId}/resource/`;\n\n  factory.getResourceURI = (entryStore, contextId, entryId) => {\n    if (contextId === '_contexts') {\n      return entryStore.getBaseURI() + entryId;\n    }\n    return `${entryStore.getBaseURI() + contextId}/resource/${entryId}`;\n  };\n\n  factory.getURIFromCreated = (data, context) =>\n    `${context.getResourceURI()}/entry/${data.entryId}`;\n\n  factory.getEntryLoadURI = (entryURI, params) => {\n    const _params = params || {};\n    let strL = '';\n    if (_params.limit > 0 || _params.limit === -1) {\n      strL = `&limit=${_params.limit}`;\n    } else {\n      strL = `&limit=${defaultLimit}`;\n    }\n    const strO = _params.offset == null || _params.offset === 0 ? '' : `&offset=${_params.offset}`;\n    const sort = _params.sort == null ? sortObj : _params.sort;\n    let strSort = '';\n    let strDesc = '';\n    let strPrio = '';\n    if (sort != null) {\n      strSort = sort.sortBy == null ? '' : `&sort=${sort.sortBy}`;\n      strDesc = sort.descending === true ? '&order=desc' : '';\n      strPrio = sort.prio == null ? '' : `&prio=${sort.prio}`;\n      // TODO lang remains.\n    }\n    return `${entryURI}?includeAll${strL}${strO}${strSort}${strDesc}${strPrio}`;\n  };\n\n  factory.getEntryCreateURI = (prototypeEntry, parentListEntry) => {\n    let uri = `${prototypeEntry.getContext().getResourceURI()}?`;\n    if (prototypeEntry) {\n      const ei = prototypeEntry.getEntryInfo();\n      if (prototypeEntry.getSpecificId() != null) {\n        uri = `${uri}id=${prototypeEntry.getSpecificId()}&`;\n      }\n      if (prototypeEntry.isLink()) {\n        uri = `${uri}resource=${encodeURIComponent(prototypeEntry.getResourceURI())}&`;\n      }\n      if (prototypeEntry.isReference() || prototypeEntry.isLinkReference()) { // external metadata\n        uri = `${uri}resource=${encodeURIComponent(prototypeEntry.getResourceURI())}&`;\n        uri = `${uri}cached-external-metadata=${encodeURIComponent(ei.getExternalMetadataURI())}&`;\n      }\n      if (ei.getEntryType() !== _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].ET_LOCAL) { // local, link, linkreference, reference\n        uri = `${uri}entrytype=${ei.getEntryType().toLowerCase()}&`;\n      }\n      // informationresource, namedresource\n      if (ei.getResourceType() !== _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].RT_INFORMATIONRESOURCE) {\n        // TODO Bug in REST layer, should be resourcetype, is now informationresource innstead\n        uri = `${uri}informationresource=false&`;\n      }\n      if (ei.getGraphType() !== _types__WEBPACK_IMPORTED_MODULE_1__[\"types\"].GT_NONE) {\n        uri = `${uri}graphtype=${ei.getGraphType().toLowerCase()}&`;\n      }\n    }\n    if (parentListEntry) {\n      uri = `${uri}list=${parentListEntry.getResourceURI()}&`;\n    }\n    return uri.slice(0, -1);\n  };\n\n  factory.getEntryCreatePostData = (prototypeEntry) => {\n    const postData = {};\n    let empty = true;\n    const md = prototypeEntry.getMetadata();\n    if (md != null && !md.isEmpty()) {\n      postData.metadata = md.exportRDFJSON();\n      empty = false;\n    }\n    const re = prototypeEntry.getResource(true);\n    if (re != null && re.getSource != null) {\n      postData.resource = re.getSource();\n      empty = false;\n    }\n    const ei = prototypeEntry.getEntryInfo().getGraph();\n    if (ei != null && !ei.isEmpty()) {\n      postData.info = ei.exportRDFJSON();\n      empty = false;\n    }\n    const cemd = prototypeEntry.getCachedExternalMetadata();\n    if (cemd != null && !cemd.isEmpty()) {\n      postData['cached-external-metadata'] = cemd.exportRDFJSON();\n      empty = false;\n    }\n    return empty ? '' : json.stringify(postData);\n  };\n\n  factory.getMoveURI = (entry, fromListEntry, toListEntry, baseURI) => {\n    const euri = entry.getURI().substr(baseURI.length); // Only send something like 3/entry/2\n    const furi = fromListEntry.getResourceURI().substr(baseURI.length);\n    return `${toListEntry.getResourceURI()}?moveEntry=${euri}&fromList=${furi}`;\n  };\n\n  factory.getProxyURI = (baseURI, uri, formatHint) => {\n    let url = `${baseURI}proxy?url=${encodeURIComponent(uri)}`;\n    if (formatHint != null) {\n      url += `&fromFormat=${formatHint}`;\n    }\n    return url;\n  };\n\n  factory.getPutFileURI = uri =>\n    `${uri + (uri.indexOf('?') < 0 ? '?' : '&')}method=put&textarea=true`;\n\n  factory.setSort = (sortObject) => {\n    sortObj = sortObject;\n  };\n\n  factory.getSort = () => sortObj;\n\n  factory.getDefaultLimit = () => defaultLimit;\n\n  factory.setDefaultLimit = (limit) => {\n    defaultLimit = limit;\n  };\n\n  \n\n\n//# sourceURL=webpack:///./factory.js?");

/***/ }),

/***/ "./html.js":
/*!*****************!*\
  !*** ./html.js ***!
  \*****************/
/*! exports provided: html */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"html\", function() { return html; });\nconst print = __webpack_require__(/*! rdfjson/print */ \"./node_modules/rdfjson/print.js\");\n\n  /**\n   * A module that contain utility methods for generating html for entries.\n   *\n   * @exports store/html\n   * @namespace\n   */\n  const html = {};\n  // The above construction seem to be needed because of jsdoc3 issues with not detecting the\n  // exports variable.\n\n  /**\n   * Generates a table with columns subject, predicate, and object.\n   * @param {store/Entry} entry to expose metadata for\n   * @returns {string} rendered html as a string\n   */\n  html.metadataTable = (entry) => {\n    const delegates = print.prettyTree(entry.getMetadata(), entry.getResourceURI());\n    const arr = [];\n    for (let i = 0; i < delegates.length; i++) {\n      const d = delegates[i];\n      const st = d.stmt;\n      arr.push(`${'<tr>' +\n        \"<td class='rdf_subject'>\"}${st.isSubjectBlank() ? d.s :\n          `<a href='${st.getSubject()}'>${d.s}</a>`}</td>` +\n        `<td class='rdf_predicate'><a href='${st.getPredicate()}'>${d.p}</a></td>` +\n        `<td class='rdf_object'>${st.getType() === 'uri' ? `<a href='${st.getValue()}'>${d.o}</a>` :\n          d.o}</td></tr>`);\n    }\n    return arr.join('\\n');\n  };\n\n  const _ind = {};\n  const indenter = function (indent) {\n    if (!_ind[indent]) {\n      let str = '';\n      for (let i = 1; i < indent; i++) {\n        str += \"<span class='rdf_indent'></span>\";\n      }\n      _ind[indent] = str;\n    }\n    return _ind[indent];\n  };\n\n  /**\n   * Prints one level of triples from a subject where URIs are namespaced.\n   *\n   * @param {rdfjson/Graph} graph the graph containing the metadata\n   * @param {string} subject URI to a resource to start from\n   * @returns {string} string with the triples rendered as HTML.\n   */\n  html.metadataIndent = function (graph, subject) {\n    const delegates = print.prettyTree(graph, subject);\n    const arr = [];\n    for (let i = 0; i < delegates.length; i++) {\n      const d = delegates[i];\n      const st = d.stmt;\n      arr.push(`<div class='rdf_statement'>${indenter(d.indent)}<span class='rdf_subject'>${\n          st.isSubjectBlank() ? d.s : `<a href='${st.getSubject()}'>${d.s}</a>`}</span>` +\n        `<span class='rdf_predicate'><a href='${st.getPredicate()}'>${d.p}</a></span>` +\n        `<span class='rdf_object'>${st.getType() === 'uri' ?\n          `<a href='${st.getValue()}'>${d.o}</a>` : d.o}</span></div>`);\n    }\n    return arr.join('\\n');\n  };\n\n  /**\n   * Prints the three types of the entry, i.e. entry, resource and graphtype.\n   * @param {store/EntryInfo} entryInfo\n   * @returns {string}\n   */\n  html.entryInfo = entryInfo =>\n  `<span class='info entrytype'><label>EntryType:</label> ${entryInfo.getEntryType()}</span>` +\n  `<span class='info resourceType'><label>ResourceType:</label> ${entryInfo.getResourceType()\n  }</span>` +\n  `<span class='info graphType'><label>GraphType:</label> ${entryInfo.getGraphType()}</span>`;\n\n  /**\n   * Prints information about the entry, including entryinfo, metadata, cached external metadata\n   * as well as which context the entry belongs to.\n   *\n   * @param {store/Entry} entry\n   * @returns {string} information about the entry as a HTML string.\n   */\n  html.print = (entry) => {\n    const strs = [`${\"<div class='entry'>\" +\n    \"<h3>Context: <a class='contextURI' href='\"}${entry.getContext().getEntryURI()}'>${entry.getContext().getId()}</a> <span></span> ` +\n    `Entry: <a class='entryURI' href='${entry.getURI()}'>${entry.getId()}</a></h3>` +\n    '<div>' +\n    `<div class='entryInfo'>${html.entryInfo(entry.getEntryInfo())}</div>`];\n    const md = entry.getMetadata();\n    if (md && !md.isEmpty()) {\n      strs.push(`<h4>Local metadata:</h4><div class='metadata'>${html.metadataIndent(md, entry.getResourceURI())}</div>`);\n    }\n    const emd = entry.getCachedExternalMetadata();\n    if (emd && !emd.isEmpty()) {\n      strs.push(`<h4>Cached external metadata:</h4><div class='metadata'>${html.metadataIndent(emd, entry.getResourceURI())}</div>`);\n    }\n    strs.push('</div></div>');\n    return strs.join('');\n  };\n\n  \n\n\n//# sourceURL=webpack:///./html.js?");

/***/ }),

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: factory, html, promiseUtil, rest, solr, types, Auth, Cache, Context, Entry, EntryInfo, EntryStore, EntryStoreUtil, File, Graph, Group, List, Pipeline, PrototypeEntry, Resource, SearchList, String, User, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _factory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./factory */ \"./factory.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"factory\", function() { return _factory__WEBPACK_IMPORTED_MODULE_0__[\"factory\"]; });\n\n/* harmony import */ var _html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./html */ \"./html.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"html\", function() { return _html__WEBPACK_IMPORTED_MODULE_1__[\"html\"]; });\n\n/* harmony import */ var _promiseUtil__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./promiseUtil */ \"./promiseUtil.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"promiseUtil\", function() { return _promiseUtil__WEBPACK_IMPORTED_MODULE_2__[\"promiseUtil\"]; });\n\n/* harmony import */ var _Rest__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Rest */ \"./Rest.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"rest\", function() { return _Rest__WEBPACK_IMPORTED_MODULE_3__[\"Rest\"]; });\n\n/* harmony import */ var _SolrQuery__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SolrQuery */ \"./SolrQuery.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"solr\", function() { return _SolrQuery__WEBPACK_IMPORTED_MODULE_4__[\"SolrQuery\"]; });\n\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ \"./types.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"types\", function() { return _types__WEBPACK_IMPORTED_MODULE_5__[\"types\"]; });\n\n/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Auth */ \"./Auth.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Auth\", function() { return _Auth__WEBPACK_IMPORTED_MODULE_6__[\"Auth\"]; });\n\n/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Cache */ \"./Cache.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Cache\", function() { return _Cache__WEBPACK_IMPORTED_MODULE_7__[\"Cache\"]; });\n\n/* harmony import */ var _Context__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Context */ \"./Context.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Context\", function() { return _Context__WEBPACK_IMPORTED_MODULE_8__[\"Context\"]; });\n\n/* harmony import */ var _Entry__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Entry */ \"./Entry.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Entry\", function() { return _Entry__WEBPACK_IMPORTED_MODULE_9__[\"Entry\"]; });\n\n/* harmony import */ var _EntryInfo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./EntryInfo */ \"./EntryInfo.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EntryInfo\", function() { return _EntryInfo__WEBPACK_IMPORTED_MODULE_10__[\"EntryInfo\"]; });\n\n/* harmony import */ var _EntryStore__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./EntryStore */ \"./EntryStore.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EntryStore\", function() { return _EntryStore__WEBPACK_IMPORTED_MODULE_11__[\"EntryStore\"]; });\n\n/* harmony import */ var _EntryStoreUtil__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./EntryStoreUtil */ \"./EntryStoreUtil.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EntryStoreUtil\", function() { return _EntryStoreUtil__WEBPACK_IMPORTED_MODULE_12__[\"EntryStoreUtil\"]; });\n\n/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./File */ \"./File.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"File\", function() { return _File__WEBPACK_IMPORTED_MODULE_13__[\"FileResource\"]; });\n\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./Graph */ \"./Graph.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Graph\", function() { return _Graph__WEBPACK_IMPORTED_MODULE_14__[\"GraphResource\"]; });\n\n/* harmony import */ var _Group__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Group */ \"./Group.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Group\", function() { return _Group__WEBPACK_IMPORTED_MODULE_15__[\"Group\"]; });\n\n/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./List */ \"./List.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"List\", function() { return _List__WEBPACK_IMPORTED_MODULE_16__[\"List\"]; });\n\n/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./Pipeline */ \"./Pipeline.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Pipeline\", function() { return _Pipeline__WEBPACK_IMPORTED_MODULE_17__[\"Pipeline\"]; });\n\n/* harmony import */ var _PrototypeEntry__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./PrototypeEntry */ \"./PrototypeEntry.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PrototypeEntry\", function() { return _PrototypeEntry__WEBPACK_IMPORTED_MODULE_18__[\"PrototypeEntry\"]; });\n\n/* harmony import */ var _Resource__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./Resource */ \"./Resource.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Resource\", function() { return _Resource__WEBPACK_IMPORTED_MODULE_19__[\"Resource\"]; });\n\n/* harmony import */ var _SearchList__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./SearchList */ \"./SearchList.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"SearchList\", function() { return _SearchList__WEBPACK_IMPORTED_MODULE_20__[\"SearchList\"]; });\n\n/* harmony import */ var _String__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./String */ \"./String.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"String\", function() { return _String__WEBPACK_IMPORTED_MODULE_21__[\"StringResource\"]; });\n\n/* harmony import */ var _User__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./User */ \"./User.js\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"User\", function() { return _User__WEBPACK_IMPORTED_MODULE_22__[\"User\"]; });\n\n/* harmony import */ var _terms__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./terms */ \"./terms.js\");\n/*\n * The exposed EntryStore API\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_EntryStore__WEBPACK_IMPORTED_MODULE_11__[\"EntryStore\"].util = _EntryStoreUtil__WEBPACK_IMPORTED_MODULE_12__[\"EntryStoreUtil\"];\n_EntryStore__WEBPACK_IMPORTED_MODULE_11__[\"EntryStore\"].terms = _terms__WEBPACK_IMPORTED_MODULE_23__[\"terms\"];\n_EntryStore__WEBPACK_IMPORTED_MODULE_11__[\"EntryStore\"].types = _types__WEBPACK_IMPORTED_MODULE_5__[\"types\"];\n_EntryStore__WEBPACK_IMPORTED_MODULE_11__[\"EntryStore\"].Cache = _Cache__WEBPACK_IMPORTED_MODULE_7__[\"Cache\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (_EntryStore__WEBPACK_IMPORTED_MODULE_11__[\"EntryStore\"]);\n\n\n//# sourceURL=webpack:///./index.js?");

/***/ }),

/***/ "./libs/dojo/_base/array.js":
/*!**********************************!*\
  !*** ./libs/dojo/_base/array.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./libs/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./libs/dojo/has.js\"), __webpack_require__(/*! ./lang */ \"./libs/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, lang){\n\t// module:\n\t//\t\tdojo/_base/array\n\n\t// our old simple function builder stuff\n\tvar cache = {}, u;\n\n\tfunction buildFn(fn){\n\t\treturn cache[fn] = new Function(\"item\", \"index\", \"array\", fn); // Function\n\t}\n\t// magic snippet: if(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\n\t// every & some\n\n\tfunction everyOrSome(some){\n\t\tvar every = !some;\n\t\treturn function(a, fn, o){\n\t\t\tvar i = 0, l = a && a.length || 0, result;\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\t\tif(o){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn.call(o, a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn(a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn every; // Boolean\n\t\t};\n\t}\n\n\t// indexOf, lastIndexOf\n\n\tfunction index(up){\n\t\tvar delta = 1, lOver = 0, uOver = 0;\n\t\tif(!up){\n\t\t\tdelta = lOver = uOver = -1;\n\t\t}\n\t\treturn function(a, x, from, last){\n\t\t\tif(last && delta > 0){\n\t\t\t\t// TODO: why do we use a non-standard signature? why do we need \"last\"?\n\t\t\t\treturn array.lastIndexOf(a, x, from);\n\t\t\t}\n\t\t\tvar l = a && a.length || 0, end = up ? l + uOver : lOver, i;\n\t\t\tif(from === u){\n\t\t\t\ti = up ? lOver : l + uOver;\n\t\t\t}else{\n\t\t\t\tif(from < 0){\n\t\t\t\t\ti = l + from;\n\t\t\t\t\tif(i < 0){\n\t\t\t\t\t\ti = lOver;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\ti = from >= l ? l + uOver : from;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tfor(; i != end; i += delta){\n\t\t\t\tif(a[i] == x){\n\t\t\t\t\treturn i; // Number\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1; // Number\n\t\t};\n\t}\n\n\tvar array = {\n\t\t// summary:\n\t\t//\t\tThe Javascript v1.6 array extensions.\n\n\t\tevery: everyOrSome(false),\n\t\t/*=====\n\t\t every: function(arr, callback, thisObject){\n\t\t\t // summary:\n\t\t\t //\t\tDetermines whether or not every item in arr satisfies the\n\t\t\t //\t\tcondition implemented by callback.\n\t\t\t // arr: Array|String\n\t\t\t //\t\tthe array to iterate on. If a string, operates on individual characters.\n\t\t\t // callback: Function|String\n\t\t\t //\t\ta function is invoked with three arguments: item, index,\n\t\t\t //\t\tand array and returns true if the condition is met.\n\t\t\t // thisObject: Object?\n\t\t\t //\t\tmay be used to scope the call to callback\n\t\t\t // returns: Boolean\n\t\t\t // description:\n\t\t\t //\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\n\t\t\t //\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t //\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\n\t\t\t //\t\tFor more details, see:\n\t\t\t //\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\n\t\t\t // example:\n\t\t\t //\t|\t// returns false\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\t // example:\n\t\t\t //\t|\t// returns true\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>0; });\n\t\t },\n\t\t =====*/\n\n\t\tsome: everyOrSome(true),\n\t\t/*=====\n\t\tsome: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tDetermines whether or not any item in arr satisfies the\n\t\t\t//\t\tcondition implemented by callback.\n\t\t\t// arr: Array|String\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function is invoked with three arguments: item, index,\n\t\t\t//\t\tand array and returns true if the condition is met.\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Boolean\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\n\t\t\t// example:\n\t\t\t//\t| // is true\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\t// example:\n\t\t\t//\t| // is false\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item<1; });\n\t\t},\n\t\t=====*/\n\n\t\tindexOf: index(true),\n\t\t/*=====\n\t\tindexOf: function(arr, value, fromIndex, findLast){\n\t\t\t// summary:\n\t\t\t//\t\tlocates the first index of the provided value in the\n\t\t\t//\t\tpassed array. If the value is not found, -1 is returned.\n\t\t\t// description:\n\t\t\t//\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\n\t\t\t//\n\t\t\t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\n\t\t\t//\t\t   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.\n\t\t\t//\t\t2. uses equality (==) rather than strict equality (===)\n\t\t\t//\n\t\t\t//\t\tFor details on this method, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\n\t\t\t// arr: Array\n\t\t\t// value: Object\n\t\t\t// fromIndex: Integer?\n\t\t\t// findLast: Boolean?\n\t\t\t//\t\tMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.\n\t\t\t// returns: Number\n\t\t},\n\t\t=====*/\n\n\t\tlastIndexOf: index(false),\n\t\t/*=====\n\t\tlastIndexOf: function(arr, value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tlocates the last index of the provided value in the passed\n\t\t\t//\t\tarray. If the value is not found, -1 is returned.\n\t\t\t// description:\n\t\t \t//\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\n\t\t \t//\n\t\t \t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\n\t\t \t//\t\t   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.\n\t\t \t//\t\t2. uses equality (==) rather than strict equality (===)\n\t\t \t//\n\t\t \t//\t\tFor details on this method, see:\n\t\t \t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\n\t\t\t// arr: Array,\n\t\t\t// value: Object,\n\t\t\t// fromIndex: Integer?\n\t\t\t// returns: Number\n\t\t},\n\t\t=====*/\n\n\t\tforEach: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tfor every item in arr, callback is invoked. Return values are ignored.\n\t\t\t//\t\tIf you want to break out of the loop, consider using array.every() or array.some().\n\t\t\t//\t\tforEach does not allow breaking out of the loop over the items in arr.\n\t\t\t// arr:\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\t// callback:\n\t\t\t//\t\ta function is invoked with three arguments: item, index, and array\n\t\t\t// thisObject:\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\n\t\t\t// example:\n\t\t\t//\t| // log out all members of the array:\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tfunction(item){\n\t\t\t//\t|\t\t\tconsole.log(item);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| );\n\t\t\t// example:\n\t\t\t//\t| // log out the members and their indexes\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tfunction(item, idx, arr){\n\t\t\t//\t|\t\t\tconsole.log(item, \"at index:\", idx);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| );\n\t\t\t// example:\n\t\t\t//\t| // use a scoped object member as the callback\n\t\t\t//\t|\n\t\t\t//\t| var obj = {\n\t\t\t//\t|\t\tprefix: \"logged via obj.callback:\",\n\t\t\t//\t|\t\tcallback: function(item){\n\t\t\t//\t|\t\t\tconsole.log(this.prefix, item);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| };\n\t\t\t//\t|\n\t\t\t//\t| // specifying the scope function executes the callback in that scope\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tobj.callback,\n\t\t\t//\t|\t\tobj\n\t\t\t//\t| );\n\t\t\t//\t|\n\t\t\t//\t| // alternately, we can accomplish the same thing with lang.hitch()\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tlang.hitch(obj, \"callback\")\n\t\t\t//\t| );\n\t\t\t// arr: Array|String\n\t\t\t// callback: Function|String\n\t\t\t// thisObject: Object?\n\n\t\t\tvar i = 0, l = arr && arr.length || 0;\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tcallback.call(thisObject, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tcallback(arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmap: function(arr, callback, thisObject, Ctr){\n\t\t\t// summary:\n\t\t\t//\t\tapplies callback to each element of arr and returns\n\t\t\t//\t\tan Array with the results\n\t\t\t// arr: Array|String\n\t\t\t//\t\tthe array to iterate on. If a string, operates on\n\t\t\t//\t\tindividual characters.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function is invoked with three arguments, (item, index,\n\t\t\t//\t\tarray),\t and returns a value\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Array\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\n\t\t\t// example:\n\t\t\t//\t| // returns [2, 3, 4, 5]\n\t\t\t//\t| array.map([1, 2, 3, 4], function(item){ return item+1 });\n\n\t\t\t// TODO: why do we have a non-standard signature here? do we need \"Ctr\"?\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tout[i] = callback.call(thisObject, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tout[i] = callback(arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out; // Array\n\t\t},\n\n\t\tfilter: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new Array with those items from arr that match the\n\t\t\t//\t\tcondition implemented by callback.\n\t\t\t// arr: Array\n\t\t\t//\t\tthe array to iterate over.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function that is invoked with three arguments (item,\n\t\t\t//\t\tindex, array). The return of this function is expected to\n\t\t\t//\t\tbe a boolean which determines whether the passed-in item\n\t\t\t//\t\twill be included in the returned array.\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Array\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\n\t\t\t// example:\n\t\t\t//\t| // returns [2, 3, 4]\n\t\t\t//\t| array.filter([1, 2, 3, 4], function(item){ return item>1; });\n\n\t\t\t// TODO: do we need \"Ctr\" here like in map()?\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = [], value;\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tvalue = arr[i];\n\t\t\t\t\tif(callback.call(thisObject, value, i, arr)){\n\t\t\t\t\t\tout.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tvalue = arr[i];\n\t\t\t\t\tif(callback(value, i, arr)){\n\t\t\t\t\t\tout.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out; // Array\n\t\t},\n\n\t\tclearCache: function(){\n\t\t\tcache = {};\n\t\t}\n\t};\n\n\n\thas(\"extend-dojo\") && lang.mixin(dojo, array);\n\n\treturn array;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./libs/dojo/_base/array.js?");

/***/ }),

/***/ "./libs/dojo/_base/config.js":
/*!***********************************!*\
  !*** ./libs/dojo/_base/config.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../has */ \"./libs/dojo/has.js\"), __webpack_require__.dj.c(module.i)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, require){\n\t// module:\n\t//\t\tdojo/_base/config\n\n/*=====\nreturn {\n\t// summary:\n\t//\t\tThis module defines the user configuration during bootstrap.\n\t// description:\n\t//\t\tBy defining user configuration as a module value, an entire configuration can be specified in a build,\n\t//\t\tthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\n\t//\t\tAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\n\t//\t\tat an unique absolute module identifier as given by the package configuration. Implementing configuration\n\t//\t\tas a module allows for specifying unique, per-instance configurations.\n\t// example:\n\t//\t\tCreate a second instance of dojo with a different, instance-unique configuration (assume the loader and\n\t//\t\tdojo.js are already loaded).\n\t//\t\t|\t// specify a configuration that creates a new instance of dojo at the absolute module identifier \"myDojo\"\n\t//\t\t|\trequire({\n\t//\t\t|\t\tpackages:[{\n\t//\t\t|\t\t\tname:\"myDojo\",\n\t//\t\t|\t\t\tlocation:\".\", //assume baseUrl points to dojo.js\n\t//\t\t|\t\t}]\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// specify a configuration for the myDojo instance\n\t//\t\t|\tdefine(\"myDojo/config\", {\n\t//\t\t|\t\t// normal configuration variables go here, e.g.,\n\t//\t\t|\t\tlocale:\"fr-ca\"\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// load and use the new instance of dojo\n\t//\t\t|\trequire([\"myDojo\"], function(dojo){\n\t//\t\t|\t\t// dojo is the new instance of dojo\n\t//\t\t|\t\t// use as required\n\t//\t\t|\t});\n\n\t// isDebug: Boolean\n\t//\t\tDefaults to `false`. If set to `true`, ensures that Dojo provides\n\t//\t\textended debugging feedback to the console.\n\tisDebug: false,\n\n\t// locale: String\n\t//\t\tThe locale to assume for loading localized resources in this page,\n\t//\t\tspecified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).\n\t//\t\tMust be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.\n\t//\t\tSee the documentation for `dojo.i18n` and `dojo.requireLocalization`\n\t//\t\tfor details on loading localized resources. If no locale is specified,\n\t//\t\tDojo assumes the locale of the user agent, according to `navigator.userLanguage`\n\t//\t\tor `navigator.language` properties.\n\tlocale: undefined,\n\n\t// extraLocale: Array\n\t//\t\tNo default value. Specifies additional locales whose\n\t//\t\tresources should also be loaded alongside the default locale when\n\t//\t\tcalls to `dojo.requireLocalization()` are processed.\n\textraLocale: undefined,\n\n\t// baseUrl: String\n\t//\t\tThe directory in which `dojo.js` is located. Under normal\n\t//\t\tconditions, Dojo auto-detects the correct location from which it\n\t//\t\twas loaded. You may need to manually configure `baseUrl` in cases\n\t//\t\twhere you have renamed `dojo.js` or in which `<base>` tags confuse\n\t//\t\tsome browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned\n\t//\t\teither the value of `djConfig.baseUrl` if one is provided or the\n\t//\t\tauto-detected root if not. Other modules are located relative to\n\t//\t\tthis path. The path should end in a slash.\n\tbaseUrl: undefined,\n\n\t// modulePaths: [deprecated] Object\n\t//\t\tA map of module names to paths relative to `dojo.baseUrl`. The\n\t//\t\tkey/value pairs correspond directly to the arguments which\n\t//\t\t`dojo.registerModulePath` accepts. Specifying\n\t//\t\t`djConfig.modulePaths = { \"foo\": \"../../bar\" }` is the equivalent\n\t//\t\tof calling `dojo.registerModulePath(\"foo\", \"../../bar\");`. Multiple\n\t//\t\tmodules may be configured via `djConfig.modulePaths`.\n\tmodulePaths: {},\n\n\t// addOnLoad: Function|Array\n\t//\t\tAdds a callback via dojo/ready. Useful when Dojo is added after\n\t//\t\tthe page loads and djConfig.afterOnLoad is true. Supports the same\n\t//\t\targuments as dojo/ready. When using a function reference, use\n\t//\t\t`djConfig.addOnLoad = function(){};`. For object with function name use\n\t//\t\t`djConfig.addOnLoad = [myObject, \"functionName\"];` and for object with\n\t//\t\tfunction reference use\n\t//\t\t`djConfig.addOnLoad = [myObject, function(){}];`\n\taddOnLoad: null,\n\n\t// parseOnLoad: Boolean\n\t//\t\tRun the parser after the page is loaded\n\tparseOnLoad: false,\n\n\t// require: String[]\n\t//\t\tAn array of module names to be loaded immediately after dojo.js has been included\n\t//\t\tin a page.\n\trequire: [],\n\n\t// defaultDuration: Number\n\t//\t\tDefault duration, in milliseconds, for wipe and fade animations within dijits.\n\t//\t\tAssigned to dijit.defaultDuration.\n\tdefaultDuration: 200,\n\n\t// dojoBlankHtmlUrl: String\n\t//\t\tUsed by some modules to configure an empty iframe. Used by dojo/io/iframe and\n\t//\t\tdojo/back, and dijit/popup support in IE where an iframe is needed to make sure native\n\t//\t\tcontrols do not bleed through the popups. Normally this configuration variable\n\t//\t\tdoes not need to be set, except when using cross-domain/CDN Dojo builds.\n\t//\t\tSave dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`\n\t//\t\tto the path on your domain your copy of blank.html.\n\tdojoBlankHtmlUrl: undefined,\n\n\t// ioPublish: Boolean?\n\t//\t\tSet this to true to enable publishing of topics for the different phases of\n\t//\t\tIO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list\n\t//\t\tof topics that are published.\n\tioPublish: false,\n\n\t// transparentColor: Array\n\t//\t\tArray containing the r, g, b components used as transparent color in dojo.Color;\n\t//\t\tif undefined, [255,255,255] (white) will be used.\n\ttransparentColor: undefined,\n\t\n\t// deps: Function|Array\n\t//\t\tDefines dependencies to be used before the loader has been loaded.\n\t//\t\tWhen provided, they cause the loader to execute require(deps, callback) \n\t//\t\tonce it has finished loading. Should be used with callback.\n\tdeps: undefined,\n\t\n\t// callback: Function|Array\n\t//\t\tDefines a callback to be used when dependencies are defined before \n\t//\t\tthe loader has been loaded. When provided, they cause the loader to \n\t//\t\texecute require(deps, callback) once it has finished loading. \n\t//\t\tShould be used with deps.\n\tcallback: undefined,\n\t\n\t// deferredInstrumentation: Boolean\n\t//\t\tWhether deferred instrumentation should be loaded or included\n\t//\t\tin builds.\n\tdeferredInstrumentation: true,\n\n\t// useDeferredInstrumentation: Boolean|String\n\t//\t\tWhether the deferred instrumentation should be used.\n\t//\n\t//\t\t* `\"report-rejections\"`: report each rejection as it occurs.\n\t//\t\t* `true` or `1` or `\"report-unhandled-rejections\"`: wait 1 second\n\t//\t\t\tin an attempt to detect unhandled rejections.\n\tuseDeferredInstrumentation: \"report-unhandled-rejections\"\n};\n=====*/\n\n\tvar result = {};\n\tif(has(\"dojo-config-api\")){\n\t\t// must be the dojo loader; take a shallow copy of require.rawConfig\n\t\tvar src = require.rawConfig, p;\n\t\tfor(p in src){\n\t\t\tresult[p] = src[p];\n\t\t}\n\t}else{\n\t\tvar adviseHas = function(featureSet, prefix, booting){\n\t\t\tfor(p in featureSet){\n\t\t\t\tp!=\"has\" && has.add(prefix + p, featureSet[p], 0, booting);\n\t\t\t}\n\t\t};\n\t\tvar global = (function () { return this; })();\n\t\tresult = has(\"dojo-loader\") ?\n\t\t\t// must be a built version of the dojo loader; all config stuffed in require.rawConfig\n\t\t\trequire.rawConfig :\n\t\t\t// a foreign loader\n\t\t\tglobal.dojoConfig || global.djConfig || {};\n\t\tadviseHas(result, \"config\", 1);\n\t\tadviseHas(result.has, \"\", 1);\n\t}\n\n\tif(!result.locale && typeof navigator != \"undefined\"){\n\t\t// Default locale for browsers (ensure it's read from user-settings not download locale).\n\t\tvar language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :\n\t\t\t(navigator.language || navigator.userLanguage);\n\t\tif(language){\n\t\t\tresult.locale = language.toLowerCase();\n\t\t}\n\t}\n\n\treturn result;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n\n//# sourceURL=webpack:///./libs/dojo/_base/config.js?");

/***/ }),

/***/ "./libs/dojo/_base/kernel.js":
/*!***********************************!*\
  !*** ./libs/dojo/_base/kernel.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../has */ \"./libs/dojo/has.js\"), __webpack_require__(/*! ./config */ \"./libs/dojo/_base/config.js\"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, config, require, module){\n\t// module:\n\t//\t\tdojo/_base/kernel\n\n\t// This module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\n\tvar\n\t\t// loop variables for this module\n\t\ti, p,\n\n\t\t// create dojo, dijit, and dojox\n\t\t// FIXME: in 2.0 remove dijit, dojox being created by dojo\n\t\tglobal = (function () { return this; })(),\n\t\tdijit = {},\n\t\tdojox = {},\n\t\tdojo = {\n\t\t\t// summary:\n\t\t\t//\t\tThis module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\n\t\t\t// notice dojo takes ownership of the value of the config module\n\t\t\tconfig:config,\n\t\t\tglobal:global,\n\t\t\tdijit:dijit,\n\t\t\tdojox:dojox\n\t\t};\n\n\n\t// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide\n\t// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create\n\t// unique names in the global space.\n\t//\n\t// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,\n\t// where global when in fact they are either global under different names or not global at all. In v1.6-, the\n\t// config variable \"scopeMap\" was used to map names as used within a module to global names. This has been\n\t// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,\n\t// only the \"*\" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.\n\t//\n\t// The following computations contort the packageMap for this dojo instance into a scopeMap.\n\tvar scopeMap =\n\t\t\t// a map from a name used in a legacy module to the (global variable name, object addressed by that name)\n\t\t\t// always map dojo, dijit, and dojox\n\t\t\t{\n\t\t\t\tdojo:[\"dojo\", dojo],\n\t\t\t\tdijit:[\"dijit\", dijit],\n\t\t\t\tdojox:[\"dojox\", dojox]\n\t\t\t},\n\n\t\tpackageMap =\n\t\t\t// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config\n\t\t\t(require.map && require.map[module.i.match(/[^\\/]+/)[0]]),\n\n\t\titem;\n\n\n\t// process all mapped top-level names for this instance of dojo\n\tfor(p in packageMap){\n\t\tif(scopeMap[p]){\n\t\t\t// mapped dojo, dijit, or dojox\n\t\t\tscopeMap[p][0] = packageMap[p];\n\t\t}else{\n\t\t\t// some other top-level name\n\t\t\tscopeMap[p] = [packageMap[p], {}];\n\t\t}\n\t}\n\n\t// publish those names to _scopeName and, optionally, the global namespace\n\tfor(p in scopeMap){\n\t\titem = scopeMap[p];\n\t\titem[1]._scopeName = item[0];\n\t\tif(!config.noGlobals){\n\t\t\tglobal[item[0]] = item[1];\n\t\t}\n\t}\n\tdojo.scopeMap = scopeMap;\n\n\t/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/\n\n\t// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated\n\tdojo.baseUrl = dojo.config.baseUrl = require.baseUrl;\n\tdojo.isAsync = !has(\"dojo-loader\") || require.async;\n\tdojo.locale = config.locale;\n\n\tvar rev = \"$Rev: 594ed6f $\".match(/[0-9a-f]{7,}/);\n\tdojo.version = {\n\t\t// summary:\n\t\t//\t\tVersion number of the Dojo Toolkit\n\t\t// description:\n\t\t//\t\tHash about the version, including\n\t\t//\n\t\t//\t\t- major: Integer: Major version. If total version is \"1.2.0beta1\", will be 1\n\t\t//\t\t- minor: Integer: Minor version. If total version is \"1.2.0beta1\", will be 2\n\t\t//\t\t- patch: Integer: Patch version. If total version is \"1.2.0beta1\", will be 0\n\t\t//\t\t- flag: String: Descriptor flag. If total version is \"1.2.0beta1\", will be \"beta1\"\n\t\t//\t\t- revision: Number: The Git rev from which dojo was pulled\n\n\t\tmajor: 1, minor: 12, patch: 2, flag: \"\",\n\t\trevision: rev ? rev[0] : NaN,\n\t\ttoString: function(){\n\t\t\tvar v = dojo.version;\n\t\t\treturn v.major + \".\" + v.minor + \".\" + v.patch + v.flag + \" (\" + v.revision + \")\";\t// String\n\t\t}\n\t};\n\n\t// If has(\"extend-dojo\") is truthy, then as a dojo module is defined it should push it's definitions\n\t// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object\n\t// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code\n\t// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.\n\thas.add(\"extend-dojo\", 1);\n\n\tif(!has(\"csp-restrictions\")){\n\t\t(Function(\"d\", \"d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}\"))(dojo);\n\t}\n\t/*=====\n\tdojo.eval = function(scriptText){\n\t\t// summary:\n\t\t//\t\tA legacy method created for use exclusively by internal Dojo methods. Do not use this method\n\t\t//\t\tdirectly unless you understand its possibly-different implications on the platforms your are targeting.\n\t\t// description:\n\t\t//\t\tMakes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers\n\t\t//\t\tthat support indirect eval.\n\t\t//\n\t\t//\t\tAs usual, IE does not. On IE, the only way to implement global eval is to\n\t\t//\t\tuse execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.\n\t\t//\t\tThis implementation uses the technique of executing eval in the scope of a function that is a single scope\n\t\t//\t\tframe below the global scope; thereby coming close to the global scope. Note carefully that\n\t\t//\n\t\t//\t\tdojo.eval(\"var pi = 3.14;\");\n\t\t//\n\t\t//\t\twill define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want\n\t\t//\t\tto define a global variable using dojo.eval, write something like\n\t\t//\n\t\t//\t\tdojo.eval(\"window.pi = 3.14;\")\n\t\t// scriptText:\n\t\t//\t\tThe text to evaluation.\n\t\t// returns:\n\t\t//\t\tThe result of the evaluation. Often `undefined`\n\t};\n\t=====*/\n\n\n\tif(has(\"host-rhino\")){\n\t\tdojo.exit = function(exitcode){\n\t\t\tquit(exitcode);\n\t\t};\n\t}else{\n\t\tdojo.exit = function(){\n\t\t};\n\t}\n\n\tif(!has(\"host-webworker\")){\n\t\t// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100\n\t\thas.add(\"dojo-guarantee-console\",\n\t\t\t// ensure that console.log, console.warn, etc. are defined\n\t\t\t1\n\t\t);\n\t}\n\n\tif(has(\"dojo-guarantee-console\")){\n\t\t// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197\n\t\thas.add(\"console-as-object\", function () {\n\t\t\treturn Function.prototype.bind && console && typeof console.log === \"object\";\n\t\t});\n\n\t\ttypeof console != \"undefined\" || (console = {});  // intentional assignment\n\t\t//\tBe careful to leave 'log' always at the end\n\t\tvar cn = [\n\t\t\t\"assert\", \"count\", \"debug\", \"dir\", \"dirxml\", \"error\", \"group\",\n\t\t\t\"groupEnd\", \"info\", \"profile\", \"profileEnd\", \"time\", \"timeEnd\",\n\t\t\t\"trace\", \"warn\", \"log\"\n\t\t];\n\t\tvar tn;\n\t\ti = 0;\n\t\twhile((tn = cn[i++])){\n\t\t\tif(!console[tn]){\n\t\t\t\t(function(){\n\t\t\t\t\tvar tcn = tn + \"\";\n\t\t\t\t\tconsole[tcn] = ('log' in console) ? function(){\n\t\t\t\t\t\tvar a = Array.prototype.slice.call(arguments);\n\t\t\t\t\t\ta.unshift(tcn + \":\");\n\t\t\t\t\t\tconsole[\"log\"](a.join(\" \"));\n\t\t\t\t\t} : function(){};\n\t\t\t\t\tconsole[tcn]._fake = true;\n\t\t\t\t})();\n\t\t\t}else if(has(\"console-as-object\")){\n\t\t\t\tconsole[tn] = Function.prototype.bind.call(console[tn], console);\n\t\t\t}\n\t\t}\n\t}\n\n\thas.add(\"dojo-debug-messages\",\n\t\t// include dojo.deprecated/dojo.experimental implementations\n\t\t!!config.isDebug\n\t);\n\tdojo.deprecated = dojo.experimental =  function(){};\n\tif(has(\"dojo-debug-messages\")){\n\t\tdojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){\n\t\t\t// summary:\n\t\t\t//\t\tLog a debug message to indicate that a behavior has been\n\t\t\t//\t\tdeprecated.\n\t\t\t// behaviour: String\n\t\t\t//\t\tThe API or behavior being deprecated. Usually in the form\n\t\t\t//\t\tof \"myApp.someFunction()\".\n\t\t\t// extra: String?\n\t\t\t//\t\tText to append to the message. Often provides advice on a\n\t\t\t//\t\tnew function or facility to achieve the same goal during\n\t\t\t//\t\tthe deprecation period.\n\t\t\t// removal: String?\n\t\t\t//\t\tText to indicate when in the future the behavior will be\n\t\t\t//\t\tremoved. Usually a version number.\n\t\t\t// example:\n\t\t\t//\t| dojo.deprecated(\"myApp.getTemp()\", \"use myApp.getLocaleTemp() instead\", \"1.0\");\n\n\t\t\tvar message = \"DEPRECATED: \" + behaviour;\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\t\t\tconsole.warn(message);\n\t\t};\n\n\t\tdojo.experimental = function(/* String */ moduleName, /* String? */ extra){\n\t\t\t// summary:\n\t\t\t//\t\tMarks code as experimental.\n\t\t\t// description:\n\t\t\t//\t\tThis can be used to mark a function, file, or module as\n\t\t\t//\t\texperimental.\t Experimental code is not ready to be used, and the\n\t\t\t//\t\tAPIs are subject to change without notice.\tExperimental code may be\n\t\t\t//\t\tcompleted deleted without going through the normal deprecation\n\t\t\t//\t\tprocess.\n\t\t\t// moduleName: String\n\t\t\t//\t\tThe name of a module, or the name of a module file or a specific\n\t\t\t//\t\tfunction\n\t\t\t// extra: String?\n\t\t\t//\t\tsome additional message for the user\n\t\t\t// example:\n\t\t\t//\t| dojo.experimental(\"dojo.data.Result\");\n\t\t\t// example:\n\t\t\t//\t| dojo.experimental(\"dojo.weather.toKelvin()\", \"PENDING approval from NOAA\");\n\n\t\t\tvar message = \"EXPERIMENTAL: \" + moduleName + \" -- APIs subject to change without notice.\";\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tconsole.warn(message);\n\t\t};\n\t}\n\n\thas.add(\"dojo-modulePaths\",\n\t\t// consume dojo.modulePaths processing\n\t\t1\n\t);\n\tif(has(\"dojo-modulePaths\")){\n\t\t// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;\n\t\t// this is the v1.6- behavior.\n\t\tif(config.modulePaths){\n\t\t\tdojo.deprecated(\"dojo.modulePaths\", \"use paths configuration\");\n\t\t\tvar paths = {};\n\t\t\tfor(p in config.modulePaths){\n\t\t\t\tpaths[p.replace(/\\./g, \"/\")] = config.modulePaths[p];\n\t\t\t}\n\t\t\trequire({paths:paths});\n\t\t}\n\t}\n\n\thas.add(\"dojo-moduleUrl\",\n\t\t// include dojo.moduleUrl\n\t\t1\n\t);\n\tif(has(\"dojo-moduleUrl\")){\n\t\tdojo.moduleUrl = function(/*String*/module, /*String?*/url){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a URL relative to a module.\n\t\t\t// example:\n\t\t\t//\t|\tvar pngPath = dojo.moduleUrl(\"acme\",\"images/small.png\");\n\t\t\t//\t|\tconsole.dir(pngPath); // list the object properties\n\t\t\t//\t|\t// create an image and set it's source to pngPath's value:\n\t\t\t//\t|\tvar img = document.createElement(\"img\");\n\t\t\t//\t|\timg.src = pngPath;\n\t\t\t//\t|\t// add our image to the document\n\t\t\t//\t|\tdojo.body().appendChild(img);\n\t\t\t// example:\n\t\t\t//\t\tyou may de-reference as far as you like down the package\n\t\t\t//\t\thierarchy.  This is sometimes handy to avoid lengthy relative\n\t\t\t//\t\turls or for building portable sub-packages. In this example,\n\t\t\t//\t\tthe `acme.widget` and `acme.util` directories may be located\n\t\t\t//\t\tunder different roots (see `dojo.registerModulePath`) but the\n\t\t\t//\t\tthe modules which reference them can be unaware of their\n\t\t\t//\t\trelative locations on the filesystem:\n\t\t\t//\t|\t// somewhere in a configuration block\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.widget\", \"../../acme/widget\");\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.util\", \"../../util\");\n\t\t\t//\t|\n\t\t\t//\t|\t// ...\n\t\t\t//\t|\n\t\t\t//\t|\t// code in a module using acme resources\n\t\t\t//\t|\tvar tmpltPath = dojo.moduleUrl(\"acme.widget\",\"templates/template.html\");\n\t\t\t//\t|\tvar dataPath = dojo.moduleUrl(\"acme.util\",\"resources/data.json\");\n\n\t\t\tdojo.deprecated(\"dojo.moduleUrl()\", \"use require.toUrl\", \"2.0\");\n\n\t\t\t// require.toUrl requires a filetype; therefore, just append the suffix \"/*.*\" to guarantee a filetype, then\n\t\t\t// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be\n\t\t\t// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).\n\t\t\t// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.\n\t\t\tvar result = null;\n\t\t\tif(module){\n\t\t\t\tresult = require.toUrl(module.replace(/\\./g, \"/\") + (url ? (\"/\" + url) : \"\") + \"/*.*\").replace(/\\/\\*\\.\\*/, \"\") + (url ? \"\" : \"/\");\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tdojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling\n\n\treturn dojo;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./libs/dojo/_base/kernel.js?");

/***/ }),

/***/ "./libs/dojo/_base/lang.js":
/*!*********************************!*\
  !*** ./libs/dojo/_base/lang.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./libs/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./libs/dojo/has.js\"), __webpack_require__(/*! ../sniff */ \"./libs/dojo/sniff.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has){\n\t// module:\n\t//\t\tdojo/_base/lang\n\n\thas.add(\"bug-for-in-skips-shadowed\", function(){\n\t\t// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)\n\t\tfor(var i in {toString: 1}){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t});\n\n\t// Helper methods\n\tvar _extraNames =\n\t\t\thas(\"bug-for-in-skips-shadowed\") ?\n\t\t\t\t\"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor\".split(\".\") : [],\n\n\t\t_extraLen = _extraNames.length,\n\n\t\tgetProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){\n\t\t\tif(!context){\n\t\t\t\tif(parts[0] && dojo.scopeMap[parts[0]]) {\n\t\t\t\t\t// Voodoo code from the old days where \"dojo\" or \"dijit\" maps to some special object\n\t\t\t\t\t// rather than just window.dojo\n\t\t\t\t\tcontext = dojo.scopeMap[parts.shift()][1];\n\t\t\t\t}else{\n\t\t\t\t\tcontext = dojo.global;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < parts.length; i++){\n\t\t\t\t\tvar p = parts[i];\n\t\t\t\t\tif(!(p in context)){\n\t\t\t\t\t\tif(create){\n\t\t\t\t\t\t\tcontext[p] = {};\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn;\t\t// return undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontext = context[p];\n\t\t\t\t}\n\t\t\t\treturn context; // mixed\n\t\t\t}catch(e){\n\t\t\t\t// \"p in context\" throws an exception when context is a number, boolean, etc. rather than an object,\n\t\t\t\t// so in that corner case just return undefined (by having no return statement)\n\t\t\t}\n\t\t},\n\n\t\topts = Object.prototype.toString,\n\n\t\tefficient = function(obj, offset, startWith){\n\t\t\treturn (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));\n\t\t},\n\n\t\t_pattern = /\\{([^\\}]+)\\}/g;\n\n\t// Module export\n\tvar lang = {\n\t\t// summary:\n\t\t//\t\tThis module defines Javascript language extensions.\n\n\t\t// _extraNames: String[]\n\t\t//\t\tLists property names that must be explicitly processed during for-in iteration\n\t\t//\t\tin environments that have has(\"bug-for-in-skips-shadowed\") true.\n\t\t_extraNames:_extraNames,\n\n\t\t_mixin: function(dest, source, copyFunc){\n\t\t\t// summary:\n\t\t\t//\t\tCopies/adds all properties of source to dest; returns dest.\n\t\t\t// dest: Object\n\t\t\t//\t\tThe object to which to copy/add all properties contained in source.\n\t\t\t// source: Object\n\t\t\t//\t\tThe object from which to draw all properties to copy into dest.\n\t\t\t// copyFunc: Function?\n\t\t\t//\t\tThe process used to copy/add a property in source; defaults to the Javascript assignment operator.\n\t\t\t// returns:\n\t\t\t//\t\tdest, as modified\n\t\t\t// description:\n\t\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\t//\t\tfound in Object.prototype, are copied/added to dest. Copying/adding each particular property is\n\t\t\t//\t\tdelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\n\t\t\t//\t\tNotice that by default, _mixin executes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t\t\tvar name, s, i, empty = {};\n\t\t\tfor(name in source){\n\t\t\t\t// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n\t\t\t\t// inherited from Object.prototype.\t For example, if dest has a custom toString() method,\n\t\t\t\t// don't overwrite it with the toString() method that source inherited from Object.prototype\n\t\t\t\ts = source[name];\n\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\t\tif(source){\n\t\t\t\t\tfor(i = 0; i < _extraLen; ++i){\n\t\t\t\t\t\tname = _extraNames[i];\n\t\t\t\t\t\ts = source[name];\n\t\t\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tmixin: function(dest, sources){\n\t\t\t// summary:\n\t\t\t//\t\tCopies/adds all properties of one or more sources to dest; returns dest.\n\t\t\t// dest: Object\n\t\t\t//\t\tThe object to which to copy/add all properties contained in source. If dest is falsy, then\n\t\t\t//\t\ta new object is manufactured before copying/adding properties begins.\n\t\t\t// sources: Object...\n\t\t\t//\t\tOne of more objects from which to draw all properties to copy into dest. sources are processed\n\t\t\t//\t\tleft-to-right and if more than one of these objects contain the same property name, the right-most\n\t\t\t//\t\tvalue \"wins\".\n\t\t\t// returns: Object\n\t\t\t//\t\tdest, as modified\n\t\t\t// description:\n\t\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\t//\t\tfound in Object.prototype, are copied/added from sources to dest. sources are processed left to right.\n\t\t\t//\t\tThe Javascript assignment operator is used to copy/add each property; therefore, by default, mixin\n\t\t\t//\t\texecutes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t\t\t// example:\n\t\t\t//\t\tmake a shallow copy of an object\n\t\t\t//\t|\tvar copy = lang.mixin({}, source);\n\t\t\t// example:\n\t\t\t//\t\tmany class constructors often take an object which specifies\n\t\t\t//\t\tvalues to be configured on the object. In this case, it is\n\t\t\t//\t\toften simplest to call `lang.mixin` on the `this` object:\n\t\t\t//\t|\tdeclare(\"acme.Base\", null, {\n\t\t\t//\t|\t\tconstructor: function(properties){\n\t\t\t//\t|\t\t\t// property configuration:\n\t\t\t//\t|\t\t\tlang.mixin(this, properties);\n\t\t\t//\t|\n\t\t\t//\t|\t\t\tconsole.log(this.quip);\n\t\t\t//\t|\t\t\t//\t...\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\tquip: \"I wasn't born yesterday, you know - I've seen movies.\",\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\n\t\t\t//\t|\t// create an instance of the class and configure it\n\t\t\t//\t|\tvar b = new acme.Base({quip: \"That's what it does!\" });\n\t\t\t// example:\n\t\t\t//\t\tcopy in properties from multiple objects\n\t\t\t//\t|\tvar flattened = lang.mixin(\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tname: \"Frylock\",\n\t\t\t//\t|\t\t\tbraces: true\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tname: \"Carl Brutanananadilewski\"\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t);\n\t\t\t//\t|\n\t\t\t//\t|\t// will print \"Carl Brutanananadilewski\"\n\t\t\t//\t|\tconsole.log(flattened.name);\n\t\t\t//\t|\t// will print \"true\"\n\t\t\t//\t|\tconsole.log(flattened.braces);\n\n\t\t\tif(!dest){ dest = {}; }\n\t\t\tfor(var i = 1, l = arguments.length; i < l; i++){\n\t\t\t\tlang._mixin(dest, arguments[i]);\n\t\t\t}\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tsetObject: function(name, value, context){\n\t\t\t// summary:\n\t\t\t//\t\tSet a property from a dot-separated string, such as \"A.B.C\"\n\t\t\t// description:\n\t\t\t//\t\tUseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain, or when you have an object reference in string format.\n\t\t\t//\t\tObjects are created as needed along `path`. Returns the passed\n\t\t\t//\t\tvalue if setting is successful or `undefined` if not.\n\t\t\t// name: String\n\t\t\t//\t\tPath to a property, in the form \"A.B.C\".\n\t\t\t// value: anything\n\t\t\t//\t\tvalue or object to place at location given by name\n\t\t\t// context: Object?\n\t\t\t//\t\tOptional. Object to use as root of path. Defaults to\n\t\t\t//\t\t`dojo.global`.\n\t\t\t// example:\n\t\t\t//\t\tset the value of `foo.bar.baz`, regardless of whether\n\t\t\t//\t\tintermediate objects already exist:\n\t\t\t//\t| lang.setObject(\"foo.bar.baz\", value);\n\t\t\t// example:\n\t\t\t//\t\twithout `lang.setObject`, we often see code like this:\n\t\t\t//\t| // ensure that intermediate objects are available\n\t\t\t//\t| if(!obj[\"parent\"]){ obj.parent = {}; }\n\t\t\t//\t| if(!obj.parent[\"child\"]){ obj.parent.child = {}; }\n\t\t\t//\t| // now we can safely set the property\n\t\t\t//\t| obj.parent.child.prop = \"some value\";\n\t\t\t//\t\twhereas with `lang.setObject`, we can shorten that to:\n\t\t\t//\t| lang.setObject(\"parent.child.prop\", \"some value\", obj);\n\n\t\t\tvar parts = name.split(\".\"), p = parts.pop(), obj = getProp(parts, true, context);\n\t\t\treturn obj && p ? (obj[p] = value) : undefined; // Object\n\t\t},\n\n\t\tgetObject: function(name, create, context){\n\t\t\t// summary:\n\t\t\t//\t\tGet a property from a dot-separated string, such as \"A.B.C\"\n\t\t\t// description:\n\t\t\t//\t\tUseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain, or when you have an object reference in string format.\n\t\t\t// name: String\n\t\t\t//\t\tPath to an property, in the form \"A.B.C\".\n\t\t\t// create: Boolean?\n\t\t\t//\t\tOptional. Defaults to `false`. If `true`, Objects will be\n\t\t\t//\t\tcreated at any point along the 'path' that is undefined.\n\t\t\t// context: Object?\n\t\t\t//\t\tOptional. Object to use as root of path. Defaults to\n\t\t\t//\t\t'dojo.global'. Null may be passed.\n\t\t\treturn !name ? context : getProp(name.split(\".\"), create, context); // Object\n\t\t},\n\n\t\texists: function(name, obj){\n\t\t\t// summary:\n\t\t\t//\t\tdetermine if an object supports a given method\n\t\t\t// description:\n\t\t\t//\t\tuseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain. Useful for object and method detection.\n\t\t\t// name: String\n\t\t\t//\t\tPath to an object, in the form \"A.B.C\".\n\t\t\t// obj: Object?\n\t\t\t//\t\tObject to use as root of path. Defaults to\n\t\t\t//\t\t'dojo.global'. Null may be passed.\n\t\t\t// example:\n\t\t\t//\t| // define an object\n\t\t\t//\t| var foo = {\n\t\t\t//\t|\t\tbar: { }\n\t\t\t//\t| };\n\t\t\t//\t|\n\t\t\t//\t| // search the global scope\n\t\t\t//\t| lang.exists(\"foo.bar\"); // true\n\t\t\t//\t| lang.exists(\"foo.bar.baz\"); // false\n\t\t\t//\t|\n\t\t\t//\t| // search from a particular scope\n\t\t\t//\t| lang.exists(\"bar\", foo); // true\n\t\t\t//\t| lang.exists(\"bar.baz\", foo); // false\n\t\t\treturn lang.getObject(name, false, obj) !== undefined; // Boolean\n\t\t},\n\n\t\t// Crockford (ish) functions\n\n\t\tisString: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is a String\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn (typeof it == \"string\" || it instanceof String); // Boolean\n\t\t},\n\n\t\tisArray: Array.isArray || function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is an Array.\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn opts.call(it) == \"[object Array]\"; // Boolean\n\t\t},\n\n\t\tisFunction: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is a Function\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn opts.call(it) === \"[object Function]\";\n\t\t},\n\n\t\tisObject: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturns true if it is a JavaScript object (or an Array, a Function\n\t\t\t//\t\tor null)\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn it !== undefined &&\n\t\t\t\t(it === null || typeof it == \"object\" || lang.isArray(it) || lang.isFunction(it)); // Boolean\n\t\t},\n\n\t\tisArrayLike: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tsimilar to isArray() but more permissive\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\t// returns:\n\t\t\t//\t\tIf it walks like a duck and quacks like a duck, return `true`\n\t\t\t// description:\n\t\t\t//\t\tDoesn't strongly test for \"arrayness\".  Instead, settles for \"isn't\n\t\t\t//\t\ta string or number and has a length property\". Arguments objects\n\t\t\t//\t\tand DOM collections will return true when passed to\n\t\t\t//\t\tisArrayLike(), but will return false when passed to\n\t\t\t//\t\tisArray().\n\t\t\treturn !!it && // Boolean\n\t\t\t\t// keep out built-in constructors (Number, String, ...) which have length\n\t\t\t\t// properties\n\t\t\t\t!lang.isString(it) && !lang.isFunction(it) &&\n\t\t\t\t!(it.tagName && it.tagName.toLowerCase() == 'form') &&\n\t\t\t\t(lang.isArray(it) || isFinite(it.length));\n\t\t},\n\n\t\tisAlien: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturns true if it is a built-in function or some other kind of\n\t\t\t//\t\toddball that *should* report as a function but doesn't\n\t\t\treturn it && !lang.isFunction(it) && /\\{\\s*\\[native code\\]\\s*\\}/.test(String(it)); // Boolean\n\t\t},\n\n\t\textend: function(ctor, props){\n\t\t\t// summary:\n\t\t\t//\t\tAdds all properties and methods of props to constructor's\n\t\t\t//\t\tprototype, making them available to all instances created with\n\t\t\t//\t\tconstructor.\n\t\t\t// ctor: Object\n\t\t\t//\t\tTarget constructor to extend.\n\t\t\t// props: Object\n\t\t\t//\t\tOne or more objects to mix into ctor.prototype\n\t\t\tfor(var i=1, l=arguments.length; i<l; i++){\n\t\t\t\tlang._mixin(ctor.prototype, arguments[i]);\n\t\t\t}\n\t\t\treturn ctor; // Object\n\t\t},\n\n\t\t_hitchArgs: function(scope, method){\n\t\t\tvar pre = lang._toArray(arguments, 2);\n\t\t\tvar named = lang.isString(method);\n\t\t\treturn function(){\n\t\t\t\t// arrayify arguments\n\t\t\t\tvar args = lang._toArray(arguments);\n\t\t\t\t// locate our method\n\t\t\t\tvar f = named ? (scope||dojo.global)[method] : method;\n\t\t\t\t// invoke with collected args\n\t\t\t\treturn f && f.apply(scope || this, pre.concat(args)); // mixed\n\t\t\t}; // Function\n\t\t},\n\n\t\thitch: function(scope, method){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a function that will only ever execute in the given scope.\n\t\t\t//\t\tThis allows for easy use of object member functions\n\t\t\t//\t\tin callbacks and other places in which the \"this\" keyword may\n\t\t\t//\t\totherwise not reference the expected scope.\n\t\t\t//\t\tAny number of default positional arguments may be passed as parameters\n\t\t\t//\t\tbeyond \"method\".\n\t\t\t//\t\tEach of these values will be used to \"placehold\" (similar to curry)\n\t\t\t//\t\tfor the hitched function.\n\t\t\t// scope: Object\n\t\t\t//\t\tThe scope to use when method executes. If method is a string,\n\t\t\t//\t\tscope is also the object containing method.\n\t\t\t// method: Function|String...\n\t\t\t//\t\tA function to be hitched to scope, or the name of the method in\n\t\t\t//\t\tscope to be hitched.\n\t\t\t// example:\n\t\t\t//\t|\tlang.hitch(foo, \"bar\")();\n\t\t\t//\t\truns foo.bar() in the scope of foo\n\t\t\t// example:\n\t\t\t//\t|\tlang.hitch(foo, myFunction);\n\t\t\t//\t\treturns a function that runs myFunction in the scope of foo\n\t\t\t// example:\n\t\t\t//\t\tExpansion on the default positional arguments passed along from\n\t\t\t//\t\thitch. Passed args are mixed first, additional args after.\n\t\t\t//\t|\tvar foo = { bar: function(a, b, c){ console.log(a, b, c); } };\n\t\t\t//\t|\tvar fn = lang.hitch(foo, \"bar\", 1, 2);\n\t\t\t//\t|\tfn(3); // logs \"1, 2, 3\"\n\t\t\t// example:\n\t\t\t//\t|\tvar foo = { bar: 2 };\n\t\t\t//\t|\tlang.hitch(foo, function(){ this.bar = 10; })();\n\t\t\t//\t\texecute an anonymous function in scope of foo\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn lang._hitchArgs.apply(dojo, arguments); // Function\n\t\t\t}\n\t\t\tif(!method){\n\t\t\t\tmethod = scope;\n\t\t\t\tscope = null;\n\t\t\t}\n\t\t\tif(lang.isString(method)){\n\t\t\t\tscope = scope || dojo.global;\n\t\t\t\tif(!scope[method]){ throw(['lang.hitch: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\t\treturn function(){ return scope[method].apply(scope, arguments || []); }; // Function\n\t\t\t}\n\t\t\treturn !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function\n\t\t},\n\n\t\tdelegate: (function(){\n\t\t\t// boodman/crockford delegation w/ cornford optimization\n\t\t\tfunction TMP(){}\n\t\t\treturn function(obj, props){\n\t\t\t\tTMP.prototype = obj;\n\t\t\t\tvar tmp = new TMP();\n\t\t\t\tTMP.prototype = null;\n\t\t\t\tif(props){\n\t\t\t\t\tlang._mixin(tmp, props);\n\t\t\t\t}\n\t\t\t\treturn tmp; // Object\n\t\t\t};\n\t\t})(),\n\t\t/*=====\n\t\tdelegate: function(obj, props){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new object which \"looks\" to obj for properties which it\n\t\t\t//\t\tdoes not have a value for. Optionally takes a bag of properties to\n\t\t\t//\t\tseed the returned object with initially.\n\t\t\t// description:\n\t\t\t//\t\tThis is a small implementation of the Boodman/Crockford delegation\n\t\t\t//\t\tpattern in JavaScript. An intermediate object constructor mediates\n\t\t\t//\t\tthe prototype chain for the returned object, using it to delegate\n\t\t\t//\t\tdown to obj for property lookup when object-local lookup fails.\n\t\t\t//\t\tThis can be thought of similarly to ES4's \"wrap\", save that it does\n\t\t\t//\t\tnot act on types but rather on pure objects.\n\t\t\t// obj: Object\n\t\t\t//\t\tThe object to delegate to for properties not found directly on the\n\t\t\t//\t\treturn object or in props.\n\t\t\t// props: Object...\n\t\t\t//\t\tan object containing properties to assign to the returned object\n\t\t\t// returns:\n\t\t\t//\t\tan Object of anonymous type\n\t\t\t// example:\n\t\t\t//\t|\tvar foo = { bar: \"baz\" };\n\t\t\t//\t|\tvar thinger = lang.delegate(foo, { thud: \"xyzzy\"});\n\t\t\t//\t|\tthinger.bar == \"baz\"; // delegated to foo\n\t\t\t//\t|\tfoo.thud == undefined; // by definition\n\t\t\t//\t|\tthinger.thud == \"xyzzy\"; // mixed in from props\n\t\t\t//\t|\tfoo.bar = \"thonk\";\n\t\t\t//\t|\tthinger.bar == \"thonk\"; // still delegated to foo's bar\n\t\t},\n\t\t=====*/\n\n\t\t_toArray: has(\"ie\") ?\n\t\t\t(function(){\n\t\t\t\tfunction slow(obj, offset, startWith){\n\t\t\t\t\tvar arr = startWith||[];\n\t\t\t\t\tfor(var x = offset || 0; x < obj.length; x++){\n\t\t\t\t\t\tarr.push(obj[x]);\n\t\t\t\t\t}\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t\treturn function(obj){\n\t\t\t\t\treturn ((obj.item) ? slow : efficient).apply(this, arguments);\n\t\t\t\t};\n\t\t\t})() : efficient,\n\t\t/*=====\n\t\t _toArray: function(obj, offset, startWith){\n\t\t\t // summary:\n\t\t\t //\t\tConverts an array-like object (i.e. arguments, DOMCollection) to an\n\t\t\t //\t\tarray. Returns a new Array with the elements of obj.\n\t\t\t // obj: Object\n\t\t\t //\t\tthe object to \"arrayify\". We expect the object to have, at a\n\t\t\t //\t\tminimum, a length property which corresponds to integer-indexed\n\t\t\t //\t\tproperties.\n\t\t\t // offset: Number?\n\t\t\t //\t\tthe location in obj to start iterating from. Defaults to 0.\n\t\t\t //\t\tOptional.\n\t\t\t // startWith: Array?\n\t\t\t //\t\tAn array to pack with the properties of obj. If provided,\n\t\t\t //\t\tproperties in obj are appended at the end of startWith and\n\t\t\t //\t\tstartWith is the returned array.\n\t\t },\n\t\t =====*/\n\n\t\tpartial: function(/*Function|String*/ method /*, ...*/){\n\t\t\t// summary:\n\t\t\t//\t\tsimilar to hitch() except that the scope object is left to be\n\t\t\t//\t\twhatever the execution context eventually becomes.\n\t\t\t// description:\n\t\t\t//\t\tCalling lang.partial is the functional equivalent of calling:\n\t\t\t//\t\t|\tlang.hitch(null, funcName, ...);\n\t\t\t// method:\n\t\t\t//\t\tThe function to \"wrap\"\n\t\t\tvar arr = [ null ];\n\t\t\treturn lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function\n\t\t},\n\n\t\tclone: function(/*anything*/ src){\n\t\t\t// summary:\n\t\t\t//\t\tClones objects (including DOM nodes) and all children.\n\t\t\t//\t\tWarning: do not clone cyclic structures.\n\t\t\t// src:\n\t\t\t//\t\tThe object to clone\n\t\t\tif(!src || typeof src != \"object\" || lang.isFunction(src)){\n\t\t\t\t// null, undefined, any non-object, or function\n\t\t\t\treturn src;\t// anything\n\t\t\t}\n\t\t\tif(src.nodeType && \"cloneNode\" in src){\n\t\t\t\t// DOM Node\n\t\t\t\treturn src.cloneNode(true); // Node\n\t\t\t}\n\t\t\tif(src instanceof Date){\n\t\t\t\t// Date\n\t\t\t\treturn new Date(src.getTime());\t// Date\n\t\t\t}\n\t\t\tif(src instanceof RegExp){\n\t\t\t\t// RegExp\n\t\t\t\treturn new RegExp(src);   // RegExp\n\t\t\t}\n\t\t\tvar r, i, l;\n\t\t\tif(lang.isArray(src)){\n\t\t\t\t// array\n\t\t\t\tr = [];\n\t\t\t\tfor(i = 0, l = src.length; i < l; ++i){\n\t\t\t\t\tif(i in src){\n\t\t\t\t\t\tr[i] = lang.clone(src[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// we don't clone functions for performance reasons\n\t\t\t\t//\t\t}else if(d.isFunction(src)){\n\t\t\t\t//\t\t\t// function\n\t\t\t\t//\t\t\tr = function(){ return src.apply(this, arguments); };\n\t\t\t}else{\n\t\t\t\t// generic objects\n\t\t\t\tr = src.constructor ? new src.constructor() : {};\n\t\t\t}\n\t\t\treturn lang._mixin(r, src, lang.clone);\n\t\t},\n\n\n\t\ttrim: String.prototype.trim ?\n\t\t\tfunction(str){ return str.trim(); } :\n\t\t\tfunction(str){ return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); },\n\t\t/*=====\n\t\t trim: function(str){\n\t\t\t // summary:\n\t\t\t //\t\tTrims whitespace from both sides of the string\n\t\t\t // str: String\n\t\t\t //\t\tString to be trimmed\n\t\t\t // returns: String\n\t\t\t //\t\tReturns the trimmed string\n\t\t\t // description:\n\t\t\t //\t\tThis version of trim() was selected for inclusion into the base due\n\t\t\t //\t\tto its compact size and relatively good performance\n\t\t\t //\t\t(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)\n\t\t\t //\t\tUses String.prototype.trim instead, if available.\n\t\t\t //\t\tThe fastest but longest version of this function is located at\n\t\t\t //\t\tlang.string.trim()\n\t\t },\n\t\t =====*/\n\n\t\treplace: function(tmpl, map, pattern){\n\t\t\t// summary:\n\t\t\t//\t\tPerforms parameterized substitutions on a string. Throws an\n\t\t\t//\t\texception if any parameter is unmatched.\n\t\t\t// tmpl: String\n\t\t\t//\t\tString to be used as a template.\n\t\t\t// map: Object|Function\n\t\t\t//\t\tIf an object, it is used as a dictionary to look up substitutions.\n\t\t\t//\t\tIf a function, it is called for every substitution with following parameters:\n\t\t\t//\t\ta whole match, a name, an offset, and the whole template\n\t\t\t//\t\tstring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace\n\t\t\t//\t\tfor more details).\n\t\t\t// pattern: RegEx?\n\t\t\t//\t\tOptional regular expression objects that overrides the default pattern.\n\t\t\t//\t\tMust be global and match one item. The default is: /\\{([^\\}]+)\\}/g,\n\t\t\t//\t\twhich matches patterns like that: \"{xxx}\", where \"xxx\" is any sequence\n\t\t\t//\t\tof characters, which doesn't include \"}\".\n\t\t\t// returns: String\n\t\t\t//\t\tReturns the substituted string.\n\t\t\t// example:\n\t\t\t//\t|\t// uses a dictionary for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, {name.first} {name.last} AKA {nick}!\",\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tnick: \"Bob\",\n\t\t\t//\t|\t\t\tname: {\n\t\t\t//\t|\t\t\t\tfirst:\t\"Robert\",\n\t\t\t//\t|\t\t\t\tmiddle: \"X\",\n\t\t\t//\t|\t\t\t\tlast:\t\t\"Cringely\"\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t});\n\t\t\t//\t|\t// returns: Hello, Robert Cringely AKA Bob!\n\t\t\t// example:\n\t\t\t//\t|\t// uses an array for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, {0} {2}!\",\n\t\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"]);\n\t\t\t//\t|\t// returns: Hello, Robert Cringely!\n\t\t\t// example:\n\t\t\t//\t|\t// uses a function for substitutions:\n\t\t\t//\t|\tfunction sum(a){\n\t\t\t//\t|\t\tvar t = 0;\n\t\t\t//\t|\t\tarrayforEach(a, function(x){ t += x; });\n\t\t\t//\t|\t\treturn t;\n\t\t\t//\t|\t}\n\t\t\t//\t|\tlang.replace(\n\t\t\t//\t|\t\t\"{count} payments averaging {avg} USD per payment.\",\n\t\t\t//\t|\t\tlang.hitch(\n\t\t\t//\t|\t\t\t{ payments: [11, 16, 12] },\n\t\t\t//\t|\t\t\tfunction(_, key){\n\t\t\t//\t|\t\t\t\tswitch(key){\n\t\t\t//\t|\t\t\t\t\tcase \"count\": return this.payments.length;\n\t\t\t//\t|\t\t\t\t\tcase \"min\":\t\treturn Math.min.apply(Math, this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"max\":\t\treturn Math.max.apply(Math, this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"sum\":\t\treturn sum(this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"avg\":\t\treturn sum(this.payments) / this.payments.length;\n\t\t\t//\t|\t\t\t\t}\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t)\n\t\t\t//\t|\t);\n\t\t\t//\t|\t// prints: 3 payments averaging 13 USD per payment.\n\t\t\t// example:\n\t\t\t//\t|\t// uses an alternative PHP-like pattern for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, ${0} ${2}!\",\n\t\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"], /\\$\\{([^\\}]+)\\}/g);\n\t\t\t//\t|\t// returns: Hello, Robert Cringely!\n\n\t\t\treturn tmpl.replace(pattern || _pattern, lang.isFunction(map) ?\n\t\t\t\tmap : function(_, k){ return lang.getObject(k, false, map); });\n\t\t}\n\t};\n\n\thas(\"extend-dojo\") && lang.mixin(dojo, lang);\n\n\treturn lang;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./libs/dojo/_base/lang.js?");

/***/ }),

/***/ "./libs/dojo/date/stamp.js":
/*!*********************************!*\
  !*** ./libs/dojo/date/stamp.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ \"./libs/dojo/_base/lang.js\"), __webpack_require__(/*! ../_base/array */ \"./libs/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, array){\n\n// module:\n//\t\tdojo/date/stamp\n\nvar stamp = {\n\t// summary:\n\t//\t\tTODOC\n};\nlang.setObject(\"dojo.date.stamp\", stamp);\n\n// Methods to convert dates to or from a wire (string) format using well-known conventions\n\nstamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){\n\t// summary:\n\t//\t\tReturns a Date object given a string formatted according to a subset of the ISO-8601 standard.\n\t//\n\t// description:\n\t//\t\tAccepts a string formatted according to a profile of ISO8601 as defined by\n\t//\t\t[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.\n\t//\t\tCan also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)\n\t//\t\tThe following combinations are valid:\n\t//\n\t//\t\t- dates only\n\t//\t\t\t- yyyy\n\t//\t\t\t- yyyy-MM\n\t//\t\t\t- yyyy-MM-dd\n\t//\t\t- times only, with an optional time zone appended\n\t//\t\t\t- THH:mm\n\t//\t\t\t- THH:mm:ss\n\t//\t\t\t- THH:mm:ss.SSS\n\t//\t\t- and \"datetimes\" which could be any combination of the above\n\t//\n\t//\t\ttimezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm\n\t//\t\tAssumes the local time zone if not specified.  Does not validate.  Improperly formatted\n\t//\t\tinput may return null.  Arguments which are out of bounds will be handled\n\t//\t\tby the Date constructor (e.g. January 32nd typically gets resolved to February 1st)\n\t//\t\tOnly years between 100 and 9999 are supported.\n  \t// formattedString:\n\t//\t\tA string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00\n\t// defaultTime:\n\t//\t\tUsed for defaults for fields omitted in the formattedString.\n\t//\t\tUses 1970-01-01T00:00:00.0Z by default.\n\n\tif(!stamp._isoRegExp){\n\t\tstamp._isoRegExp =\n//TODO: could be more restrictive and check for 00-59, etc.\n\t\t\t/^(?:(\\d{4})(?:-(\\d{2})(?:-(\\d{2}))?)?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(.\\d+)?)?((?:[+-](\\d{2}):(\\d{2}))|Z)?)?$/;\n\t}\n\n\tvar match = stamp._isoRegExp.exec(formattedString),\n\t\tresult = null;\n\n\tif(match){\n\t\tmatch.shift();\n\t\tif(match[1]){match[1]--;} // Javascript Date months are 0-based\n\t\tif(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds\n\n\t\tif(defaultTime){\n\t\t\t// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0\n\t\t\tdefaultTime = new Date(defaultTime);\n\t\t\tarray.forEach(array.map([\"FullYear\", \"Month\", \"Date\", \"Hours\", \"Minutes\", \"Seconds\", \"Milliseconds\"], function(prop){\n\t\t\t\treturn defaultTime[\"get\" + prop]();\n\t\t\t}), function(value, index){\n\t\t\t\tmatch[index] = match[index] || value;\n\t\t\t});\n\t\t}\n\t\tresult = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults\n\t\tif(match[0] < 100){\n\t\t\tresult.setFullYear(match[0] || 1970);\n\t\t}\n\n\t\tvar offset = 0,\n\t\t\tzoneSign = match[7] && match[7].charAt(0);\n\t\tif(zoneSign != 'Z'){\n\t\t\toffset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);\n\t\t\tif(zoneSign != '-'){ offset *= -1; }\n\t\t}\n\t\tif(zoneSign){\n\t\t\toffset -= result.getTimezoneOffset();\n\t\t}\n\t\tif(offset){\n\t\t\tresult.setTime(result.getTime() + offset * 60000);\n\t\t}\n\t}\n\n\treturn result; // Date or null\n};\n\n/*=====\nvar __Options = {\n\t// selector: String\n\t//\t\t\"date\" or \"time\" for partial formatting of the Date object.\n\t//\t\tBoth date and time will be formatted by default.\n\t// zulu: Boolean\n\t//\t\tif true, UTC/GMT is used for a timezone\n\t// milliseconds: Boolean\n\t//\t\tif true, output milliseconds\n};\n=====*/\n\nstamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){\n\t// summary:\n\t//\t\tFormat a Date object as a string according a subset of the ISO-8601 standard\n\t//\n\t// description:\n\t//\t\tWhen options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)\n\t//\t\tThe local time zone is included as an offset from GMT, except when selector=='time' (time without a date)\n\t//\t\tDoes not check bounds.  Only years between 100 and 9999 are supported.\n\t//\n\t// dateObject:\n\t//\t\tA Date object\n\n\tvar _ = function(n){ return (n < 10) ? \"0\" + n : n; };\n\toptions = options || {};\n\tvar formattedDate = [],\n\t\tgetter = options.zulu ? \"getUTC\" : \"get\",\n\t\tdate = \"\";\n\tif(options.selector != \"time\"){\n\t\tvar year = dateObject[getter+\"FullYear\"]();\n\t\tdate = [\"0000\".substr((year+\"\").length)+year, _(dateObject[getter+\"Month\"]()+1), _(dateObject[getter+\"Date\"]())].join('-');\n\t}\n\tformattedDate.push(date);\n\tif(options.selector != \"date\"){\n\t\tvar time = [_(dateObject[getter+\"Hours\"]()), _(dateObject[getter+\"Minutes\"]()), _(dateObject[getter+\"Seconds\"]())].join(':');\n\t\tvar millis = dateObject[getter+\"Milliseconds\"]();\n\t\tif(options.milliseconds){\n\t\t\ttime += \".\"+ (millis < 100 ? \"0\" : \"\") + _(millis);\n\t\t}\n\t\tif(options.zulu){\n\t\t\ttime += \"Z\";\n\t\t}else if(options.selector != \"time\"){\n\t\t\tvar timezoneOffset = dateObject.getTimezoneOffset();\n\t\t\tvar absOffset = Math.abs(timezoneOffset);\n\t\t\ttime += (timezoneOffset > 0 ? \"-\" : \"+\") +\n\t\t\t\t_(Math.floor(absOffset/60)) + \":\" + _(absOffset%60);\n\t\t}\n\t\tformattedDate.push(time);\n\t}\n\treturn formattedDate.join('T'); // String\n};\n\nreturn stamp;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./libs/dojo/date/stamp.js?");

/***/ }),

/***/ "./libs/dojo/has.js":
/*!**************************!*\
  !*** ./libs/dojo/has.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(require, module){\n\t// module:\n\t//\t\tdojo/has\n\t// summary:\n\t//\t\tDefines the has.js API and several feature tests used by dojo.\n\t// description:\n\t//\t\tThis module defines the has API as described by the project has.js with the following additional features:\n\t//\n\t//\t\t- the has test cache is exposed at has.cache.\n\t//\t\t- the method has.add includes a forth parameter that controls whether or not existing tests are replaced\n\t//\t\t- the loader's has cache may be optionally copied into this module's has cahce.\n\t//\n\t//\t\tThis module adopted from https://github.com/phiggins42/has.js; thanks has.js team!\n\n\t// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one\n\t// if using a foreign loader, then the has cache may be initialized via the config object for this module\n\t// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail\n\tvar has = require.has || function(){};\n\tif(!has(\"dojo-has-api\")){\n\t\tvar\n\t\t\tisBrowser =\n\t\t\t\t// the most fundamental decision: are we in the browser?\n\t\t\t\ttypeof window != \"undefined\" &&\n\t\t\t\ttypeof location != \"undefined\" &&\n\t\t\t\ttypeof document != \"undefined\" &&\n\t\t\t\twindow.location == location && window.document == document,\n\n\t\t\t// has API variables\n\t\t\tglobal = (function () { return this; })(),\n\t\t\tdoc = isBrowser && document,\n\t\t\telement = doc && doc.createElement(\"DiV\"),\n\t\t\tcache = (module.config && module.config()) || {};\n\n\t\thas = function(name){\n\t\t\t// summary:\n\t\t\t//\t\tReturn the current value of the named feature.\n\t\t\t//\n\t\t\t// name: String|Integer\n\t\t\t//\t\tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t//\n\t\t\t// description:\n\t\t\t//\t\tReturns the value of the feature named by name. The feature must have been\n\t\t\t//\t\tpreviously added to the cache by has.add.\n\n\t\t\treturn typeof cache[name] == \"function\" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean\n\t\t};\n\n\t\thas.cache = cache;\n\n\t\thas.add = function(name, test, now, force){\n\t\t\t// summary:\n\t\t\t//\t \tRegister a new feature test for some named feature.\n\t\t\t// name: String|Integer\n\t\t\t//\t \tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t// test: Function\n\t\t\t//\t\t A test function to register. If a function, queued for testing until actually\n\t\t\t//\t\t needed. The test function should return a boolean indicating\n\t\t\t//\t \tthe presence of a feature or bug.\n\t\t\t// now: Boolean?\n\t\t\t//\t\t Optional. Omit if `test` is not a function. Provides a way to immediately\n\t\t\t//\t\t run the test and cache the result.\n\t\t\t// force: Boolean?\n\t\t\t//\t \tOptional. If the test already exists and force is truthy, then the existing\n\t\t\t//\t \ttest will be replaced; otherwise, add does not replace an existing test (that\n\t\t\t//\t \tis, by default, the first test advice wins).\n\t\t\t// example:\n\t\t\t//\t\tA redundant test, testFn with immediate execution:\n\t\t\t//\t|\thas.add(\"javascript\", function(){ return true; }, true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAgain with the redundantness. You can do this in your tests, but we should\n\t\t\t//\t\tnot be doing this in any internal has.js tests\n\t\t\t//\t|\thas.add(\"javascript\", true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tThree things are passed to the testFunction. `global`, `document`, and a generic element\n\t\t\t//\t\tfrom which to work your test should the need arise.\n\t\t\t//\t|\thas.add(\"bug-byid\", function(g, d, el){\n\t\t\t//\t|\t\t// g\t== global, typically window, yadda yadda\n\t\t\t//\t|\t\t// d\t== document object\n\t\t\t//\t|\t\t// el == the generic element. a `has` element.\n\t\t\t//\t|\t\treturn false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer\n\t\t\t//\t|\t});\n\n\t\t\t(typeof cache[name]==\"undefined\" || force) && (cache[name]= test);\n\t\t\treturn now && has(name);\n\t\t};\n\n\t\t// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize\n\t\t// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder\n\t\t// can optimize these away iff desired\n\t\thas.add(\"host-browser\", isBrowser);\n\t\thas.add(\"host-node\", (typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\t\thas.add(\"host-rhino\", (typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\t\thas.add(\"dom\", isBrowser);\n\t\thas.add(\"dojo-dom-ready-api\", 1);\n\t\thas.add(\"dojo-sniff\", 1);\n\t}\n\n\tif(has(\"host-browser\")){\n\t\t// Common application level tests\n\t\thas.add(\"dom-addeventlistener\", !!document.addEventListener);\n\n\t\t// Do the device and browser have touch capability?\n\t\thas.add(\"touch\", \"ontouchstart\" in document\n\t\t\t|| (\"onpointerdown\" in document && navigator.maxTouchPoints > 0)\n\t\t\t|| window.navigator.msMaxTouchPoints);\n\n\t\t// Touch events support\n\t\thas.add(\"touch-events\", \"ontouchstart\" in document);\n\n\t\t// Test if pointer events are supported and enabled, with either standard names (\"pointerdown\" etc.) or\n\t\t// IE specific names (\"MSPointerDown\" etc.).  Tests are designed to work on embedded C# WebBrowser Controls\n\t\t// in addition to IE, Edge, and future versions of Firefox and Chrome.\n\t\t// Note that on IE11, has(\"pointer-events\") and has(\"MSPointer\") are both true.\n\t\thas.add(\"pointer-events\", \"pointerEnabled\" in window.navigator ?\n\t\t\t\twindow.navigator.pointerEnabled : \"PointerEvent\" in window);\n\t\thas.add(\"MSPointer\", window.navigator.msPointerEnabled);\n\t\t// The \"pointermove\"\" event is only continuously emitted in a touch environment if\n\t\t// the target node's \"touch-action\"\" CSS property is set to \"none\"\n\t\t// https://www.w3.org/TR/pointerevents/#the-touch-action-css-property\n\t\thas.add(\"touch-action\", has(\"touch\") && has(\"pointer-events\"));\n\n\t\t// I don't know if any of these tests are really correct, just a rough guess\n\t\thas.add(\"device-width\", screen.availWidth || innerWidth);\n\n\t\t// Tests for DOMNode.attributes[] behavior:\n\t\t//\t - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes\n\t\t//\t - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify\n\t\t//\t - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.\n\t\tvar form = document.createElement(\"form\");\n\t\thas.add(\"dom-attributes-explicit\", form.attributes.length == 0); // W3C\n\t\thas.add(\"dom-attributes-specified-flag\", form.attributes.length > 0 && form.attributes.length < 40);\t// IE8\n\t}\n\n\thas.clearElement = function(element){\n\t\t// summary:\n\t\t//\t Deletes the contents of the element passed to test functions.\n\t\telement.innerHTML= \"\";\n\t\treturn element;\n\t};\n\n\thas.normalize = function(id, toAbsMid){\n\t\t// summary:\n\t\t//\t Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).\n\t\t//\n\t\t// toAbsMid: Function\n\t\t//\t Resolves a relative module id into an absolute module id\n\t\tvar\n\t\t\ttokens = id.match(/[\\?:]|[^:\\?]*/g), i = 0,\n\t\t\tget = function(skip){\n\t\t\t\tvar term = tokens[i++];\n\t\t\t\tif(term == \":\"){\n\t\t\t\t\t// empty string module name, resolves to 0\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\t\t\tif(tokens[i++] == \"?\"){\n\t\t\t\t\t\tif(!skip && has(term)){\n\t\t\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\t\t\treturn get();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\t\t\tget(true);\n\t\t\t\t\t\t\treturn get(skip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// a module\n\t\t\t\t\treturn term || 0;\n\t\t\t\t}\n\t\t\t};\n\t\tid = get();\n\t\treturn id && toAbsMid(id);\n\t};\n\n\thas.load = function(id, parentRequire, loaded){\n\t\t// summary:\n\t\t//\t\tConditional loading of AMD modules based on a has feature test value.\n\t\t// id: String\n\t\t//\t\tGives the resolved module id to load.\n\t\t// parentRequire: Function\n\t\t//\t\tThe loader require function with respect to the module that contained the plugin resource in it's\n\t\t//\t\tdependency list.\n\t\t// loaded: Function\n\t\t//\t Callback to loader that consumes result of plugin demand.\n\n\t\tif(id){\n\t\t\tparentRequire([id], loaded);\n\t\t}else{\n\t\t\tloaded();\n\t\t}\n\t};\n\n\treturn has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./libs/dojo/has.js?");

/***/ }),

/***/ "./libs/dojo/sniff.js":
/*!****************************!*\
  !*** ./libs/dojo/sniff.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ \"./libs/dojo/has.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has){\n\t// module:\n\t//\t\tdojo/sniff\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tThis module sets has() flags based on the current browser.\n\t\t//\t\tIt returns the has() function.\n\t};\n\t=====*/\n\n\tif(has(\"host-browser\")){\n\t\tvar n = navigator,\n\t\t\tdua = n.userAgent,\n\t\t\tdav = n.appVersion,\n\t\t\ttv = parseFloat(dav);\n\t\thas.add(\"air\", dua.indexOf(\"AdobeAIR\") >= 0);\n\t\thas.add(\"wp\", parseFloat(dua.split(\"Windows Phone\")[1]) || undefined);\n\t\thas.add(\"msapp\", parseFloat(dua.split(\"MSAppHost/\")[1]) || undefined);\n\t\thas.add(\"khtml\", dav.indexOf(\"Konqueror\") >= 0 ? tv : undefined);\n\t\thas.add(\"edge\", parseFloat(dua.split(\"Edge/\")[1]) || undefined);\n\t\thas.add(\"opr\", parseFloat(dua.split(\"OPR/\")[1]) || undefined);\n\t\t// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/\n\t\thas.add(\"webkit\", !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540\n\t\t\t&& !has(\"edge\") && parseFloat(dua.split(\"WebKit/\")[1]) || undefined);\n\t\thas.add(\"chrome\", !has(\"edge\") && !has(\"opr\")\n\t\t\t\t&& parseFloat(dua.split(\"Chrome/\")[1]) || undefined);\n\t\thas.add(\"android\", !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528\n\t\t\t\t&& parseFloat(dua.split(\"Android \")[1]) || undefined);\n\t\thas.add(\"safari\", dav.indexOf(\"Safari\") >= 0\n\t\t\t\t&& !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540\n\t\t\t\t&& !has(\"chrome\") && !has(\"android\") && !has(\"edge\") && !has(\"opr\") ?\n\t\t\tparseFloat(dav.split(\"Version/\")[1]) : undefined);\n\t\thas.add(\"mac\", dav.indexOf(\"Macintosh\") >= 0);\n\t\thas.add(\"quirks\", document.compatMode == \"BackCompat\");\n\t\tif(!has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528\n\t\t\t\t&& dua.match(/(iPhone|iPod|iPad)/)){\n\t\t\tvar p = RegExp.$1.replace(/P/, \"p\");\n\t\t\tvar v = dua.match(/OS ([\\d_]+)/) ? RegExp.$1 : \"1\";\n\t\t\tvar os = parseFloat(v.replace(/_/, \".\").replace(/_/g, \"\"));\n\t\t\thas.add(p, os);\t\t// \"iphone\", \"ipad\" or \"ipod\"\n\t\t\thas.add(\"ios\", os);\n\t\t}\n\t\thas.add(\"bb\", (dua.indexOf(\"BlackBerry\") >= 0 || dua.indexOf(\"BB10\") >= 0) && parseFloat(dua.split(\"Version/\")[1]) || undefined);\n\t\thas.add(\"trident\", parseFloat(dav.split(\"Trident/\")[1]) || undefined);\n\n\t\thas.add(\"svg\", typeof SVGAngle !== \"undefined\");\n\n\t\tif(!has(\"webkit\")){\n\t\t\t// Opera\n\t\t\tif(dua.indexOf(\"Opera\") >= 0){\n\t\t\t\t// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/\n\t\t\t\t// 9.8 has both styles; <9.8, 9.9 only old style\n\t\t\t\thas.add(\"opera\", tv >= 9.8 ? parseFloat(dua.split(\"Version/\")[1]) || tv : tv);\n\t\t\t}\n\n\t\t\t// Mozilla and firefox\n\t\t\tif(dua.indexOf(\"Gecko\") >= 0 && !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1\n\t\t\t\t\t&& !has(\"khtml\") && !has(\"trident\") && !has(\"edge\")){\n\t\t\t\thas.add(\"mozilla\", tv);\n\t\t\t}\n\t\t\tif(has(\"mozilla\")){\n\t\t\t\t//We really need to get away from this. Consider a sane isGecko approach for the future.\n\t\t\t\thas.add(\"ff\", parseFloat(dua.split(\"Firefox/\")[1] || dua.split(\"Minefield/\")[1]) || undefined);\n\t\t\t}\n\n\t\t\t// IE\n\t\t\tif(document.all && !has(\"opera\")){\n\t\t\t\tvar isIE = parseFloat(dav.split(\"MSIE \")[1]) || undefined;\n\n\t\t\t\t//In cases where the page has an HTTP header or META tag with\n\t\t\t\t//X-UA-Compatible, then it is in emulation mode.\n\t\t\t\t//Make sure isIE reflects the desired version.\n\t\t\t\t//document.documentMode of 5 means quirks mode.\n\t\t\t\t//Only switch the value if documentMode's major version\n\t\t\t\t//is different from isIE's major version.\n\t\t\t\tvar mode = document.documentMode;\n\t\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\t\tisIE = mode;\n\t\t\t\t}\n\n\t\t\t\thas.add(\"ie\", isIE);\n\t\t\t}\n\n\t\t\t// Wii\n\t\t\thas.add(\"wii\", typeof opera != \"undefined\" && opera.wiiremote);\n\t\t}\n\t}\n\n\treturn has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./libs/dojo/sniff.js?");

/***/ }),

/***/ "./node_modules/blueimp-md5/js/md5.js":
/*!********************************************!*\
  !*** ./node_modules/blueimp-md5/js/md5.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;/*\n * JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\n\n/* global define */\n\n;(function ($) {\n  'use strict'\n\n  /*\n  * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n  * to work around bugs in some JS interpreters.\n  */\n  function safeAdd (x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff)\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)\n    return (msw << 16) | (lsw & 0xffff)\n  }\n\n  /*\n  * Bitwise rotate a 32-bit number to the left.\n  */\n  function bitRotateLeft (num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt))\n  }\n\n  /*\n  * These functions implement the four basic operations the algorithm uses.\n  */\n  function md5cmn (q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)\n  }\n  function md5ff (a, b, c, d, x, s, t) {\n    return md5cmn((b & c) | (~b & d), a, b, x, s, t)\n  }\n  function md5gg (a, b, c, d, x, s, t) {\n    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)\n  }\n  function md5hh (a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t)\n  }\n  function md5ii (a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t)\n  }\n\n  /*\n  * Calculate the MD5 of an array of little-endian words, and a bit length.\n  */\n  function binlMD5 (x, len) {\n    /* append padding */\n    x[len >> 5] |= 0x80 << (len % 32)\n    x[((len + 64) >>> 9 << 4) + 14] = len\n\n    var i\n    var olda\n    var oldb\n    var oldc\n    var oldd\n    var a = 1732584193\n    var b = -271733879\n    var c = -1732584194\n    var d = 271733878\n\n    for (i = 0; i < x.length; i += 16) {\n      olda = a\n      oldb = b\n      oldc = c\n      oldd = d\n\n      a = md5ff(a, b, c, d, x[i], 7, -680876936)\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)\n\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)\n      b = md5gg(b, c, d, a, x[i], 20, -373897302)\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)\n\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)\n      d = md5hh(d, a, b, c, x[i], 11, -358537222)\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)\n\n      a = md5ii(a, b, c, d, x[i], 6, -198630844)\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)\n\n      a = safeAdd(a, olda)\n      b = safeAdd(b, oldb)\n      c = safeAdd(c, oldc)\n      d = safeAdd(d, oldd)\n    }\n    return [a, b, c, d]\n  }\n\n  /*\n  * Convert an array of little-endian words to a string\n  */\n  function binl2rstr (input) {\n    var i\n    var output = ''\n    var length32 = input.length * 32\n    for (i = 0; i < length32; i += 8) {\n      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff)\n    }\n    return output\n  }\n\n  /*\n  * Convert a raw string to an array of little-endian words\n  * Characters >255 have their high-byte silently ignored.\n  */\n  function rstr2binl (input) {\n    var i\n    var output = []\n    output[(input.length >> 2) - 1] = undefined\n    for (i = 0; i < output.length; i += 1) {\n      output[i] = 0\n    }\n    var length8 = input.length * 8\n    for (i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32)\n    }\n    return output\n  }\n\n  /*\n  * Calculate the MD5 of a raw string\n  */\n  function rstrMD5 (s) {\n    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))\n  }\n\n  /*\n  * Calculate the HMAC-MD5, of a key and some data (raw strings)\n  */\n  function rstrHMACMD5 (key, data) {\n    var i\n    var bkey = rstr2binl(key)\n    var ipad = []\n    var opad = []\n    var hash\n    ipad[15] = opad[15] = undefined\n    if (bkey.length > 16) {\n      bkey = binlMD5(bkey, key.length * 8)\n    }\n    for (i = 0; i < 16; i += 1) {\n      ipad[i] = bkey[i] ^ 0x36363636\n      opad[i] = bkey[i] ^ 0x5c5c5c5c\n    }\n    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)\n    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))\n  }\n\n  /*\n  * Convert a raw string to a hex string\n  */\n  function rstr2hex (input) {\n    var hexTab = '0123456789abcdef'\n    var output = ''\n    var x\n    var i\n    for (i = 0; i < input.length; i += 1) {\n      x = input.charCodeAt(i)\n      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)\n    }\n    return output\n  }\n\n  /*\n  * Encode a string as utf-8\n  */\n  function str2rstrUTF8 (input) {\n    return unescape(encodeURIComponent(input))\n  }\n\n  /*\n  * Take string arguments and return either raw or hex encoded strings\n  */\n  function rawMD5 (s) {\n    return rstrMD5(str2rstrUTF8(s))\n  }\n  function hexMD5 (s) {\n    return rstr2hex(rawMD5(s))\n  }\n  function rawHMACMD5 (k, d) {\n    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))\n  }\n  function hexHMACMD5 (k, d) {\n    return rstr2hex(rawHMACMD5(k, d))\n  }\n\n  function md5 (string, key, raw) {\n    if (!key) {\n      if (!raw) {\n        return hexMD5(string)\n      }\n      return rawMD5(string)\n    }\n    if (!raw) {\n      return hexHMACMD5(key, string)\n    }\n    return rawHMACMD5(key, string)\n  }\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n      return md5\n    }).call(null, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n  } else {}\n})(this)\n\n\n//# sourceURL=webpack:///./node_modules/blueimp-md5/js/md5.js?");

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (true) {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  var args = [].slice.call(arguments, 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/component-emitter/index.js?");

/***/ }),

/***/ "./node_modules/dojo-webpack-plugin/lib/NoModule.js":
/*!**********************************************************!*\
  !*** ./node_modules/dojo-webpack-plugin/lib/NoModule.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\r\n * (C) Copyright IBM Corp. 2012, 2016 All Rights Reserved.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nmodule.exports = undefined;\r\n\n\n//# sourceURL=webpack:///./node_modules/dojo-webpack-plugin/lib/NoModule.js?");

/***/ }),

/***/ "./node_modules/dojo/Deferred.js":
/*!***************************************!*\
  !*** ./node_modules/dojo/Deferred.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ./has */ \"./node_modules/dojo/has.js\"),\n\t__webpack_require__(/*! ./_base/lang */ \"./node_modules/dojo/_base/lang.js\"),\n\t__webpack_require__(/*! ./errors/CancelError */ \"./node_modules/dojo/errors/CancelError.js\"),\n\t__webpack_require__(/*! ./promise/Promise */ \"./node_modules/dojo/promise/Promise.js\"),\n\t__webpack_require__(/*! ./promise/instrumentation */ \"./node_modules/dojo/promise/instrumentation.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has, lang, CancelError, Promise, instrumentation){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/Deferred\n\n\tvar PROGRESS = 0,\n\t\t\tRESOLVED = 1,\n\t\t\tREJECTED = 2;\n\tvar FULFILLED_ERROR_MESSAGE = \"This deferred has already been fulfilled.\";\n\n\tvar freezeObject = Object.freeze || function(){};\n\n\tvar signalWaiting = function(waiting, type, result, rejection, deferred){\n\t\tif(has(\"config-deferredInstrumentation\")){\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected && waiting.length === 0){\n\t\t\t\tDeferred.instrumentRejected(result, false, rejection, deferred);\n\t\t\t}\n\t\t}\n\n\t\tfor(var i = 0; i < waiting.length; i++){\n\t\t\tsignalListener(waiting[i], type, result, rejection);\n\t\t}\n\t};\n\n\tvar signalListener = function(listener, type, result, rejection){\n\t\tvar func = listener[type];\n\t\tvar deferred = listener.deferred;\n\t\tif(func){\n\t\t\ttry{\n\t\t\t\tvar newResult = func(result);\n\t\t\t\tif(type === PROGRESS){\n\t\t\t\t\tif(typeof newResult !== \"undefined\"){\n\t\t\t\t\t\tsignalDeferred(deferred, type, newResult);\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tif(newResult && typeof newResult.then === \"function\"){\n\t\t\t\t\t\tlistener.cancel = newResult.cancel;\n\t\t\t\t\t\tnewResult.then(\n\t\t\t\t\t\t\t\t// Only make resolvers if they're actually going to be used\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, RESOLVED),\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, REJECTED),\n\t\t\t\t\t\t\t\tmakeDeferredSignaler(deferred, PROGRESS));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tsignalDeferred(deferred, RESOLVED, newResult);\n\t\t\t\t}\n\t\t\t}catch(error){\n\t\t\t\tsignalDeferred(deferred, REJECTED, error);\n\t\t\t}\n\t\t}else{\n\t\t\tsignalDeferred(deferred, type, result);\n\t\t}\n\n\t\tif(has(\"config-deferredInstrumentation\")){\n\t\t\tif(type === REJECTED && Deferred.instrumentRejected){\n\t\t\t\tDeferred.instrumentRejected(result, !!func, rejection, deferred.promise);\n\t\t\t}\n\t\t}\n\t};\n\n\tvar makeDeferredSignaler = function(deferred, type){\n\t\treturn function(value){\n\t\t\tsignalDeferred(deferred, type, value);\n\t\t};\n\t};\n\n\tvar signalDeferred = function(deferred, type, result){\n\t\tif(!deferred.isCanceled()){\n\t\t\tswitch(type){\n\t\t\t\tcase PROGRESS:\n\t\t\t\t\tdeferred.progress(result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase RESOLVED:\n\t\t\t\t\tdeferred.resolve(result);\n\t\t\t\t\tbreak;\n\t\t\t\tcase REJECTED:\n\t\t\t\t\tdeferred.reject(result);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t};\n\n\tvar Deferred = function(canceler){\n\t\t// summary:\n\t\t//\t\tCreates a new deferred. This API is preferred over\n\t\t//\t\t`dojo/_base/Deferred`.\n\t\t// description:\n\t\t//\t\tCreates a new deferred, as an abstraction over (primarily)\n\t\t//\t\tasynchronous operations. The deferred is the private interface\n\t\t//\t\tthat should not be returned to calling code. That's what the\n\t\t//\t\t`promise` is for. See `dojo/promise/Promise`.\n\t\t// canceler: Function?\n\t\t//\t\tWill be invoked if the deferred is canceled. The canceler\n\t\t//\t\treceives the reason the deferred was canceled as its argument.\n\t\t//\t\tThe deferred is rejected with its return value, or a new\n\t\t//\t\t`dojo/errors/CancelError` instance.\n\n\t\t// promise: dojo/promise/Promise\n\t\t//\t\tThe public promise object that clients can add callbacks to. \n\t\tvar promise = this.promise = new Promise();\n\n\t\tvar deferred = this;\n\t\tvar fulfilled, result, rejection;\n\t\tvar canceled = false;\n\t\tvar waiting = [];\n\n\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n\t\t\tError.captureStackTrace(deferred, Deferred);\n\t\t\tError.captureStackTrace(promise, Deferred);\n\t\t}\n\n\t\tthis.isResolved = promise.isResolved = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been resolved.\n\t\t\t// returns: Boolean\n\n\t\t\treturn fulfilled === RESOLVED;\n\t\t};\n\n\t\tthis.isRejected = promise.isRejected = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been rejected.\n\t\t\t// returns: Boolean\n\n\t\t\treturn fulfilled === REJECTED;\n\t\t};\n\n\t\tthis.isFulfilled = promise.isFulfilled = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been resolved or rejected.\n\t\t\t// returns: Boolean\n\n\t\t\treturn !!fulfilled;\n\t\t};\n\n\t\tthis.isCanceled = promise.isCanceled = function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the deferred has been canceled.\n\t\t\t// returns: Boolean\n\n\t\t\treturn canceled;\n\t\t};\n\n\t\tthis.progress = function(update, strict){\n\t\t\t// summary:\n\t\t\t//\t\tEmit a progress update on the deferred.\n\t\t\t// description:\n\t\t\t//\t\tEmit a progress update on the deferred. Progress updates\n\t\t\t//\t\tcan be used to communicate updates about the asynchronous\n\t\t\t//\t\toperation before it has finished.\n\t\t\t// update: any\n\t\t\t//\t\tThe progress update. Passed to progbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently no progress can be emitted.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\tsignalWaiting(waiting, PROGRESS, update, null, deferred);\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tthis.resolve = function(value, strict){\n\t\t\t// summary:\n\t\t\t//\t\tResolve the deferred.\n\t\t\t// description:\n\t\t\t//\t\tResolve the deferred, putting it in a success state.\n\t\t\t// value: any\n\t\t\t//\t\tThe result of the deferred. Passed to callbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be resolved.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\t// Set fulfilled, store value. After signaling waiting listeners unset\n\t\t\t\t// waiting.\n\t\t\t\tsignalWaiting(waiting, fulfilled = RESOLVED, result = value, null, deferred);\n\t\t\t\twaiting = null;\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tvar reject = this.reject = function(error, strict){\n\t\t\t// summary:\n\t\t\t//\t\tReject the deferred.\n\t\t\t// description:\n\t\t\t//\t\tReject the deferred, putting it in an error state.\n\t\t\t// error: any\n\t\t\t//\t\tThe error result of the deferred. Passed to errbacks.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be rejected.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns the original promise for the deferred.\n\n\t\t\tif(!fulfilled){\n\t\t\t\tif(has(\"config-deferredInstrumentation\") && Error.captureStackTrace){\n\t\t\t\t\tError.captureStackTrace(rejection = {}, reject);\n\t\t\t\t}\n\t\t\t\tsignalWaiting(waiting, fulfilled = REJECTED, result = error, rejection, deferred);\n\t\t\t\twaiting = null;\n\t\t\t\treturn promise;\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}else{\n\t\t\t\treturn promise;\n\t\t\t}\n\t\t};\n\n\t\tthis.then = promise.then = function(callback, errback, progback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new callbacks to the deferred.\n\t\t\t// description:\n\t\t\t//\t\tAdd new callbacks to the deferred. Callbacks can be added\n\t\t\t//\t\tbefore or after the deferred is fulfilled.\n\t\t\t// callback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is resolved.\n\t\t\t//\t\tReceives the resolution value.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t//\t\tReceives the rejection error.\n\t\t\t// progback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise emits a progress\n\t\t\t//\t\tupdate. Receives the progress update.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback(s).\n\t\t\t//\t\tThis can be used for chaining many asynchronous operations.\n\n\t\t\tvar listener = [progback, callback, errback];\n\t\t\t// Ensure we cancel the promise we're waiting for, or if callback/errback\n\t\t\t// have returned a promise, cancel that one.\n\t\t\tlistener.cancel = promise.cancel;\n\t\t\tlistener.deferred = new Deferred(function(reason){\n\t\t\t\t// Check whether cancel is really available, returned promises are not\n\t\t\t\t// required to expose `cancel`\n\t\t\t\treturn listener.cancel && listener.cancel(reason);\n\t\t\t});\n\t\t\tif(fulfilled && !waiting){\n\t\t\t\tsignalListener(listener, fulfilled, result, rejection);\n\t\t\t}else{\n\t\t\t\twaiting.push(listener);\n\t\t\t}\n\t\t\treturn listener.deferred.promise;\n\t\t};\n\n\t\tthis.cancel = promise.cancel = function(reason, strict){\n\t\t\t// summary:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t// description:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t//\t\tThe deferred's (optional) canceler is invoked and the\n\t\t\t//\t\tdeferred will be left in a rejected state. Can affect other\n\t\t\t//\t\tpromises that originate with the same deferred.\n\t\t\t// reason: any\n\t\t\t//\t\tA message that may be sent to the deferred's canceler,\n\t\t\t//\t\texplaining why it's being canceled.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be canceled.\n\t\t\t// returns: any\n\t\t\t//\t\tReturns the rejection reason if the deferred was canceled\n\t\t\t//\t\tnormally.\n\n\t\t\tif(!fulfilled){\n\t\t\t\t// Cancel can be called even after the deferred is fulfilled\n\t\t\t\tif(canceler){\n\t\t\t\t\tvar returnedReason = canceler(reason);\n\t\t\t\t\treason = typeof returnedReason === \"undefined\" ? reason : returnedReason;\n\t\t\t\t}\n\t\t\t\tcanceled = true;\n\t\t\t\tif(!fulfilled){\n\t\t\t\t\t// Allow canceler to provide its own reason, but fall back to a CancelError\n\t\t\t\t\tif(typeof reason === \"undefined\"){\n\t\t\t\t\t\treason = new CancelError();\n\t\t\t\t\t}\n\t\t\t\t\treject(reason);\n\t\t\t\t\treturn reason;\n\t\t\t\t}else if(fulfilled === REJECTED && result === reason){\n\t\t\t\t\treturn reason;\n\t\t\t\t}\n\t\t\t}else if(strict === true){\n\t\t\t\tthrow new Error(FULFILLED_ERROR_MESSAGE);\n\t\t\t}\n\t\t};\n\n\t\tfreezeObject(promise);\n\t};\n\n\tDeferred.prototype.toString = function(){\n\t\t// returns: String\n\t\t//\t\tReturns `[object Deferred]`.\n\n\t\treturn \"[object Deferred]\";\n\t};\n\n\tif(instrumentation){\n\t\tinstrumentation(Deferred);\n\t}\n\n\treturn Deferred;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/Deferred.js?");

/***/ }),

/***/ "./node_modules/dojo/Evented.js":
/*!**************************************!*\
  !*** ./node_modules/dojo/Evented.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./aspect */ \"./node_modules/dojo/aspect.js\"), __webpack_require__(/*! ./on */ \"./node_modules/dojo/on.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, on){\n\t// module:\n\t//\t\tdojo/Evented\n\n \t\"use strict\";\n \tvar after = aspect.after;\n\tfunction Evented(){\n\t\t// summary:\n\t\t//\t\tA class that can be used as a mixin or base class,\n\t\t//\t\tto add on() and emit() methods to a class\n\t\t//\t\tfor listening for events and emitting events:\n\t\t// example:\n\t\t//\t\t|\tdefine([\"dojo/Evented\", \"dojo/_base/declare\", \"dojo/Stateful\"\n\t\t//\t\t|\t], function(Evented, declare, Stateful){\n\t\t//\t\t|\t\tvar EventedStateful = declare([Evented, Stateful], {...});\n\t\t//\t\t|\t\tvar instance = new EventedStateful();\n\t\t//\t\t|\t\tinstance.on(\"open\", function(event){\n\t\t//\t\t|\t\t... do something with event\n\t\t//\t\t|\t });\n\t\t//\t\t|\n\t\t//\t\t|\tinstance.emit(\"open\", {name:\"some event\", ...});\n\t}\n\tEvented.prototype = {\n\t\ton: function(type, listener){\n\t\t\treturn on.parse(this, type, listener, function(target, type){\n\t\t\t\treturn after(target, 'on' + type, listener, true);\n\t\t\t});\n\t\t},\n\t\temit: function(type, event){\n\t\t\tvar args = [this];\n\t\t\targs.push.apply(args, arguments);\n\t\t\treturn on.emit.apply(on, args);\n\t\t}\n\t};\n\treturn Evented;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/Evented.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/array.js":
/*!******************************************!*\
  !*** ./node_modules/dojo/_base/array.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ./lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has, lang){\n\t// module:\n\t//\t\tdojo/_base/array\n\n\t// our old simple function builder stuff\n\tvar cache = {}, u;\n\n\tfunction buildFn(fn){\n\t\treturn cache[fn] = new Function(\"item\", \"index\", \"array\", fn); // Function\n\t}\n\t// magic snippet: if(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\n\t// every & some\n\n\tfunction everyOrSome(some){\n\t\tvar every = !some;\n\t\treturn function(a, fn, o){\n\t\t\tvar i = 0, l = a && a.length || 0, result;\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tif(typeof fn == \"string\") fn = cache[fn] || buildFn(fn);\n\t\t\tif(o){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn.call(o, a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tresult = !fn(a[i], i, a);\n\t\t\t\t\tif(some ^ result){\n\t\t\t\t\t\treturn !result;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn every; // Boolean\n\t\t};\n\t}\n\n\t// indexOf, lastIndexOf\n\n\tfunction index(up){\n\t\tvar delta = 1, lOver = 0, uOver = 0;\n\t\tif(!up){\n\t\t\tdelta = lOver = uOver = -1;\n\t\t}\n\t\treturn function(a, x, from, last){\n\t\t\tif(last && delta > 0){\n\t\t\t\t// TODO: why do we use a non-standard signature? why do we need \"last\"?\n\t\t\t\treturn array.lastIndexOf(a, x, from);\n\t\t\t}\n\t\t\tvar l = a && a.length || 0, end = up ? l + uOver : lOver, i;\n\t\t\tif(from === u){\n\t\t\t\ti = up ? lOver : l + uOver;\n\t\t\t}else{\n\t\t\t\tif(from < 0){\n\t\t\t\t\ti = l + from;\n\t\t\t\t\tif(i < 0){\n\t\t\t\t\t\ti = lOver;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\ti = from >= l ? l + uOver : from;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(l && typeof a == \"string\") a = a.split(\"\");\n\t\t\tfor(; i != end; i += delta){\n\t\t\t\tif(a[i] == x){\n\t\t\t\t\treturn i; // Number\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn -1; // Number\n\t\t};\n\t}\n\n\tvar array = {\n\t\t// summary:\n\t\t//\t\tThe Javascript v1.6 array extensions.\n\n\t\tevery: everyOrSome(false),\n\t\t/*=====\n\t\t every: function(arr, callback, thisObject){\n\t\t\t // summary:\n\t\t\t //\t\tDetermines whether or not every item in arr satisfies the\n\t\t\t //\t\tcondition implemented by callback.\n\t\t\t // arr: Array|String\n\t\t\t //\t\tthe array to iterate on. If a string, operates on individual characters.\n\t\t\t // callback: Function|String\n\t\t\t //\t\ta function is invoked with three arguments: item, index,\n\t\t\t //\t\tand array and returns true if the condition is met.\n\t\t\t // thisObject: Object?\n\t\t\t //\t\tmay be used to scope the call to callback\n\t\t\t // returns: Boolean\n\t\t\t // description:\n\t\t\t //\t\tThis function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when\n\t\t\t //\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t //\t\tthe callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.\n\t\t\t //\t\tFor more details, see:\n\t\t\t //\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every\n\t\t\t // example:\n\t\t\t //\t|\t// returns false\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\t // example:\n\t\t\t //\t|\t// returns true\n\t\t\t //\t|\tarray.every([1, 2, 3, 4], function(item){ return item>0; });\n\t\t },\n\t\t =====*/\n\n\t\tsome: everyOrSome(true),\n\t\t/*=====\n\t\tsome: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tDetermines whether or not any item in arr satisfies the\n\t\t\t//\t\tcondition implemented by callback.\n\t\t\t// arr: Array|String\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function is invoked with three arguments: item, index,\n\t\t\t//\t\tand array and returns true if the condition is met.\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Boolean\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some\n\t\t\t// example:\n\t\t\t//\t| // is true\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item>1; });\n\t\t\t// example:\n\t\t\t//\t| // is false\n\t\t\t//\t| array.some([1, 2, 3, 4], function(item){ return item<1; });\n\t\t},\n\t\t=====*/\n\n\t\tindexOf: index(true),\n\t\t/*=====\n\t\tindexOf: function(arr, value, fromIndex, findLast){\n\t\t\t// summary:\n\t\t\t//\t\tlocates the first index of the provided value in the\n\t\t\t//\t\tpassed array. If the value is not found, -1 is returned.\n\t\t\t// description:\n\t\t\t//\t\tThis method corresponds to the JavaScript 1.6 Array.indexOf method, with two differences:\n\t\t\t//\n\t\t\t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\n\t\t\t//\t\t   whereas JavaScript 1.6's indexOf skips the holes in the sparse array.\n\t\t\t//\t\t2. uses equality (==) rather than strict equality (===)\n\t\t\t//\n\t\t\t//\t\tFor details on this method, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf\n\t\t\t// arr: Array\n\t\t\t// value: Object\n\t\t\t// fromIndex: Integer?\n\t\t\t// findLast: Boolean?\n\t\t\t//\t\tMakes indexOf() work like lastIndexOf().  Used internally; not meant for external usage.\n\t\t\t// returns: Number\n\t\t},\n\t\t=====*/\n\n\t\tlastIndexOf: index(false),\n\t\t/*=====\n\t\tlastIndexOf: function(arr, value, fromIndex){\n\t\t\t// summary:\n\t\t\t//\t\tlocates the last index of the provided value in the passed\n\t\t\t//\t\tarray. If the value is not found, -1 is returned.\n\t\t\t// description:\n\t\t \t//\t\tThis method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with two differences:\n\t\t \t//\n\t\t \t//\t\t1. when run over sparse arrays, the Dojo function invokes the callback for every index\n\t\t \t//\t\t   whereas JavaScript 1.6's lasIndexOf skips the holes in the sparse array.\n\t\t \t//\t\t2. uses equality (==) rather than strict equality (===)\n\t\t \t//\n\t\t \t//\t\tFor details on this method, see:\n\t\t \t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf\n\t\t\t// arr: Array,\n\t\t\t// value: Object,\n\t\t\t// fromIndex: Integer?\n\t\t\t// returns: Number\n\t\t},\n\t\t=====*/\n\n\t\tforEach: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tfor every item in arr, callback is invoked. Return values are ignored.\n\t\t\t//\t\tIf you want to break out of the loop, consider using array.every() or array.some().\n\t\t\t//\t\tforEach does not allow breaking out of the loop over the items in arr.\n\t\t\t// arr:\n\t\t\t//\t\tthe array to iterate over. If a string, operates on individual characters.\n\t\t\t// callback:\n\t\t\t//\t\ta function is invoked with three arguments: item, index, and array\n\t\t\t// thisObject:\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach\n\t\t\t// example:\n\t\t\t//\t| // log out all members of the array:\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tfunction(item){\n\t\t\t//\t|\t\t\tconsole.log(item);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| );\n\t\t\t// example:\n\t\t\t//\t| // log out the members and their indexes\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tfunction(item, idx, arr){\n\t\t\t//\t|\t\t\tconsole.log(item, \"at index:\", idx);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| );\n\t\t\t// example:\n\t\t\t//\t| // use a scoped object member as the callback\n\t\t\t//\t|\n\t\t\t//\t| var obj = {\n\t\t\t//\t|\t\tprefix: \"logged via obj.callback:\",\n\t\t\t//\t|\t\tcallback: function(item){\n\t\t\t//\t|\t\t\tconsole.log(this.prefix, item);\n\t\t\t//\t|\t\t}\n\t\t\t//\t| };\n\t\t\t//\t|\n\t\t\t//\t| // specifying the scope function executes the callback in that scope\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tobj.callback,\n\t\t\t//\t|\t\tobj\n\t\t\t//\t| );\n\t\t\t//\t|\n\t\t\t//\t| // alternately, we can accomplish the same thing with lang.hitch()\n\t\t\t//\t| array.forEach(\n\t\t\t//\t|\t\t[ \"thinger\", \"blah\", \"howdy\", 10 ],\n\t\t\t//\t|\t\tlang.hitch(obj, \"callback\")\n\t\t\t//\t| );\n\t\t\t// arr: Array|String\n\t\t\t// callback: Function|String\n\t\t\t// thisObject: Object?\n\n\t\t\tvar i = 0, l = arr && arr.length || 0;\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tcallback.call(thisObject, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tcallback(arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\tmap: function(arr, callback, thisObject, Ctr){\n\t\t\t// summary:\n\t\t\t//\t\tapplies callback to each element of arr and returns\n\t\t\t//\t\tan Array with the results\n\t\t\t// arr: Array|String\n\t\t\t//\t\tthe array to iterate on. If a string, operates on\n\t\t\t//\t\tindividual characters.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function is invoked with three arguments, (item, index,\n\t\t\t//\t\tarray),\t and returns a value\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Array\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\n\t\t\t// example:\n\t\t\t//\t| // returns [2, 3, 4, 5]\n\t\t\t//\t| array.map([1, 2, 3, 4], function(item){ return item+1 });\n\n\t\t\t// TODO: why do we have a non-standard signature here? do we need \"Ctr\"?\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tout[i] = callback.call(thisObject, arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tout[i] = callback(arr[i], i, arr);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out; // Array\n\t\t},\n\n\t\tfilter: function(arr, callback, thisObject){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new Array with those items from arr that match the\n\t\t\t//\t\tcondition implemented by callback.\n\t\t\t// arr: Array\n\t\t\t//\t\tthe array to iterate over.\n\t\t\t// callback: Function|String\n\t\t\t//\t\ta function that is invoked with three arguments (item,\n\t\t\t//\t\tindex, array). The return of this function is expected to\n\t\t\t//\t\tbe a boolean which determines whether the passed-in item\n\t\t\t//\t\twill be included in the returned array.\n\t\t\t// thisObject: Object?\n\t\t\t//\t\tmay be used to scope the call to callback\n\t\t\t// returns: Array\n\t\t\t// description:\n\t\t\t//\t\tThis function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when\n\t\t\t//\t\trun over sparse arrays, this implementation passes the \"holes\" in the sparse array to\n\t\t\t//\t\tthe callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.\n\t\t\t//\t\tFor more details, see:\n\t\t\t//\t\thttps://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\n\t\t\t// example:\n\t\t\t//\t| // returns [2, 3, 4]\n\t\t\t//\t| array.filter([1, 2, 3, 4], function(item){ return item>1; });\n\n\t\t\t// TODO: do we need \"Ctr\" here like in map()?\n\t\t\tvar i = 0, l = arr && arr.length || 0, out = [], value;\n\t\t\tif(l && typeof arr == \"string\") arr = arr.split(\"\");\n\t\t\tif(typeof callback == \"string\") callback = cache[callback] || buildFn(callback);\n\t\t\tif(thisObject){\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tvalue = arr[i];\n\t\t\t\t\tif(callback.call(thisObject, value, i, arr)){\n\t\t\t\t\t\tout.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor(; i < l; ++i){\n\t\t\t\t\tvalue = arr[i];\n\t\t\t\t\tif(callback(value, i, arr)){\n\t\t\t\t\t\tout.push(value);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn out; // Array\n\t\t},\n\n\t\tclearCache: function(){\n\t\t\tcache = {};\n\t\t}\n\t};\n\n\n\thas(\"extend-dojo\") && lang.mixin(dojo, array);\n\n\treturn array;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/array.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/config.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/config.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ \"./node_modules/dojo/global.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__.dj.c(module.i)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has, require){\n\t// module:\n\t//\t\tdojo/_base/config\n\n/*=====\nreturn {\n\t// summary:\n\t//\t\tThis module defines the user configuration during bootstrap.\n\t// description:\n\t//\t\tBy defining user configuration as a module value, an entire configuration can be specified in a build,\n\t//\t\tthereby eliminating the need for sniffing and or explicitly setting in the global variable dojoConfig.\n\t//\t\tAlso, when multiple instances of dojo exist in a single application, each will necessarily be located\n\t//\t\tat an unique absolute module identifier as given by the package configuration. Implementing configuration\n\t//\t\tas a module allows for specifying unique, per-instance configurations.\n\t// example:\n\t//\t\tCreate a second instance of dojo with a different, instance-unique configuration (assume the loader and\n\t//\t\tdojo.js are already loaded).\n\t//\t\t|\t// specify a configuration that creates a new instance of dojo at the absolute module identifier \"myDojo\"\n\t//\t\t|\trequire({\n\t//\t\t|\t\tpackages:[{\n\t//\t\t|\t\t\tname:\"myDojo\",\n\t//\t\t|\t\t\tlocation:\".\", //assume baseUrl points to dojo.js\n\t//\t\t|\t\t}]\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// specify a configuration for the myDojo instance\n\t//\t\t|\tdefine(\"myDojo/config\", {\n\t//\t\t|\t\t// normal configuration variables go here, e.g.,\n\t//\t\t|\t\tlocale:\"fr-ca\"\n\t//\t\t|\t});\n\t//\t\t|\n\t//\t\t|\t// load and use the new instance of dojo\n\t//\t\t|\trequire([\"myDojo\"], function(dojo){\n\t//\t\t|\t\t// dojo is the new instance of dojo\n\t//\t\t|\t\t// use as required\n\t//\t\t|\t});\n\n\t// isDebug: Boolean\n\t//\t\tDefaults to `false`. If set to `true`, ensures that Dojo provides\n\t//\t\textended debugging feedback to the console.\n\tisDebug: false,\n\n\t// locale: String\n\t//\t\tThe locale to assume for loading localized resources in this page,\n\t//\t\tspecified according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).\n\t//\t\tMust be specified entirely in lowercase, e.g. `en-us` and `zh-cn`.\n\t//\t\tSee the documentation for `dojo.i18n` and `dojo.requireLocalization`\n\t//\t\tfor details on loading localized resources. If no locale is specified,\n\t//\t\tDojo assumes the locale of the user agent, according to `navigator.userLanguage`\n\t//\t\tor `navigator.language` properties.\n\tlocale: undefined,\n\n\t// extraLocale: Array\n\t//\t\tNo default value. Specifies additional locales whose\n\t//\t\tresources should also be loaded alongside the default locale when\n\t//\t\tcalls to `dojo.requireLocalization()` are processed.\n\textraLocale: undefined,\n\n\t// baseUrl: String\n\t//\t\tThe directory in which `dojo.js` is located. Under normal\n\t//\t\tconditions, Dojo auto-detects the correct location from which it\n\t//\t\twas loaded. You may need to manually configure `baseUrl` in cases\n\t//\t\twhere you have renamed `dojo.js` or in which `<base>` tags confuse\n\t//\t\tsome browsers (e.g. IE 6). The variable `dojo.baseUrl` is assigned\n\t//\t\teither the value of `djConfig.baseUrl` if one is provided or the\n\t//\t\tauto-detected root if not. Other modules are located relative to\n\t//\t\tthis path. The path should end in a slash.\n\tbaseUrl: undefined,\n\n\t// modulePaths: [deprecated] Object\n\t//\t\tA map of module names to paths relative to `dojo.baseUrl`. The\n\t//\t\tkey/value pairs correspond directly to the arguments which\n\t//\t\t`dojo.registerModulePath` accepts. Specifying\n\t//\t\t`djConfig.modulePaths = { \"foo\": \"../../bar\" }` is the equivalent\n\t//\t\tof calling `dojo.registerModulePath(\"foo\", \"../../bar\");`. Multiple\n\t//\t\tmodules may be configured via `djConfig.modulePaths`.\n\tmodulePaths: {},\n\n\t// addOnLoad: Function|Array\n\t//\t\tAdds a callback via dojo/ready. Useful when Dojo is added after\n\t//\t\tthe page loads and djConfig.afterOnLoad is true. Supports the same\n\t//\t\targuments as dojo/ready. When using a function reference, use\n\t//\t\t`djConfig.addOnLoad = function(){};`. For object with function name use\n\t//\t\t`djConfig.addOnLoad = [myObject, \"functionName\"];` and for object with\n\t//\t\tfunction reference use\n\t//\t\t`djConfig.addOnLoad = [myObject, function(){}];`\n\taddOnLoad: null,\n\n\t// parseOnLoad: Boolean\n\t//\t\tRun the parser after the page is loaded\n\tparseOnLoad: false,\n\n\t// require: String[]\n\t//\t\tAn array of module names to be loaded immediately after dojo.js has been included\n\t//\t\tin a page.\n\trequire: [],\n\n\t// defaultDuration: Number\n\t//\t\tDefault duration, in milliseconds, for wipe and fade animations within dijits.\n\t//\t\tAssigned to dijit.defaultDuration.\n\tdefaultDuration: 200,\n\n\t// dojoBlankHtmlUrl: String\n\t//\t\tUsed by some modules to configure an empty iframe. Used by dojo/io/iframe and\n\t//\t\tdojo/back, and dijit/popup support in IE where an iframe is needed to make sure native\n\t//\t\tcontrols do not bleed through the popups. Normally this configuration variable\n\t//\t\tdoes not need to be set, except when using cross-domain/CDN Dojo builds.\n\t//\t\tSave dojo/resources/blank.html to your domain and set `djConfig.dojoBlankHtmlUrl`\n\t//\t\tto the path on your domain your copy of blank.html.\n\tdojoBlankHtmlUrl: undefined,\n\n\t// ioPublish: Boolean?\n\t//\t\tSet this to true to enable publishing of topics for the different phases of\n\t//\t\tIO operations. Publishing is done via dojo/topic.publish(). See dojo/main.__IoPublish for a list\n\t//\t\tof topics that are published.\n\tioPublish: false,\n\n\t// transparentColor: Array\n\t//\t\tArray containing the r, g, b components used as transparent color in dojo.Color;\n\t//\t\tif undefined, [255,255,255] (white) will be used.\n\ttransparentColor: undefined,\n\t\n\t// deps: Function|Array\n\t//\t\tDefines dependencies to be used before the loader has been loaded.\n\t//\t\tWhen provided, they cause the loader to execute require(deps, callback) \n\t//\t\tonce it has finished loading. Should be used with callback.\n\tdeps: undefined,\n\t\n\t// callback: Function|Array\n\t//\t\tDefines a callback to be used when dependencies are defined before \n\t//\t\tthe loader has been loaded. When provided, they cause the loader to \n\t//\t\texecute require(deps, callback) once it has finished loading. \n\t//\t\tShould be used with deps.\n\tcallback: undefined,\n\t\n\t// deferredInstrumentation: Boolean\n\t//\t\tWhether deferred instrumentation should be loaded or included\n\t//\t\tin builds.\n\tdeferredInstrumentation: true,\n\n\t// useDeferredInstrumentation: Boolean|String\n\t//\t\tWhether the deferred instrumentation should be used.\n\t//\n\t//\t\t* `\"report-rejections\"`: report each rejection as it occurs.\n\t//\t\t* `true` or `1` or `\"report-unhandled-rejections\"`: wait 1 second\n\t//\t\t\tin an attempt to detect unhandled rejections.\n\tuseDeferredInstrumentation: \"report-unhandled-rejections\"\n};\n=====*/\n\n\tvar result = {};\n\tif(has(\"dojo-config-api\")){\n\t\t// must be the dojo loader; take a shallow copy of require.rawConfig\n\t\tvar src = require.rawConfig, p;\n\t\tfor(p in src){\n\t\t\tresult[p] = src[p];\n\t\t}\n\t}else{\n\t\tvar adviseHas = function(featureSet, prefix, booting){\n\t\t\tfor(p in featureSet){\n\t\t\t\tp!=\"has\" && has.add(prefix + p, featureSet[p], 0, booting);\n\t\t\t}\n\t\t};\n\t\tresult = has(\"dojo-loader\") ?\n\t\t\t// must be a built version of the dojo loader; all config stuffed in require.rawConfig\n\t\t\trequire.rawConfig :\n\t\t\t// a foreign loader\n\t\t\tglobal.dojoConfig || global.djConfig || {};\n\t\tadviseHas(result, \"config\", 1);\n\t\tadviseHas(result.has, \"\", 1);\n\t}\n\n\tif(!result.locale && typeof navigator != \"undefined\"){\n\t\t// Default locale for browsers (ensure it's read from user-settings not download locale).\n\t\tvar language = (navigator.languages && navigator.languages.length) ? navigator.languages[0] :\n\t\t\t(navigator.language || navigator.userLanguage);\n\t\tif(language){\n\t\t\tresult.locale = language.toLowerCase();\n\t\t}\n\t}\n\n\treturn result;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/config.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/kernel.js":
/*!*******************************************!*\
  !*** ./node_modules/dojo/_base/kernel.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../global */ \"./node_modules/dojo/global.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ./config */ \"./node_modules/dojo/_base/config.js\"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, has, config, require, module){\n\t// module:\n\t//\t\tdojo/_base/kernel\n\n\t// This module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\n\tvar\n\t\t// loop variables for this module\n\t\ti, p,\n\n\t\t// create dojo, dijit, and dojox\n\t\t// FIXME: in 2.0 remove dijit, dojox being created by dojo\n\t\tdijit = {},\n\t\tdojox = {},\n\t\tdojo = {\n\t\t\t// summary:\n\t\t\t//\t\tThis module is the foundational module of the dojo boot sequence; it defines the dojo object.\n\n\t\t\t// notice dojo takes ownership of the value of the config module\n\t\t\tconfig:config,\n\t\t\tglobal:global,\n\t\t\tdijit:dijit,\n\t\t\tdojox:dojox\n\t\t};\n\n\n\t// Configure the scope map. For a 100% AMD application, the scope map is not needed other than to provide\n\t// a _scopeName property for the dojo, dijit, and dojox root object so those packages can create\n\t// unique names in the global space.\n\t//\n\t// Built, legacy modules use the scope map to allow those modules to be expressed as if dojo, dijit, and dojox,\n\t// where global when in fact they are either global under different names or not global at all. In v1.6-, the\n\t// config variable \"scopeMap\" was used to map names as used within a module to global names. This has been\n\t// subsumed by the AMD map configuration variable which can relocate packages to different names. For backcompat,\n\t// only the \"*\" mapping is supported. See http://livedocs.dojotoolkit.org/developer/design/loader#legacy-cross-domain-mode for details.\n\t//\n\t// The following computations contort the packageMap for this dojo instance into a scopeMap.\n\tvar scopeMap =\n\t\t\t// a map from a name used in a legacy module to the (global variable name, object addressed by that name)\n\t\t\t// always map dojo, dijit, and dojox\n\t\t\t{\n\t\t\t\tdojo:[\"dojo\", dojo],\n\t\t\t\tdijit:[\"dijit\", dijit],\n\t\t\t\tdojox:[\"dojox\", dojox]\n\t\t\t},\n\n\t\tpackageMap =\n\t\t\t// the package map for this dojo instance; note, a foreign loader or no pacakgeMap results in the above default config\n\t\t\t(require.map && require.map[module.i.match(/[^\\/]+/)[0]]),\n\n\t\titem;\n\n\n\t// process all mapped top-level names for this instance of dojo\n\tfor(p in packageMap){\n\t\tif(scopeMap[p]){\n\t\t\t// mapped dojo, dijit, or dojox\n\t\t\tscopeMap[p][0] = packageMap[p];\n\t\t}else{\n\t\t\t// some other top-level name\n\t\t\tscopeMap[p] = [packageMap[p], {}];\n\t\t}\n\t}\n\n\t// publish those names to _scopeName and, optionally, the global namespace\n\tfor(p in scopeMap){\n\t\titem = scopeMap[p];\n\t\titem[1]._scopeName = item[0];\n\t\tif(!config.noGlobals){\n\t\t\tglobal[item[0]] = item[1];\n\t\t}\n\t}\n\tdojo.scopeMap = scopeMap;\n\n\t/*===== dojo.__docParserConfigureScopeMap(scopeMap); =====*/\n\n\t// FIXME: dojo.baseUrl and dojo.config.baseUrl should be deprecated\n\tdojo.baseUrl = dojo.config.baseUrl = require.baseUrl;\n\tdojo.isAsync = !has(\"dojo-loader\") || require.async;\n\tdojo.locale = config.locale;\n\n\tvar rev = \"$Rev: aaa6750 $\".match(/[0-9a-f]{7,}/);\n\tdojo.version = {\n\t\t// summary:\n\t\t//\t\tVersion number of the Dojo Toolkit\n\t\t// description:\n\t\t//\t\tHash about the version, including\n\t\t//\n\t\t//\t\t- major: Integer: Major version. If total version is \"1.2.0beta1\", will be 1\n\t\t//\t\t- minor: Integer: Minor version. If total version is \"1.2.0beta1\", will be 2\n\t\t//\t\t- patch: Integer: Patch version. If total version is \"1.2.0beta1\", will be 0\n\t\t//\t\t- flag: String: Descriptor flag. If total version is \"1.2.0beta1\", will be \"beta1\"\n\t\t//\t\t- revision: Number: The Git rev from which dojo was pulled\n\n\t\tmajor: 1, minor: 13, patch: 0, flag: \"\",\n\t\trevision: rev ? rev[0] : NaN,\n\t\ttoString: function(){\n\t\t\tvar v = dojo.version;\n\t\t\treturn v.major + \".\" + v.minor + \".\" + v.patch + v.flag + \" (\" + v.revision + \")\";\t// String\n\t\t}\n\t};\n\n\t// If has(\"extend-dojo\") is truthy, then as a dojo module is defined it should push it's definitions\n\t// into the dojo object, and conversely. In 2.0, it will likely be unusual to augment another object\n\t// as a result of defining a module. This has feature gives a way to force 2.0 behavior as the code\n\t// is migrated. Absent specific advice otherwise, set extend-dojo to truthy.\n\thas.add(\"extend-dojo\", 1);\n\n\tif(!has(\"csp-restrictions\")){\n\t\t(Function(\"d\", \"d.eval = function(){return d.global.eval ? d.global.eval(arguments[0]) : eval(arguments[0]);}\"))(dojo);\n\t}\n\t/*=====\n\tdojo.eval = function(scriptText){\n\t\t// summary:\n\t\t//\t\tA legacy method created for use exclusively by internal Dojo methods. Do not use this method\n\t\t//\t\tdirectly unless you understand its possibly-different implications on the platforms your are targeting.\n\t\t// description:\n\t\t//\t\tMakes an attempt to evaluate scriptText in the global scope. The function works correctly for browsers\n\t\t//\t\tthat support indirect eval.\n\t\t//\n\t\t//\t\tAs usual, IE does not. On IE, the only way to implement global eval is to\n\t\t//\t\tuse execScript. Unfortunately, execScript does not return a value and breaks some current usages of dojo.eval.\n\t\t//\t\tThis implementation uses the technique of executing eval in the scope of a function that is a single scope\n\t\t//\t\tframe below the global scope; thereby coming close to the global scope. Note carefully that\n\t\t//\n\t\t//\t\tdojo.eval(\"var pi = 3.14;\");\n\t\t//\n\t\t//\t\twill define global pi in non-IE environments, but define pi only in a temporary local scope for IE. If you want\n\t\t//\t\tto define a global variable using dojo.eval, write something like\n\t\t//\n\t\t//\t\tdojo.eval(\"window.pi = 3.14;\")\n\t\t// scriptText:\n\t\t//\t\tThe text to evaluation.\n\t\t// returns:\n\t\t//\t\tThe result of the evaluation. Often `undefined`\n\t};\n\t=====*/\n\n\n\tif(has(\"host-rhino\")){\n\t\tdojo.exit = function(exitcode){\n\t\t\tquit(exitcode);\n\t\t};\n\t}else{\n\t\tdojo.exit = function(){\n\t\t};\n\t}\n\n\tif(!has(\"host-webworker\")){\n\t\t// console is immutable in FF30+, https://bugs.dojotoolkit.org/ticket/18100\n\t\thas.add(\"dojo-guarantee-console\",\n\t\t\t// ensure that console.log, console.warn, etc. are defined\n\t\t\t1\n\t\t);\n\t}\n\n\tif(has(\"dojo-guarantee-console\")){\n\t\t// IE 9 bug: https://bugs.dojotoolkit.org/ticket/18197\n\t\thas.add(\"console-as-object\", function () {\n\t\t\treturn Function.prototype.bind && console && typeof console.log === \"object\";\n\t\t});\n\n\t\ttypeof console != \"undefined\" || (console = {});  // intentional assignment\n\t\t//\tBe careful to leave 'log' always at the end\n\t\tvar cn = [\n\t\t\t\"assert\", \"count\", \"debug\", \"dir\", \"dirxml\", \"error\", \"group\",\n\t\t\t\"groupEnd\", \"info\", \"profile\", \"profileEnd\", \"time\", \"timeEnd\",\n\t\t\t\"trace\", \"warn\", \"log\"\n\t\t];\n\t\tvar tn;\n\t\ti = 0;\n\t\twhile((tn = cn[i++])){\n\t\t\tif(!console[tn]){\n\t\t\t\t(function(){\n\t\t\t\t\tvar tcn = tn + \"\";\n\t\t\t\t\tconsole[tcn] = ('log' in console) ? function(){\n\t\t\t\t\t\tvar a = Array.prototype.slice.call(arguments);\n\t\t\t\t\t\ta.unshift(tcn + \":\");\n\t\t\t\t\t\tconsole[\"log\"](a.join(\" \"));\n\t\t\t\t\t} : function(){};\n\t\t\t\t\tconsole[tcn]._fake = true;\n\t\t\t\t})();\n\t\t\t}else if(has(\"console-as-object\")){\n\t\t\t\tconsole[tn] = Function.prototype.bind.call(console[tn], console);\n\t\t\t}\n\t\t}\n\t}\n\n\thas.add(\"dojo-debug-messages\",\n\t\t// include dojo.deprecated/dojo.experimental implementations\n\t\t!!config.isDebug\n\t);\n\tdojo.deprecated = dojo.experimental =  function(){};\n\tif(has(\"dojo-debug-messages\")){\n\t\tdojo.deprecated = function(/*String*/ behaviour, /*String?*/ extra, /*String?*/ removal){\n\t\t\t// summary:\n\t\t\t//\t\tLog a debug message to indicate that a behavior has been\n\t\t\t//\t\tdeprecated.\n\t\t\t// behaviour: String\n\t\t\t//\t\tThe API or behavior being deprecated. Usually in the form\n\t\t\t//\t\tof \"myApp.someFunction()\".\n\t\t\t// extra: String?\n\t\t\t//\t\tText to append to the message. Often provides advice on a\n\t\t\t//\t\tnew function or facility to achieve the same goal during\n\t\t\t//\t\tthe deprecation period.\n\t\t\t// removal: String?\n\t\t\t//\t\tText to indicate when in the future the behavior will be\n\t\t\t//\t\tremoved. Usually a version number.\n\t\t\t// example:\n\t\t\t//\t| dojo.deprecated(\"myApp.getTemp()\", \"use myApp.getLocaleTemp() instead\", \"1.0\");\n\n\t\t\tvar message = \"DEPRECATED: \" + behaviour;\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tif(removal){ message += \" -- will be removed in version: \" + removal; }\n\t\t\tconsole.warn(message);\n\t\t};\n\n\t\tdojo.experimental = function(/* String */ moduleName, /* String? */ extra){\n\t\t\t// summary:\n\t\t\t//\t\tMarks code as experimental.\n\t\t\t// description:\n\t\t\t//\t\tThis can be used to mark a function, file, or module as\n\t\t\t//\t\texperimental.\t Experimental code is not ready to be used, and the\n\t\t\t//\t\tAPIs are subject to change without notice.\tExperimental code may be\n\t\t\t//\t\tcompleted deleted without going through the normal deprecation\n\t\t\t//\t\tprocess.\n\t\t\t// moduleName: String\n\t\t\t//\t\tThe name of a module, or the name of a module file or a specific\n\t\t\t//\t\tfunction\n\t\t\t// extra: String?\n\t\t\t//\t\tsome additional message for the user\n\t\t\t// example:\n\t\t\t//\t| dojo.experimental(\"dojo.data.Result\");\n\t\t\t// example:\n\t\t\t//\t| dojo.experimental(\"dojo.weather.toKelvin()\", \"PENDING approval from NOAA\");\n\n\t\t\tvar message = \"EXPERIMENTAL: \" + moduleName + \" -- APIs subject to change without notice.\";\n\t\t\tif(extra){ message += \" \" + extra; }\n\t\t\tconsole.warn(message);\n\t\t};\n\t}\n\n\thas.add(\"dojo-modulePaths\",\n\t\t// consume dojo.modulePaths processing\n\t\t1\n\t);\n\tif(has(\"dojo-modulePaths\")){\n\t\t// notice that modulePaths won't be applied to any require's before the dojo/_base/kernel factory is run;\n\t\t// this is the v1.6- behavior.\n\t\tif(config.modulePaths){\n\t\t\tdojo.deprecated(\"dojo.modulePaths\", \"use paths configuration\");\n\t\t\tvar paths = {};\n\t\t\tfor(p in config.modulePaths){\n\t\t\t\tpaths[p.replace(/\\./g, \"/\")] = config.modulePaths[p];\n\t\t\t}\n\t\t\trequire({paths:paths});\n\t\t}\n\t}\n\n\thas.add(\"dojo-moduleUrl\",\n\t\t// include dojo.moduleUrl\n\t\t1\n\t);\n\tif(has(\"dojo-moduleUrl\")){\n\t\tdojo.moduleUrl = function(/*String*/module, /*String?*/url){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a URL relative to a module.\n\t\t\t// example:\n\t\t\t//\t|\tvar pngPath = dojo.moduleUrl(\"acme\",\"images/small.png\");\n\t\t\t//\t|\tconsole.dir(pngPath); // list the object properties\n\t\t\t//\t|\t// create an image and set it's source to pngPath's value:\n\t\t\t//\t|\tvar img = document.createElement(\"img\");\n\t\t\t//\t|\timg.src = pngPath;\n\t\t\t//\t|\t// add our image to the document\n\t\t\t//\t|\tdojo.body().appendChild(img);\n\t\t\t// example:\n\t\t\t//\t\tyou may de-reference as far as you like down the package\n\t\t\t//\t\thierarchy.  This is sometimes handy to avoid lengthy relative\n\t\t\t//\t\turls or for building portable sub-packages. In this example,\n\t\t\t//\t\tthe `acme.widget` and `acme.util` directories may be located\n\t\t\t//\t\tunder different roots (see `dojo.registerModulePath`) but the\n\t\t\t//\t\tthe modules which reference them can be unaware of their\n\t\t\t//\t\trelative locations on the filesystem:\n\t\t\t//\t|\t// somewhere in a configuration block\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.widget\", \"../../acme/widget\");\n\t\t\t//\t|\tdojo.registerModulePath(\"acme.util\", \"../../util\");\n\t\t\t//\t|\n\t\t\t//\t|\t// ...\n\t\t\t//\t|\n\t\t\t//\t|\t// code in a module using acme resources\n\t\t\t//\t|\tvar tmpltPath = dojo.moduleUrl(\"acme.widget\",\"templates/template.html\");\n\t\t\t//\t|\tvar dataPath = dojo.moduleUrl(\"acme.util\",\"resources/data.json\");\n\n\t\t\tdojo.deprecated(\"dojo.moduleUrl()\", \"use require.toUrl\", \"2.0\");\n\n\t\t\t// require.toUrl requires a filetype; therefore, just append the suffix \"/*.*\" to guarantee a filetype, then\n\t\t\t// remove the suffix from the result. This way clients can request a url w/out a filetype. This should be\n\t\t\t// rare, but it maintains backcompat for the v1.x line (note: dojo.moduleUrl will be removed in v2.0).\n\t\t\t// Notice * is an illegal filename so it won't conflict with any real path map that may exist the paths config.\n\t\t\tvar result = null;\n\t\t\tif(module){\n\t\t\t\tresult = require.toUrl(module.replace(/\\./g, \"/\") + (url ? (\"/\" + url) : \"\") + \"/*.*\").replace(/\\/\\*\\.\\*/, \"\") + (url ? \"\" : \"/\");\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\t}\n\n\tdojo._hasResource = {}; // for backward compatibility with layers built with 1.6 tooling\n\n\treturn dojo;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/kernel.js?");

/***/ }),

/***/ "./node_modules/dojo/_base/lang.js":
/*!*****************************************!*\
  !*** ./node_modules/dojo/_base/lang.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"), __webpack_require__(/*! ../sniff */ \"./node_modules/dojo/sniff.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(dojo, has){\n\t// module:\n\t//\t\tdojo/_base/lang\n\n\thas.add(\"bug-for-in-skips-shadowed\", function(){\n\t\t// if true, the for-in iterator skips object properties that exist in Object's prototype (IE 6 - ?)\n\t\tfor(var i in {toString: 1}){\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t});\n\n\t// Helper methods\n\tvar _extraNames =\n\t\t\thas(\"bug-for-in-skips-shadowed\") ?\n\t\t\t\t\"hasOwnProperty.valueOf.isPrototypeOf.propertyIsEnumerable.toLocaleString.toString.constructor\".split(\".\") : [],\n\n\t\t_extraLen = _extraNames.length,\n\n\t\tgetProp = function(/*Array*/parts, /*Boolean*/create, /*Object*/context){\n\t\t\tif(!context){\n\t\t\t\tif(parts[0] && dojo.scopeMap[parts[0]]) {\n\t\t\t\t\t// Voodoo code from the old days where \"dojo\" or \"dijit\" maps to some special object\n\t\t\t\t\t// rather than just window.dojo\n\t\t\t\t\tcontext = dojo.scopeMap[parts.shift()][1];\n\t\t\t\t}else{\n\t\t\t\t\tcontext = dojo.global;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttry{\n\t\t\t\tfor(var i = 0; i < parts.length; i++){\n\t\t\t\t\tvar p = parts[i];\n\t\t\t\t\tif(!(p in context)){\n\t\t\t\t\t\tif(create){\n\t\t\t\t\t\t\tcontext[p] = {};\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\treturn;\t\t// return undefined\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcontext = context[p];\n\t\t\t\t}\n\t\t\t\treturn context; // mixed\n\t\t\t}catch(e){\n\t\t\t\t// \"p in context\" throws an exception when context is a number, boolean, etc. rather than an object,\n\t\t\t\t// so in that corner case just return undefined (by having no return statement)\n\t\t\t}\n\t\t},\n\n\t\topts = Object.prototype.toString,\n\n\t\tefficient = function(obj, offset, startWith){\n\t\t\treturn (startWith||[]).concat(Array.prototype.slice.call(obj, offset||0));\n\t\t},\n\n\t\t_pattern = /\\{([^\\}]+)\\}/g;\n\n\t// Module export\n\tvar lang = {\n\t\t// summary:\n\t\t//\t\tThis module defines Javascript language extensions.\n\n\t\t// _extraNames: String[]\n\t\t//\t\tLists property names that must be explicitly processed during for-in iteration\n\t\t//\t\tin environments that have has(\"bug-for-in-skips-shadowed\") true.\n\t\t_extraNames:_extraNames,\n\n\t\t_mixin: function(dest, source, copyFunc){\n\t\t\t// summary:\n\t\t\t//\t\tCopies/adds all properties of source to dest; returns dest.\n\t\t\t// dest: Object\n\t\t\t//\t\tThe object to which to copy/add all properties contained in source.\n\t\t\t// source: Object\n\t\t\t//\t\tThe object from which to draw all properties to copy into dest.\n\t\t\t// copyFunc: Function?\n\t\t\t//\t\tThe process used to copy/add a property in source; defaults to the Javascript assignment operator.\n\t\t\t// returns:\n\t\t\t//\t\tdest, as modified\n\t\t\t// description:\n\t\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\t//\t\tfound in Object.prototype, are copied/added to dest. Copying/adding each particular property is\n\t\t\t//\t\tdelegated to copyFunc (if any); copyFunc defaults to the Javascript assignment operator if not provided.\n\t\t\t//\t\tNotice that by default, _mixin executes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t\t\tvar name, s, i, empty = {};\n\t\t\tfor(name in source){\n\t\t\t\t// the (!(name in empty) || empty[name] !== s) condition avoids copying properties in \"source\"\n\t\t\t\t// inherited from Object.prototype.\t For example, if dest has a custom toString() method,\n\t\t\t\t// don't overwrite it with the toString() method that source inherited from Object.prototype\n\t\t\t\ts = source[name];\n\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(has(\"bug-for-in-skips-shadowed\")){\n\t\t\t\tif(source){\n\t\t\t\t\tfor(i = 0; i < _extraLen; ++i){\n\t\t\t\t\t\tname = _extraNames[i];\n\t\t\t\t\t\ts = source[name];\n\t\t\t\t\t\tif(!(name in dest) || (dest[name] !== s && (!(name in empty) || empty[name] !== s))){\n\t\t\t\t\t\t\tdest[name] = copyFunc ? copyFunc(s) : s;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tmixin: function(dest, sources){\n\t\t\t// summary:\n\t\t\t//\t\tCopies/adds all properties of one or more sources to dest; returns dest.\n\t\t\t// dest: Object\n\t\t\t//\t\tThe object to which to copy/add all properties contained in source. If dest is falsy, then\n\t\t\t//\t\ta new object is manufactured before copying/adding properties begins.\n\t\t\t// sources: Object...\n\t\t\t//\t\tOne of more objects from which to draw all properties to copy into dest. sources are processed\n\t\t\t//\t\tleft-to-right and if more than one of these objects contain the same property name, the right-most\n\t\t\t//\t\tvalue \"wins\".\n\t\t\t// returns: Object\n\t\t\t//\t\tdest, as modified\n\t\t\t// description:\n\t\t\t//\t\tAll properties, including functions (sometimes termed \"methods\"), excluding any non-standard extensions\n\t\t\t//\t\tfound in Object.prototype, are copied/added from sources to dest. sources are processed left to right.\n\t\t\t//\t\tThe Javascript assignment operator is used to copy/add each property; therefore, by default, mixin\n\t\t\t//\t\texecutes a so-called \"shallow copy\" and aggregate types are copied/added by reference.\n\t\t\t// example:\n\t\t\t//\t\tmake a shallow copy of an object\n\t\t\t//\t|\tvar copy = lang.mixin({}, source);\n\t\t\t// example:\n\t\t\t//\t\tmany class constructors often take an object which specifies\n\t\t\t//\t\tvalues to be configured on the object. In this case, it is\n\t\t\t//\t\toften simplest to call `lang.mixin` on the `this` object:\n\t\t\t//\t|\tdeclare(\"acme.Base\", null, {\n\t\t\t//\t|\t\tconstructor: function(properties){\n\t\t\t//\t|\t\t\t// property configuration:\n\t\t\t//\t|\t\t\tlang.mixin(this, properties);\n\t\t\t//\t|\n\t\t\t//\t|\t\t\tconsole.log(this.quip);\n\t\t\t//\t|\t\t\t//\t...\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\tquip: \"I wasn't born yesterday, you know - I've seen movies.\",\n\t\t\t//\t|\t\t// ...\n\t\t\t//\t|\t});\n\t\t\t//\t|\n\t\t\t//\t|\t// create an instance of the class and configure it\n\t\t\t//\t|\tvar b = new acme.Base({quip: \"That's what it does!\" });\n\t\t\t// example:\n\t\t\t//\t\tcopy in properties from multiple objects\n\t\t\t//\t|\tvar flattened = lang.mixin(\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tname: \"Frylock\",\n\t\t\t//\t|\t\t\tbraces: true\n\t\t\t//\t|\t\t},\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tname: \"Carl Brutanananadilewski\"\n\t\t\t//\t|\t\t}\n\t\t\t//\t|\t);\n\t\t\t//\t|\n\t\t\t//\t|\t// will print \"Carl Brutanananadilewski\"\n\t\t\t//\t|\tconsole.log(flattened.name);\n\t\t\t//\t|\t// will print \"true\"\n\t\t\t//\t|\tconsole.log(flattened.braces);\n\n\t\t\tif(!dest){ dest = {}; }\n\t\t\tfor(var i = 1, l = arguments.length; i < l; i++){\n\t\t\t\tlang._mixin(dest, arguments[i]);\n\t\t\t}\n\t\t\treturn dest; // Object\n\t\t},\n\n\t\tsetObject: function(name, value, context){\n\t\t\t// summary:\n\t\t\t//\t\tSet a property from a dot-separated string, such as \"A.B.C\"\n\t\t\t// description:\n\t\t\t//\t\tUseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain, or when you have an object reference in string format.\n\t\t\t//\t\tObjects are created as needed along `path`. Returns the passed\n\t\t\t//\t\tvalue if setting is successful or `undefined` if not.\n\t\t\t// name: String\n\t\t\t//\t\tPath to a property, in the form \"A.B.C\".\n\t\t\t// value: anything\n\t\t\t//\t\tvalue or object to place at location given by name\n\t\t\t// context: Object?\n\t\t\t//\t\tOptional. Object to use as root of path. Defaults to\n\t\t\t//\t\t`dojo.global`.\n\t\t\t// example:\n\t\t\t//\t\tset the value of `foo.bar.baz`, regardless of whether\n\t\t\t//\t\tintermediate objects already exist:\n\t\t\t//\t| lang.setObject(\"foo.bar.baz\", value);\n\t\t\t// example:\n\t\t\t//\t\twithout `lang.setObject`, we often see code like this:\n\t\t\t//\t| // ensure that intermediate objects are available\n\t\t\t//\t| if(!obj[\"parent\"]){ obj.parent = {}; }\n\t\t\t//\t| if(!obj.parent[\"child\"]){ obj.parent.child = {}; }\n\t\t\t//\t| // now we can safely set the property\n\t\t\t//\t| obj.parent.child.prop = \"some value\";\n\t\t\t//\t\twhereas with `lang.setObject`, we can shorten that to:\n\t\t\t//\t| lang.setObject(\"parent.child.prop\", \"some value\", obj);\n\n\t\t\tvar parts = name.split(\".\"), p = parts.pop(), obj = getProp(parts, true, context);\n\t\t\treturn obj && p ? (obj[p] = value) : undefined; // Object\n\t\t},\n\n\t\tgetObject: function(name, create, context){\n\t\t\t// summary:\n\t\t\t//\t\tGet a property from a dot-separated string, such as \"A.B.C\"\n\t\t\t// description:\n\t\t\t//\t\tUseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain, or when you have an object reference in string format.\n\t\t\t// name: String\n\t\t\t//\t\tPath to an property, in the form \"A.B.C\".\n\t\t\t// create: Boolean?\n\t\t\t//\t\tOptional. Defaults to `false`. If `true`, Objects will be\n\t\t\t//\t\tcreated at any point along the 'path' that is undefined.\n\t\t\t// context: Object?\n\t\t\t//\t\tOptional. Object to use as root of path. Defaults to\n\t\t\t//\t\t'dojo.global'. Null may be passed.\n\t\t\treturn !name ? context : getProp(name.split(\".\"), create, context); // Object\n\t\t},\n\n\t\texists: function(name, obj){\n\t\t\t// summary:\n\t\t\t//\t\tdetermine if an object supports a given method\n\t\t\t// description:\n\t\t\t//\t\tuseful for longer api chains where you have to test each object in\n\t\t\t//\t\tthe chain. Useful for object and method detection.\n\t\t\t// name: String\n\t\t\t//\t\tPath to an object, in the form \"A.B.C\".\n\t\t\t// obj: Object?\n\t\t\t//\t\tObject to use as root of path. Defaults to\n\t\t\t//\t\t'dojo.global'. Null may be passed.\n\t\t\t// example:\n\t\t\t//\t| // define an object\n\t\t\t//\t| var foo = {\n\t\t\t//\t|\t\tbar: { }\n\t\t\t//\t| };\n\t\t\t//\t|\n\t\t\t//\t| // search the global scope\n\t\t\t//\t| lang.exists(\"foo.bar\"); // true\n\t\t\t//\t| lang.exists(\"foo.bar.baz\"); // false\n\t\t\t//\t|\n\t\t\t//\t| // search from a particular scope\n\t\t\t//\t| lang.exists(\"bar\", foo); // true\n\t\t\t//\t| lang.exists(\"bar.baz\", foo); // false\n\t\t\treturn lang.getObject(name, false, obj) !== undefined; // Boolean\n\t\t},\n\n\t\t// Crockford (ish) functions\n\n\t\tisString: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is a String\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn (typeof it == \"string\" || it instanceof String); // Boolean\n\t\t},\n\n\t\tisArray: Array.isArray || function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is an Array.\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn opts.call(it) == \"[object Array]\"; // Boolean\n\t\t},\n\n\t\tisFunction: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturn true if it is a Function\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn opts.call(it) === \"[object Function]\";\n\t\t},\n\n\t\tisObject: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturns true if it is a JavaScript object (or an Array, a Function\n\t\t\t//\t\tor null)\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\treturn it !== undefined &&\n\t\t\t\t(it === null || typeof it == \"object\" || lang.isArray(it) || lang.isFunction(it)); // Boolean\n\t\t},\n\n\t\tisArrayLike: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tsimilar to isArray() but more permissive\n\t\t\t// it: anything\n\t\t\t//\t\tItem to test.\n\t\t\t// returns:\n\t\t\t//\t\tIf it walks like a duck and quacks like a duck, return `true`\n\t\t\t// description:\n\t\t\t//\t\tDoesn't strongly test for \"arrayness\".  Instead, settles for \"isn't\n\t\t\t//\t\ta string or number and has a length property\". Arguments objects\n\t\t\t//\t\tand DOM collections will return true when passed to\n\t\t\t//\t\tisArrayLike(), but will return false when passed to\n\t\t\t//\t\tisArray().\n\t\t\treturn !!it && // Boolean\n\t\t\t\t// keep out built-in constructors (Number, String, ...) which have length\n\t\t\t\t// properties\n\t\t\t\t!lang.isString(it) && !lang.isFunction(it) &&\n\t\t\t\t!(it.tagName && it.tagName.toLowerCase() == 'form') &&\n\t\t\t\t(lang.isArray(it) || isFinite(it.length));\n\t\t},\n\n\t\tisAlien: function(it){\n\t\t\t// summary:\n\t\t\t//\t\tReturns true if it is a built-in function or some other kind of\n\t\t\t//\t\toddball that *should* report as a function but doesn't\n\t\t\treturn it && !lang.isFunction(it) && /\\{\\s*\\[native code\\]\\s*\\}/.test(String(it)); // Boolean\n\t\t},\n\n\t\textend: function(ctor, props){\n\t\t\t// summary:\n\t\t\t//\t\tAdds all properties and methods of props to constructor's\n\t\t\t//\t\tprototype, making them available to all instances created with\n\t\t\t//\t\tconstructor.\n\t\t\t// ctor: Object\n\t\t\t//\t\tTarget constructor to extend.\n\t\t\t// props: Object\n\t\t\t//\t\tOne or more objects to mix into ctor.prototype\n\t\t\tfor(var i=1, l=arguments.length; i<l; i++){\n\t\t\t\tlang._mixin(ctor.prototype, arguments[i]);\n\t\t\t}\n\t\t\treturn ctor; // Object\n\t\t},\n\n\t\t_hitchArgs: function(scope, method){\n\t\t\tvar pre = lang._toArray(arguments, 2);\n\t\t\tvar named = lang.isString(method);\n\t\t\treturn function(){\n\t\t\t\t// arrayify arguments\n\t\t\t\tvar args = lang._toArray(arguments);\n\t\t\t\t// locate our method\n\t\t\t\tvar f = named ? (scope||dojo.global)[method] : method;\n\t\t\t\t// invoke with collected args\n\t\t\t\treturn f && f.apply(scope || this, pre.concat(args)); // mixed\n\t\t\t}; // Function\n\t\t},\n\n\t\thitch: function(scope, method){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a function that will only ever execute in the given scope.\n\t\t\t//\t\tThis allows for easy use of object member functions\n\t\t\t//\t\tin callbacks and other places in which the \"this\" keyword may\n\t\t\t//\t\totherwise not reference the expected scope.\n\t\t\t//\t\tAny number of default positional arguments may be passed as parameters\n\t\t\t//\t\tbeyond \"method\".\n\t\t\t//\t\tEach of these values will be used to \"placehold\" (similar to curry)\n\t\t\t//\t\tfor the hitched function.\n\t\t\t// scope: Object\n\t\t\t//\t\tThe scope to use when method executes. If method is a string,\n\t\t\t//\t\tscope is also the object containing method.\n\t\t\t// method: Function|String...\n\t\t\t//\t\tA function to be hitched to scope, or the name of the method in\n\t\t\t//\t\tscope to be hitched.\n\t\t\t// example:\n\t\t\t//\t|\tlang.hitch(foo, \"bar\")();\n\t\t\t//\t\truns foo.bar() in the scope of foo\n\t\t\t// example:\n\t\t\t//\t|\tlang.hitch(foo, myFunction);\n\t\t\t//\t\treturns a function that runs myFunction in the scope of foo\n\t\t\t// example:\n\t\t\t//\t\tExpansion on the default positional arguments passed along from\n\t\t\t//\t\thitch. Passed args are mixed first, additional args after.\n\t\t\t//\t|\tvar foo = { bar: function(a, b, c){ console.log(a, b, c); } };\n\t\t\t//\t|\tvar fn = lang.hitch(foo, \"bar\", 1, 2);\n\t\t\t//\t|\tfn(3); // logs \"1, 2, 3\"\n\t\t\t// example:\n\t\t\t//\t|\tvar foo = { bar: 2 };\n\t\t\t//\t|\tlang.hitch(foo, function(){ this.bar = 10; })();\n\t\t\t//\t\texecute an anonymous function in scope of foo\n\t\t\tif(arguments.length > 2){\n\t\t\t\treturn lang._hitchArgs.apply(dojo, arguments); // Function\n\t\t\t}\n\t\t\tif(!method){\n\t\t\t\tmethod = scope;\n\t\t\t\tscope = null;\n\t\t\t}\n\t\t\tif(lang.isString(method)){\n\t\t\t\tscope = scope || dojo.global;\n\t\t\t\tif(!scope[method]){ throw(['lang.hitch: scope[\"', method, '\"] is null (scope=\"', scope, '\")'].join('')); }\n\t\t\t\treturn function(){ return scope[method].apply(scope, arguments || []); }; // Function\n\t\t\t}\n\t\t\treturn !scope ? method : function(){ return method.apply(scope, arguments || []); }; // Function\n\t\t},\n\n\t\tdelegate: (function(){\n\t\t\t// boodman/crockford delegation w/ cornford optimization\n\t\t\tfunction TMP(){}\n\t\t\treturn function(obj, props){\n\t\t\t\tTMP.prototype = obj;\n\t\t\t\tvar tmp = new TMP();\n\t\t\t\tTMP.prototype = null;\n\t\t\t\tif(props){\n\t\t\t\t\tlang._mixin(tmp, props);\n\t\t\t\t}\n\t\t\t\treturn tmp; // Object\n\t\t\t};\n\t\t})(),\n\t\t/*=====\n\t\tdelegate: function(obj, props){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a new object which \"looks\" to obj for properties which it\n\t\t\t//\t\tdoes not have a value for. Optionally takes a bag of properties to\n\t\t\t//\t\tseed the returned object with initially.\n\t\t\t// description:\n\t\t\t//\t\tThis is a small implementation of the Boodman/Crockford delegation\n\t\t\t//\t\tpattern in JavaScript. An intermediate object constructor mediates\n\t\t\t//\t\tthe prototype chain for the returned object, using it to delegate\n\t\t\t//\t\tdown to obj for property lookup when object-local lookup fails.\n\t\t\t//\t\tThis can be thought of similarly to ES4's \"wrap\", save that it does\n\t\t\t//\t\tnot act on types but rather on pure objects.\n\t\t\t// obj: Object\n\t\t\t//\t\tThe object to delegate to for properties not found directly on the\n\t\t\t//\t\treturn object or in props.\n\t\t\t// props: Object...\n\t\t\t//\t\tan object containing properties to assign to the returned object\n\t\t\t// returns:\n\t\t\t//\t\tan Object of anonymous type\n\t\t\t// example:\n\t\t\t//\t|\tvar foo = { bar: \"baz\" };\n\t\t\t//\t|\tvar thinger = lang.delegate(foo, { thud: \"xyzzy\"});\n\t\t\t//\t|\tthinger.bar == \"baz\"; // delegated to foo\n\t\t\t//\t|\tfoo.thud == undefined; // by definition\n\t\t\t//\t|\tthinger.thud == \"xyzzy\"; // mixed in from props\n\t\t\t//\t|\tfoo.bar = \"thonk\";\n\t\t\t//\t|\tthinger.bar == \"thonk\"; // still delegated to foo's bar\n\t\t},\n\t\t=====*/\n\n\t\t_toArray: has(\"ie\") ?\n\t\t\t(function(){\n\t\t\t\tfunction slow(obj, offset, startWith){\n\t\t\t\t\tvar arr = startWith||[];\n\t\t\t\t\tfor(var x = offset || 0; x < obj.length; x++){\n\t\t\t\t\t\tarr.push(obj[x]);\n\t\t\t\t\t}\n\t\t\t\t\treturn arr;\n\t\t\t\t}\n\t\t\t\treturn function(obj){\n\t\t\t\t\treturn ((obj.item) ? slow : efficient).apply(this, arguments);\n\t\t\t\t};\n\t\t\t})() : efficient,\n\t\t/*=====\n\t\t _toArray: function(obj, offset, startWith){\n\t\t\t // summary:\n\t\t\t //\t\tConverts an array-like object (i.e. arguments, DOMCollection) to an\n\t\t\t //\t\tarray. Returns a new Array with the elements of obj.\n\t\t\t // obj: Object\n\t\t\t //\t\tthe object to \"arrayify\". We expect the object to have, at a\n\t\t\t //\t\tminimum, a length property which corresponds to integer-indexed\n\t\t\t //\t\tproperties.\n\t\t\t // offset: Number?\n\t\t\t //\t\tthe location in obj to start iterating from. Defaults to 0.\n\t\t\t //\t\tOptional.\n\t\t\t // startWith: Array?\n\t\t\t //\t\tAn array to pack with the properties of obj. If provided,\n\t\t\t //\t\tproperties in obj are appended at the end of startWith and\n\t\t\t //\t\tstartWith is the returned array.\n\t\t },\n\t\t =====*/\n\n\t\tpartial: function(/*Function|String*/ method /*, ...*/){\n\t\t\t// summary:\n\t\t\t//\t\tsimilar to hitch() except that the scope object is left to be\n\t\t\t//\t\twhatever the execution context eventually becomes.\n\t\t\t// description:\n\t\t\t//\t\tCalling lang.partial is the functional equivalent of calling:\n\t\t\t//\t\t|\tlang.hitch(null, funcName, ...);\n\t\t\t// method:\n\t\t\t//\t\tThe function to \"wrap\"\n\t\t\tvar arr = [ null ];\n\t\t\treturn lang.hitch.apply(dojo, arr.concat(lang._toArray(arguments))); // Function\n\t\t},\n\n\t\tclone: function(/*anything*/ src){\n\t\t\t// summary:\n\t\t\t//\t\tClones objects (including DOM nodes) and all children.\n\t\t\t//\t\tWarning: do not clone cyclic structures.\n\t\t\t// src:\n\t\t\t//\t\tThe object to clone\n\t\t\tif(!src || typeof src != \"object\" || lang.isFunction(src)){\n\t\t\t\t// null, undefined, any non-object, or function\n\t\t\t\treturn src;\t// anything\n\t\t\t}\n\t\t\tif(src.nodeType && \"cloneNode\" in src){\n\t\t\t\t// DOM Node\n\t\t\t\treturn src.cloneNode(true); // Node\n\t\t\t}\n\t\t\tif(src instanceof Date){\n\t\t\t\t// Date\n\t\t\t\treturn new Date(src.getTime());\t// Date\n\t\t\t}\n\t\t\tif(src instanceof RegExp){\n\t\t\t\t// RegExp\n\t\t\t\treturn new RegExp(src);   // RegExp\n\t\t\t}\n\t\t\tvar r, i, l;\n\t\t\tif(lang.isArray(src)){\n\t\t\t\t// array\n\t\t\t\tr = [];\n\t\t\t\tfor(i = 0, l = src.length; i < l; ++i){\n\t\t\t\t\tif(i in src){\n\t\t\t\t\t\tr[i] = lang.clone(src[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// we don't clone functions for performance reasons\n\t\t\t\t//\t\t}else if(d.isFunction(src)){\n\t\t\t\t//\t\t\t// function\n\t\t\t\t//\t\t\tr = function(){ return src.apply(this, arguments); };\n\t\t\t}else{\n\t\t\t\t// generic objects\n\t\t\t\tr = src.constructor ? new src.constructor() : {};\n\t\t\t}\n\t\t\treturn lang._mixin(r, src, lang.clone);\n\t\t},\n\n\n\t\ttrim: String.prototype.trim ?\n\t\t\tfunction(str){ return str.trim(); } :\n\t\t\tfunction(str){ return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, ''); },\n\t\t/*=====\n\t\t trim: function(str){\n\t\t\t // summary:\n\t\t\t //\t\tTrims whitespace from both sides of the string\n\t\t\t // str: String\n\t\t\t //\t\tString to be trimmed\n\t\t\t // returns: String\n\t\t\t //\t\tReturns the trimmed string\n\t\t\t // description:\n\t\t\t //\t\tThis version of trim() was selected for inclusion into the base due\n\t\t\t //\t\tto its compact size and relatively good performance\n\t\t\t //\t\t(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)\n\t\t\t //\t\tUses String.prototype.trim instead, if available.\n\t\t\t //\t\tThe fastest but longest version of this function is located at\n\t\t\t //\t\tlang.string.trim()\n\t\t },\n\t\t =====*/\n\n\t\treplace: function(tmpl, map, pattern){\n\t\t\t// summary:\n\t\t\t//\t\tPerforms parameterized substitutions on a string. Throws an\n\t\t\t//\t\texception if any parameter is unmatched.\n\t\t\t// tmpl: String\n\t\t\t//\t\tString to be used as a template.\n\t\t\t// map: Object|Function\n\t\t\t//\t\tIf an object, it is used as a dictionary to look up substitutions.\n\t\t\t//\t\tIf a function, it is called for every substitution with following parameters:\n\t\t\t//\t\ta whole match, a name, an offset, and the whole template\n\t\t\t//\t\tstring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace\n\t\t\t//\t\tfor more details).\n\t\t\t// pattern: RegEx?\n\t\t\t//\t\tOptional regular expression objects that overrides the default pattern.\n\t\t\t//\t\tMust be global and match one item. The default is: /\\{([^\\}]+)\\}/g,\n\t\t\t//\t\twhich matches patterns like that: \"{xxx}\", where \"xxx\" is any sequence\n\t\t\t//\t\tof characters, which doesn't include \"}\".\n\t\t\t// returns: String\n\t\t\t//\t\tReturns the substituted string.\n\t\t\t// example:\n\t\t\t//\t|\t// uses a dictionary for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, {name.first} {name.last} AKA {nick}!\",\n\t\t\t//\t|\t\t{\n\t\t\t//\t|\t\t\tnick: \"Bob\",\n\t\t\t//\t|\t\t\tname: {\n\t\t\t//\t|\t\t\t\tfirst:\t\"Robert\",\n\t\t\t//\t|\t\t\t\tmiddle: \"X\",\n\t\t\t//\t|\t\t\t\tlast:\t\t\"Cringely\"\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t});\n\t\t\t//\t|\t// returns: Hello, Robert Cringely AKA Bob!\n\t\t\t// example:\n\t\t\t//\t|\t// uses an array for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, {0} {2}!\",\n\t\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"]);\n\t\t\t//\t|\t// returns: Hello, Robert Cringely!\n\t\t\t// example:\n\t\t\t//\t|\t// uses a function for substitutions:\n\t\t\t//\t|\tfunction sum(a){\n\t\t\t//\t|\t\tvar t = 0;\n\t\t\t//\t|\t\tarrayforEach(a, function(x){ t += x; });\n\t\t\t//\t|\t\treturn t;\n\t\t\t//\t|\t}\n\t\t\t//\t|\tlang.replace(\n\t\t\t//\t|\t\t\"{count} payments averaging {avg} USD per payment.\",\n\t\t\t//\t|\t\tlang.hitch(\n\t\t\t//\t|\t\t\t{ payments: [11, 16, 12] },\n\t\t\t//\t|\t\t\tfunction(_, key){\n\t\t\t//\t|\t\t\t\tswitch(key){\n\t\t\t//\t|\t\t\t\t\tcase \"count\": return this.payments.length;\n\t\t\t//\t|\t\t\t\t\tcase \"min\":\t\treturn Math.min.apply(Math, this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"max\":\t\treturn Math.max.apply(Math, this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"sum\":\t\treturn sum(this.payments);\n\t\t\t//\t|\t\t\t\t\tcase \"avg\":\t\treturn sum(this.payments) / this.payments.length;\n\t\t\t//\t|\t\t\t\t}\n\t\t\t//\t|\t\t\t}\n\t\t\t//\t|\t\t)\n\t\t\t//\t|\t);\n\t\t\t//\t|\t// prints: 3 payments averaging 13 USD per payment.\n\t\t\t// example:\n\t\t\t//\t|\t// uses an alternative PHP-like pattern for substitutions:\n\t\t\t//\t|\tlang.replace(\"Hello, ${0} ${2}!\",\n\t\t\t//\t|\t\t[\"Robert\", \"X\", \"Cringely\"], /\\$\\{([^\\}]+)\\}/g);\n\t\t\t//\t|\t// returns: Hello, Robert Cringely!\n\n\t\t\treturn tmpl.replace(pattern || _pattern, lang.isFunction(map) ?\n\t\t\t\tmap : function(_, k){ return lang.getObject(k, false, map); });\n\t\t}\n\t};\n\n\thas(\"extend-dojo\") && lang.mixin(dojo, lang);\n\n\treturn lang;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/_base/lang.js?");

/***/ }),

/***/ "./node_modules/dojo/aspect.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/aspect.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n\n\t// module:\n\t//\t\tdojo/aspect\n\n\t\"use strict\";\n\tvar undefined;\n\tfunction advise(dispatcher, type, advice, receiveArguments){\n\t\tvar previous = dispatcher[type];\n\t\tvar around = type == \"around\";\n\t\tvar signal;\n\t\tif(around){\n\t\t\tvar advised = advice(function(){\n\t\t\t\treturn previous.advice(this, arguments);\n\t\t\t});\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tif(advised){\n\t\t\t\t\t\tadvised = dispatcher = advice = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tadvice: function(target, args){\n\t\t\t\t\treturn advised ?\n\t\t\t\t\t\tadvised.apply(target, args) :  // called the advised function\n\t\t\t\t\t\tprevious.advice(target, args); // cancelled, skip to next one\n\t\t\t\t}\n\t\t\t};\n\t\t}else{\n\t\t\t// create the remove handler\n\t\t\tsignal = {\n\t\t\t\tremove: function(){\n\t\t\t\t\tif(signal.advice){\n\t\t\t\t\t\tvar previous = signal.previous;\n\t\t\t\t\t\tvar next = signal.next;\n\t\t\t\t\t\tif(!next && !previous){\n\t\t\t\t\t\t\tdelete dispatcher[type];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tif(previous){\n\t\t\t\t\t\t\t\tprevious.next = next;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tdispatcher[type] = next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(next){\n\t\t\t\t\t\t\t\tnext.previous = previous;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// remove the advice to signal that this signal has been removed\n\t\t\t\t\t\tdispatcher = advice = signal.advice = null;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tid: dispatcher.nextId++,\n\t\t\t\tadvice: advice,\n\t\t\t\treceiveArguments: receiveArguments\n\t\t\t};\n\t\t}\n\t\tif(previous && !around){\n\t\t\tif(type == \"after\"){\n\t\t\t\t// add the listener to the end of the list\n\t\t\t\t// note that we had to change this loop a little bit to workaround a bizarre IE10 JIT bug\n\t\t\t\twhile(previous.next && (previous = previous.next)){}\n\t\t\t\tprevious.next = signal;\n\t\t\t\tsignal.previous = previous;\n\t\t\t}else if(type == \"before\"){\n\t\t\t\t// add to beginning\n\t\t\t\tdispatcher[type] = signal;\n\t\t\t\tsignal.next = previous;\n\t\t\t\tprevious.previous = signal;\n\t\t\t}\n\t\t}else{\n\t\t\t// around or first one just replaces\n\t\t\tdispatcher[type] = signal;\n\t\t}\n\t\treturn signal;\n\t}\n\tfunction aspect(type){\n\t\treturn function(target, methodName, advice, receiveArguments){\n\t\t\tvar existing = target[methodName], dispatcher;\n\t\t\tif(!existing || existing.target != target){\n\t\t\t\t// no dispatcher in place\n\t\t\t\ttarget[methodName] = dispatcher = function(){\n\t\t\t\t\tvar executionId = dispatcher.nextId;\n\t\t\t\t\t// before advice\n\t\t\t\t\tvar args = arguments;\n\t\t\t\t\tvar before = dispatcher.before;\n\t\t\t\t\twhile(before){\n\t\t\t\t\t\tif(before.advice){\n\t\t\t\t\t\t\targs = before.advice.apply(this, args) || args;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbefore = before.next;\n\t\t\t\t\t}\n\t\t\t\t\t// around advice\n\t\t\t\t\tif(dispatcher.around){\n\t\t\t\t\t\tvar results = dispatcher.around.advice(this, args);\n\t\t\t\t\t}\n\t\t\t\t\t// after advice\n\t\t\t\t\tvar after = dispatcher.after;\n\t\t\t\t\twhile(after && after.id < executionId){\n\t\t\t\t\t\tif(after.advice){\n\t\t\t\t\t\t\tif(after.receiveArguments){\n\t\t\t\t\t\t\t\tvar newResults = after.advice.apply(this, args);\n\t\t\t\t\t\t\t\t// change the return value only if a new value was returned\n\t\t\t\t\t\t\t\tresults = newResults === undefined ? results : newResults;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tresults = after.advice.call(this, results, args);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tafter = after.next;\n\t\t\t\t\t}\n\t\t\t\t\treturn results;\n\t\t\t\t};\n\t\t\t\tif(existing){\n\t\t\t\t\tdispatcher.around = {advice: function(target, args){\n\t\t\t\t\t\treturn existing.apply(target, args);\n\t\t\t\t\t}};\n\t\t\t\t}\n\t\t\t\tdispatcher.target = target;\n\t\t\t\tdispatcher.nextId = dispatcher.nextId || 0;\n\t\t\t}\n\t\t\tvar results = advise((dispatcher || existing), type, advice, receiveArguments);\n\t\t\tadvice = null;\n\t\t\treturn results;\n\t\t};\n\t}\n\n\t// TODOC: after/before/around return object\n\n\tvar after = aspect(\"after\");\n\t/*=====\n\tafter = function(target, methodName, advice, receiveArguments){\n\t\t// summary:\n\t\t//\t\tThe \"after\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"after\" advice to a method. This function will be executed after the original method\n\t\t//\t\tis executed. By default the function will be called with a single argument, the return\n\t\t//\t\tvalue of the original method, or the the return value of the last executed advice (if a previous one exists).\n\t\t//\t\tThe fourth (optional) argument can be set to true to so the function receives the original\n\t\t//\t\targuments (from when the original method was called) rather than the return value.\n\t\t//\t\tIf there are multiple \"after\" advisors, they are executed in the order they were registered.\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called after the original method\n\t\t// receiveArguments: Boolean?\n\t\t//\t\tIf this is set to true, the advice function receives the original arguments (from when the original mehtod\n\t\t//\t\twas called) rather than the return value of the original/previous method.\n\t\t// returns:\n\t\t//\t\tA signal object that can be used to cancel the advice. If remove() is called on this signal object, it will\n\t\t//\t\tstop the advice function from being executed.\n\t};\n\t=====*/\n\n\tvar before = aspect(\"before\");\n\t/*=====\n\tbefore = function(target, methodName, advice){\n\t\t// summary:\n\t\t//\t\tThe \"before\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"before\" advice to a method. This function will be executed before the original method\n\t\t//\t\tis executed. This function will be called with the arguments used to call the method.\n\t\t//\t\tThis function may optionally return an array as the new arguments to use to call\n\t\t//\t\tthe original method (or the previous, next-to-execute before advice, if one exists).\n\t\t//\t\tIf the before method doesn't return anything (returns undefined) the original arguments\n\t\t//\t\twill be preserved.\n\t\t//\t\tIf there are multiple \"before\" advisors, they are executed in the reverse order they were registered.\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called before the original method\n\t};\n\t=====*/\n\n\tvar around = aspect(\"around\");\n\t/*=====\n\t around = function(target, methodName, advice){\n\t\t// summary:\n\t\t//\t\tThe \"around\" export of the aspect module is a function that can be used to attach\n\t\t//\t\t\"around\" advice to a method. The advisor function is immediately executed when\n\t\t//\t\tthe around() is called, is passed a single argument that is a function that can be\n\t\t//\t\tcalled to continue execution of the original method (or the next around advisor).\n\t\t//\t\tThe advisor function should return a function, and this function will be called whenever\n\t\t//\t\tthe method is called. It will be called with the arguments used to call the method.\n\t\t//\t\tWhatever this function returns will be returned as the result of the method call (unless after advise changes it).\n\t\t// example:\n\t\t//\t\tIf there are multiple \"around\" advisors, the most recent one is executed first,\n\t\t//\t\twhich can then delegate to the next one and so on. For example:\n\t\t//\t\t|\taround(obj, \"foo\", function(originalFoo){\n\t\t//\t\t|\t\treturn function(){\n\t\t//\t\t|\t\t\tvar start = new Date().getTime();\n\t\t//\t\t|\t\t\tvar results = originalFoo.apply(this, arguments); // call the original\n\t\t//\t\t|\t\t\tvar end = new Date().getTime();\n\t\t//\t\t|\t\t\tconsole.log(\"foo execution took \" + (end - start) + \" ms\");\n\t\t//\t\t|\t\t\treturn results;\n\t\t//\t\t|\t\t};\n\t\t//\t\t|\t});\n\t\t// target: Object\n\t\t//\t\tThis is the target object\n\t\t// methodName: String\n\t\t//\t\tThis is the name of the method to attach to.\n\t\t// advice: Function\n\t\t//\t\tThis is function to be called around the original method\n\t};\n\t=====*/\n\n\treturn {\n\t\t// summary:\n\t\t//\t\tprovides aspect oriented programming functionality, allowing for\n\t\t//\t\tone to add before, around, or after advice on existing methods.\n\t\t// example:\n\t\t//\t|\tdefine([\"dojo/aspect\"], function(aspect){\n\t\t//\t|\t\tvar signal = aspect.after(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t\tthis will be called when targetObject.methodName() is called, after the original function is called\n\t\t//\t|\t\t});\n\t\t//\n\t\t// example:\n\t\t//\tThe returned signal object can be used to cancel the advice.\n\t\t//\t|\tsignal.remove(); // this will stop the advice from being executed anymore\n\t\t//\t|\taspect.before(targetObject, \"methodName\", function(someArgument){\n\t\t//\t|\t\t// this will be called when targetObject.methodName() is called, before the original function is called\n\t\t//\t|\t });\n\n\t\tbefore: before,\n\t\taround: around,\n\t\tafter: after\n\t};\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/aspect.js?");

/***/ }),

/***/ "./node_modules/dojo/date/stamp.js":
/*!*****************************************!*\
  !*** ./node_modules/dojo/date/stamp.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\"), __webpack_require__(/*! ../_base/array */ \"./node_modules/dojo/_base/array.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, array){\n\n// module:\n//\t\tdojo/date/stamp\n\nvar stamp = {\n\t// summary:\n\t//\t\tTODOC\n};\nlang.setObject(\"dojo.date.stamp\", stamp);\n\n// Methods to convert dates to or from a wire (string) format using well-known conventions\n\nstamp.fromISOString = function(/*String*/ formattedString, /*Number?*/ defaultTime){\n\t// summary:\n\t//\t\tReturns a Date object given a string formatted according to a subset of the ISO-8601 standard.\n\t//\n\t// description:\n\t//\t\tAccepts a string formatted according to a profile of ISO8601 as defined by\n\t//\t\t[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.\n\t//\t\tCan also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)\n\t//\t\tThe following combinations are valid:\n\t//\n\t//\t\t- dates only\n\t//\t\t\t- yyyy\n\t//\t\t\t- yyyy-MM\n\t//\t\t\t- yyyy-MM-dd\n\t//\t\t- times only, with an optional time zone appended\n\t//\t\t\t- THH:mm\n\t//\t\t\t- THH:mm:ss\n\t//\t\t\t- THH:mm:ss.SSS\n\t//\t\t- and \"datetimes\" which could be any combination of the above\n\t//\n\t//\t\ttimezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm\n\t//\t\tAssumes the local time zone if not specified.  Does not validate.  Improperly formatted\n\t//\t\tinput may return null.  Arguments which are out of bounds will be handled\n\t//\t\tby the Date constructor (e.g. January 32nd typically gets resolved to February 1st)\n\t//\t\tOnly years between 100 and 9999 are supported.\n  \t// formattedString:\n\t//\t\tA string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00\n\t// defaultTime:\n\t//\t\tUsed for defaults for fields omitted in the formattedString.\n\t//\t\tUses 1970-01-01T00:00:00.0Z by default.\n\n\tif(!stamp._isoRegExp){\n\t\tstamp._isoRegExp =\n//TODO: could be more restrictive and check for 00-59, etc.\n\t\t\t/^(?:(\\d{4})(?:-(\\d{2})(?:-(\\d{2}))?)?)?(?:T(\\d{2}):(\\d{2})(?::(\\d{2})(.\\d+)?)?((?:[+-](\\d{2}):(\\d{2}))|Z)?)?$/;\n\t}\n\n\tvar match = stamp._isoRegExp.exec(formattedString),\n\t\tresult = null;\n\n\tif(match){\n\t\tmatch.shift();\n\t\tif(match[1]){match[1]--;} // Javascript Date months are 0-based\n\t\tif(match[6]){match[6] *= 1000;} // Javascript Date expects fractional seconds as milliseconds\n\n\t\tif(defaultTime){\n\t\t\t// mix in defaultTime.  Relatively expensive, so use || operators for the fast path of defaultTime === 0\n\t\t\tdefaultTime = new Date(defaultTime);\n\t\t\tarray.forEach(array.map([\"FullYear\", \"Month\", \"Date\", \"Hours\", \"Minutes\", \"Seconds\", \"Milliseconds\"], function(prop){\n\t\t\t\treturn defaultTime[\"get\" + prop]();\n\t\t\t}), function(value, index){\n\t\t\t\tmatch[index] = match[index] || value;\n\t\t\t});\n\t\t}\n\t\tresult = new Date(match[0]||1970, match[1]||0, match[2]||1, match[3]||0, match[4]||0, match[5]||0, match[6]||0); //TODO: UTC defaults\n\t\tif(match[0] < 100){\n\t\t\tresult.setFullYear(match[0] || 1970);\n\t\t}\n\n\t\tvar offset = 0,\n\t\t\tzoneSign = match[7] && match[7].charAt(0);\n\t\tif(zoneSign != 'Z'){\n\t\t\toffset = ((match[8] || 0) * 60) + (Number(match[9]) || 0);\n\t\t\tif(zoneSign != '-'){ offset *= -1; }\n\t\t}\n\t\tif(zoneSign){\n\t\t\toffset -= result.getTimezoneOffset();\n\t\t}\n\t\tif(offset){\n\t\t\tresult.setTime(result.getTime() + offset * 60000);\n\t\t}\n\t}\n\n\treturn result; // Date or null\n};\n\n/*=====\nvar __Options = {\n\t// selector: String\n\t//\t\t\"date\" or \"time\" for partial formatting of the Date object.\n\t//\t\tBoth date and time will be formatted by default.\n\t// zulu: Boolean\n\t//\t\tif true, UTC/GMT is used for a timezone\n\t// milliseconds: Boolean\n\t//\t\tif true, output milliseconds\n};\n=====*/\n\nstamp.toISOString = function(/*Date*/ dateObject, /*__Options?*/ options){\n\t// summary:\n\t//\t\tFormat a Date object as a string according a subset of the ISO-8601 standard\n\t//\n\t// description:\n\t//\t\tWhen options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)\n\t//\t\tThe local time zone is included as an offset from GMT, except when selector=='time' (time without a date)\n\t//\t\tDoes not check bounds.  Only years between 100 and 9999 are supported.\n\t//\n\t// dateObject:\n\t//\t\tA Date object\n\n\tvar _ = function(n){ return (n < 10) ? \"0\" + n : n; };\n\toptions = options || {};\n\tvar formattedDate = [],\n\t\tgetter = options.zulu ? \"getUTC\" : \"get\",\n\t\tdate = \"\";\n\tif(options.selector != \"time\"){\n\t\tvar year = dateObject[getter+\"FullYear\"]();\n\t\tdate = [\"0000\".substr((year+\"\").length)+year, _(dateObject[getter+\"Month\"]()+1), _(dateObject[getter+\"Date\"]())].join('-');\n\t}\n\tformattedDate.push(date);\n\tif(options.selector != \"date\"){\n\t\tvar time = [_(dateObject[getter+\"Hours\"]()), _(dateObject[getter+\"Minutes\"]()), _(dateObject[getter+\"Seconds\"]())].join(':');\n\t\tvar millis = dateObject[getter+\"Milliseconds\"]();\n\t\tif(options.milliseconds){\n\t\t\ttime += \".\"+ (millis < 100 ? \"0\" : \"\") + _(millis);\n\t\t}\n\t\tif(options.zulu){\n\t\t\ttime += \"Z\";\n\t\t}else if(options.selector != \"time\"){\n\t\t\tvar timezoneOffset = dateObject.getTimezoneOffset();\n\t\t\tvar absOffset = Math.abs(timezoneOffset);\n\t\t\ttime += (timezoneOffset > 0 ? \"-\" : \"+\") +\n\t\t\t\t_(Math.floor(absOffset/60)) + \":\" + _(absOffset%60);\n\t\t}\n\t\tformattedDate.push(time);\n\t}\n\treturn formattedDate.join('T'); // String\n};\n\nreturn stamp;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/date/stamp.js?");

/***/ }),

/***/ "./node_modules/dojo/errors/CancelError.js":
/*!*************************************************!*\
  !*** ./node_modules/dojo/errors/CancelError.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./create */ \"./node_modules/dojo/errors/create.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(create){\n\t// module:\n\t//\t\tdojo/errors/CancelError\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tDefault error if a promise is canceled without a reason.\n\t};\n\t=====*/\n\n\treturn create(\"CancelError\", null, null, { dojoType: \"cancel\", log: false });\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/errors/CancelError.js?");

/***/ }),

/***/ "./node_modules/dojo/errors/create.js":
/*!********************************************!*\
  !*** ./node_modules/dojo/errors/create.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){\n\treturn function(name, ctor, base, props){\n\t\tbase = base || Error;\n\n\t\tvar ErrorCtor = function(message){\n\t\t\tif(base === Error){\n\t\t\t\tif(Error.captureStackTrace){\n\t\t\t\t\tError.captureStackTrace(this, ErrorCtor);\n\t\t\t\t}\n\n\t\t\t\t// Error.call() operates on the returned error\n\t\t\t\t// object rather than operating on |this|\n\t\t\t\tvar err = Error.call(this, message),\n\t\t\t\t\tprop;\n\n\t\t\t\t// Copy own properties from err to |this|\n\t\t\t\tfor(prop in err){\n\t\t\t\t\tif(err.hasOwnProperty(prop)){\n\t\t\t\t\t\tthis[prop] = err[prop];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// messsage is non-enumerable in ES5\n\t\t\t\tthis.message = message;\n\t\t\t\t// stack is non-enumerable in at least Firefox\n\t\t\t\tthis.stack = err.stack;\n\t\t\t}else{\n\t\t\t\tbase.apply(this, arguments);\n\t\t\t}\n\t\t\tif(ctor){\n\t\t\t\tctor.apply(this, arguments);\n\t\t\t}\n\t\t};\n\n\t\tErrorCtor.prototype = lang.delegate(base.prototype, props);\n\t\tErrorCtor.prototype.name = name;\n\t\tErrorCtor.prototype.constructor = ErrorCtor;\n\n\t\treturn ErrorCtor;\n\t};\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/errors/create.js?");

/***/ }),

/***/ "./node_modules/dojo/global.js":
/*!*************************************!*\
  !*** ./node_modules/dojo/global.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n    if (typeof global !== 'undefined' && typeof global !== 'function') {\n        // global spec defines a reference to the global object called 'global'\n        // https://github.com/tc39/proposal-global\n        // `global` is also defined in NodeJS\n        return global;\n    }\n    else if (typeof window !== 'undefined') {\n        // window is defined in browsers\n        return window;\n    }\n    else if (typeof self !== 'undefined') {\n        // self is defined in WebWorkers\n        return self;\n    }\n    return this;\n}).call(null, __webpack_require__, exports, module),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/global.js?");

/***/ }),

/***/ "./node_modules/dojo/has.js":
/*!**********************************!*\
  !*** ./node_modules/dojo/has.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./global */ \"./node_modules/dojo/global.js\"), __webpack_require__.dj.c(module.i), __webpack_require__.dj.m(module)], __WEBPACK_AMD_DEFINE_RESULT__ = (function(global, require, module){\n\t// module:\n\t//\t\tdojo/has\n\t// summary:\n\t//\t\tDefines the has.js API and several feature tests used by dojo.\n\t// description:\n\t//\t\tThis module defines the has API as described by the project has.js with the following additional features:\n\t//\n\t//\t\t- the has test cache is exposed at has.cache.\n\t//\t\t- the method has.add includes a forth parameter that controls whether or not existing tests are replaced\n\t//\t\t- the loader's has cache may be optionally copied into this module's has cahce.\n\t//\n\t//\t\tThis module adopted from https://github.com/phiggins42/has.js; thanks has.js team!\n\n\t// try to pull the has implementation from the loader; both the dojo loader and bdLoad provide one\n\t// if using a foreign loader, then the has cache may be initialized via the config object for this module\n\t// WARNING: if a foreign loader defines require.has to be something other than the has.js API, then this implementation fail\n\tvar has = require.has || function(){};\n\tif(!has(\"dojo-has-api\")){\n\t\tvar\n\t\t\tisBrowser =\n\t\t\t\t// the most fundamental decision: are we in the browser?\n\t\t\t\ttypeof window != \"undefined\" &&\n\t\t\t\ttypeof location != \"undefined\" &&\n\t\t\t\ttypeof document != \"undefined\" &&\n\t\t\t\twindow.location == location && window.document == document,\n\n\t\t\t// has API variables\n\t\t\tdoc = isBrowser && document,\n\t\t\telement = doc && doc.createElement(\"DiV\"),\n\t\t\tcache = (module.config && module.config()) || {};\n\n\t\thas = function(name){\n\t\t\t// summary:\n\t\t\t//\t\tReturn the current value of the named feature.\n\t\t\t//\n\t\t\t// name: String|Integer\n\t\t\t//\t\tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t//\n\t\t\t// description:\n\t\t\t//\t\tReturns the value of the feature named by name. The feature must have been\n\t\t\t//\t\tpreviously added to the cache by has.add.\n\n\t\t\treturn typeof cache[name] == \"function\" ? (cache[name] = cache[name](global, doc, element)) : cache[name]; // Boolean\n\t\t};\n\n\t\thas.cache = cache;\n\n\t\thas.add = function(name, test, now, force){\n\t\t\t// summary:\n\t\t\t//\t \tRegister a new feature test for some named feature.\n\t\t\t// name: String|Integer\n\t\t\t//\t \tThe name (if a string) or identifier (if an integer) of the feature to test.\n\t\t\t// test: Function\n\t\t\t//\t\t A test function to register. If a function, queued for testing until actually\n\t\t\t//\t\t needed. The test function should return a boolean indicating\n\t\t\t//\t \tthe presence of a feature or bug.\n\t\t\t// now: Boolean?\n\t\t\t//\t\t Optional. Omit if `test` is not a function. Provides a way to immediately\n\t\t\t//\t\t run the test and cache the result.\n\t\t\t// force: Boolean?\n\t\t\t//\t \tOptional. If the test already exists and force is truthy, then the existing\n\t\t\t//\t \ttest will be replaced; otherwise, add does not replace an existing test (that\n\t\t\t//\t \tis, by default, the first test advice wins).\n\t\t\t// example:\n\t\t\t//\t\tA redundant test, testFn with immediate execution:\n\t\t\t//\t|\thas.add(\"javascript\", function(){ return true; }, true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tAgain with the redundantness. You can do this in your tests, but we should\n\t\t\t//\t\tnot be doing this in any internal has.js tests\n\t\t\t//\t|\thas.add(\"javascript\", true);\n\t\t\t//\n\t\t\t// example:\n\t\t\t//\t\tThree things are passed to the testFunction. `global`, `document`, and a generic element\n\t\t\t//\t\tfrom which to work your test should the need arise.\n\t\t\t//\t|\thas.add(\"bug-byid\", function(g, d, el){\n\t\t\t//\t|\t\t// g\t== global, typically window, yadda yadda\n\t\t\t//\t|\t\t// d\t== document object\n\t\t\t//\t|\t\t// el == the generic element. a `has` element.\n\t\t\t//\t|\t\treturn false; // fake test, byid-when-form-has-name-matching-an-id is slightly longer\n\t\t\t//\t|\t});\n\n\t\t\t(typeof cache[name]==\"undefined\" || force) && (cache[name]= test);\n\t\t\treturn now && has(name);\n\t\t};\n\n\t\t// since we're operating under a loader that doesn't provide a has API, we must explicitly initialize\n\t\t// has as it would have otherwise been initialized by the dojo loader; use has.add to the builder\n\t\t// can optimize these away iff desired\n\t\thas.add(\"host-browser\", isBrowser);\n\t\thas.add(\"host-node\", (typeof process == \"object\" && process.versions && process.versions.node && process.versions.v8));\n\t\thas.add(\"host-rhino\", (typeof load == \"function\" && (typeof Packages == \"function\" || typeof Packages == \"object\")));\n\t\thas.add(\"dom\", isBrowser);\n\t\thas.add(\"dojo-dom-ready-api\", 1);\n\t\thas.add(\"dojo-sniff\", 1);\n\t}\n\n\tif(has(\"host-browser\")){\n\t\t// Common application level tests\n\t\thas.add(\"dom-addeventlistener\", !!document.addEventListener);\n\n\t\t// Do the device and browser have touch capability?\n\t\thas.add(\"touch\", \"ontouchstart\" in document\n\t\t\t|| (\"onpointerdown\" in document && navigator.maxTouchPoints > 0)\n\t\t\t|| window.navigator.msMaxTouchPoints);\n\n\t\t// Touch events support\n\t\thas.add(\"touch-events\", \"ontouchstart\" in document);\n\n\t\t// Test if pointer events are supported and enabled, with either standard names (\"pointerdown\" etc.) or\n\t\t// IE specific names (\"MSPointerDown\" etc.).  Tests are designed to work on embedded C# WebBrowser Controls\n\t\t// in addition to IE, Edge, and future versions of Firefox and Chrome.\n\t\t// Note that on IE11, has(\"pointer-events\") and has(\"MSPointer\") are both true.\n\t\thas.add(\"pointer-events\", \"pointerEnabled\" in window.navigator ?\n\t\t\t\twindow.navigator.pointerEnabled : \"PointerEvent\" in window);\n\t\thas.add(\"MSPointer\", window.navigator.msPointerEnabled);\n\t\t// The \"pointermove\"\" event is only continuously emitted in a touch environment if\n\t\t// the target node's \"touch-action\"\" CSS property is set to \"none\"\n\t\t// https://www.w3.org/TR/pointerevents/#the-touch-action-css-property\n\t\thas.add(\"touch-action\", has(\"touch\") && has(\"pointer-events\"));\n\n\t\t// I don't know if any of these tests are really correct, just a rough guess\n\t\thas.add(\"device-width\", screen.availWidth || innerWidth);\n\n\t\t// Tests for DOMNode.attributes[] behavior:\n\t\t//\t - dom-attributes-explicit - attributes[] only lists explicitly user specified attributes\n\t\t//\t - dom-attributes-specified-flag (IE8) - need to check attr.specified flag to skip attributes user didn't specify\n\t\t//\t - Otherwise, in IE6-7. attributes[] will list hundreds of values, so need to do outerHTML to get attrs instead.\n\t\tvar form = document.createElement(\"form\");\n\t\thas.add(\"dom-attributes-explicit\", form.attributes.length == 0); // W3C\n\t\thas.add(\"dom-attributes-specified-flag\", form.attributes.length > 0 && form.attributes.length < 40);\t// IE8\n\t}\n\n\thas.clearElement = function(element){\n\t\t// summary:\n\t\t//\t Deletes the contents of the element passed to test functions.\n\t\telement.innerHTML= \"\";\n\t\treturn element;\n\t};\n\n\thas.normalize = function(id, toAbsMid){\n\t\t// summary:\n\t\t//\t Resolves id into a module id based on possibly-nested tenary expression that branches on has feature test value(s).\n\t\t//\n\t\t// toAbsMid: Function\n\t\t//\t Resolves a relative module id into an absolute module id\n\t\tvar\n\t\t\ttokens = id.match(/[\\?:]|[^:\\?]*/g), i = 0,\n\t\t\tget = function(skip){\n\t\t\t\tvar term = tokens[i++];\n\t\t\t\tif(term == \":\"){\n\t\t\t\t\t// empty string module name, resolves to 0\n\t\t\t\t\treturn 0;\n\t\t\t\t}else{\n\t\t\t\t\t// postfixed with a ? means it is a feature to branch on, the term is the name of the feature\n\t\t\t\t\tif(tokens[i++] == \"?\"){\n\t\t\t\t\t\tif(!skip && has(term)){\n\t\t\t\t\t\t\t// matched the feature, get the first value from the options\n\t\t\t\t\t\t\treturn get();\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// did not match, get the second value, passing over the first\n\t\t\t\t\t\t\tget(true);\n\t\t\t\t\t\t\treturn get(skip);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// a module\n\t\t\t\t\treturn term || 0;\n\t\t\t\t}\n\t\t\t};\n\t\tid = get();\n\t\treturn id && toAbsMid(id);\n\t};\n\n\thas.load = function(id, parentRequire, loaded){\n\t\t// summary:\n\t\t//\t\tConditional loading of AMD modules based on a has feature test value.\n\t\t// id: String\n\t\t//\t\tGives the resolved module id to load.\n\t\t// parentRequire: Function\n\t\t//\t\tThe loader require function with respect to the module that contained the plugin resource in it's\n\t\t//\t\tdependency list.\n\t\t// loaded: Function\n\t\t//\t Callback to loader that consumes result of plugin demand.\n\n\t\tif(id){\n\t\t\tparentRequire([id], loaded);\n\t\t}else{\n\t\t\tloaded();\n\t\t}\n\t};\n\n\treturn has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/has.js?");

/***/ }),

/***/ "./node_modules/dojo/json.js":
/*!***********************************!*\
  !*** ./node_modules/dojo/json.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ \"./node_modules/dojo/has.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has){\n\t\"use strict\";\n\tvar hasJSON = typeof JSON != \"undefined\";\n\thas.add(\"json-parse\", hasJSON); // all the parsers work fine\n\t\t// Firefox 3.5/Gecko 1.9 fails to use replacer in stringify properly https://bugzilla.mozilla.org/show_bug.cgi?id=509184\n\thas.add(\"json-stringify\", hasJSON && JSON.stringify({a:0}, function(k,v){return v||1;}) == '{\"a\":1}');\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tFunctions to parse and serialize JSON\n\n\t\tparse: function(str, strict){\n\t\t\t// summary:\n\t\t\t//\t\tParses a [JSON](http://json.org) string to return a JavaScript object.\n\t\t\t// description:\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t//\t\tThrows for invalid JSON strings. This delegates to eval() if native JSON\n\t\t\t//\t\tsupport is not available. By default this will evaluate any valid JS expression.\n\t\t\t//\t\tWith the strict parameter set to true, the parser will ensure that only\n\t\t\t//\t\tvalid JSON strings are parsed (otherwise throwing an error). Without the strict\n\t\t\t//\t\tparameter, the content passed to this method must come\n\t\t\t//\t\tfrom a trusted source.\n\t\t\t// str:\n\t\t\t//\t\ta string literal of a JSON item, for instance:\n\t\t\t//\t\t`'{ \"foo\": [ \"bar\", 1, { \"baz\": \"thud\" } ] }'`\n\t\t\t// strict:\n\t\t\t//\t\tWhen set to true, this will ensure that only valid, secure JSON is ever parsed.\n\t\t\t//\t\tMake sure this is set to true for untrusted content. Note that on browsers/engines\n\t\t\t//\t\twithout native JSON support, setting this to true will run slower.\n\t\t},\n\t\tstringify: function(value, replacer, spacer){\n\t\t\t// summary:\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t// description:\n\t\t\t//\t\tReturns a [JSON](http://json.org) serialization of an object.\n\t\t\t//\t\tThis function follows [native JSON API](https://developer.mozilla.org/en/JSON)\n\t\t\t//\t\tNote that this doesn't check for infinite recursion, so don't do that!\n\t\t\t// value:\n\t\t\t//\t\tA value to be serialized.\n\t\t\t// replacer:\n\t\t\t//\t\tA replacer function that is called for each value and can return a replacement\n\t\t\t// spacer:\n\t\t\t//\t\tA spacer string to be used for pretty printing of JSON\n\t\t\t// example:\n\t\t\t//\t\tsimple serialization of a trivial object\n\t\t\t//\t|\tdefine([\"dojo/json\"], function(JSON){\n\t\t\t// \t|\t\tvar jsonStr = JSON.stringify({ howdy: \"stranger!\", isStrange: true });\n\t\t\t//\t|\t\tdoh.is('{\"howdy\":\"stranger!\",\"isStrange\":true}', jsonStr);\n\t\t}\n\t};\n\t=====*/\n\n\tif(has(\"json-stringify\")){\n\t\treturn JSON;\n\t}else{\n\t\tvar escapeString = function(/*String*/str){\n\t\t\t// summary:\n\t\t\t//\t\tAdds escape sequences for non-visual characters, double quote and\n\t\t\t//\t\tbackslash and surrounds with double quotes to form a valid string\n\t\t\t//\t\tliteral.\n\t\t\treturn ('\"' + str.replace(/([\"\\\\])/g, '\\\\$1') + '\"').\n\t\t\t\treplace(/[\\f]/g, \"\\\\f\").replace(/[\\b]/g, \"\\\\b\").replace(/[\\n]/g, \"\\\\n\").\n\t\t\t\treplace(/[\\t]/g, \"\\\\t\").replace(/[\\r]/g, \"\\\\r\"); // string\n\t\t};\n\t\treturn {\n\t\t\tparse: has(\"json-parse\") ? JSON.parse : function(str, strict){\n\t\t\t\tif(strict && !/^([\\s\\[\\{]*(?:\"(?:\\\\.|[^\"])*\"|-?\\d[\\d\\.]*(?:[Ee][+-]?\\d+)?|null|true|false|)[\\s\\]\\}]*(?:,|:|$))+$/.test(str)){\n\t\t\t\t\tthrow new SyntaxError(\"Invalid characters in JSON\");\n\t\t\t\t}\n\t\t\t\treturn eval('(' + str + ')');\n\t\t\t},\n\t\t\tstringify: function(value, replacer, spacer){\n\t\t\t\tvar undef;\n\t\t\t\tif(typeof replacer == \"string\"){\n\t\t\t\t\tspacer = replacer;\n\t\t\t\t\treplacer = null;\n\t\t\t\t}\n\t\t\t\tfunction stringify(it, indent, key){\n\t\t\t\t\tif(replacer){\n\t\t\t\t\t\tit = replacer(key, it);\n\t\t\t\t\t}\n\t\t\t\t\tvar val, objtype = typeof it;\n\t\t\t\t\tif(objtype == \"number\"){\n\t\t\t\t\t\treturn isFinite(it) ? it + \"\" : \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"boolean\"){\n\t\t\t\t\t\treturn it + \"\";\n\t\t\t\t\t}\n\t\t\t\t\tif(it === null){\n\t\t\t\t\t\treturn \"null\";\n\t\t\t\t\t}\n\t\t\t\t\tif(typeof it == \"string\"){\n\t\t\t\t\t\treturn escapeString(it);\n\t\t\t\t\t}\n\t\t\t\t\tif(objtype == \"function\" || objtype == \"undefined\"){\n\t\t\t\t\t\treturn undef; // undefined\n\t\t\t\t\t}\n\t\t\t\t\t// short-circuit for objects that support \"json\" serialization\n\t\t\t\t\t// if they return \"self\" then just pass-through...\n\t\t\t\t\tif(typeof it.toJSON == \"function\"){\n\t\t\t\t\t\treturn stringify(it.toJSON(key), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tif(it instanceof Date){\n\t\t\t\t\t\treturn '\"{FullYear}-{Month+}-{Date}T{Hours}:{Minutes}:{Seconds}Z\"'.replace(/\\{(\\w+)(\\+)?\\}/g, function(t, prop, plus){\n\t\t\t\t\t\t\tvar num = it[\"getUTC\" + prop]() + (plus ? 1 : 0);\n\t\t\t\t\t\t\treturn num < 10 ? \"0\" + num : num;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tif(it.valueOf() !== it){\n\t\t\t\t\t\t// primitive wrapper, try again unwrapped:\n\t\t\t\t\t\treturn stringify(it.valueOf(), indent, key);\n\t\t\t\t\t}\n\t\t\t\t\tvar nextIndent= spacer ? (indent + spacer) : \"\";\n\t\t\t\t\t/* we used to test for DOM nodes and throw, but FF serializes them as {}, so cross-browser consistency is probably not efficiently attainable */ \n\t\t\t\t\n\t\t\t\t\tvar sep = spacer ? \" \" : \"\";\n\t\t\t\t\tvar newLine = spacer ? \"\\n\" : \"\";\n\t\t\t\t\n\t\t\t\t\t// array\n\t\t\t\t\tif(it instanceof Array){\n\t\t\t\t\t\tvar itl = it.length, res = [];\n\t\t\t\t\t\tfor(key = 0; key < itl; key++){\n\t\t\t\t\t\t\tvar obj = it[key];\n\t\t\t\t\t\t\tval = stringify(obj, nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\tval = \"null\";\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tres.push(newLine + nextIndent + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn \"[\" + res.join(\",\") + newLine + indent + \"]\";\n\t\t\t\t\t}\n\t\t\t\t\t// generic object code path\n\t\t\t\t\tvar output = [];\n\t\t\t\t\tfor(key in it){\n\t\t\t\t\t\tvar keyStr;\n\t\t\t\t\t\tif(it.hasOwnProperty(key)){\n\t\t\t\t\t\t\tif(typeof key == \"number\"){\n\t\t\t\t\t\t\t\tkeyStr = '\"' + key + '\"';\n\t\t\t\t\t\t\t}else if(typeof key == \"string\"){\n\t\t\t\t\t\t\t\tkeyStr = escapeString(key);\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\t// skip non-string or number keys\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tval = stringify(it[key], nextIndent, key);\n\t\t\t\t\t\t\tif(typeof val != \"string\"){\n\t\t\t\t\t\t\t\t// skip non-serializable values\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// At this point, the most non-IE browsers don't get in this branch \n\t\t\t\t\t\t\t// (they have native JSON), so push is definitely the way to\n\t\t\t\t\t\t\toutput.push(newLine + nextIndent + keyStr + \":\" + sep + val);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn \"{\" + output.join(\",\") + newLine + indent + \"}\"; // String\n\t\t\t\t}\n\t\t\t\treturn stringify(value, \"\", \"\");\n\t\t\t}\n\t\t};\n\t}\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/json.js?");

/***/ }),

/***/ "./node_modules/dojo/on.js":
/*!*********************************!*\
  !*** ./node_modules/dojo/on.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__.dj.h(\"dom-addeventlistener?:./node_modules/dojo/aspect.js\"), __webpack_require__(/*! ./_base/kernel */ \"./node_modules/dojo/_base/kernel.js\"), __webpack_require__(/*! ./sniff */ \"./node_modules/dojo/sniff.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(aspect, dojo, has){\n\n\t\"use strict\";\n\tif(has(\"dom\")){ // check to make sure we are in a browser, this module should work anywhere\n\t\tvar major = window.ScriptEngineMajorVersion;\n\t\thas.add(\"jscript\", major && (major() + ScriptEngineMinorVersion() / 10));\n\t\thas.add(\"event-orientationchange\", has(\"touch\") && !has(\"android\")); // TODO: how do we detect this?\n\t\thas.add(\"event-stopimmediatepropagation\", window.Event && !!window.Event.prototype && !!window.Event.prototype.stopImmediatePropagation);\n\t\thas.add(\"event-focusin\", function(global, doc, element){\n\t\t\treturn 'onfocusin' in element;\n\t\t});\n\n\t\tif(has(\"touch\")){\n\t\t\thas.add(\"touch-can-modify-event-delegate\", function(){\n\t\t\t\t// This feature test checks whether deleting a property of an event delegate works\n\t\t\t\t// for a touch-enabled device. If it works, event delegation can be used as fallback\n\t\t\t\t// for browsers such as Safari in older iOS where deleting properties of the original\n\t\t\t\t// event does not work.\n\t\t\t\tvar EventDelegate = function(){};\n\t\t\t\tEventDelegate.prototype =\n\t\t\t\t\tdocument.createEvent(\"MouseEvents\"); // original event\n\t\t\t\t// Attempt to modify a property of an event delegate and check if\n\t\t\t\t// it succeeds. Depending on browsers and on whether dojo/on's\n\t\t\t\t// strict mode is stripped in a Dojo build, there are 3 known behaviors:\n\t\t\t\t// it may either succeed, or raise an error, or fail to set the property\n\t\t\t\t// without raising an error.\n\t\t\t\ttry{\n\t\t\t\t\tvar eventDelegate = new EventDelegate;\n\t\t\t\t\teventDelegate.target = null;\n\t\t\t\t\treturn eventDelegate.target === null;\n\t\t\t\t}catch(e){\n\t\t\t\t\treturn false; // cannot use event delegation\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tvar on = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tA function that provides core event listening functionality. With this function\n\t\t//\t\tyou can provide a target, event type, and listener to be notified of\n\t\t//\t\tfuture matching events that are fired.\n\t\t// target: Element|Object\n\t\t//\t\tThis is the target object or DOM element that to receive events from\n\t\t// type: String|Function\n\t\t//\t\tThis is the name of the event to listen for or an extension event type.\n\t\t// listener: Function\n\t\t//\t\tThis is the function that should be called when the event fires.\n\t\t// returns: Object\n\t\t//\t\tAn object with a remove() method that can be used to stop listening for this\n\t\t//\t\tevent.\n\t\t// description:\n\t\t//\t\tTo listen for \"click\" events on a button node, we can do:\n\t\t//\t\t|\tdefine([\"dojo/on\"], function(on){\n\t\t//\t\t|\t\ton(button, \"click\", clickHandler);\n\t\t//\t\t|\t\t...\n\t\t//\t\tEvented JavaScript objects can also have their own events.\n\t\t//\t\t|\tvar obj = new Evented;\n\t\t//\t\t|\ton(obj, \"foo\", fooHandler);\n\t\t//\t\tAnd then we could publish a \"foo\" event:\n\t\t//\t\t|\ton.emit(obj, \"foo\", {key: \"value\"});\n\t\t//\t\tWe can use extension events as well. For example, you could listen for a tap gesture:\n\t\t//\t\t|\tdefine([\"dojo/on\", \"dojo/gesture/tap\", function(on, tap){\n\t\t//\t\t|\t\ton(button, tap, tapHandler);\n\t\t//\t\t|\t\t...\n\t\t//\t\twhich would trigger fooHandler. Note that for a simple object this is equivalent to calling:\n\t\t//\t\t|\tobj.onfoo({key:\"value\"});\n\t\t//\t\tIf you use on.emit on a DOM node, it will use native event dispatching when possible.\n\n\t\tif(typeof target.on == \"function\" && typeof type != \"function\" && !target.nodeType){\n\t\t\t// delegate to the target's on() method, so it can handle it's own listening if it wants (unless it\n\t\t\t// is DOM node and we may be dealing with jQuery or Prototype's incompatible addition to the\n\t\t\t// Element prototype\n\t\t\treturn target.on(type, listener);\n\t\t}\n\t\t// delegate to main listener code\n\t\treturn on.parse(target, type, listener, addListener, dontFix, this);\n\t};\n\ton.pausable =  function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but with pausable functionality. The\n\t\t//\t\treturned signal object has pause() and resume() functions. Calling the\n\t\t//\t\tpause() method will cause the listener to not be called for future events. Calling the\n\t\t//\t\tresume() method will cause the listener to again be called for future events.\n\t\tvar paused;\n\t\tvar signal = on(target, type, function(){\n\t\t\tif(!paused){\n\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t}\n\t\t}, dontFix);\n\t\tsignal.pause = function(){\n\t\t\tpaused = true;\n\t\t};\n\t\tsignal.resume = function(){\n\t\t\tpaused = false;\n\t\t};\n\t\treturn signal;\n\t};\n\ton.once = function(target, type, listener, dontFix){\n\t\t// summary:\n\t\t//\t\tThis function acts the same as on(), but will only call the listener once. The\n\t\t//\t\tlistener will be called for the first\n\t\t//\t\tevent that takes place and then listener will automatically be removed.\n\t\tvar signal = on(target, type, function(){\n\t\t\t// remove this listener\n\t\t\tsignal.remove();\n\t\t\t// proceed to call the listener\n\t\t\treturn listener.apply(this, arguments);\n\t\t});\n\t\treturn signal;\n\t};\n\ton.parse = function(target, type, listener, addListener, dontFix, matchesTarget){\n\t\tvar events;\n\t\tif(type.call){\n\t\t\t// event handler function\n\t\t\t// on(node, touch.press, touchListener);\n\t\t\treturn type.call(matchesTarget, target, listener);\n\t\t}\n\n\t\tif(type instanceof Array){\n\t\t\t// allow an array of event names (or event handler functions)\n\t\t\tevents = type;\n\t\t}else if(type.indexOf(\",\") > -1){\n\t\t\t// we allow comma delimited event names, so you can register for multiple events at once\n\t\t\tevents = type.split(/\\s*,\\s*/);\n\t\t}\n\t\tif(events){\n\t\t\tvar handles = [];\n\t\t\tvar i = 0;\n\t\t\tvar eventName;\n\t\t\twhile(eventName = events[i++]){ // intentional assignment\n\t\t\t\thandles.push(on.parse(target, eventName, listener, addListener, dontFix, matchesTarget));\n\t\t\t}\n\t\t\thandles.remove = function(){\n\t\t\t\tfor(var i = 0; i < handles.length; i++){\n\t\t\t\t\thandles[i].remove();\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn handles;\n\t\t}\n\t\treturn addListener(target, type, listener, dontFix, matchesTarget);\n\t};\n\tvar touchEvents = /^touch/;\n\tfunction addListener(target, type, listener, dontFix, matchesTarget){\n\t\t// event delegation:\n\t\tvar selector = type.match(/(.*):(.*)/);\n\t\t// if we have a selector:event, the last one is interpreted as an event, and we use event delegation\n\t\tif(selector){\n\t\t\ttype = selector[2];\n\t\t\tselector = selector[1];\n\t\t\t// create the extension event for selectors and directly call it\n\t\t\treturn on.selector(selector, type).call(matchesTarget, target, listener);\n\t\t}\n\t\t// test to see if it a touch event right now, so we don't have to do it every time it fires\n\t\tif(has(\"touch\")){\n\t\t\tif(touchEvents.test(type)){\n\t\t\t\t// touch event, fix it\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t}\n\t\t\tif(!has(\"event-orientationchange\") && (type == \"orientationchange\")){\n\t\t\t\t//\"orientationchange\" not supported <= Android 2.1,\n\t\t\t\t//but works through \"resize\" on window\n\t\t\t\ttype = \"resize\";\n\t\t\t\ttarget = window;\n\t\t\t\tlistener = fixTouchListener(listener);\n\t\t\t}\n\t\t}\n\t\tif(addStopImmediate){\n\t\t\t// add stopImmediatePropagation if it doesn't exist\n\t\t\tlistener = addStopImmediate(listener);\n\t\t}\n\t\t// normal path, the target is |this|\n\t\tif(target.addEventListener){\n\t\t\t// the target has addEventListener, which should be used if available (might or might not be a node, non-nodes can implement this method as well)\n\t\t\t// check for capture conversions\n\t\t\tvar capture = type in captures,\n\t\t\t\tadjustedType = capture ? captures[type] : type;\n\t\t\ttarget.addEventListener(adjustedType, listener, capture);\n\t\t\t// create and return the signal\n\t\t\treturn {\n\t\t\t\tremove: function(){\n\t\t\t\t\ttarget.removeEventListener(adjustedType, listener, capture);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t\ttype = \"on\" + type;\n\t\tif(fixAttach && target.attachEvent){\n\t\t\treturn fixAttach(target, type, listener);\n\t\t}\n\t\tthrow new Error(\"Target must be an event emitter\");\n\t}\n\ton.matches = function(node, selector, context, children, matchesTarget) {\n\t\t// summary:\n\t\t//\t\tCheck if a node match the current selector within the constraint of a context\n\t\t// node: DOMNode\n\t\t//\t\tThe node that originate the event\n\t\t// selector: String\n\t\t//\t\tThe selector to check against\n\t\t// context: DOMNode\n\t\t//\t\tThe context to search in.\n\t\t// children: Boolean\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to\n\t\t//\t\ttrue\n\t\t// matchesTarget: Object|dojo/query?\n\t\t//\t\tAn object with a property \"matches\" as a function. Default is dojo/query.\n\t\t//\t\tMatching DOMNodes will be done against this function\n\t\t//\t\tThe function must return a Boolean.\n\t\t//\t\tIt will have 3 arguments: \"node\", \"selector\" and \"context\"\n\t\t//\t\tTrue is expected if \"node\" is matching the current \"selector\" in the passed \"context\"\n\t\t// returns: DOMNode?\n\t\t//\t\tThe matching node, if any. Else you get false\n\n\t\t// see if we have a valid matchesTarget or default to dojo/query\n\t\tmatchesTarget = matchesTarget && (typeof matchesTarget.matches == \"function\") ? matchesTarget : dojo.query;\n\t\tchildren = children !== false;\n\t\t// there is a selector, so make sure it matches\n\t\tif(node.nodeType != 1){\n\t\t\t// text node will fail in native match selector\n\t\t\tnode = node.parentNode;\n\t\t}\n\t\twhile(!matchesTarget.matches(node, selector, context)){\n\t\t\tif(node == context || children === false || !(node = node.parentNode) || node.nodeType != 1){ // intentional assignment\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn node;\n\t};\n\ton.selector = function(selector, eventType, children){\n\t\t// summary:\n\t\t//\t\tCreates a new extension event with event delegation. This is based on\n\t\t//\t\tthe provided event type (can be extension event) that\n\t\t//\t\tonly calls the listener when the CSS selector matches the target of the event.\n\t\t//\n\t\t//\t\tThe application must require() an appropriate level of dojo/query to handle the selector.\n\t\t// selector:\n\t\t//\t\tThe CSS selector to use for filter events and determine the |this| of the event listener.\n\t\t// eventType:\n\t\t//\t\tThe event to listen for\n\t\t// children:\n\t\t//\t\tIndicates if children elements of the selector should be allowed. This defaults to\n\t\t//\t\ttrue\n\t\t// example:\n\t\t// |\trequire([\"dojo/on\", \"dojo/mouse\", \"dojo/query!css2\"], function(on, mouse){\n\t\t// |\t\ton(node, on.selector(\".my-class\", mouse.enter), handlerForMyHover);\n\t\treturn function(target, listener){\n\t\t\t// if the selector is function, use it to select the node, otherwise use the matches method\n\t\t\tvar matchesTarget = typeof selector == \"function\" ? {matches: selector} : this,\n\t\t\t\tbubble = eventType.bubble;\n\t\t\tfunction select(eventTarget){\n\t\t\t\treturn on.matches(eventTarget, selector, target, children, matchesTarget);\n\t\t\t}\n\t\t\tif(bubble){\n\t\t\t\t// the event type doesn't naturally bubble, but has a bubbling form, use that, and give it the selector so it can perform the select itself\n\t\t\t\treturn on(target, bubble(select), listener);\n\t\t\t}\n\t\t\t// standard event delegation\n\t\t\treturn on(target, eventType, function(event){\n\t\t\t\t// call select to see if we match\n\t\t\t\tvar eventTarget = select(event.target);\n\t\t\t\t// if it matches we call the listener\n\t\t\t\tif (eventTarget) {\n\t\t\t\t\t// We save the matching target into the event, so it can be accessed even when hitching (see #18355)\n\t\t\t\t\tevent.selectorTarget = eventTarget;\n\t\t\t\t\treturn listener.call(eventTarget, event);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t};\n\n\tfunction syntheticPreventDefault(){\n\t\tthis.cancelable = false;\n\t\tthis.defaultPrevented = true;\n\t}\n\tfunction syntheticStopPropagation(){\n\t\tthis.bubbles = false;\n\t}\n\tvar slice = [].slice,\n\t\tsyntheticDispatch = on.emit = function(target, type, event){\n\t\t// summary:\n\t\t//\t\tFires an event on the target object.\n\t\t// target:\n\t\t//\t\tThe target object to fire the event on. This can be a DOM element or a plain\n\t\t//\t\tJS object. If the target is a DOM element, native event emitting mechanisms\n\t\t//\t\tare used when possible.\n\t\t// type:\n\t\t//\t\tThe event type name. You can emulate standard native events like \"click\" and\n\t\t//\t\t\"mouseover\" or create custom events like \"open\" or \"finish\".\n\t\t// event:\n\t\t//\t\tAn object that provides the properties for the event. See https://developer.mozilla.org/en/DOM/event.initEvent\n\t\t//\t\tfor some of the properties. These properties are copied to the event object.\n\t\t//\t\tOf particular importance are the cancelable and bubbles properties. The\n\t\t//\t\tcancelable property indicates whether or not the event has a default action\n\t\t//\t\tthat can be cancelled. The event is cancelled by calling preventDefault() on\n\t\t//\t\tthe event object. The bubbles property indicates whether or not the\n\t\t//\t\tevent will bubble up the DOM tree. If bubbles is true, the event will be called\n\t\t//\t\ton the target and then each parent successively until the top of the tree\n\t\t//\t\tis reached or stopPropagation() is called. Both bubbles and cancelable\n\t\t//\t\tdefault to false.\n\t\t// returns:\n\t\t//\t\tIf the event is cancelable and the event is not cancelled,\n\t\t//\t\temit will return true. If the event is cancelable and the event is cancelled,\n\t\t//\t\temit will return false.\n\t\t// details:\n\t\t//\t\tNote that this is designed to emit events for listeners registered through\n\t\t//\t\tdojo/on. It should actually work with any event listener except those\n\t\t//\t\tadded through IE's attachEvent (IE8 and below's non-W3C event emitting\n\t\t//\t\tdoesn't support custom event types). It should work with all events registered\n\t\t//\t\tthrough dojo/on. Also note that the emit method does do any default\n\t\t//\t\taction, it only returns a value to indicate if the default action should take\n\t\t//\t\tplace. For example, emitting a keypress event would not cause a character\n\t\t//\t\tto appear in a textbox.\n\t\t// example:\n\t\t//\t\tTo fire our own click event\n\t\t//\t|\trequire([\"dojo/on\", \"dojo/dom\"\n\t\t//\t|\t], function(on, dom){\n\t\t//\t|\t\ton.emit(dom.byId(\"button\"), \"click\", {\n\t\t//\t|\t\t\tcancelable: true,\n\t\t//\t|\t\t\tbubbles: true,\n\t\t//\t|\t\t\tscreenX: 33,\n\t\t//\t|\t\t\tscreenY: 44\n\t\t//\t|\t\t});\n\t\t//\t\tWe can also fire our own custom events:\n\t\t//\t|\t\ton.emit(dom.byId(\"slider\"), \"slide\", {\n\t\t//\t|\t\t\tcancelable: true,\n\t\t//\t|\t\t\tbubbles: true,\n\t\t//\t|\t\t\tdirection: \"left-to-right\"\n\t\t//\t|\t\t});\n\t\t//\t|\t});\n\t\tvar args = slice.call(arguments, 2);\n\t\tvar method = \"on\" + type;\n\t\tif(\"parentNode\" in target){\n\t\t\t// node (or node-like), create event controller methods\n\t\t\tvar newEvent = args[0] = {};\n\t\t\tfor(var i in event){\n\t\t\t\tnewEvent[i] = event[i];\n\t\t\t}\n\t\t\tnewEvent.preventDefault = syntheticPreventDefault;\n\t\t\tnewEvent.stopPropagation = syntheticStopPropagation;\n\t\t\tnewEvent.target = target;\n\t\t\tnewEvent.type = type;\n\t\t\tevent = newEvent;\n\t\t}\n\t\tdo{\n\t\t\t// call any node which has a handler (note that ideally we would try/catch to simulate normal event propagation but that causes too much pain for debugging)\n\t\t\ttarget[method] && target[method].apply(target, args);\n\t\t\t// and then continue up the parent node chain if it is still bubbling (if started as bubbles and stopPropagation hasn't been called)\n\t\t}while(event && event.bubbles && (target = target.parentNode));\n\t\treturn event && event.cancelable && event; // if it is still true (was cancelable and was cancelled), return the event to indicate default action should happen\n\t};\n\tvar captures = has(\"event-focusin\") ? {} : {focusin: \"focus\", focusout: \"blur\"};\n\tif(!has(\"event-stopimmediatepropagation\")){\n\t\tvar stopImmediatePropagation =function(){\n\t\t\tthis.immediatelyStopped = true;\n\t\t\tthis.modified = true; // mark it as modified so the event will be cached in IE\n\t\t};\n\t\tvar addStopImmediate = function(listener){\n\t\t\treturn function(event){\n\t\t\t\tif(!event.immediatelyStopped){// check to make sure it hasn't been stopped immediately\n\t\t\t\t\tevent.stopImmediatePropagation = stopImmediatePropagation;\n\t\t\t\t\treturn listener.apply(this, arguments);\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\tif(has(\"dom-addeventlistener\")){\n\t\t// emitter that works with native event handling\n\t\ton.emit = function(target, type, event){\n\t\t\tif(target.dispatchEvent && document.createEvent){\n\t\t\t\t// use the native event emitting mechanism if it is available on the target object\n\t\t\t\t// create a generic event\n\t\t\t\t// we could create branch into the different types of event constructors, but\n\t\t\t\t// that would be a lot of extra code, with little benefit that I can see, seems\n\t\t\t\t// best to use the generic constructor and copy properties over, making it\n\t\t\t\t// easy to have events look like the ones created with specific initializers\n\t\t\t\tvar ownerDocument = target.ownerDocument || document;\n\t\t\t\tvar nativeEvent = ownerDocument.createEvent(\"HTMLEvents\");\n\t\t\t\tnativeEvent.initEvent(type, !!event.bubbles, !!event.cancelable);\n\t\t\t\t// and copy all our properties over\n\t\t\t\tfor(var i in event){\n\t\t\t\t\tif(!(i in nativeEvent)){\n\t\t\t\t\t\tnativeEvent[i] = event[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn target.dispatchEvent(nativeEvent) && nativeEvent;\n\t\t\t}\n\t\t\treturn syntheticDispatch.apply(on, arguments); // emit for a non-node\n\t\t};\n\t}else{\n\t\t// no addEventListener, basically old IE event normalization\n\t\ton._fixEvent = function(evt, sender){\n\t\t\t// summary:\n\t\t\t//\t\tnormalizes properties on the event object including event\n\t\t\t//\t\tbubbling methods, keystroke normalization, and x/y positions\n\t\t\t// evt:\n\t\t\t//\t\tnative event object\n\t\t\t// sender:\n\t\t\t//\t\tnode to treat as \"currentTarget\"\n\t\t\tif(!evt){\n\t\t\t\tvar w = sender && (sender.ownerDocument || sender.document || sender).parentWindow || window;\n\t\t\t\tevt = w.event;\n\t\t\t}\n\t\t\tif(!evt){return evt;}\n\t\t\ttry{\n\t\t\t\tif(lastEvent && evt.type == lastEvent.type  && evt.srcElement == lastEvent.target){\n\t\t\t\t\t// should be same event, reuse event object (so it can be augmented);\n\t\t\t\t\t// accessing evt.srcElement rather than evt.target since evt.target not set on IE until fixup below\n\t\t\t\t\tevt = lastEvent;\n\t\t\t\t}\n\t\t\t}catch(e){\n\t\t\t\t// will occur on IE on lastEvent.type reference if lastEvent points to a previous event that already\n\t\t\t\t// finished bubbling, but the setTimeout() to clear lastEvent hasn't fired yet\n\t\t\t}\n\t\t\tif(!evt.target){ // check to see if it has been fixed yet\n\t\t\t\tevt.target = evt.srcElement;\n\t\t\t\tevt.currentTarget = (sender || evt.srcElement);\n\t\t\t\tif(evt.type == \"mouseover\"){\n\t\t\t\t\tevt.relatedTarget = evt.fromElement;\n\t\t\t\t}\n\t\t\t\tif(evt.type == \"mouseout\"){\n\t\t\t\t\tevt.relatedTarget = evt.toElement;\n\t\t\t\t}\n\t\t\t\tif(!evt.stopPropagation){\n\t\t\t\t\tevt.stopPropagation = stopPropagation;\n\t\t\t\t\tevt.preventDefault = preventDefault;\n\t\t\t\t}\n\t\t\t\tswitch(evt.type){\n\t\t\t\t\tcase \"keypress\":\n\t\t\t\t\t\tvar c = (\"charCode\" in evt ? evt.charCode : evt.keyCode);\n\t\t\t\t\t\tif (c==10){\n\t\t\t\t\t\t\t// CTRL-ENTER is CTRL-ASCII(10) on IE, but CTRL-ENTER on Mozilla\n\t\t\t\t\t\t\tc=0;\n\t\t\t\t\t\t\tevt.keyCode = 13;\n\t\t\t\t\t\t}else if(c==13||c==27){\n\t\t\t\t\t\t\tc=0; // Mozilla considers ENTER and ESC non-printable\n\t\t\t\t\t\t}else if(c==3){\n\t\t\t\t\t\t\tc=99; // Mozilla maps CTRL-BREAK to CTRL-c\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Mozilla sets keyCode to 0 when there is a charCode\n\t\t\t\t\t\t// but that stops the event on IE.\n\t\t\t\t\t\tevt.charCode = c;\n\t\t\t\t\t\t_setKeyChar(evt);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn evt;\n\t\t};\n\t\tvar lastEvent, IESignal = function(handle){\n\t\t\tthis.handle = handle;\n\t\t};\n\t\tIESignal.prototype.remove = function(){\n\t\t\tdelete _dojoIEListeners_[this.handle];\n\t\t};\n\t\tvar fixListener = function(listener){\n\t\t\t// this is a minimal function for closing on the previous listener with as few as variables as possible\n\t\t\treturn function(evt){\n\t\t\t\tevt = on._fixEvent(evt, this);\n\t\t\t\tvar result = listener.call(this, evt);\n\t\t\t\tif(evt.modified){\n\t\t\t\t\t// cache the last event and reuse it if we can\n\t\t\t\t\tif(!lastEvent){\n\t\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t\tlastEvent = null;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tlastEvent = evt;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t};\n\t\t};\n\t\tvar fixAttach = function(target, type, listener){\n\t\t\tlistener = fixListener(listener);\n\t\t\tif(((target.ownerDocument ? target.ownerDocument.parentWindow : target.parentWindow || target.window || window) != top ||\n\t\t\t\t\t\thas(\"jscript\") < 5.8) &&\n\t\t\t\t\t!has(\"config-_allow_leaks\")){\n\t\t\t\t// IE will leak memory on certain handlers in frames (IE8 and earlier) and in unattached DOM nodes for JScript 5.7 and below.\n\t\t\t\t// Here we use global redirection to solve the memory leaks\n\t\t\t\tif(typeof _dojoIEListeners_ == \"undefined\"){\n\t\t\t\t\t_dojoIEListeners_ = [];\n\t\t\t\t}\n\t\t\t\tvar emitter = target[type];\n\t\t\t\tif(!emitter || !emitter.listeners){\n\t\t\t\t\tvar oldListener = emitter;\n\t\t\t\t\temitter = Function('event', 'var callee = arguments.callee; for(var i = 0; i<callee.listeners.length; i++){var listener = _dojoIEListeners_[callee.listeners[i]]; if(listener){listener.call(this,event);}}');\n\t\t\t\t\temitter.listeners = [];\n\t\t\t\t\ttarget[type] = emitter;\n\t\t\t\t\temitter.global = this;\n\t\t\t\t\tif(oldListener){\n\t\t\t\t\t\temitter.listeners.push(_dojoIEListeners_.push(oldListener) - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar handle;\n\t\t\t\temitter.listeners.push(handle = (emitter.global._dojoIEListeners_.push(listener) - 1));\n\t\t\t\treturn new IESignal(handle);\n\t\t\t}\n\t\t\treturn aspect.after(target, type, listener, true);\n\t\t};\n\n\t\tvar _setKeyChar = function(evt){\n\t\t\tevt.keyChar = evt.charCode ? String.fromCharCode(evt.charCode) : '';\n\t\t\tevt.charOrCode = evt.keyChar || evt.keyCode;\t// TODO: remove for 2.0\n\t\t};\n\t\t// Called in Event scope\n\t\tvar stopPropagation = function(){\n\t\t\tthis.cancelBubble = true;\n\t\t};\n\t\tvar preventDefault = on._preventDefault = function(){\n\t\t\t// Setting keyCode to 0 is the only way to prevent certain keypresses (namely\n\t\t\t// ctrl-combinations that correspond to menu accelerator keys).\n\t\t\t// Otoh, it prevents upstream listeners from getting this information\n\t\t\t// Try to split the difference here by clobbering keyCode only for ctrl\n\t\t\t// combinations. If you still need to access the key upstream, bubbledKeyCode is\n\t\t\t// provided as a workaround.\n\t\t\tthis.bubbledKeyCode = this.keyCode;\n\t\t\tif(this.ctrlKey){\n\t\t\t\ttry{\n\t\t\t\t\t// squelch errors when keyCode is read-only\n\t\t\t\t\t// (e.g. if keyCode is ctrl or shift)\n\t\t\t\t\tthis.keyCode = 0;\n\t\t\t\t}catch(e){\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.defaultPrevented = true;\n\t\t\tthis.returnValue = false;\n\t\t\tthis.modified = true; // mark it as modified  (for defaultPrevented flag) so the event will be cached in IE\n\t\t};\n\t}\n\tif(has(\"touch\")){\n\t\tvar EventDelegate = function(){};\n\t\tvar windowOrientation = window.orientation;\n\t\tvar fixTouchListener = function(listener){\n\t\t\treturn function(originalEvent){\n\t\t\t\t//Event normalization(for ontouchxxx and resize):\n\t\t\t\t//1.incorrect e.pageX|pageY in iOS\n\t\t\t\t//2.there are no \"e.rotation\", \"e.scale\" and \"onorientationchange\" in Android\n\t\t\t\t//3.More TBD e.g. force | screenX | screenX | clientX | clientY | radiusX | radiusY\n\n\t\t\t\t// see if it has already been corrected\n\t\t\t\tvar event = originalEvent.corrected;\n\t\t\t\tif(!event){\n\t\t\t\t\tvar type = originalEvent.type;\n\t\t\t\t\ttry{\n\t\t\t\t\t\tdelete originalEvent.type; // on some JS engines (android), deleting properties makes them mutable\n\t\t\t\t\t}catch(e){}\n\t\t\t\t\tif(originalEvent.type){\n\t\t\t\t\t\t// Deleting the property of the original event did not work (this is the case of\n\t\t\t\t\t\t// browsers such as older Safari iOS), hence fallback:\n\t\t\t\t\t\tif(has(\"touch-can-modify-event-delegate\")){\n\t\t\t\t\t\t\t// If deleting properties of delegated event works, use event delegation:\n\t\t\t\t\t\t\tEventDelegate.prototype = originalEvent;\n\t\t\t\t\t\t\tevent = new EventDelegate;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t// Otherwise last fallback: other browsers, such as mobile Firefox, do not like\n\t\t\t\t\t\t\t// delegated properties, so we have to copy\n\t\t\t\t\t\t\tevent = {};\n\t\t\t\t\t\t\tfor(var name in originalEvent){\n\t\t\t\t\t\t\t\tevent[name] = originalEvent[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// have to delegate methods to make them work\n\t\t\t\t\t\tevent.preventDefault = function(){\n\t\t\t\t\t\t\toriginalEvent.preventDefault();\n\t\t\t\t\t\t};\n\t\t\t\t\t\tevent.stopPropagation = function(){\n\t\t\t\t\t\t\toriginalEvent.stopPropagation();\n\t\t\t\t\t\t};\n\t\t\t\t\t}else{\n\t\t\t\t\t\t// deletion worked, use property as is\n\t\t\t\t\t\tevent = originalEvent;\n\t\t\t\t\t\tevent.type = type;\n\t\t\t\t\t}\n\t\t\t\t\toriginalEvent.corrected = event;\n\t\t\t\t\tif(type == 'resize'){\n\t\t\t\t\t\tif(windowOrientation == window.orientation){\n\t\t\t\t\t\t\treturn null;//double tap causes an unexpected 'resize' in Android\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindowOrientation = window.orientation;\n\t\t\t\t\t\tevent.type = \"orientationchange\";\n\t\t\t\t\t\treturn listener.call(this, event);\n\t\t\t\t\t}\n\t\t\t\t\t// We use the original event and augment, rather than doing an expensive mixin operation\n\t\t\t\t\tif(!(\"rotation\" in event)){ // test to see if it has rotation\n\t\t\t\t\t\tevent.rotation = 0;\n\t\t\t\t\t\tevent.scale = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (window.TouchEvent && originalEvent instanceof TouchEvent) {\n\t\t\t\t\t\t// use event.changedTouches[0].pageX|pageY|screenX|screenY|clientX|clientY|target\n\t\t\t\t\t\tvar firstChangeTouch = event.changedTouches[0];\n\t\t\t\t\t\tfor(var i in firstChangeTouch){ // use for-in, we don't need to have dependency on dojo/_base/lang here\n\t\t\t\t\t\t\tdelete event[i]; // delete it first to make it mutable\n\t\t\t\t\t\t\tevent[i] = firstChangeTouch[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn listener.call(this, event);\n\t\t\t};\n\t\t};\n\t}\n\treturn on;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/on.js?");

/***/ }),

/***/ "./node_modules/dojo/promise/Promise.js":
/*!**********************************************!*\
  !*** ./node_modules/dojo/promise/Promise.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/promise/Promise\n\n\tfunction throwAbstract(){\n\t\tthrow new TypeError(\"abstract\");\n\t}\n\n\treturn lang.extend(function Promise(){\n\t\t// summary:\n\t\t//\t\tThe public interface to a deferred.\n\t\t// description:\n\t\t//\t\tThe public interface to a deferred. All promises in Dojo are\n\t\t//\t\tinstances of this class.\n\t}, {\n\t\tthen: function(callback, errback, progback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new callbacks to the promise.\n\t\t\t// description:\n\t\t\t//\t\tAdd new callbacks to the deferred. Callbacks can be added\n\t\t\t//\t\tbefore or after the deferred is fulfilled.\n\t\t\t// callback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is resolved.\n\t\t\t//\t\tReceives the resolution value.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t//\t\tReceives the rejection error.\n\t\t\t// progback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise emits a progress\n\t\t\t//\t\tupdate. Receives the progress update.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback(s).\n\t\t\t//\t\tThis can be used for chaining many asynchronous operations.\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tcancel: function(reason, strict){\n\t\t\t// summary:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t// description:\n\t\t\t//\t\tInform the deferred it may cancel its asynchronous operation.\n\t\t\t//\t\tThe deferred's (optional) canceler is invoked and the\n\t\t\t//\t\tdeferred will be left in a rejected state. Can affect other\n\t\t\t//\t\tpromises that originate with the same deferred.\n\t\t\t// reason: any\n\t\t\t//\t\tA message that may be sent to the deferred's canceler,\n\t\t\t//\t\texplaining why it's being canceled.\n\t\t\t// strict: Boolean?\n\t\t\t//\t\tIf strict, will throw an error if the deferred has already\n\t\t\t//\t\tbeen fulfilled and consequently cannot be canceled.\n\t\t\t// returns: any\n\t\t\t//\t\tReturns the rejection reason if the deferred was canceled\n\t\t\t//\t\tnormally.\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisResolved: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been resolved.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisRejected: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been rejected.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisFulfilled: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been resolved or rejected.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\tisCanceled: function(){\n\t\t\t// summary:\n\t\t\t//\t\tChecks whether the promise has been canceled.\n\t\t\t// returns: Boolean\n\n\t\t\tthrowAbstract();\n\t\t},\n\n\t\talways: function(callbackOrErrback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd a callback to be invoked when the promise is resolved\n\t\t\t//\t\tor rejected.\n\t\t\t// callbackOrErrback: Function?\n\t\t\t//\t\tA function that is used both as a callback and errback.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the callback/errback.\n\n\t\t\treturn this.then(callbackOrErrback, callbackOrErrback);\n\t\t},\n\n\t\t\"catch\": function(errback){\n\t\t    // summary:\n\t\t    //\t\tAdd new errbacks to the promise. Follows ECMA specification naming.\n\t\t    // errback: Function?\n\t\t    //\t\tCallback to be invoked when the promise is rejected.\n\t\t    // returns: dojo/promise/Promise\n\t\t    //\t\tReturns a new promise for the result of the errback.\n\n\t\t    return this.then(null, errback);\n\t\t},\n\n\t\totherwise: function(errback){\n\t\t\t// summary:\n\t\t\t//\t\tAdd new errbacks to the promise.\n\t\t\t// errback: Function?\n\t\t\t//\t\tCallback to be invoked when the promise is rejected.\n\t\t\t// returns: dojo/promise/Promise\n\t\t\t//\t\tReturns a new promise for the result of the errback.\n\n\t\t\treturn this.then(null, errback);\n\t\t},\n\n\t\ttrace: function(){\n\t\t\treturn this;\n\t\t},\n\n\t\ttraceRejected: function(){\n\t\t\treturn this;\n\t\t},\n\n\t\ttoString: function(){\n\t\t\t// returns: string\n\t\t\t//\t\tReturns `[object Promise]`.\n\n\t\t\treturn \"[object Promise]\";\n\t\t}\n\t});\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/promise/Promise.js?");

/***/ }),

/***/ "./node_modules/dojo/promise/instrumentation.js":
/*!******************************************************!*\
  !*** ./node_modules/dojo/promise/instrumentation.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ./tracer */ \"./node_modules/dojo/promise/tracer.js\"),\n\t__webpack_require__(/*! ../has */ \"./node_modules/dojo/has.js\"),\n\t__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\"),\n\t__webpack_require__(/*! ../_base/array */ \"./node_modules/dojo/_base/array.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(tracer, has, lang, arrayUtil){\n\thas.add(\"config-useDeferredInstrumentation\", \"report-unhandled-rejections\");\n\n\tfunction logError(error, rejection, deferred){\n\t\tif(error && error.log === false){\n\t\t\treturn;\n\t\t}\n\t\tvar stack = \"\";\n\t\tif(error && error.stack){\n\t\t\tstack += error.stack;\n\t\t}\n\t\tif(rejection && rejection.stack){\n\t\t\tstack += \"\\n    ----------------------------------------\\n    rejected\" + rejection.stack.split(\"\\n\").slice(1).join(\"\\n\").replace(/^\\s+/, \" \");\n\t\t}\n\t\tif(deferred && deferred.stack){\n\t\t\tstack += \"\\n    ----------------------------------------\\n\" + deferred.stack;\n\t\t}\n\t\tconsole.error(error, stack);\n\t}\n\n\tfunction reportRejections(error, handled, rejection, deferred){\n\t\tif(!handled){\n\t\t\tlogError(error, rejection, deferred);\n\t\t}\n\t}\n\n\tvar errors = [];\n\tvar activeTimeout = false;\n\tvar unhandledWait = 1000;\n\tfunction trackUnhandledRejections(error, handled, rejection, deferred){\n\t\t// try to find the existing tracking object\n\t\tif(!arrayUtil.some(errors, function(obj){\n\t\t\tif(obj.error === error){\n\t\t\t\t// found the tracking object for this error\n\t\t\t\tif(handled){\n\t\t\t\t\t// if handled, update the state\n\t\t\t\t\tobj.handled = true;\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t})){\n\t\t\t// no tracking object has been setup, create one\n\t\t\terrors.push({\n\t\t\t\terror: error,\n\t\t\t\trejection: rejection,\n\t\t\t\thandled: handled,\n\t\t\t\tdeferred: deferred,\n\t\t\t\ttimestamp: new Date().getTime()\n\t\t\t});\n\t\t}\n\n\t\tif(!activeTimeout){\n\t\t\tactiveTimeout = setTimeout(logRejected, unhandledWait);\n\t\t}\n\t}\n\n\tfunction logRejected(){\n\t\tvar now = new Date().getTime();\n\t\tvar reportBefore = now - unhandledWait;\n\t\terrors = arrayUtil.filter(errors, function(obj){\n\t\t\t// only report the error if we have waited long enough and\n\t\t\t// it hasn't been handled\n\t\t\tif(obj.timestamp < reportBefore){\n\t\t\t\tif(!obj.handled){\n\t\t\t\t\tlogError(obj.error, obj.rejection, obj.deferred);\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\n\t\tif(errors.length){\n\t\t\tactiveTimeout = setTimeout(logRejected, errors[0].timestamp + unhandledWait - now);\n\t\t}else{\n\t\t\tactiveTimeout = false;\n\t\t}\n\t}\n\n\treturn function(Deferred){\n\t\t// summary:\n\t\t//\t\tInitialize instrumentation for the Deferred class.\n\t\t// description:\n\t\t//\t\tInitialize instrumentation for the Deferred class.\n\t\t//\t\tDone automatically by `dojo/Deferred` if the\n\t\t//\t\t`deferredInstrumentation` and `useDeferredInstrumentation`\n\t\t//\t\tconfig options are set.\n\t\t//\n\t\t//\t\tSets up `dojo/promise/tracer` to log to the console.\n\t\t//\n\t\t//\t\tSets up instrumentation of rejected deferreds so unhandled\n\t\t//\t\terrors are logged to the console.\n\n\t\tvar usage = has(\"config-useDeferredInstrumentation\");\n\t\tif(usage){\n\t\t\ttracer.on(\"resolved\", lang.hitch(console, \"log\", \"resolved\"));\n\t\t\ttracer.on(\"rejected\", lang.hitch(console, \"log\", \"rejected\"));\n\t\t\ttracer.on(\"progress\", lang.hitch(console, \"log\", \"progress\"));\n\n\t\t\tvar args = [];\n\t\t\tif(typeof usage === \"string\"){\n\t\t\t\targs = usage.split(\",\");\n\t\t\t\tusage = args.shift();\n\t\t\t}\n\t\t\tif(usage === \"report-rejections\"){\n\t\t\t\tDeferred.instrumentRejected = reportRejections;\n\t\t\t}else if(usage === \"report-unhandled-rejections\" || usage === true || usage === 1){\n\t\t\t\tDeferred.instrumentRejected = trackUnhandledRejections;\n\t\t\t\tunhandledWait = parseInt(args[0], 10) || unhandledWait;\n\t\t\t}else{\n\t\t\t\tthrow new Error(\"Unsupported instrumentation usage <\" + usage + \">\");\n\t\t\t}\n\t\t}\n\t};\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/promise/instrumentation.js?");

/***/ }),

/***/ "./node_modules/dojo/promise/tracer.js":
/*!*********************************************!*\
  !*** ./node_modules/dojo/promise/tracer.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n\t__webpack_require__(/*! ../_base/lang */ \"./node_modules/dojo/_base/lang.js\"),\n\t__webpack_require__(/*! ./Promise */ \"./node_modules/dojo/promise/Promise.js\"),\n\t__webpack_require__(/*! ../Evented */ \"./node_modules/dojo/Evented.js\")\n], __WEBPACK_AMD_DEFINE_RESULT__ = (function(lang, Promise, Evented){\n\t\"use strict\";\n\n\t// module:\n\t//\t\tdojo/promise/tracer\n\n\t/*=====\n\treturn {\n\t\t// summary:\n\t\t//\t\tTrace promise fulfillment.\n\t\t// description:\n\t\t//\t\tTrace promise fulfillment. Calling `.trace()` or `.traceError()` on a\n\t\t//\t\tpromise enables tracing. Will emit `resolved`, `rejected` or `progress`\n\t\t//\t\tevents.\n\n\t\ton: function(type, listener){\n\t\t\t// summary:\n\t\t\t//\t\tSubscribe to traces.\n\t\t\t// description:\n\t\t\t//\t\tSee `dojo/Evented#on()`.\n\t\t\t// type: String\n\t\t\t//\t\t`resolved`, `rejected`, or `progress`\n\t\t\t// listener: Function\n\t\t\t//\t\tThe listener is passed the traced value and any arguments\n\t\t\t//\t\tthat were used with the `.trace()` call.\n\t\t}\n\t};\n\t=====*/\n\n\tvar evented = new Evented;\n\tvar emit = evented.emit;\n\tevented.emit = null;\n\t// Emit events asynchronously since they should not change the promise state.\n\tfunction emitAsync(args){\n\t\tsetTimeout(function(){\n\t\t\temit.apply(evented, args);\n\t\t}, 0);\n\t}\n\n\tPromise.prototype.trace = function(){\n\t\t// summary:\n\t\t//\t\tTrace the promise.\n\t\t// description:\n\t\t//\t\tTracing allows you to transparently log progress,\n\t\t//\t\tresolution and rejection of promises, without affecting the\n\t\t//\t\tpromise itself. Any arguments passed to `trace()` are\n\t\t//\t\temitted in trace events. See `dojo/promise/tracer` on how\n\t\t//\t\tto handle traces.\n\t\t// returns: dojo/promise/Promise\n\t\t//\t\tThe promise instance `trace()` is called on.\n\n\t\tvar args = lang._toArray(arguments);\n\t\tthis.then(\n\t\t\tfunction(value){ emitAsync([\"resolved\", value].concat(args)); },\n\t\t\tfunction(error){ emitAsync([\"rejected\", error].concat(args)); },\n\t\t\tfunction(update){ emitAsync([\"progress\", update].concat(args)); }\n\t\t);\n\t\treturn this;\n\t};\n\n\tPromise.prototype.traceRejected = function(){\n\t\t// summary:\n\t\t//\t\tTrace rejection of the promise.\n\t\t// description:\n\t\t//\t\tTracing allows you to transparently log progress,\n\t\t//\t\tresolution and rejection of promises, without affecting the\n\t\t//\t\tpromise itself. Any arguments passed to `trace()` are\n\t\t//\t\temitted in trace events. See `dojo/promise/tracer` on how\n\t\t//\t\tto handle traces.\n\t\t// returns: dojo/promise/Promise\n\t\t//\t\tThe promise instance `traceRejected()` is called on.\n\n\t\tvar args = lang._toArray(arguments);\n\t\tthis.otherwise(function(error){\n\t\t\temitAsync([\"rejected\", error].concat(args));\n\t\t});\n\t\treturn this;\n\t};\n\n\treturn evented;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/promise/tracer.js?");

/***/ }),

/***/ "./node_modules/dojo/sniff.js":
/*!************************************!*\
  !*** ./node_modules/dojo/sniff.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./has */ \"./node_modules/dojo/has.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(has){\n\t// module:\n\t//\t\tdojo/sniff\n\n\t/*=====\n\treturn function(){\n\t\t// summary:\n\t\t//\t\tThis module sets has() flags based on the current browser.\n\t\t//\t\tIt returns the has() function.\n\t};\n\t=====*/\n\n\tif(has(\"host-browser\")){\n\t\tvar n = navigator,\n\t\t\tdua = n.userAgent,\n\t\t\tdav = n.appVersion,\n\t\t\ttv = parseFloat(dav);\n\t\thas.add(\"air\", dua.indexOf(\"AdobeAIR\") >= 0);\n\t\thas.add(\"wp\", parseFloat(dua.split(\"Windows Phone\")[1]) || undefined);\n\t\thas.add(\"msapp\", parseFloat(dua.split(\"MSAppHost/\")[1]) || undefined);\n\t\thas.add(\"khtml\", dav.indexOf(\"Konqueror\") >= 0 ? tv : undefined);\n\t\thas.add(\"edge\", parseFloat(dua.split(\"Edge/\")[1]) || undefined);\n\t\thas.add(\"opr\", parseFloat(dua.split(\"OPR/\")[1]) || undefined);\n\t\t// NOTE: https://dev.opera.com/blog/opera-user-agent-strings-opera-15-and-beyond/\n\t\thas.add(\"webkit\", !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540\n\t\t\t&& !has(\"edge\") && parseFloat(dua.split(\"WebKit/\")[1]) || undefined);\n\t\thas.add(\"chrome\", !has(\"edge\") && !has(\"opr\")\n\t\t\t\t&& parseFloat(dua.split(\"Chrome/\")[1]) || undefined);\n\t\thas.add(\"android\", !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528\n\t\t\t\t&& parseFloat(dua.split(\"Android \")[1]) || undefined);\n\t\thas.add(\"safari\", dav.indexOf(\"Safari\") >= 0\n\t\t\t\t&& !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18540\n\t\t\t\t&& !has(\"chrome\") && !has(\"android\") && !has(\"edge\") && !has(\"opr\") ?\n\t\t\tparseFloat(dav.split(\"Version/\")[1]) : undefined);\n\t\thas.add(\"mac\", dav.indexOf(\"Macintosh\") >= 0);\n\t\thas.add(\"quirks\", document.compatMode == \"BackCompat\");\n\t\tif(!has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1, see #18528\n\t\t\t\t&& dua.match(/(iPhone|iPod|iPad)/)){\n\t\t\tvar p = RegExp.$1.replace(/P/, \"p\");\n\t\t\tvar v = dua.match(/OS ([\\d_]+)/) ? RegExp.$1 : \"1\";\n\t\t\tvar os = parseFloat(v.replace(/_/, \".\").replace(/_/g, \"\"));\n\t\t\thas.add(p, os);\t\t// \"iphone\", \"ipad\" or \"ipod\"\n\t\t\thas.add(\"ios\", os);\n\t\t}\n\t\thas.add(\"bb\", (dua.indexOf(\"BlackBerry\") >= 0 || dua.indexOf(\"BB10\") >= 0) && parseFloat(dua.split(\"Version/\")[1]) || undefined);\n\t\thas.add(\"trident\", parseFloat(dav.split(\"Trident/\")[1]) || undefined);\n\n\t\thas.add(\"svg\", typeof SVGAngle !== \"undefined\");\n\n\t\tif(!has(\"webkit\")){\n\t\t\t// Opera\n\t\t\tif(dua.indexOf(\"Opera\") >= 0){\n\t\t\t\t// see http://dev.opera.com/articles/view/opera-ua-string-changes and http://www.useragentstring.com/pages/Opera/\n\t\t\t\t// 9.8 has both styles; <9.8, 9.9 only old style\n\t\t\t\thas.add(\"opera\", tv >= 9.8 ? parseFloat(dua.split(\"Version/\")[1]) || tv : tv);\n\t\t\t}\n\n\t\t\t// Mozilla and firefox\n\t\t\tif(dua.indexOf(\"Gecko\") >= 0 && !has(\"wp\") // NOTE: necessary since Windows Phone 8.1 Update 1\n\t\t\t\t\t&& !has(\"khtml\") && !has(\"trident\") && !has(\"edge\")){\n\t\t\t\thas.add(\"mozilla\", tv);\n\t\t\t}\n\t\t\tif(has(\"mozilla\")){\n\t\t\t\t//We really need to get away from this. Consider a sane isGecko approach for the future.\n\t\t\t\thas.add(\"ff\", parseFloat(dua.split(\"Firefox/\")[1] || dua.split(\"Minefield/\")[1]) || undefined);\n\t\t\t}\n\n\t\t\t// IE\n\t\t\tif(document.all && !has(\"opera\")){\n\t\t\t\tvar isIE = parseFloat(dav.split(\"MSIE \")[1]) || undefined;\n\n\t\t\t\t//In cases where the page has an HTTP header or META tag with\n\t\t\t\t//X-UA-Compatible, then it is in emulation mode.\n\t\t\t\t//Make sure isIE reflects the desired version.\n\t\t\t\t//document.documentMode of 5 means quirks mode.\n\t\t\t\t//Only switch the value if documentMode's major version\n\t\t\t\t//is different from isIE's major version.\n\t\t\t\tvar mode = document.documentMode;\n\t\t\t\tif(mode && mode != 5 && Math.floor(isIE) != mode){\n\t\t\t\t\tisIE = mode;\n\t\t\t\t}\n\n\t\t\t\thas.add(\"ie\", isIE);\n\t\t\t}\n\n\t\t\t// Wii\n\t\t\thas.add(\"wii\", typeof opera != \"undefined\" && opera.wiiremote);\n\t\t}\n\t}\n\n\treturn has;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/dojo/sniff.js?");

/***/ }),

/***/ "./node_modules/rdfjson/Graph.js":
/*!***************************************!*\
  !*** ./node_modules/rdfjson/Graph.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n  __webpack_require__(/*! ./formats/rdfjson/util */ \"./node_modules/rdfjson/formats/rdfjson/util.js\"),\n  __webpack_require__(/*! ./Statement */ \"./node_modules/rdfjson/Statement.js\"),\n  __webpack_require__(/*! ./namespaces */ \"./node_modules/rdfjson/namespaces.js\"),\n], __WEBPACK_AMD_DEFINE_RESULT__ = ((util, Statement, namespaces) => {\n  /**\n   * @param {Array} arr\n   * @returns {*}\n   * @private\n   */\n  const zeroOrOne = (arr) => {\n    if (arr.length === 0) {\n      return arr;\n    }\n    return [arr[0]];\n  };\n\n  /**\n   * @param {rdfjson/Graph} graph\n   * @param {rdfjson/Statement[]} statements an array\n   * @param {Boolean=} perSubject if true means that all consecutive calls will be focused on\n   * all the subjects of the specified statments, otherwise the resource objects of the statements\n   * will be the focus. Assumed to be false unless explicitly set to true.\n   *\n   * @returns {{object: Function, objects: Function, constr: Function, each: Function, nodes:\n     * Function, values: Function, firstValue: Function}}\n   * @private\n   */\n  const perStatement = (graph, statements, perSubject) => ({\n    object(predicate) {\n      for (let i = 0; i < statements.length; i++) {\n        let subj;\n        if (perSubject) {\n          subj = statements[i].getSubject();\n        } else {\n          const t = statements[i].getType();\n          if (t === 'uri' || t === 'bnode') {\n// eslint-disable-next-line no-continue\n            continue;\n          }\n          subj = statements[i].getValue();\n        }\n        const stmts = graph.find(subj, predicate);\n        if (stmts.length > 0) {\n          perStatement(graph, [stmts[0]]);\n        }\n      }\n      return perStatement(graph, []);\n    },\n    objects(predicate) {\n      let nstats = [];\n      let i;\n      if (perSubject === true) {\n        for (i = 0; i < statements.length; i++) {\n          nstats = nstats.concat(graph.find(statements[i].getSubject(), predicate));\n        }\n      } else {\n        for (i = 0; i < statements.length; i++) {\n          const t = statements[i].getType();\n          if (t === 'uri' || t === 'bnode') {\n            nstats = nstats.concat(graph.find(statements[i].getValue(), predicate));\n          }\n        }\n      }\n      return perStatement(graph, nstats);\n    },\n    constr(predicate, object) {\n      let _object = object;\n      if (util.isString(_object)) {\n        _object = { type: 'uri', value: _object };\n      }\n      const nstats = [];\n      for (let i = 0; i < statements.length; i++) {\n        const subj = perSubject ? statements[i].getSubject() : statements[i].getValue();\n        if (graph.find(subj, predicate, _object).length > 0) {\n          nstats.push(statements[i]);\n        }\n      }\n      return perStatement(graph, nstats, perSubject);\n    },\n    /**\n     * For each match the callback will be called with a focused iterator.\n     */\n    each(callback, type) {\n      if (perSubject === true) {\n        for (let i = 0; i < statements.length; i++) {\n          const subj = statements[i].getSubject();\n          const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';\n          if (type == null || type === t) {\n            callback(perStatement(graph, statements[i], perSubject));\n          }\n        }\n      } else {\n        for (let j = 0; j < statements.length; j++) {\n          callback(perStatement(graph, statements[j], perSubject));\n        }\n      }\n    },\n    nodes(type) {\n      const res = [];\n      if (perSubject === true) {\n        for (let i = 0; i < statements.length; i++) {\n          const subj = statements[i].getSubject();\n          const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';\n          if (type == null || type === t) {\n            res.push({ type: t, value: statements[i].getSubject() });\n          }\n        }\n      } else {\n        for (let j = 0; j < statements.length; j++) {\n          if (type == null || type === statements[j].getType()) {\n            res.push(statements[j].getObject());\n          }\n        }\n      }\n      return res;\n    },\n    values(type) {\n      const res = [];\n      if (perSubject === true) {\n        for (let i = 0; i < statements.length; i++) {\n          const subj = statements[i].getSubject();\n          const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';\n          if (type == null || type === t) {\n            res.push(statements[i].getSubject());\n          }\n        }\n      } else {\n        for (let j = 0; j < statements.length; j++) {\n          if (type == null || type === statements[j].getType()) {\n            res.push(statements[j].getValue());\n          }\n        }\n      }\n      return res;\n    },\n    firstValue(type) {\n      if (perSubject === true) {\n        for (let i = 0; i < statements.length; i++) {\n          const subj = statements[i].getSubject();\n          const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';\n          if (type == null || type === t) {\n            return statements[i].getSubject();\n          }\n        }\n      } else {\n        for (let j = 0; j < statements.length; j++) {\n          if (type == null || type === statements[j].getType()) {\n            return statements[j].getValue();\n          }\n        }\n      }\n      return undefined;\n    },\n  });\n\n  /**\n   * Provides an API for accessing and manipulating an RDF Graph.\n   *\n   * The Graph API wraps a pure RDF JSON object to make it easy to access and manipulate on the\n   * level of rdfjson/Statements.\n   * Note that for efficiency reasons the RDF JSON object will be extended, hence it will\n   * contain attributes that goes beyond the specification.\n   *\n   * The pure RDF JSON object:\n   * <ul><li>can still be inspected independently, it will contain the correct RDF expression.\n   *     </li>\n   *     <li>cannot be modified directly since it will conflict with manipulations via this\n   *     class, the exception is the statement object attributes which can be updated.</li>\n   *     <li>is now unsuitable to be communicated for instance back to a server storage\n   *      due to the extra attributes. Use the exportRDFJSON function to get a clean RDF\n   *      JSON object.</li></ul>\n   *\n   * The constructor is sheap, no indexes or additional statements are created until requested\n   * or created.\n   *\n   * @param {Object=} graph a pure RDF JSON object according to the specification that will be\n   * manipulated internally.\n   * @param {Boolean=} validate indicates wether to validate the graph directly or not.\n   * @class\n   */\n  const Graph =  class {\n    constructor(graph, validate) {\n      this._graph = graph || {};\n      /**\n       * Internal index of bnodes, will never shrink after creation of this graph instance.\n       * New bnodes will be added but bnodes contained in removed statements will be kept\n       * in case the statement is only temporarily unasserted.\n       */\n      this._bnodes = {};\n      /**\n       * If true the graph has been iterated through and all found bnodes have been added to index.\n       */\n      this._bnodesIndexed = false;\n\n      if (validate !== false) {\n        this.validate();\n      }\n      this._changed = false;\n    }\n\n    /**\n     * @return {Boolean} true if the graph contains no asserted statements.\n     */\n    isEmpty() {\n      return !Object.keys(this._graph).find((s) => {\n        const props = this._graph[s];\n        return Object.keys(props).find(p =>\n          props[p].find(o => o._statement == null || o._statement.isAsserted()));\n      });\n    }\n\n// eslint-disable-next-line class-methods-use-this\n    onChange() {\n    }\n\n    setChanged(changed) {\n      this._changed = !!(changed === true || changed == null);\n      if (this._changed) {\n        this.onChange();\n      }\n    }\n\n    isChanged() {\n      return this._changed;\n    }\n\n    /**\n     * Adds all statements of a graph to the current graph.\n     * Will create new blank nodes ids in the source graph to avoid clashes with target graph.\n     *\n     * @param graph\n     */\n    addAll(graph) {\n      const bnodeIdx = {};\n      let bn;\n      const stmts = graph.find();\n      for (let i = 0; i < stmts.length; i++) {\n        const stmt = stmts[i];\n        let s = stmt.getSubject();\n        let p = stmt.getPredicate();\n        const o = stmt.getCleanObject();\n\n        if (s.indexOf('_:') === 0) {\n          bn = bnodeIdx[s] || this._newBNode();\n          bnodeIdx[s] = bn;\n          s = bn;\n        }\n        if (p.indexOf('_:') === 0) {\n          bn = bnodeIdx[p] || this._newBNode();\n          bnodeIdx[p] = bn;\n          p = bn;\n        }\n        if (o.type === 'bnode') {\n          bn = bnodeIdx[o.value] || this._newBNode();\n          bnodeIdx[o.value] = bn;\n          o.value = bn;\n        }\n        this.add(s, p, o);\n      }\n    }\n\n    /**\n     * Adds a statement to the graph, either an existing statement or creates an new one from the\n     * triple pattern. If a statement instance is used it may originate from another graph, although\n     * potential bnodes are not renamed.\n     *\n     * @param {rdfjson/Statement|string} s either the subject in a triple pattern or a Statement\n     * instance to add,\n     * in the latter case the other parameters must be undefined.\n     * @param {string} p the predicate of the triple to add.\n     * @param {Object|string} o the object where the attributes type, value, lang and datatype are\n     * used to describe the object.\n     * @returns {rdfjson/Statement}\n     */\n    add(s, p, o) {\n      if (s instanceof Statement) {\n        const _p = s.getPredicate();\n        const _o = s.getObject();\n        const _s = s.getSubject();\n        this._trackBNodes(_s, _p, _o);\n        const o1 = this._graphObject(_o);\n        const o2 = util.add(this._graph, _s, _p, o1);\n        this.setChanged();\n        return this._get(_s, _p, o2, true);\n      }\n      return this.create(s, p, o, true);\n    }\n\n    addL(s, p, value, lang) {\n      const o = { type: 'literal', value };\n      if (typeof lang === 'string') {\n        o.lang = lang;\n      }\n      return this.create(s, p, o, true);\n    }\n\n    addD(s, p, value, datatype) {\n      const o = { type: 'literal', value };\n      if (typeof datatype === 'string') {\n        o.datatype = namespaces.expand(datatype);\n      }\n      return this.create(s, p, o, true);\n    }\n\n    /**\n     * Creates a new statement and associates it to the graph, unless assert is explicitly set to\n     * false it is also added to the graph.\n     *\n     * @param {String=} s the subject as a uri, if undefined a new blank node is created.\n     * @param {String} p the predicate as a uri, if undefined a new blank node is created.\n     * @param {Object} o the object in the form of an object containing the attributes:\n     * 'type', 'value', 'lang', and 'datatype'. If undefined a new blank node is created.\n     *  If a string is provided it is assumed to be a url, i.e. sending in \"the url\" is the same as\n     *  sending in {type: \"uri\", value: \"the url\"}.\n     * @param {Boolean} assert indicated if the statement should be added to the graph directly. If\n     * not specified true is assumed.\n     * @returns {rdfjson/Statement}\n     * @see rdfjson/rdfjson#add\n     */\n    create(s, p, o, assert) {\n      let _s = s;\n      let _p = p;\n      let _o = o;\n      if (_s == null) {\n        _s = this._newBNode();\n      } else {\n        _s = namespaces.expand(_s);\n      }\n      if (_p == null) {\n        _p = this._newBNode();\n      } else {\n        _p = namespaces.expand(_p);\n      }\n\n      if (_o == null) {\n        _o = { type: 'bnode', value: this._newBNode() };\n      } else if (util.isString(_o)) {\n        _o = { type: 'uri', value: namespaces.expand(_o) };\n      } else {\n        // The object is copied to avoid reuse of same object in multiple places of the graph\n        // leading to strange updates.\n        _o = { type: _o.type, value: _o.value, lang: _o.lang, datatype: _o.datatype };\n        if (_o.type === 'uri' && _o.value != null) {\n          _o.value = namespaces.expand(_o.value);\n        }\n        if (_o.datatype) {\n          _o.datatype = namespaces.expand(_o.datatype);\n        }\n      }\n      if (assert !== false) {\n        const o1 = util.add(this._graph, _s, _p, _o);\n        this.setChanged();\n        return this._getOrCreate(_s, _p, o1, true);\n      }\n      return new Statement(this, _s, _p, _o, false);\n    }\n\n    /**\n     * Convenience function that combines the find and remove functions.\n     * @param {String=} s the subject\n     * @param {String=} p the predicate\n     * @param {Object=} o the object\n     * @see rdfjson/Graph#find\n     * @see rdfjson/Graph#remove\n     */\n    findAndRemove(s, p, o) {\n      const stmts = this.find(s, p, o);\n      for (let i = 0; i < stmts.length; i++) {\n        this.remove(stmts[i]);\n      }\n    }\n\n    /**\n     * Removes the given statement from the graph.\n     * If you plan to keep the statement around and assert it later,\n     * it is recommended to only use the rdfjson/Statement#setAsserted method instead.\n     *\n     * @param {rdfjson/Statement} statement the statement to remove from the graph.\n     * @see rdfjson/Statement#setAsserted\n     */\n    remove(statement) {\n      const s = statement.getSubject();\n      const p = statement.getPredicate();\n      const o = statement.getObject();\n      this._trackBNodes(s, p, o);\n      if (util.remove(this._graph, s, p, o) != null) {\n        this.setChanged();\n      }\n    }\n\n    /**\n     * Finds all statements that fulfills the given pattern. Any combination of the arguments may\n     * be left out.\n     *\n     * @param {String=} s the subject in the statements to be returned, undefined indicates that\n     * any subject is ok.\n     * @param {String=} p the predicate in the statements to be returned, undefined indicates\n     * that any predicate is ok.\n     * @param {Object=} o the object in the statements to be returned, undefined indicates that\n     * any object is ok.\n     * Objets of matching statements have to be equal according to the objectEquals method.\n     * @return {rdfjson/Statement[]}\n     * @see rdfjson/rdfjson#objectEquals\n     */\n    find(s, p, o) {\n      let _s = s;\n      let _p = p;\n      let _o = o;\n      // none, s, p, s&p\n      if (typeof _s === 'string') {\n        _s = namespaces.expand(_s);\n      }\n      if (typeof _p === 'string') {\n        _p = namespaces.expand(_p);\n      }\n      if (typeof _o === 'object' && _o !== null && _o.type === 'uri') {\n        _o.value = namespaces.expand(_o.value);\n      } else if (typeof _o === 'string') {\n        _o = { type: 'uri', value: namespaces.expand(_o) };\n      }\n      if (_o == null) {\n        // none, s\n        if (_p == null) {\n          if (_s == null) {\n            return this._find();\n          }\n          return this._findS(_s);\n\n          // p, s&p\n        }\n        // p\n        if (_s == null) {\n          return this._findP(_p);\n          // s&p\n        }\n        return this._findSP(_s, _p);\n      }\n      // o, s&o\n      if (_p == null) {\n        if (_s == null) {\n          return this._findO(_o);\n        }\n        return this._findSO(_s, _o);\n      }\n\n      // p&o\n      if (_s == null) {\n        return this._findPO(_p, _o);\n      }\n\n      // s&p&o\n      const stmt = this._get(_s, _p, util.contains(this._graph, _s, _p, _o), true);\n      if (stmt == null) {\n        return [];\n      }\n      return [stmt];\n    }\n\n    /**\n     * Convenience method that returns the value of object of the first matching Statement\n     * for the given subject and predicate.\n     *\n     * @param {String=} s the subject\n     * @param {String=} p the predicate\n     * @return {String} the value, may be a literal or a URI, if undefined no matching statement\n     * (and value) could be found.\n     * @see rdfjson/Graph#find\n     */\n    findFirstValue(s, p) {\n      const arr = this.find(s, p);\n      if (arr.length > 0) {\n        return arr[0].getValue();\n      }\n      return undefined;\n    }\n\n    /**\n     * Retrieves a projection, a plain object with simple attribute value pairs given a subject\n     * and a mapping.\n     * The mapping is an object where the same attributes appear but with the predicates are values.\n     * Hence, each attribute gives rise to a search for all statements with the given subject and\n     * the predicate specified by the attribute.\n     * The result object will contain the mapping attributes with values from the the first\n     * matched statements object value if there are any.\n     * To access additional information like multiple statement or the statements\n     * (type, language, datatype) a \"*\" prepended version of each attribute can be provided that\n     * contains a list of matching Statements if so indicated by the multipleValueStyle parameter.\n     *\n     * @param {String} s the subject to use for the projection.\n     * @param {Object} mapping the mapping configuration\n     * @param {String} multipleValueStyle if provided an array is provided for that property\n     * prefixed with \"*\", the array should be indicated to be either\n     * \"statements\", \"values\" or \"objects\".\n     * @returns {Object}\n     * @example\n     * var proj = graph.projection(\"http://example.com\", {\n     *     \"title\":       \"http://purl.org/dc/terms/title\",\n     *     \"description\": \"http://purl.org/dc/terms/description\"\n     * });\n     * // The object proj now has the attributes title, *title, description, and *description.\n     *\n     * // Accessing the title of http://example.com\n     * console.log(proj.title);\n     *\n     * // To get hold of additional information available in the statement,\n     * // for instance the language of a literal:\n     * console.log(proj[\"*title\"][0].getLanguage())\n     *\n     */\n    projection(s, mapping, multipleValueStyle) {\n      const mapped = {};\n      Object.keys(mapping).forEach((key) => {\n        const prop = mapping[key];\n        const values = this.find(s, prop);\n        if (values.length > 0) {\n          if (key[0] === '*') {\n            mapped[key.substr(1)] = values.map(val => val.getValue());\n          } else {\n            mapped[key] = values[0].getValue();\n          }\n          switch (multipleValueStyle || 'none') {\n            case 'statement':\n              mapped[`*${key}`] = values;\n              break;\n            case 'objects':\n              mapped[`*${key}`] = values.map(v => v.getCleanObject());\n              break;\n            case 'values':\n              mapped[`*${key}`] = values.map(v => v.getValue());\n              break;\n            default:\n          }\n        }\n      });\n      return mapped;\n    }\n\n    subjects(p, o) {\n      return perStatement(this, this.find(null, p, o), true);\n    }\n\n    subject(p, o) {\n      return perStatement(this, zeroOrOne(this.find(null, p, o)), true);\n    }\n\n    objects(s, p) {\n      return perStatement(this, this.find(s, p, null));\n    }\n\n    object(s, p) {\n      return perStatement(this, zeroOrOne(this.find(s, p, null)));\n    }\n\n    /**\n     * @return {Object} a plain RDF JSON object without the additional artifacts created by this\n     * Graph class.\n     * The returned object is suitable for serilization and communicated with other systems.\n     */\n    exportRDFJSON() {\n      const graph = this._graph;\n      const ngraph = {};\n      Object.keys(graph).forEach((s) => {\n        const subj = graph[s];\n        ngraph[s] = {};\n        Object.keys(subj).forEach((p) => {\n          const nObjArr = [];\n          ngraph[s][p] = nObjArr;\n          subj[p].forEach((o) => {\n            const no = { type: o.type, value: o.value };\n            if (o.lang != null) {\n              no.lang = o.lang;\n            }\n            if (o.datatype != null) {\n              no.datatype = o.datatype;\n            }\n            nObjArr.push(no);\n          });\n        });\n      });\n      return ngraph;\n    }\n\n    /**\n     * Replaces a URI in subject position with another,\n     * assuming the target URI does not exist in the graph already.\n     *\n     * @param sourceURI\n     * @param targetURI\n     * @returns {Graph}\n     * @deprecated Use replaceURI instead.\n     */\n    replaceSubject(sourceURI, targetURI) {\n      return this.replaceURI(sourceURI, targetURI);\n    }\n\n    /**\n     * Replaces all occurences of a URI in the graph with another URI.\n     * Assumes the target URI does not exist in the graph already.\n     *\n     * @param sourceURI\n     * @param targetURI\n     * @returns {Graph}\n     */\n    replaceURI(sourceURI, targetURI) {\n      const graph = this._graph;\n      if (graph.hasOwnProperty(sourceURI)) {\n        if (!graph.hasOwnProperty((targetURI))) {\n          graph[targetURI] = graph[sourceURI];\n          delete graph[sourceURI];\n        } else {\n          throw new Error('Cannot replace subject with target URI since it already exists.');\n        }\n\n        this.forEach((s, p, o) => {\n          if (o.type === 'uri' && o.value === sourceURI) {\n            o.value = targetURI;\n          }\n          if (s === targetURI && o._statement) {\n            o._statement._s = targetURI;\n          }\n        });\n      }\n\n      return this;\n    }\n\n    /**\n     * Clones this graph.\n     * @returns {rdfjson/Graph}\n     */\n    clone() {\n      return new Graph(this.exportRDFJSON());\n    }\n\n    /**\n     * Finds all properties for a given subject.\n     * Note: Optimal.\n     * @param {String} s the subject to find properties for\n     * @return {Array[String]} of strings\n     */\n    findProperties(s) {\n      return Object.keys(this._graph[s] || {});\n    }\n\n    /**\n     * Validates the graph and returns a report.\n     * If errors are detected an exception is thrown.\n     * The validation report is a object with a valid attribute which is either false or true.\n     * If it is false an array of errors are provided where each error is an object containing\n     * a message and information regarding which subject,predicate and object index in the\n     * rdjson javascript object that caused the error..\n     *\n     * @returns {undefined} if there where no errors\n     * @throws {Object} the validation report.\n     */\n    validate() {\n      this.report = this._validate();\n      if (!this.report.valid) {\n        throw (this.report);\n      }\n      return this.report;\n    }\n\n    /**\n     * You should not use this function unless you are VERY certain of what you are doing.\n     *\n     * @param {String} bNodeId\n     */\n    registerBNode(bNodeId) {\n      this._bnodes[bNodeId] = true;\n    }\n\n    /**\n     * Iterates through all statements of the graph and calls the provided function on them.\n     *\n     * @param {Function} f are called for each statement with the three arguments\n     *  (in order) subject, predicate, and object.\n     */\n    forEach(f) {\n      const graph = this._graph;\n      Object.keys(graph).forEach((s) => {\n        const subj = graph[s];\n        Object.keys(subj).forEach((p) => {\n          subj[p].forEach((o) => {\n            f(s, p, o);\n          });\n        });\n      });\n    }\n\n    /**\n     * Iterates through all statements of the graph and calls the provided function on them and\n     * returns an array of the results.\n     *\n     * @param {Function} f are called for each statement with the three arguments\n     *  (in order) subject, predicate, and object, f should return a value that is added to the\n     *  array\n     *  @return {array} an array with the value of the function applied for each statement.\n     */\n    map(f) {\n      const arr = [];\n      this.forEach((stmt) => {\n        arr.push(f(stmt));\n      });\n      return arr;\n    }\n\n    // ===================================================\n    // Private methods\n    // ===================================================\n\n    /**\n     * If the object already contains a statement that is returned, otherwise a new is created.\n     * If the object is not specified undefined is returned.\n     * @return {Statement|undefined} a statement that belongs to this graph.\n     */\n    _get(s, p, o, asserted) {\n      if (o == null) {\n        return undefined;\n      }\n\n      return this._getOrCreate(s, p, o, asserted);\n    }\n\n    /**\n     * If the object already contains a statement that is returned, otherwise a new is created.\n     * @return {rdfjson/Statement} a statement that belongs to this graph.\n     */\n    _getOrCreate(s, p, o, asserted) {\n      if (o._statement == null) {\n        o._statement = new Statement(this, s, p, o, asserted);\n      }\n      return o._statement;\n    }\n\n    /**\n     * @return {Object} if the object originates from another graph a copy is made.\n     */\n    _graphObject(o) {\n      if (o._statement == null ||\n        o._statement._graph === this) {\n        return o;\n      }\n      return { type: o.type, value: o.value, lang: o.lang, datatype: o.datatype };\n    }\n\n    /**\n     * Finds all statements with a given subject and object.\n     * @param {String} s\n     * @param {String} p\n     * @returns {rdfjson/Statement[]}\n     */\n    _findSP(s, p) {\n      if (this._graph[s] == null || this._graph[s][p] == null) {\n        return [];\n      }\n      return this._graph[s][p].map(o => this._get(s, p, o, true));\n    }\n\n    /**\n     * Finds all statements with a given subject.\n     * Note: Optimal.\n     * @param {String} s\n     * @returns {rdfjson/Statement[]}\n     */\n    _findS(s) {\n      const subj = this._graph[s];\n      const spArrs = Object.keys(subj || {}).map(p => this._findSP(s, p));\n      return Array.prototype.concat.apply([], spArrs);\n    }\n\n    /**\n     * Generates statements for the entire graph.\n     * Note: Optimal.\n     * @returns {rdfjson/Statement[]}\n     */\n    _find() {\n      const arr = [];\n      this.forEach((s1, p1, o1) => {\n        arr.push(this._get(s1, p1, o1, true));\n      });\n      return arr;\n    }\n\n    /**\n     * Finds all statements with a given predicate.\n     * Note: Close to optimal without further indexing, to many checks due to iteration via _map.\n     * @param {String} p\n     * @returns {rdfjson/Statement[]}\n     */\n    _findP(p) {\n      const arr = [];\n      this.forEach((s1, p1, o1) => {\n        if (p === p1) {\n          arr.push(this._get(s1, p1, o1, true));\n        }\n      });\n      return arr;\n    }\n\n    /**\n     * Iterates through all statements to find those with specified object.\n     * Note: Optimal without additional indexing.\n     * @param {Object} o\n     * @returns {rdfjson/Statement[]}\n     */\n    _findO(o) {\n      const arr = [];\n      this.forEach((s1, p1, o1) => {\n        if (util.objectEquals(o, o1)) {\n          arr.push(this._get(s1, p1, o1, true));\n        }\n      });\n      return arr;\n    }\n\n    /**\n     * Finds all statements with a given subject and object.\n     * Note: Close to optimal without further indexing, to many checks due to iteration via _map.\n     * @returns {rdfjson/Statement[]}\n     */\n    _findSO(s, o) {\n      const arr = [];\n      this.forEach((s1, p1, o1) => {\n        if (s === s1 && util.objectEquals(o, o1)) {\n          arr.push(this._get(s1, p1, o1, true));\n        }\n      });\n      return arr;\n    }\n\n    /**\n     * Finds all statements with a given predicate and object.\n     * Note: Close to optimal without further indexing, to many checks due to iteration via _map.\n     * @returns {rdfjson/Statement[]}\n     */\n    _findPO(p, o) {\n      const arr = [];\n      this.forEach((s1, p1, o1) => {\n        if (p === p1 && util.objectEquals(o, o1)) {\n          arr.push(this._get(s1, p1, o1, true));\n        }\n      });\n      return arr;\n    }\n\n    _validate() {\n      const graph = this._graph;\n      const report = { valid: true, errors: [], nr: 0 };\n      Object.keys(graph).forEach((s) => {\n        const subj = graph[s];\n        if (util.isObject(subj)) {\n          Object.keys(subj).forEach((p) => {\n            const objArr = subj[p];\n            if (util.isArray(objArr)) {\n              objArr.forEach((o, oindex) => {\n                if (util.isObject(o)) {\n                  if (o.type != null) {\n                    if (util.isString(o.value)) {\n                      report.nr += 1;\n                    } else {\n                      report.errors.push({ s, p, oindex: (oindex + 1), message: `Object ${oindex + 1} in object array must have the 'value' attribute pointing to a string.` });\n                      report.valid = false;\n                    }\n                  } else {\n                    report.errors.push({ s, p, oindex: (oindex + 1), message: `Object ${oindex + 1} in object array lacks the attribute type, must be either 'literal', 'resource' or 'bnode'.` });\n                    report.valid = false;\n                  }\n                } else {\n                  report.errors.push({ s, p, oindex: (oindex + 1), message: `Element ${oindex + 1} in object array is not an object.` });\n                  report.valid = false;\n                }\n              });\n            } else {\n              report.errors.push({ s, p, message: 'Predicate must point to an array of objects.' });\n              report.valid = false;\n            }\n          });\n        } else {\n          report.errors.push({ s, message: 'Subject must point to an object.' });\n          report.valid = false;\n        }\n      });\n      return report;\n    }\n\n    /**\n     * Creates a new bnode that is unique in the current graph.\n     * Bnodes in temporarily unasserted statements (currently removed from the graph)\n     * are avoided as well.\n     * @returns {String}\n     */\n    _newBNode() {\n      this._indexBNodes();\n      let p;\n      let n;\n      let bnode;\n      for (p = 1; p < 20; p++) {\n        for (n = 1; n <= p; n++) {\n          bnode = `_:${Math.floor(Math.random() * (Math.pow(10, p) + 1))}`;\n          if (this._bnodes[bnode] !== true) {\n            this._bnodes[bnode] = true;\n            return bnode;\n          }\n        }\n      }\n      throw new Error('Failed creating a new blank node, increadible unprobable...');\n    }\n\n    /**\n     * Adds the bnodes in the graph to the bnode index.\n     * The index can be calculated late, just before the first call to create.\n     * (Bnodes in statements that are removed are added in advance to the index as\n     * they may be only temporarily unasserted and when they are asserted again\n     * they should not overlap with newly created bnodes.)\n     * After the index is created all statemnts added update the index.\n     */\n    _indexBNodes() {\n      if (this._bnodesIndexed) {\n        return;\n      }\n      const graph = this._graph;\n      Object.keys(graph).forEach((s) => {\n        if (s.indexOf('_:') === 0) {\n          this._bnodes[s] = true;\n        }\n        const subj = graph[s];\n        Object.keys(subj).forEach((p) => {\n          if (p.indexOf('_:') === 0) {\n            this._bnodes[p] = true;\n          }\n          subj[p].forEach((o) => {\n            if (o.type === 'bnode') {\n              this._bnodes[o.value] = true;\n            }\n          });\n        });\n      });\n      this._bnodesIndexed = true;\n    }\n\n    /**\n     * Adds any bnodes in the given parameters to the index (the index may still be incomplete).\n     * @param {String} s the subject in a statement.\n     * @param {String} p the predicate in a statement.\n     * @param {Object} o the object in a statement.\n     */\n    _trackBNodes(s, p, o) {\n      if (s.indexOf('_:') === 0) {\n        this._bnodes[s] = true;\n      }\n      if (p.indexOf('_:') === 0) {\n        this._bnodes[p] = true;\n      }\n      if (o.type === 'bnode') {\n        this._bnodes[o.value] = true;\n      }\n    }\n  };\n\n  return Graph;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/rdfjson/Graph.js?");

/***/ }),

/***/ "./node_modules/rdfjson/Statement.js":
/*!*******************************************!*\
  !*** ./node_modules/rdfjson/Statement.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ./namespaces */ \"./node_modules/rdfjson/namespaces.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (namespaces =>\n  /**\n   * rdfjson.Statement Represents a statement in a graph.\n   * Never create directly, use the methods in rdfjson.Graph.\n   * Constructs a statement from the provided parts, the object is assumed to be the same\n   * actual javascript object as is used in the graph.\n   *\n   * @param {rdfjson.Graph} graph the rdfjson.Graph we will manipulate.\n   * @param {String} s the subject in the statement\n   * @param {String} p the predicate in the statement.\n   * @param {Object} o the object in the statement.\n   * @param {Boolean} asserted indicates if the statement is asserted in the accompanied graph.\n   * @class\n   */\n  class {\n    constructor(graph, s, p, o, asserted) {\n      this._graph = graph;\n      this._s = s;\n      this._p = p;\n      this._o = o;\n      this._o._statement = this;\n      this._asserted = asserted;\n    }\n\n    /**\n     * The Graph this Statement is associated with.\n     * @returns {rdfjson.Graph}\n     */\n    getGraph() {\n      return this._graph;\n    }\n\n    /**\n     * An asserted statement is present in its associated Graph\n     * @param {Boolean} asserted\n     */\n    setAsserted(asserted) {\n      if (asserted !== this._asserted) {\n        if (asserted) {\n          this._graph.add(this);\n        } else {\n          this._graph.remove(this);\n        }\n        this._asserted = asserted;\n      }\n    }\n\n    /**\n     * True if the Statement is asserted in the Graph.\n     * @returns {Boolean}\n     */\n    isAsserted() {\n      return this._asserted;\n    }\n\n    /**\n     * The subject of this statement.\n     * @returns {String}\n     */\n    getSubject() {\n      return this._s;\n    }\n\n    isSubjectBlank() {\n      if (this._sIsBlank !== true && this._sIsBlank !== false) {\n        this._sIsBlank = this._graph._bnodes[this._s] === true;\n      }\n      return this._sIsBlank;\n    }\n\n    /**\n     * Sets the subject of this statement, other Statements with this resource as subject or object\n     * is not affected.\n     * @param {String} s must be a valid URI.\n     */\n    setSubject(s) {\n      const _s = namespaces.expand(s);\n      if (this._asserted) {\n        this._graph.remove(this);\n        this._s = _s;\n        this._graph.add(this);\n        delete this._sIsBlank;\n      } else {\n        this._s = _s;\n      }\n    }\n\n    /**\n     * The predicate of this Statement.\n     * @returns {String}\n     */\n    getPredicate() {\n      return this._p;\n    }\n\n    /**\n     * Sets the predicate of this statement.\n     * @param {String} p must be a valid URI.\n     */\n    setPredicate(p) {\n      const _p = namespaces.expand(p);\n      if (this._asserted) {\n        this._graph.remove(this);\n        this._p = _p;\n        this._graph.add(this);\n      } else {\n        this._p = _p;\n      }\n    }\n\n    /**\n     * The object of the Statement.\n     *\n     * @returns {Object}\n     */\n    getObject() {\n      return this._o;\n    }\n\n    /**\n     * The object of the Statement.\n     *\n     * @returns {Object}\n     */\n    getCleanObject() {\n      const _o = this._o;\n      const o = {\n        value: _o.value,\n        type: _o.type,\n      };\n      if (_o.language) {\n        o.language = _o.language;\n      }\n      if (this._o.datatype) {\n        o.datatype = _o.datatype;\n      }\n      return o;\n    }\n\n    /**\n     * @returns {String} one of uri, bnode and literal\n     */\n    getType() {\n      return this._o.type;\n    }\n\n    /**\n     * @param {String} type must be one of uri, bnode and literal.\n     */\n// eslint-disable-next-line no-unused-vars,class-methods-use-this\n    setType(type) {\n      throw new Error('Changing the type of an object is not supported, create a new' +\n        ' statement instead.');\n    }\n\n    /**\n     * If type is uri it is a URI, if type is a literal it is the literal string.\n     * If type is a bnode the value is a internal bnode identity, should only be used for\n     * references within the current graph.\n     * @returns {String}\n     */\n    getValue() {\n      return this._o.value;\n    }\n\n    /**\n     * Sets the uri, literal or bnode of the current Statement depending on the type.\n     * @param {String} value must be a uri if the type so indicates.\n     * @param {boolean} silent the graph is not marked as \"changed\" if set to true\n     */\n    setValue(value, silent) {\n      if (value !== this._o.value) {\n        this._o.value = value;\n        if (this.isAsserted() && silent !== true) {\n          this._graph.setChanged();\n        }\n      }\n    }\n\n    /**\n     * @returns {String} a language expressed using RFC-3066\n     */\n    getLanguage() {\n      return this._o.lang;\n    }\n\n    /**\n     * Sets the language of the object, only acceptable if the type is literal.\n     * @param {String} lang the language expressed using RFC-30-66\n     */\n    setLanguage(lang) {\n      if (this._o.type !== 'literal') {\n        throw new Error('Cannot set the language for a resource, has to be a literal');\n      }\n      if (this._o.lang !== lang) {\n        this._o.lang = lang;\n        if (this.isAsserted()) {\n          this._graph.setChanged();\n        }\n      }\n    }\n\n    /**\n     * The datatype of this object, only acceptable if the type is literal.\n     * @returns {String} the datatype is always represented via a URI.\n     */\n    getDatatype() {\n      return this._o.datatype;\n    }\n\n    /**\n     * Set the datatype, only acceptable if the type is literal and no language is set.\n     * @param {String} datatype the datatype expressed as a URI.\n     */\n    setDatatype(datatype) {\n      if (this._o.type !== 'literal' || this._o.lang != null) {\n        throw new Error('Cannot set the datatype for a resource, has to be a literal');\n      }\n      if (this._o.datatype !== datatype) {\n        this._o.datatype = datatype;\n        if (this.isAsserted()) {\n          this._graph.setChanged();\n        }\n      }\n    }\n  }).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/rdfjson/Statement.js?");

/***/ }),

/***/ "./node_modules/rdfjson/formats/rdfjson/util.js":
/*!******************************************************!*\
  !*** ./node_modules/rdfjson/formats/rdfjson/util.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* global define,rdfjson*/\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (() => {\n  const exports = {};\n\n  // Four helper methods, from dojo.\n  exports.isObject = it => it !== undefined &&\n      (it === null || typeof it === 'object' || exports.isArray(it) || exports.isFunction(it));\n\n  exports.isString = it => (typeof it === 'string' || it instanceof String);\n\n  exports.isArray = it => Array.isArray(it);\n\n  exports.isFunction = it => Object.prototype.toString.call(it) === '[object Function]';\n\n  exports.statementEquals = (s1, s2) =>\n    s1.s === s2.s && s1.p === s2.p && exports.objectEquals(s1.o, s2.o);\n\n  /**\n   * Adds a statement to a graph object according to the rdf/json specification.\n   * Duplicates of the same statement are not allowed in a graph,\n   * hence they are not allowed to be added.\n   *\n   * The object in the statement are represented via an javascript object containing:\n   * <ul><li>type - one of 'uri', 'literal' or 'bnode' (<b>required</b> and must be lowercase).</li>\n   * <li>value - the lexical value of the object (<b>required</b>, full URIs should be used,\n   * not namespaced using abbreviations)</li>\n   * <li>lang - the language of a literal value (<b>optional</b>\n   * but if supplied it must not be empty)</li>\n   * <li>datatype - the datatype URI of the literal value (<b>optional</b>)</li>\n   * The 'lang' and 'datatype' keys should only be used if the value of the 'type' key is \"literal\".\n   *\n   * @param {Object} graph according to the rdf/json specification.\n   * @param {String} s a URI representing the subject in a statement.\n   * @param {String} p a URI representing the predicate in a statement.\n   * @param {Object} o an object representing either a resource or a literal,\n   *  see format described above.\n   * @return {Object} the javascript object corresponding to the statements object just added,\n   *  note that it might be a clone of the object given in the parameter o\n   * (for instance when the statement already exists in the graph).\n   * @throws {String} an error message if the arguments are not valid.\n   * @see The <a href=\"http://n2.talis.com/wiki/RDF_JSON_Specification\">RDF JSON Specification</a>.\n   */\n  exports.add = (graph, s, p, o) => {\n    exports.checkForWrongArgs([graph, s, p, o]);\n    if (graph[s] === undefined) {\n      graph[s] = {};\n      graph[s][p] = [o];\n      return o;\n    }\n    if (graph[s][p] === undefined) {\n      graph[s][p] = [o];\n      return o;\n    }\n    let i;\n    const objs = graph[s][p];\n    for (i = objs.length - 1; i >= 0; i--) {\n      if (exports.objectEquals(o, objs[i])) {\n        return objs[i];\n      }\n    }\n    objs.push(o);\n    return o;\n  };\n\n  /**\n   * Tries to remove the specified statement from the given graph.\n   * If it is successful it returns the object of the statment removed.\n   *\n   * @param {Object} graph\n   * @param {Object} s\n   * @param {Object} p\n   * @param {Object} o\n   * @return {Object|undefined} the object of the statement removed,\n   *  undefined if no matching statement could be removed.\n   * @throws {String} an error message if the arguments are not valid.\n   * @see exports.add for a longer treatment of the allowed arguments.\n   */\n  exports.remove = (graph, s, p, o) => {\n    exports.checkForWrongArgs([graph, s, p, o]);\n    if (graph[s] === undefined || graph[s][p] === undefined) {\n      return undefined;\n    }\n    let i;\n    const objs = graph[s][p];\n    for (i = objs.length - 1; i >= 0; i--) {\n      if (exports.objectEquals(o, objs[i])) {\n        const _o = objs[i];\n        objs.splice(i, 1);\n        exports.cleanup(graph, s, p);\n        return _o;\n      }\n    }\n    return undefined;\n  };\n\n  /**\n   * Checks if the graph contains the specified statement.\n   *\n   * @param {Object} graph\n   * @param {String} s\n   * @param {String} p\n   * @param {Object} o\n   * @return {Object|undefined} the object of the found statement if the graph contains the\n   * specified statement, undefined otherwise.\n   * @throws {String} an error message if the arguments are not valid.\n   */\n  exports.contains = (graph, s, p, o) => {\n    exports.checkForWrongArgs([graph, s, p, o]);\n    if (graph[s] === undefined || graph[s][p] === undefined) {\n      return undefined;\n    }\n    let i;\n    const objs = graph[s][p];\n    for (i = objs.length - 1; i >= 0; i--) {\n      if (exports.objectEquals(o, objs[i])) {\n        return objs[i];\n      }\n    }\n    return undefined;\n  };\n\n  /**\n   * Removes empty structures in the graph for the given subject and predicate.\n   * It checks if there are subjects without outgoing properties or\n   * if there are properties with no objects.\n   *\n   * Note that the need for this function is a consequence of the normalized character\n   * of the RDF JSON format.\n   *\n   * @param {Object} graph\n   * @param {Object} s\n   * @param {Object} p\n   */\n  exports.cleanup = (graph, s, p) => {\n    if (graph[s][p].length === 0) {\n      delete graph[s][p];\n      if (Object.keys(graph[s]).length === 0) {\n        delete graph[s];\n      }\n    }\n  };\n\n  /**\n   * Checks the arguments for the add function are valid\n   * (and all other functions that have the same signature).\n   *\n   * @param {Array} args an array of the arguments for the add function.\n   * @throws {String} with a message if the arguments are not valid.\n   * @see exports.add\n   */\n  exports.checkForWrongArgs = (args) => {\n    if (!exports.isObject(args[0])) {\n      throw new Error('Graph is not a object.');\n    } else if (!exports.isString(args[1])) {\n      throw new Error('Subject is not a string.');\n    } else if (!exports.isString(args[2])) {\n      throw new Error('Predicate is not a string.');\n    } else if (!exports.isObject(args[3])) {\n      throw new Error('Object is not a object.');\n    } else if (args[3].type === undefined) {\n      throw new Error(\"Object has no type attribute, must be one of 'uri', 'literal', or\" +\n        \" 'bnode'\");\n    } else if (args[3].value === undefined) {\n      throw new Error('Object has no value attribute corresponding to the lexical value ' +\n        'of the object.');\n    }\n    // TODO check that subject, predicate and object.datatype are uris.\n    // TODO Also check that object.value is a URI if the type is uri.\n  };\n\n  /**\n   * Compares two statement objects according to the RDF JSON Specification.\n   * If both o1 and o2 are strings they are simply compared.\n   * If one of o1 and o2 are a string and the other is an object the string is compared with the\n   * value of the object ignoring any other attributes of the object.\n   * If both o1 and o2 are null or undefined they are considered equal.\n   *\n   * @param {*} o1\n   * @param {*} o2\n   * @return {Boolean} true if they have the same type, lexical value, language, and datatype.\n   */\n  exports.objectEquals = (o1, o2) => {\n    if (o1 === o2 || (o1 == null && o1 === o2)) {\n      return true;\n    }\n    // Note, using\n    if (exports.isString(o1)) {\n      if (exports.isString(o2)) {\n        return o1 === o2;\n      }\n      return o1 === o2.value;\n    } else if (exports.isString(o2)) {\n      return o1.value === o2;\n    }\n    return o1.type === o2.type && o1.value === o2.value && o1.lang === o2.lang &&\n      o1.datatype === o2.datatype;\n  };\n\n  exports.findDirectOrRDFValue = (graph, subject, predicate) => {\n    const arr = graph.find(subject, predicate);\n    if (arr.length > 0) {\n      if (arr[0].getType() !== 'bnode') {\n        return arr[0].getValue();\n      }\n      return graph.findFirstValue(arr[0].getValue(), 'http://www.w3.org/1999/02/22-rdf-syntax-ns#value');\n    }\n    return undefined;\n  };\n  return exports;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/rdfjson/formats/rdfjson/util.js?");

/***/ }),

/***/ "./node_modules/rdfjson/namespaces.js":
/*!********************************************!*\
  !*** ./node_modules/rdfjson/namespaces.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports], __WEBPACK_AMD_DEFINE_RESULT__ = ((exports) => {\n  const nss = {\n    ical: 'http://www.w3.org/2002/12/cal/ical#',\n    vcard: 'http://www.w3.org/2006/vcard/ns#',\n    dcterms: 'http://purl.org/dc/terms/',\n    skos: 'http://www.w3.org/2004/02/skos/core#',\n    rdfs: 'http://www.w3.org/2000/01/rdf-schema#',\n    rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',\n    owl: 'http://www.w3.org/2002/07/owl#',\n    vs: 'http://www.w3.org/2003/06/sw-vocab-status/ns#',\n    foaf: 'http://xmlns.com/foaf/0.1/',\n    wot: 'http://xmlns.com/wot/0.1/',\n    dc: 'http://purl.org/dc/elements/1.1/',\n    xsd: 'http://www.w3.org/2001/XMLSchema#',\n    dcat: 'http://www.w3.org/ns/dcat#',\n    org: 'http://www.w3.org/ns/org#',\n    gn: 'http://www.geonames.org/ontology#',\n    schema: 'http://schema.org/',\n  };\n  let nscounter = 0;\n  const _nsify = (ns, expanded, localname) => {\n    if (!nss[ns]) {\n      nss[ns] = expanded;\n    }\n    return {\n      abbrev: ns,\n      ns: expanded,\n      localname,\n      full: expanded + localname,\n      pretty: `${ns}:${localname}`,\n    };\n  };\n\n  exports.nsify = (uri) => {\n    const ens = Object.keys(nss).find(ns => uri.indexOf(nss[ns]) === 0);\n    if (ens) {\n      return _nsify(ens, nss[ens], uri.substring(nss[ens].length));\n    }\n\n    let slash = uri.lastIndexOf('/');\n    const hash = uri.lastIndexOf('#');\n    if (hash > slash) {\n      slash = hash;\n    }\n    nscounter += 1;\n    return _nsify(`ns${nscounter}`, uri.substring(0, slash + 1), uri.substring(slash + 1));\n  };\n\n  exports.shortenKnown = (uri) => {\n    const ens = Object.keys(nss).find(ns => uri.indexOf(nss[ns]) === 0);\n    if (ens) {\n      return _nsify(ens, nss[ens], uri.substring(nss[ens].length)).pretty;\n    }\n    return uri;\n  };\n\n  exports.shorten = uri => exports.nsify(uri).pretty;\n\n  exports.expand = (str) => {\n    const arr = str.split(':');\n    if (arr.length === 2 && nss.hasOwnProperty(arr[0])) {\n      return nss[arr[0]] + arr[1];\n    }\n    return str;\n  };\n\n  exports.add = (ns, full) => {\n    if (typeof ns === 'string') {\n      nss[ns] = full;\n    } else if (typeof ns === 'object') {\n      Object.keys(ns).forEach((nskey) => {\n        nss[nskey] = ns[nskey];\n      });\n    }\n  };\n\n  exports.registry = () => nss;\n\n  return exports;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/rdfjson/namespaces.js?");

/***/ }),

/***/ "./node_modules/rdfjson/print.js":
/*!***************************************!*\
  !*** ./node_modules/rdfjson/print.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;!(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! ./namespaces */ \"./node_modules/rdfjson/namespaces.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = ((exports, namespaces) => {\n  /**\n   * @param {rdfjson.Graph} graph\n   * @param {String} subject a URI for the subject to focus on\n   */\n  exports.pretty = (graph, subject) => {\n    const pretty = {};\n    const stmts = graph.find(subject);\n    for (let i = 0; i < stmts.length; i++) {\n      const stmt = stmts[i];\n      if (stmt.getType() !== 'bnode') {\n        pretty[namespaces.shorten(stmt.getPredicate())] = stmt.getValue();\n      }\n    }\n    return pretty;\n  };\n\n  exports.statementTree = (graph, subject, visited) => {\n    const _visited = visited || {};\n    const stmts = graph ? graph.find(subject) : [];\n    const arr = [];\n    for (let i = 0; i < stmts.length; i++) {\n      const stmt = stmts[i];\n      if (stmt.getType() === 'literal') {\n        arr.push({ stmt });\n      } else {\n        const row = { stmt };\n        const obj = stmt.getValue();\n        if (!_visited[obj]) {\n          _visited[obj] = true;\n          row.children = exports.statementTree(graph, obj, _visited);\n        }\n      }\n    }\n    return arr;\n  };\n\n  exports.statementList = (graph, subject) => {\n    const tree = exports.statementTree(graph, subject);\n    const arr = [];\n    const f = (stmts, level) => {\n      for (let i = 0; i < stmts.length; i++) {\n        const stmt = stmts[i];\n        stmt.indent = level;\n        arr.push(stmt);\n        if (stmt.children) {\n          f(stmt.children, level + 1);\n          delete stmt.children;\n        }\n      }\n    };\n    f(tree, 1);\n    return arr;\n  };\n\n  exports.prettyTree = function (graph, subject) {\n    const delegates = exports.statementList(graph, subject);\n    for (let i = 0; i < delegates.length; i++) {\n      const delegate = delegates[i];\n      const stmt = delegate.stmt;\n      if (stmt.isSubjectBlank()) {\n        delegate.s = stmt.getSubject();\n      } else {\n        delegate.s = namespaces.shorten(stmt.getSubject());\n      }\n      delegate.p = namespaces.shorten(stmt.getPredicate());\n      const t = stmt.getType();\n      if (t === 'uri') {\n        delegate.o = namespaces.shorten(stmt.getValue());\n        const lang = stmt.getLanguage();\n        const dt = stmt.getDatatype();\n        if (lang != null) {\n          delegate.o += `@@${lang}`;\n        } else if (dt != null) {\n          delegate.o += `^^${dt}`;\n        }\n      } else if (t === 'literal') {\n        delegate.o = `\"${stmt.getValue()}\"`;\n      } else {\n        delegate.o = `\"${stmt.getValue()}\"`;\n      }\n    }\n    return delegates;\n  };\n  return exports;\n}).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n\n//# sourceURL=webpack:///./node_modules/rdfjson/print.js?");

/***/ }),

/***/ "./node_modules/superagent-jsonp/dist/superagent-jsonp.js":
/*!****************************************************************!*\
  !*** ./node_modules/superagent-jsonp/dist/superagent-jsonp.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar removeCallback = function removeCallback(_ref) {\n  var script = _ref.script,\n      callbackName = _ref.callbackName,\n      timeout = _ref.timeout;\n\n  if (script && script.parentNode) script.parentNode.removeChild(script);\n\n  delete window[callbackName];\n\n  clearTimeout(timeout); // clear timeout (for onerror event listener)\n};\n\nvar jsonp = function jsonp(requestOrConfig) {\n  var end = function end() {\n    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    return function handler(callback) {\n      var _this = this;\n\n      var callbackParam = config.callbackParam || 'callback';\n      var callbackName = config.callbackName || 'superagentCallback' + (new Date().valueOf() + parseInt(Math.random() * 1000, 10));\n      var timeoutLimit = config.timeout || 1000;\n\n      var timeout = setTimeout(jsonp.errorWrapper.bind(this), timeoutLimit);\n\n      this._jsonp = {\n        callbackName: callbackName,\n        callback: callback,\n        timeout: timeout\n      };\n\n      window[callbackName] = jsonp.callbackWrapper.bind(this);\n\n      this._query.push(encodeURIComponent(callbackParam) + '=' + encodeURIComponent(callbackName));\n      var queryString = this._query.join('&');\n\n      var s = document.createElement('script');\n      {\n        var separator = this.url.indexOf('?') > -1 ? '&' : '?';\n        var url = this.url + separator + queryString;\n\n        s.src = url;\n\n        // Handle script load error #27\n        s.onerror = function (e) {\n          jsonp.errorWrapper.call(_this, e);\n        };\n      }\n\n      document.head.appendChild(s);\n      this._jsonp.script = s;\n\n      return this;\n    };\n  };\n\n  var reqFunc = function reqFunc(request) {\n    // In case this is in nodejs, run without modifying request\n    if (typeof window === 'undefined') return request;\n\n    request.end = end.call(request, requestOrConfig);\n    return request;\n  };\n\n  // if requestOrConfig is request\n  if (typeof requestOrConfig.end === 'function') {\n    return reqFunc(requestOrConfig);\n  }\n\n  return reqFunc;\n};\n\njsonp.callbackWrapper = function callbackWrapper(body) {\n  var err = null;\n  var res = { body: body };\n\n  removeCallback(this._jsonp);\n\n  this._jsonp.callback.call(this, err, res);\n};\n\njsonp.errorWrapper = function errorWrapper(error) {\n  var err = new Error('404 Not found');\n  if (error && error instanceof Event && error.type === 'error') {\n    err = new Error('Connection issue');\n  }\n\n  removeCallback(this._jsonp);\n\n  this._jsonp.callback.call(this, err, null);\n};\n\n// Prefer node/browserify style requires\nif (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {\n  module.exports = jsonp;\n} else if (true) {\n  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n    return { jsonp: jsonp };\n  }).apply(null, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n} else {}\n\n//# sourceURL=webpack:///./node_modules/superagent-jsonp/dist/superagent-jsonp.js?");

/***/ }),

/***/ "./node_modules/superagent/lib/agent-base.js":
/*!***************************************************!*\
  !*** ./node_modules/superagent/lib/agent-base.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("function Agent() {\n  this._defaults = [];\n}\n\n[\"use\", \"on\", \"once\", \"set\", \"query\", \"type\", \"accept\", \"auth\", \"withCredentials\", \"sortQuery\", \"retry\", \"ok\", \"redirects\",\n \"timeout\", \"buffer\", \"serialize\", \"parse\", \"ca\", \"key\", \"pfx\", \"cert\"].forEach(function(fn) {\n  /** Default setting for all requests from this agent */\n  Agent.prototype[fn] = function(/*varargs*/) {\n    this._defaults.push({fn:fn, arguments:arguments});\n    return this;\n  }\n});\n\nAgent.prototype._setDefaults = function(req) {\n    this._defaults.forEach(function(def) {\n      req[def.fn].apply(req, def.arguments);\n    });\n};\n\nmodule.exports = Agent;\n\n\n//# sourceURL=webpack:///./node_modules/superagent/lib/agent-base.js?");

/***/ }),

/***/ "./node_modules/superagent/lib/client.js":
/*!***********************************************!*\
  !*** ./node_modules/superagent/lib/client.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nvar Emitter = __webpack_require__(/*! component-emitter */ \"./node_modules/component-emitter/index.js\");\nvar RequestBase = __webpack_require__(/*! ./request-base */ \"./node_modules/superagent/lib/request-base.js\");\nvar isObject = __webpack_require__(/*! ./is-object */ \"./node_modules/superagent/lib/is-object.js\");\nvar ResponseBase = __webpack_require__(/*! ./response-base */ \"./node_modules/superagent/lib/response-base.js\");\nvar Agent = __webpack_require__(/*! ./agent-base */ \"./node_modules/superagent/lib/agent-base.js\");\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nvar request = exports = module.exports = function(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new exports.Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new exports.Request('GET', method);\n  }\n\n  return new exports.Request(method, url);\n}\n\nexports.Request = Request;\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only version of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    pushEncodedKeyValuePair(pairs, key, obj[key]);\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (val != null) {\n    if (Array.isArray(val)) {\n      val.forEach(function(v) {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    } else if (isObject(val)) {\n      for(var subkey in val) {\n        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n      }\n    } else {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(val));\n    }\n  } else if (val === null) {\n    pairs.push(encodeURIComponent(key));\n  }\n}\n\n/**\n * Expose serialization method.\n */\n\nrequest.serializeObject = serialize;\n\n/**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var pair;\n  var pos;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'text/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\nrequest.serialize = {\n  'application/x-www-form-urlencoded': serialize,\n  'application/json': JSON.stringify\n};\n\n/**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    if (index === -1) { // could be empty line, just skip it\n      continue;\n    }\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  // should match /json or +json\n  // but not /json-seq\n  return /[\\/+]json($|[^-\\w])/.test(mime);\n}\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req) {\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  var status = this.xhr.status;\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n  this._setStatusProperties(status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n\n  if (null === this.text && req._responseType) {\n    this.body = this.xhr.response;\n  } else {\n    this.body = this.req.method != 'HEAD'\n      ? this._parseBody(this.text ? this.text : this.xhr.response)\n      : null;\n  }\n}\n\nResponseBase(Response.prototype);\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str) {\n  var parse = request.parse[this.type];\n  if (this.req._parser) {\n    return this.req._parser(this, str);\n  }\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      if (self.xhr) {\n        // ie9 doesn't have 'response' property\n        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\n        // issue #876: return the http status code if the response parsing fails\n        err.status = self.xhr.status ? self.xhr.status : null;\n        err.statusCode = err.status; // backwards-compat only\n      } else {\n        err.rawResponse = null;\n        err.status = null;\n      }\n\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    var new_err;\n    try {\n      if (!self._isResponseOK(res)) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n      }\n    } catch(custom_err) {\n      new_err = custom_err; // ok() callback can throw\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      new_err.original = err;\n      new_err.response = res;\n      new_err.status = res.status;\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `RequestBase`.\n */\n\nEmitter(Request.prototype);\nRequestBase(Request.prototype);\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} [pass] optional in case of using 'bearer' as type\n * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (1 === arguments.length) pass = '';\n  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options\n    options = pass;\n    pass = '';\n  }\n  if (!options) {\n    options = {\n      type: 'function' === typeof btoa ? 'basic' : 'auto',\n    };\n  }\n\n  var encoder = function(string) {\n    if ('function' === typeof btoa) {\n      return btoa(string);\n    }\n    throw new Error('Cannot use basic auth, btoa is not a function');\n  };\n\n  return this._auth(user, pass, options, encoder);\n};\n\n/**\n * Add query-string `val`.\n *\n * Examples:\n *\n *   request.get('/shoes')\n *     .query('size=10')\n *     .query({ color: 'blue' })\n *\n * @param {Object|String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `options` (or filename).\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String|Object} options\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, options){\n  if (file) {\n    if (this._data) {\n      throw Error(\"superagent can't mix .send() and .attach()\");\n    }\n\n    this._getFormData().append(field, file, options || file.name);\n  }\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  if (this._shouldRetry(err, res)) {\n    return this._retry();\n  }\n\n  var fn = this._callback;\n  this.clearTimeout();\n\n  if (err) {\n    if (this._maxRetries) err.retries = this._retries - 1;\n    this.emit('error', err);\n  }\n\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n// This only warns, because the request is still likely to work\nRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\n  console.warn(\"This is not supported in browser version of superagent\");\n  return this;\n};\n\n// This throws, because it can't send/receive data as expected\nRequest.prototype.pipe = Request.prototype.write = function(){\n  throw Error(\"Streaming is not supported in browser version of superagent\");\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nRequest.prototype._isHost = function _isHost(obj) {\n  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\n  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\n}\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  if (this._endCalled) {\n    console.warn(\"Warning: .end() was called twice. This is not supported in superagent\");\n  }\n  this._endCalled = true;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // querystring\n  this._finalizeQueryString();\n\n  return this._end();\n};\n\nRequest.prototype._end = function() {\n  var self = this;\n  var xhr = (this.xhr = request.getXHR());\n  var data = this._formData || this._data;\n\n  this._setTimeouts();\n\n  // state change\n  xhr.onreadystatechange = function(){\n    var readyState = xhr.readyState;\n    if (readyState >= 2 && self._responseTimeoutTimer) {\n      clearTimeout(self._responseTimeoutTimer);\n    }\n    if (4 != readyState) {\n      return;\n    }\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (!status) {\n      if (self.timedout || self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(direction, e) {\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = direction;\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    try {\n      xhr.onprogress = handleProgress.bind(null, 'download');\n      if (xhr.upload) {\n        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  }\n\n  // initiate request\n  try {\n    if (this.username && this.password) {\n      xhr.open(this.method, this.url, true, this.username, this.password);\n    } else {\n      xhr.open(this.method, this.url, true);\n    }\n  } catch (err) {\n    // see #1149\n    return this.callback(err);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) {\n      serialize = request.serialize['application/json'];\n    }\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n\n    if (this.header.hasOwnProperty(field))\n      xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\nrequest.agent = function() {\n  return new Agent();\n};\n\n[\"GET\", \"POST\", \"OPTIONS\", \"PATCH\", \"PUT\", \"DELETE\"].forEach(function(method) {\n  Agent.prototype[method.toLowerCase()] = function(url, fn) {\n    var req = new request.Request(method, url);\n    this._setDefaults(req);\n    if (fn) {\n      req.end(fn);\n    }\n    return req;\n  };\n});\n\nAgent.prototype.del = Agent.prototype['delete'];\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn) {\n  var req = request('GET', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn) {\n  var req = request('HEAD', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = function(url, data, fn) {\n  var req = request('OPTIONS', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, data, fn) {\n  var req = request('DELETE', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n}\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn) {\n  var req = request('PATCH', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn) {\n  var req = request('POST', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn) {\n  var req = request('PUT', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n\n//# sourceURL=webpack:///./node_modules/superagent/lib/client.js?");

/***/ }),

/***/ "./node_modules/superagent/lib/is-object.js":
/*!**************************************************!*\
  !*** ./node_modules/superagent/lib/is-object.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n\n\n//# sourceURL=webpack:///./node_modules/superagent/lib/is-object.js?");

/***/ }),

/***/ "./node_modules/superagent/lib/request-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/superagent/lib/request-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = __webpack_require__(/*! ./is-object */ \"./node_modules/superagent/lib/is-object.js\");\n\n/**\n * Expose `RequestBase`.\n */\n\nmodule.exports = RequestBase;\n\n/**\n * Initialize a new `RequestBase`.\n *\n * @api public\n */\n\nfunction RequestBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in RequestBase.prototype) {\n    obj[key] = RequestBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.clearTimeout = function _clearTimeout(){\n  clearTimeout(this._timer);\n  clearTimeout(this._responseTimeoutTimer);\n  delete this._timer;\n  delete this._responseTimeoutTimer;\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set format of binary response body.\n * In browser valid formats are 'blob' and 'arraybuffer',\n * which return Blob and ArrayBuffer, respectively.\n *\n * In Node all values result in Buffer.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeouts.\n *\n * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\n * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\n *\n * Value of 0 or false means no timeout.\n *\n * @param {Number|Object} ms or {response, deadline}\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.timeout = function timeout(options){\n  if (!options || 'object' !== typeof options) {\n    this._timeout = options;\n    this._responseTimeout = 0;\n    return this;\n  }\n\n  for(var option in options) {\n    switch(option) {\n      case 'deadline':\n        this._timeout = options.deadline;\n        break;\n      case 'response':\n        this._responseTimeout = options.response;\n        break;\n      default:\n        console.warn(\"Unknown timeout option\", option);\n    }\n  }\n  return this;\n};\n\n/**\n * Set number of retry attempts on error.\n *\n * Failed requests will be retried 'count' times if timeout or err.code >= 500.\n *\n * @param {Number} count\n * @param {Function} [fn]\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.retry = function retry(count, fn){\n  // Default to 1 if no count passed or true\n  if (arguments.length === 0 || count === true) count = 1;\n  if (count <= 0) count = 0;\n  this._maxRetries = count;\n  this._retries = 0;\n  this._retryCallback = fn;\n  return this;\n};\n\nvar ERROR_CODES = [\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EADDRINFO',\n  'ESOCKETTIMEDOUT'\n];\n\n/**\n * Determine if a request should be retried.\n * (Borrowed from segmentio/superagent-retry)\n *\n * @param {Error} err\n * @param {Response} [res]\n * @returns {Boolean}\n */\nRequestBase.prototype._shouldRetry = function(err, res) {\n  if (!this._maxRetries || this._retries++ >= this._maxRetries) {\n    return false;\n  }\n  if (this._retryCallback) {\n    try {\n      var override = this._retryCallback(err, res);\n      if (override === true) return true;\n      if (override === false) return false;\n      // undefined falls back to defaults\n    } catch(e) {\n      console.error(e);\n    }\n  }\n  if (res && res.status && res.status >= 500 && res.status != 501) return true;\n  if (err) {\n    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;\n    // Superagent timeout\n    if (err.timeout && err.code == 'ECONNABORTED') return true;\n    if (err.crossDomain) return true;\n  }\n  return false;\n};\n\n/**\n * Retry request\n *\n * @return {Request} for chaining\n * @api private\n */\n\nRequestBase.prototype._retry = function() {\n\n  this.clearTimeout();\n\n  // node\n  if (this.req) {\n    this.req = null;\n    this.req = this.request();\n  }\n\n  this._aborted = false;\n  this.timedout = false;\n\n  return this._end();\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} [reject]\n * @return {Request}\n */\n\nRequestBase.prototype.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    var self = this;\n    if (this._endCalled) {\n      console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\");\n    }\n    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {\n      self.end(function(err, res) {\n        if (err) innerReject(err);\n        else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n};\n\nRequestBase.prototype['catch'] = function(cb) {\n  return this.then(undefined, cb);\n};\n\n/**\n * Allow for extension\n */\n\nRequestBase.prototype.use = function use(fn) {\n  fn(this);\n  return this;\n};\n\nRequestBase.prototype.ok = function(cb) {\n  if ('function' !== typeof cb) throw Error(\"Callback required\");\n  this._okCallback = cb;\n  return this;\n};\n\nRequestBase.prototype._isResponseOK = function(res) {\n  if (!res) {\n    return false;\n  }\n\n  if (this._okCallback) {\n    return this._okCallback(res);\n  }\n\n  return res.status >= 200 && res.status < 300;\n};\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nRequestBase.prototype.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nRequestBase.prototype.getHeader = RequestBase.prototype.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nRequestBase.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val`, or multiple fields with one object\n * for \"multipart/form-data\" request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n *\n * request.post('/upload')\n *   .field({ foo: 'bar', baz: 'qux' })\n *   .end(callback);\n * ```\n *\n * @param {String|Object} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nRequestBase.prototype.field = function(name, val) {\n  // name should be either a string or an object.\n  if (null === name || undefined === name) {\n    throw new Error('.field(name, val) name can not be empty');\n  }\n\n  if (this._data) {\n    console.error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObject(name)) {\n    for (var key in name) {\n      this.field(key, name[key]);\n    }\n    return this;\n  }\n\n  if (Array.isArray(val)) {\n    for (var i in val) {\n      this.field(name, val[i]);\n    }\n    return this;\n  }\n\n  // val should be defined now\n  if (null === val || undefined === val) {\n    throw new Error('.field(name, val) val can not be empty');\n  }\n  if ('boolean' === typeof val) {\n    val = '' + val;\n  }\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nRequestBase.prototype.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\nRequestBase.prototype._auth = function(user, pass, options, base64Encoder) {\n  switch (options.type) {\n    case 'basic':\n      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));\n      break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n      break;\n\n    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\n      this.set('Authorization', 'Bearer ' + user);\n      break;\n  }\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequestBase.prototype.withCredentials = function(on) {\n  // This is browser-only functionality. Node side is no-op.\n  if (on == undefined) on = true;\n  this._withCredentials = on;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Maximum size of buffered response body, in bytes. Counts uncompressed size.\n * Default 200MB.\n *\n * @param {Number} n\n * @return {Request} for chaining\n */\nRequestBase.prototype.maxResponseSize = function(n){\n  if ('number' !== typeof n) {\n    throw TypeError(\"Invalid argument\");\n  }\n  this._maxResponseSize = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nRequestBase.prototype.toJSON = function() {\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header,\n  };\n};\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.send = function(data){\n  var isObj = isObject(data);\n  var type = this._header['content-type'];\n\n  if (this._formData) {\n    console.error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObj && !this._data) {\n    if (Array.isArray(data)) {\n      this._data = [];\n    } else if (!this._isHost(data)) {\n      this._data = {};\n    }\n  } else if (data && this._data && this._isHost(this._data)) {\n    throw Error(\"Can't merge these send calls\");\n  }\n\n  // merge\n  if (isObj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!isObj || this._isHost(data)) {\n    return this;\n  }\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Sort `querystring` by the sort function\n *\n *\n * Examples:\n *\n *       // default order\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery()\n *         .end(callback)\n *\n *       // customized sort function\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery(function(a, b){\n *           return a.length - b.length;\n *         })\n *         .end(callback)\n *\n *\n * @param {Function} sort\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.sortQuery = function(sort) {\n  // _sort default to true but otherwise can be a function or boolean\n  this._sort = typeof sort === 'undefined' ? true : sort;\n  return this;\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\nRequestBase.prototype._finalizeQueryString = function(){\n  var query = this._query.join('&');\n  if (query) {\n    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\n  }\n  this._query.length = 0; // Makes the call idempotent\n\n  if (this._sort) {\n    var index = this.url.indexOf('?');\n    if (index >= 0) {\n      var queryArr = this.url.substring(index + 1).split('&');\n      if ('function' === typeof this._sort) {\n        queryArr.sort(this._sort);\n      } else {\n        queryArr.sort();\n      }\n      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\n    }\n  }\n};\n\n// For backwards compat only\nRequestBase.prototype._appendQueryString = function() {console.trace(\"Unsupported\");}\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequestBase.prototype._timeoutError = function(reason, timeout, errno){\n  if (this._aborted) {\n    return;\n  }\n  var err = new Error(reason + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  err.code = 'ECONNABORTED';\n  err.errno = errno;\n  this.timedout = true;\n  this.abort();\n  this.callback(err);\n};\n\nRequestBase.prototype._setTimeouts = function() {\n  var self = this;\n\n  // deadline\n  if (this._timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\n    }, this._timeout);\n  }\n  // response timeout\n  if (this._responseTimeout && !this._responseTimeoutTimer) {\n    this._responseTimeoutTimer = setTimeout(function(){\n      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\n    }, this._responseTimeout);\n  }\n};\n\n\n//# sourceURL=webpack:///./node_modules/superagent/lib/request-base.js?");

/***/ }),

/***/ "./node_modules/superagent/lib/response-base.js":
/*!******************************************************!*\
  !*** ./node_modules/superagent/lib/response-base.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Module dependencies.\n */\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/superagent/lib/utils.js\");\n\n/**\n * Expose `ResponseBase`.\n */\n\nmodule.exports = ResponseBase;\n\n/**\n * Initialize a new `ResponseBase`.\n *\n * @api public\n */\n\nfunction ResponseBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in ResponseBase.prototype) {\n    obj[key] = ResponseBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponseBase.prototype.get = function(field) {\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponseBase.prototype._setHeaderProperties = function(header){\n    // TODO: moar!\n    // TODO: make this a util\n\n    // content-type\n    var ct = header['content-type'] || '';\n    this.type = utils.type(ct);\n\n    // params\n    var params = utils.params(ct);\n    for (var key in params) this[key] = params[key];\n\n    this.links = {};\n\n    // links\n    try {\n        if (header.link) {\n            this.links = utils.parseLinks(header.link);\n        }\n    } catch (err) {\n        // ignore\n    }\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponseBase.prototype._setStatusProperties = function(status){\n    var type = status / 100 | 0;\n\n    // status / class\n    this.status = this.statusCode = status;\n    this.statusType = type;\n\n    // basics\n    this.info = 1 == type;\n    this.ok = 2 == type;\n    this.redirect = 3 == type;\n    this.clientError = 4 == type;\n    this.serverError = 5 == type;\n    this.error = (4 == type || 5 == type)\n        ? this.toError()\n        : false;\n\n    // sugar\n    this.created = 201 == status;\n    this.accepted = 202 == status;\n    this.noContent = 204 == status;\n    this.badRequest = 400 == status;\n    this.unauthorized = 401 == status;\n    this.notAcceptable = 406 == status;\n    this.forbidden = 403 == status;\n    this.notFound = 404 == status;\n    this.unprocessableEntity = 422 == status;\n};\n\n\n//# sourceURL=webpack:///./node_modules/superagent/lib/response-base.js?");

/***/ }),

/***/ "./node_modules/superagent/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/superagent/lib/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.type = function(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.params = function(str){\n  return str.split(/ *; */).reduce(function(obj, str){\n    var parts = str.split(/ *= */);\n    var key = parts.shift();\n    var val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Parse Link header fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.parseLinks = function(str){\n  return str.split(/ *, */).reduce(function(obj, str){\n    var parts = str.split(/ *; */);\n    var url = parts[0].slice(1, -1);\n    var rel = parts[1].split(/ *= */)[1].slice(1, -1);\n    obj[rel] = url;\n    return obj;\n  }, {});\n};\n\n/**\n * Strip content related fields from `header`.\n *\n * @param {Object} header\n * @return {Object} header\n * @api private\n */\n\nexports.cleanHeader = function(header, changesOrigin){\n  delete header['content-type'];\n  delete header['content-length'];\n  delete header['transfer-encoding'];\n  delete header['host'];\n  // secuirty\n  if (changesOrigin) {\n    delete header['authorization'];\n    delete header['cookie'];\n  }\n  return header;\n};\n\n\n//# sourceURL=webpack:///./node_modules/superagent/lib/utils.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n\n\n//# sourceURL=webpack:///(webpack)/buildin/harmony-module.js?");

/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, main, dependencies, devDependencies, description, licenses, homepage, dojoBuild, scripts, default */
/***/ (function(module) {

eval("module.exports = {\"name\":\"store\",\"version\":\"4.6.0-SNAPSHOT\",\"main\":\"main\",\"dependencies\":{\"blueimp-md5\":\"^2.10.0\",\"dojo\":\"^1.12.2\",\"dojo-util\":\"^1.13.0\",\"rdfjson\":\"git+https://bitbucket.org/metasolutions/rdfjson.git#1.3\",\"requirejs\":\"2.3.5\",\"superagent\":\"^3.8.3\",\"superagent-jsonp\":\"^0.2.1\"},\"devDependencies\":{\"bower\":\"^1.8.4\",\"dojo-webpack-plugin\":\"^2.7.2\",\"jaguarjs-jsdoc\":\"0.0.1\",\"nodeunit\":\"~0.8.6\",\"webpack\":\"^4.6.0\",\"webpack-bundle-analyzer\":\"^2.13.0\",\"webpack-cli\":\"^2.1.3\"},\"description\":\"Store is a JS-library for working EntryStore.\",\"licenses\":[{\"type\":\"BSD\",\"url\":\"Some URL here.\"}],\"homepage\":\"https://bitbucket.org/metasolutions/entrystore.js\",\"dojoBuild\":\"package.js\",\"scripts\":{\"build\":\"./build/build.sh\",\"webpack\":\"webpack\",\"test\":\"webpack --config webpack.config.test.js\"}};\n\n//# sourceURL=webpack:///./package.json?");

/***/ }),

/***/ "./promiseUtil.js":
/*!************************!*\
  !*** ./promiseUtil.js ***!
  \************************/
/*! exports provided: promiseUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"promiseUtil\", function() { return promiseUtil; });\n  /**\n   * This module contains utility methods for promises.\n   *\n   * @exports store/promiseUtil\n   * @namespace\n   */\n  const promiseUtil = {};\n\n  /**\n   * Asynchronous forEach relying on promises that works in serial rather than parallell.\n   * It invokes a function on each item only after the promise from the previous item\n   * in the array has succeeded.\n   * If one of the promises fails the forEach promise fails altogheter.\n   * The result is provided in an array if the items is an array.\n   * In the case where the items is an object the same object is returned\n   * but with the values replaced with the result of the promise.\n   * (The function is applied to the value of each key in the items object.)\n   *\n   * @param {array|object} items\n   * @param {function} func a function that is applied to each item and must return a promise\n   * @returns {forEachPromise}\n   */\n  promiseUtil.forEach = (items, func) => new Promise((resolve, reject) => {\n    let arr;\n    let cursor;\n    const onFailure = (err) => {\n      reject(err);\n    };\n    if (Array.isArray(items)) {\n      const results = [];\n      arr = items.slice();\n      cursor = (result) => {\n        results.push(result);\n        if (arr.length > 0) {\n          return promiseUtil.toPromise(func(arr.shift())).then(cursor, onFailure);\n        }\n        resolve(results);\n        return undefined;\n      };\n      if (arr.length === 0) {\n        resolve(results);\n      } else {\n        promiseUtil.toPromise(func(arr.shift())).then(cursor, onFailure);\n      }\n    } else if (typeof items === 'object') {\n      arr = Object.keys(items);\n      let itemKey;\n      const onSuccess = (result) => {\n        items[itemKey] = result;\n        cursor();\n      };\n      cursor = () => {\n        if (arr.length > 0) {\n          itemKey = arr.shift();\n          promiseUtil.toPromise(func(items[itemKey])).then(onSuccess, onFailure);\n        } else {\n          resolve(items);\n        }\n      };\n      cursor();\n    }\n  });\n\n  /**\n   * Makes sure a value is a promise, if needed wraps it as a promise.\n   * If the value the false boolean it is interpreted as a reject.\n   *\n   * @param value the value to wrap in a promise, if it already is a promise it is returned.\n   * @return {Promise}\n   */\n  promiseUtil.toPromise = (value) => {\n    if (typeof value === 'object' && value !== null && typeof value.then === 'function') {\n      return value;\n    }\n    if (value === false) {\n      return Promise.reject(value);\n    }\n    return Promise.resolve(value);\n  };\n\n  \n\n/**\n * @name forEachPromise\n * @extends dojo/promise/Promise\n * @class\n */\n/**\n * @name forEachPromise#then\n * @param {forEachCallback} onSuccess\n * @param {function} onError\n */\n/**\n * @callback forEachCallback\n * @param {array|object} result\n */\n\n\n//# sourceURL=webpack:///./promiseUtil.js?");

/***/ }),

/***/ "./terms.js":
/*!******************!*\
  !*** ./terms.js ***!
  \******************/
/*! exports provided: terms */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"terms\", function() { return terms; });\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./types */ \"./types.js\");\n\nconst namespaces = __webpack_require__(/*! rdfjson/namespaces */ \"./node_modules/rdfjson/namespaces.js\");\n\n  const inv = (obj) => {\n    const iobj = {};\n    Object.keys(obj).forEach((key) => {\n      iobj[obj[key]] = key;\n    });\n    return iobj;\n  };\n\n    // Namespaces\n  const ns = 'http://entrystore.org/terms/';\n  const rdfns = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\n  const xsdns = 'http://www.w3.org/2001/XMLSchema#';\n  namespaces.add('prov', 'http://www.w3.org/ns/prov#');\n\n  const terms = {\n    homeContext: `${ns}homeContext`,\n    resource: `${ns}resource`,\n    metadata: `${ns}metadata`,\n    externalMetadata: `${ns}externalMetadata`,\n    reasoningFacts: `${ns}reasoningFacts`,\n    status: {\n      property: `${ns}status`,\n      InProgress: `${ns}InProgress`,\n      Pending: `${ns}Pending`,\n      Succeeded: `${ns}Success`,\n      Failed: `${ns}Failed`,\n    },\n    rdf: {\n      type: `${rdfns}type`,\n    },\n    pipeline: {\n      pipeline: `${ns}pipeline`,\n      pipelineData: `${ns}pipelineData`,\n      transform: `${ns}transform`,\n      transformPriority: `${ns}transformPriority`,\n      transformType: `${ns}transformType`,\n      transformArgument: `${ns}transformArgument`,\n      transformArgumentKey: `${ns}transformArgumentKey`,\n      transformArgumentValue: `${ns}transformArgumentValue`,\n      transformDestination: `${ns}transformDestination`,\n      transformDetectDestination: `${ns}transformDetectDestination`,\n    },\n    acl: {\n      read: `${ns}read`,\n      write: `${ns}write`,\n    },\n    xsd: {\n      integer: `${xsdns}integer`,\n      float: `${xsdns}float`,\n      boolean: `${xsdns}boolean`,\n    },\n  };\n\n    // EntryType\n  const et = {};\n  et[`${ns}Local`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LOCAL;\n  et[`${ns}Link`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LINK;\n  et[`${ns}LinkReference`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LINKREF;\n  et[`${ns}Reference`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_REF;\n  et.default = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].ET_LOCAL;   // The default option\n  terms.entryType = et;\n  terms.invEntryType = inv(et);\n\n    // GraphType\n  const gt = {};\n  gt[`${ns}None`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_NONE;\n  gt[`${ns}Context`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_CONTEXT;\n  gt[`${ns}SystemContext`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_SYSTEMCONTEXT;\n  gt[`${ns}User`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_USER;\n  gt[`${ns}Group`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_GROUP;\n  gt[`${ns}List`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_LIST;\n  gt[`${ns}ResultList`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_RESULTLIST;\n  gt[`${ns}Graph`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_GRAPH;\n  gt[`${ns}Pipeline`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_PIPELINE;\n  gt[`${ns}PipelineResult`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_PIPELINERESULT;\n  gt[`${ns}String`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_STRING;\n  gt.default = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].GT_NONE; // The default option\n  terms.graphType = gt;\n  terms.invGraphType = inv(gt);\n\n    // ResourceType\n  const rt = {};\n  rt[`${ns}InformationResource`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_INFORMATIONRESOURCE;\n  rt[`${ns}ResolvableInformationResource`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_RESOLVABLEINFORMATIONRESOURCE;\n  rt[`${ns}NamedResource`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_NAMEDRESOURCE;\n  rt[`${ns}Unknown`] = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_UNKNOWN;\n  rt.default = _types__WEBPACK_IMPORTED_MODULE_0__[\"types\"].RT_INFORMATIONRESOURCE; // The default option\n  terms.resourceType = rt;\n  terms.invResourceType = inv(rt);\n\n  \n\n\n//# sourceURL=webpack:///./terms.js?");

/***/ }),

/***/ "./tests/Auth.js":
/*!***********************!*\
  !*** ./tests/Auth.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ */ \"./index.js\");\n\n\n  //browsers have the global nodeunit already available\n\n  var es = new ___WEBPACK_IMPORTED_MODULE_1__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].repository);\n  var auth = es.getAuth();\n\n  /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({ inGroups: true,\n    authorize: {\n      cookieSignIn: function(test) {\n        test.expect(1);\n        auth.login(\"Donald\", \"donalddonald\").then(function(data) {\n          test.ok(data.user === \"donald\");\n          test.done();\n        }, function() {\n          test.ok(false, \"Could not authenticate user Donald with password donalddonald\");\n          test.done();\n        });\n      },\n      cookieSignOut: function(test) {\n        test.expect(1);\n        auth.login(\"Donald\", \"donalddonald\").then(function() {\n          return auth.logout().then(function(data) {\n            test.ok(data.user === \"guest\", \"Failed sign out from account Donald.\");\n            test.done();\n          });\n        }, function() {\n          test.ok(false, \"Could not de-authenticate user Donald.\");\n          test.done();\n        });\n      }\n    },\n    fromGuestListeners: {\n      setUp: function (callback) {\n        auth.logout().then(function() {\n          callback();\n        });\n      },\n      login: function (test) {\n        test.expect(1);\n        var f = function (topic, data) {\n          if (topic === \"login\") {\n            test.ok(data.user === \"donald\");\n            test.done();\n            auth.removeAuthListener(f);\n          }\n        };\n        auth.addAuthListener(f);\n        auth.login(\"Donald\", \"donalddonald\");\n      },\n      guestUserEntry: function(test) {\n        test.expect(1);\n        auth.getUserEntry().then(function(entry) {\n          var name = entry.getResource(true).getName();\n          test.ok(name === \"guest\");\n          test.done();\n        });\n      }\n    },\n    fromUserListeners: {\n      setUp: function (callback) {\n        auth.login(\"Donald\", \"donalddonald\").then(function() {\n          callback();\n        });\n      },\n      logout: function(test) {\n        test.expect(1);\n        var f = function(topic, data) {\n          if (topic === \"logout\") {\n            test.ok(data.user === \"guest\");\n            test.done();\n            auth.removeAuthListener(f);\n          }\n        };\n        auth.addAuthListener(f);\n        auth.logout();\n      },\n      signedInUserEntry: function(test) {\n        test.expect(1);\n        auth.getUserEntry().then(function(entry) {\n          test.ok(entry.getResource(true).getName() === \"donald\");\n          test.done();\n        });\n      }\n    }\n  }));\n\n\n//# sourceURL=webpack:///./tests/Auth.js?");

/***/ }),

/***/ "./tests/Cache.js":
/*!************************!*\
  !*** ./tests/Cache.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ */ \"./index.js\");\n\n  \n\n  var e1 = {\n    getURI: function() {return \"http://example.com/1/entry/1\"},\n    getResourceURI: function() {return \"http://example.com/1/resource/1\"}\n  };\n\n  /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n    initCache: function(test) {\n      var c = new ___WEBPACK_IMPORTED_MODULE_0__[\"Cache\"]();\n      test.ok(c != null);\n      test.done();\n    },\n    basicCacheFunctionlity: function(test) {\n      var c = new ___WEBPACK_IMPORTED_MODULE_0__[\"Cache\"]();\n      c.cache(e1);\n      test.ok(c.get(e1.getURI()) === e1, \"Failed to retrieve cached entry.\");\n      test.done();\n    },\n    invalidateCache: function(test) {\n      var c = new ___WEBPACK_IMPORTED_MODULE_0__[\"Cache\"]();\n      c.cache(e1);\n      c.addCacheUpdateListener(function(event, entry) {\n        test.ok(event===\"allEntriesNeedRefresh\");\n        test.done();\n      });\n      c.allNeedRefresh();\n    },\n    listeners: function(test) {\n      var c = new ___WEBPACK_IMPORTED_MODULE_0__[\"Cache\"]();\n      c.cache(e1);\n      c.addCacheUpdateListener(function(event, entry) {\n        test.ok(event===\"allEntriesNeedRefresh\");\n        test.done();\n      });\n      c.allNeedRefresh();\n    }\n  }));\n\n\n//# sourceURL=webpack:///./tests/Cache.js?");

/***/ }),

/***/ "./tests/Entry.js":
/*!************************!*\
  !*** ./tests/Entry.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ */ \"./index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\nconst stamp = __webpack_require__(/*! ../libs/dojo/date/stamp */ \"./libs/dojo/date/stamp.js\");\n\n\n\nconst Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n\n\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_0__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].repository);\n    var c = es.getContextById(\"1\");\n    var ready;\n    var dct = \"http://purl.org/dc/terms/\";\n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n        setUp: function(callback) {\n            if (!ready) {\n                es.auth({user: \"Donald\", password: \"donalddonald\"}).then(function() {\n                    ready = true;\n                    callback();\n                });\n            } else {\n                callback();\n            }\n        },\n        refresh: function(test) {\n            c.newEntry().commit().then(function(entry) {\n                var graph = entry.getMetadata();\n                graph.add(entry.getResourceURI(), dct+\"title\", {type: \"literal\", value:\"Some title\"});\n                test.ok(!graph.isEmpty(), \"Could not change the metadata graph.\");\n                entry.refresh(true, true).then(function() {\n                    test.ok(entry.getMetadata().isEmpty(), \"Could not refresh, unsaved changes in metadata graph remains.\");\n                    test.done();\n                });\n            });\n        },\n        createEntry: function(test) {\n            c.newEntry().commit().then(function(entry) {\n                test.ok(entry.getId() != null, \"Entry created but without id!\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed creating entry in context 1.\");\n                test.done();\n            });\n        },\n        createEntryWithId: function(test) {\n          c.newEntry('tomato').commit().then((e1) => {\n            test.ok(e1.getId() === 'tomato', \"Entry could not be created with specific id\" +\n              \" 'tomato'!\");\n            return e1.del().then(() => {\n              c.newEntry('tomato').commit().then((e2) => {\n                test.ok(e2.getId() === 'tomato', \"Entry could not be created with specific id\" +\n                  \" 'banana'!\");\n                e2.del();\n                test.done();\n              }, () => {\n                test.ok(false, 'Not allowed to create entry with id that already existed');\n                test.done();\n              });\n            });\n          }, () => {\n            test.ok(false, \"Failed creating entry with specific Id 'tomato' in context 1.\");\n            test.done();\n          });\n        },\n        createNamedEntry: function(test) {\n            c.newNamedEntry().commit().then(function(entry) {\n                test.ok(entry.getId() != null, \"Entry created but without id!\");\n                test.ok(entry.isNamedResource(), \"Entry but not as named resource!\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed creating entry in context 1.\");\n                test.done();\n            });\n        },\n        createWithMetadata: function(test) {\n            var pe = c.newEntry();\n            var uri = pe.getResourceURI();\n            var graph = new Graph();\n            graph.add(uri, dct+\"title\", {value: \"Some title\", type: \"literal\"});\n            pe.setMetadata(graph);\n            pe.commit().then(function(entry) {\n                var md = entry.getMetadata();\n                test.ok(md.findFirstValue(entry.getResourceURI(), dct+\"title\") === \"Some title\", \"Failed to create an entry with a title.\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Could not create an Entry in Context 1.\");\n                test.done();\n            });\n        },\n        updateMetadata: function(test) {\n            var pe = c.newEntry().commit().then(function(entry) {\n                entry.getMetadata(true).add(entry.getResourceURI(), dct+\"title\", {type: \"literal\", value:\"Some title2\"});\n                entry.commitMetadata().then(function() {\n                    entry.getMetadata().findAndRemove();\n                    test.ok(entry.getMetadata().findFirstValue(entry.getResourceURI(), dct+\"title\") == null, \"Could not clear the RDF graph.\");\n                    entry.refresh(true, true).then(function() {\n                        test.ok(entry.getMetadata().findFirstValue(entry.getResourceURI(), dct+\"title\") === \"Some title2\",\n                            \"Failed to create and update the metadata with a new title.\");\n                        test.done();\n                    });\n                }, function() {\n                    test.ok(false, \"Could not save metadata for new entry!\");\n                    test.done();\n                });\n            });\n        },\n      updateMetadataViaPrototype: function(test) {\n        var pe = c.newEntry().commit().then(function(e1) {\n          return c.newEntry(e1.getId()).addL(dct + \"title\", \"Some title2\").commitMetadata();\n        }).then(() => {\n          test.done();\n        }, () => {\n          test.ok(false, \"Failed to update metadata via prototypeentry and a given entryid\");\n          test.done();\n        });\n\n      },\n      linkEntry: function(test) {\n            var uri = \"http://example.com/\";\n            c.newLink(uri).commit().then(function(entry) {\n                test.ok(entry.isLink(), \"Failed to create a link.\");\n                test.ok(uri == entry.getResourceURI(), \"Failed to set resourceURI during creation step.\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed to create link in Context 1.\");\n                test.done();\n            });\n        },\n        linkRefEntry: function(test) {\n            var uri = \"http://example.com/\";\n            c.newLinkRef(uri, uri).commit().then(function(entry) {\n                test.ok(entry.isLinkReference(), \"Failed to create a link-reference.\");\n                test.ok(uri == entry.getResourceURI(), \"Failed to set resourceURI during creation step.\");\n                test.ok(uri == entry.getEntryInfo().getExternalMetadataURI(), \"Failed to set external metadatat URI during creation step.\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed to create linkreference in Context 1.\");\n                test.done();\n            });\n        },\n\n        refEntry: function(test) {\n            var uri = \"http://example.com/\";\n            c.newRef(uri, uri).commit().then(function(entry) {\n                test.ok(entry.isReference(), \"Failed to create a reference.\");\n                test.ok(uri == entry.getResourceURI(), \"Failed to set resourceURI during creation step.\");\n                test.ok(uri == entry.getEntryInfo().getExternalMetadataURI(), \"Failed to set external metadatat URI during creation step.\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed to create a reference in Context 1.\");\n                test.done();\n            });\n        },\n        listEntry: function(test) {\n            c.newList().commit().then(function(entry) {\n                test.ok(entry.isList(), \"Entry created, but it is not a list as expected.\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed to create a list in Context 1.\");\n                test.done();\n            });\n        },\n        graphEntry: function(test) {\n            var g = new Graph();\n            g.add(\"http://example.com/\", dct+\"title\", {type: \"literal\", value:\"Some title1\"});\n\n           c.newGraph(g).commit().then(function(entry) {\n                test.ok(entry.isGraph(), \"Entry created, but it is not a graph as expected.\");\n                entry.getResource().then(function(res) {\n                    test.ok(res.getGraph().find().length === 1, \"The created graph Entry does save the provided graph upon creation\");\n                    var g2 = new Graph();\n                    res.setGraph(g2).commit().then(function() {\n                        entry.setRefreshNeeded();\n                        entry.refresh().then(function() {\n                            test.ok(res.getGraph().isEmpty(), \"Failed to update \")\n                            test.done();\n                        });\n                    })\n                    g2.add(\"http://example.com/\", dct+\"title\", {type: \"literal\", value:\"Some title2\"});\n                }, function(err) {\n                    test.ok(false, \"Failed to load resource graph for graph entry.\");\n                    test.done();\n                });\n            }, function() {\n                test.ok(false, \"Failed to create a graph in Context 1.\");\n                test.done();\n            });\n        },\n        updateGraphEntry: function(test) {\n            c.newGraph().commit().then(function(entry) {\n                entry.getResource().then(function(res) {\n                    var g = new Graph();\n                    g.add(\"http://example.com/\", dct+\"title\", {type: \"literal\", value:\"Some title\"});\n                    res.setGraph(g).commit().then(function() {\n                        test.ok(res.getGraph().find(null, dct+\"subject\").length === 1, \"Statement added after save missing, should be there until refresh.\");\n                        entry.setRefreshNeeded();\n                        entry.refresh().then(function() {\n                            test.ok(!res.getGraph().isEmpty(), \"Failed to update graph of graph entry\");\n                            test.ok(res.getGraph().find(null, dct+\"subject\").length === 0, \"Statement added after save operation remains, strange.\");\n                            test.done();\n                        }, function(err) {\n                            test.ok(false, \"Failed refreshing: \"+err);\n                            test.done();\n                        });\n                    }, function(err) {\n                        test.ok(false, \"Failed to update resource of entry graph. \"+err);\n                        test.done();\n                    });\n                    g.add(\"http://example.com/\", dct+\"subject\", {type: \"literal\", value:\"not good if it remains in graph after update\"});\n\n                });\n            }, function() {\n                test.ok(false, \"Failed to create a graph in Context 1.\");\n                test.done();\n            });\n        },\n        stringEntry: function(test) {\n            c.newString(\"one\").commit().then(function(entry) {\n                test.ok(entry.isString(), \"Entry created, but it is not a string as expected.\");\n                entry.getResource().then(function(res) {\n                    test.ok(res.getString() === \"one\", \"The created string entry does not have the string provided upon creation.\");\n                    test.done();\n                });\n            }, function() {\n                test.ok(false, \"Failed to create a string entry in Context 1.\");\n                test.done();\n            });\n        },\n        updateStringEntry: function(test) {\n            var str = \"a string\";\n            c.newString().commit().then(function(entry) {\n                entry.getResource().then(function(res) {\n                    test.ok(res.getString() === \"\", \"Empty string instead of null\");\n                    res.setString(str).commit().then(function() {\n                        test.ok(res.getString() === str, \"String is not set correctly\");\n                        res.setString(\"\").commit().then(function() {\n                            entry.setRefreshNeeded();\n                            entry.refresh().then(function() {\n                                test.ok(res.getString() === \"\", \"Reload from repository gave wrong string\");\n                                test.done();\n                            }, function(err) {\n                                test.ok(false, \"Failed refreshing: \"+err);\n                                test.done();\n                            });\n                        });\n                    }, function(err) {\n                        test.ok(false, \"Failed to update resource of string entry. \"+err);\n                        test.done();\n                    });\n                });\n            }, function() {\n                test.ok(false, \"Failed to create a string entry in Context 1.\");\n                test.done();\n            });\n        },\n        createWithCachedExternalMetadata: function(test) {\n            var uri = \"http://example.com/\";\n            var graph = new Graph();\n            graph.add(uri, dct+\"title\", {value: \"Some title\", type: \"literal\"});\n            c.newLinkRef(uri, uri).setCachedExternalMetadata(graph).commit().then(function(entry) {\n                test.ok(!entry.getCachedExternalMetadata().isEmpty(), \"Failed to set cached external metadata in creation step.\");\n                test.done();\n            }, function() {\n                test.ok(false, \"Failed to create Entry with cached external metadata in Context 1.\");\n                test.done();\n            });\n        },\n\n        updateCachedExternalMetadata: function(test) {\n            var uri = \"http://example.com/\";\n            c.newRef(uri, uri).commit().then(function(entry) {\n                var cemd = entry.getCachedExternalMetadata();\n                test.ok(cemd.isEmpty(), \"New Link entry has non-empty cached external metadata, strange.\");\n                cemd.add(entry.getResourceURI(), dct+\"title\", {value: \"A title\", type: \"literal\"});\n                return entry.commitCachedExternalMetadata().then(function() {\n                    test.ok(!cemd.isEmpty(), \"Failed to save cached external metadata.\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Something went wrong updating cachedExternalMetadata.\");\n                    test.done();\n                });\n            });\n        },\n\n        ifUnModifiedSinceCheck: function(test) {\n            c.newEntry().commit().then(function(entry) {\n                var md = entry.getMetadata();\n                var uri = entry.getResourceURI();\n                entry.getMetadata().addL(uri, \"dcterms:title\", \"title1\");\n                entry.commitMetadata().then(function() {\n                    test.ok(entry.getMetadata().find(null, \"dcterms:title\").length === 1, \"More than one title added, should not happen.\");\n                });\n\n                //Manually set back the date of modification to force 412 status code.\n                var eig = entry.getEntryInfo().getGraph();\n                var stmt = eig.find(entry.getURI(), \"http://purl.org/dc/terms/modified\")[0];\n                stmt.setValue(stamp.toISOString(new Date(\"2000\")));\n\n                entry.getMetadata().addL(uri, \"dcterms:title\", \"title2\");\n                entry.commitMetadata().then(function() {\n                    test.ok(false, \"No conflict although saving metadata twice in a row\");\n                }, function() {\n                    test.done();\n                });\n            }, function() {\n                test.ok(false, \"Could not create an Entry in Context 1.\");\n                test.done();\n            });\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/Entry.js?");

/***/ }),

/***/ "./tests/EntryInfo.js":
/*!****************************!*\
  !*** ./tests/EntryInfo.js ***!
  \****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ */ \"./index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n\n\nconst Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_0__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].repository);\n    var c = es.getContextById(\"1\");\n    var ready;\n    var dct = \"http://purl.org/dc/terms/\";\n    var now = new Date();\n    var yesterday = (new Date()).setDate(now.getDate() - 1);\n    var tomorrow = (new Date()).setDate(now.getDate() + 1);\n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n        setUp: function(callback) {\n            if (!ready) {\n                es.auth({user: \"Donald\", password: \"donalddonald\"}).then(function() {\n                    ready = true;\n                    callback();\n                });\n            } else {\n                callback();\n            }\n        },\n        dates: function(test) {\n            c.newEntry().create().then(function(entry) {\n                var ei = entry.getEntryInfo();\n                var cr = ei.getCreationDate();\n                test.ok(cr > yesterday && cr < tomorrow, \"Creation date seems to be incorrect.\");\n                var mo = ei.getModificationDate();\n                test.ok(mo > yesterday && mo < tomorrow, \"Modification date seems to be incorrect\");\n                test.ok(mo >= cr, \"Modification date should be same as creation date after first creation.\");\n                entry.setMetadata(new Graph({\"http://example.com\": {\"http://purl.org/dc/terms/title\": [{value: \"A title\", type: \"literal\"}]}}))\n                    .commitMetadata().then(function(entry) {\n                        test.ok(ei.getModificationDate() > mo, \"Modification date not changed after metadata was updated.\");\n                        test.done();\n                    });\n            });\n        },\n        creator: function(test) {\n            es.getUserEntry().then(function(user) {\n                c.newEntry().create().then(function(entry) {\n                    var ei = entry.getEntryInfo();\n                    test.ok(ei.getCreator() === user.getResourceURI(), \"Creator does not match current user.\");\n                    test.done();\n                });\n            });\n        },\n        contributors: function(test) {\n            es.getUserEntry().then(function(user) {\n                c.newEntry().create().then(function(entry) {\n                    var contr = entry.getEntryInfo().getContributors();\n                    test.ok(contr.length ===  1 && contr[0] === user.getResourceURI(), \"No contributors.\");\n                    test.done();\n                });\n            });\n        },\n        acl: function(test) {\n            c.newEntry().commit().then(function(entry) {\n                var ei = entry.getEntryInfo();\n                test.ok(!ei.hasACL(), \"ACL present on created entry when no ACL was provided.\");\n                var acl = {admin: [es.getEntryURI(\"_principals\", \"admin\")]};\n                ei.setACL(acl);\n                test.ok(ei.hasACL(), \"No ACL present although it was just set.\");\n                ei.commit().then(function() {\n                    var acl = ei.getACL();\n                    test.ok(acl.admin.length === 1, \"ACL failed to save.\");\n                    test.ok(acl.rread.length === 0, \"Local modifications of ACL after save operation remains.\");\n                    test.done();\n                }, function(err) {\n                    test.ok(false, \"Failed updating ACL. \"+err);\n                    test.done();\n                });\n                acl.rread = [es.getEntryURI(\"_principals\", \"admin\")];\n                ei.setACL(acl); //Make a local modification.\n            });\n        },\n        createWithACL: function(test) {\n            var acl = {admin: [es.getEntryURI(\"_principals\", \"admin\")]};\n            c.newEntry().setACL(acl).create().then(function(entry) {\n                test.ok(entry.getEntryInfo().hasACL(), \"No ACL present although it was provided on create.\");\n                test.done();\n            });\n        },\n        changeResourceURI: function(test) {\n            var uri = \"http://example.com\";\n            var uri2 = uri + \"/about\";\n            c.newLink(uri).create().then(function(entry) {\n                var ei = entry.getEntryInfo();\n                ei.setResourceURI(uri2);\n                test.ok(uri2 === ei.getResourceURI(), \"Failed to set new URI\");\n                ei.commit().then(function() {\n                    test.ok(ei.getResourceURI() === uri2, \"Failed to save new URI, local change remains.\");\n                    test.done();\n                });\n                ei.setResourceURI(uri); //Resetting old uri, local change that should be reset after save.\n            });\n        },\n        changeExternalMetadataURI: function(test) {\n            var res = \"http://slashdot.org\";\n            var mduri = \"http://example.com\";\n            var mduri2 = mduri + \"/about\";\n            c.newRef(res, mduri).create().then(function(entry) {\n                var ei = entry.getEntryInfo();\n                ei.setExternalMetadataURI(mduri2);\n                test.ok(ei.getExternalMetadataURI() === mduri2, \"Failed to set new external metadata URI\");\n                ei.commit().then(function() {\n                    test.ok(ei.getExternalMetadataURI() === mduri2, \"Failed to save new URI, local change remains.\");\n                    test.done();\n                });\n                ei.setExternalMetadataURI(mduri); //Resetting old uri, local change that should be reset after save.\n            });\n        },\n        metadataRevisions: function(test) {\n            var pe = c.newEntry().addL(\"dcterms:title\", \"First\").commit()\n              .then(function(entry) {\n                test.ok(entry.getEntryInfo().getMetadataRevisions().length === 1);\n                entry.addL(\"dcterms:description\", \"Second\");\n                return entry.commitMetadata().then(function(entry) {\n                    var ei = entry.getEntryInfo();\n                    var revs = ei.getMetadataRevisions();\n                    test.ok(revs.length === 2);\n                    return ei.getMetadataRevisionGraph(revs[1].uri).then(function(graph) {\n                        test.ok(graph.findFirstValue(null, \"dcterms:description\") == null);\n                        test.ok(entry.getMetadata().findFirstValue(null, \"dcterms:description\") != null);\n                        return ei.getMetadataRevisionGraph(ei.getMetadataURI()+\"?rev=3\")\n                            .then(function() {\n                                test.ok(false, \"Should not be able to load non-existing versions\");\n                                test.done();\n                            }, function(err) {\n                                test.done();\n                            });\n                    });\n                });\n              }).then(null, function(err) {\n                test.ok(false, \"Problem creating entry or updating metadata in context 1\");\n                test.done();\n            });\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/EntryInfo.js?");

/***/ }),

/***/ "./tests/EntryStore.js":
/*!*****************************!*\
  !*** ./tests/EntryStore.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ */ \"./index.js\");\n\n\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_1__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].repository);\n    var authAdminReady;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({ inGroups: true,\n        withoutLogin: {\n            setUp: function(callback) {\n                es.getAuth().logout().then(function() {\n                    callback();\n                });\n            },\n            initStore: function(test) {\n                test.ok(es.getBaseURI() === _config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].repository);\n                test.done();\n            },\n            getEntry: function(test) {\n                es.getEntry(_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].repository+\"1/entry/1\").then(function(entry) {\n                    test.ok(entry != null);\n                    test.done();\n                }, function(err) {\n                    test.ok(false, err);\n                    test.done();\n                })\n            },\n            getContext: function(test) {\n                var c = es.getContextById(\"1\");\n                test.ok(c.getId() === \"1\");\n                test.done();\n            },\n        },\n        withAdminLogin: {\n            setUp: function(callback) {\n                if (!authAdminReady) {\n                    es.getAuth().login(\"admin\", \"adminadmin\").then(function() {\n                        authAdminReady = true;\n                        callback();\n                    });\n                } else {\n                    callback();\n                }\n            },\n            asyncListenerLogout: function(test) {\n                var al = function(promise, callType) {\n                    test.ok(callType === \"logout\", \"Wrong calltype, should be 'logout'\");\n                    promise.then(function() {\n                        authAdminReady = false;\n                        test.done();\n                    }, function() {\n                        test.done();\n                    });\n                };\n                es.addAsyncListener(al);\n                es.getAuth().logout();\n                es.removeAsyncListener(al);\n            },\n            getContextList: function(test) {\n                var clist = es.getContextList();\n                clist.getEntries().then(function(entries) {\n                    test.ok(entries.length > 0, \"No contexts found.\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed loading of contexts.\");\n                    test.done();\n                });\n            },\n            getPrincipalList: function(test) {\n                var plist = es.getPrincipalList();\n                plist.getEntries().then(function(entries) {\n                    test.ok(entries.length > 0, \"No principals found\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed loading principalList.\");\n                    test.done();\n                });\n            },\n            createContext: function(test) {\n                es.newContext().commit().then(function(entry) {\n                    test.ok(entry.isContext(), \"Entry created, but it is not a context\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed creating context.\");\n                    test.done();\n                });\n            },\n            createUser: function(test) {\n                var username = \"\"+new Date().getTime();\n                es.newUser(username).commit().then(function(entry) {\n                    test.ok(entry.isUser(), \"Entry created, but it is not a user!\");\n                    test.ok(entry.getResource(true).getName() === username, \"User created, but username provided in creation step is missing.\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed creating user.\");\n                    test.done();\n                });\n            },\n            createGroup: function(test) {\n                es.newGroup().commit().then(function(entry) {\n                    test.ok(entry.isGroup(), \"Entry created, but it is not a group!\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed creating group.\");\n                    test.done();\n                });\n            }\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/EntryStore.js?");

/***/ }),

/***/ "./tests/File.js":
/*!***********************!*\
  !*** ./tests/File.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ */ \"./index.js\");\nconst lang = __webpack_require__(/*! ../libs/dojo/_base/lang */ \"./libs/dojo/_base/lang.js\");\nconst has = __webpack_require__(/*! ../libs/dojo/has */ \"./libs/dojo/has.js\");\n\n\n\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_1__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].repository);\n    var c = es.getContextById(\"1\");\n    var ready;\n    var dct = \"http://purl.org/dc/terms/\";\n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n        setUp: function(callback) {\n            if (!ready) {\n                es.auth({user: \"Donald\", password: \"donalddonald\"}).then(function() {\n                    ready = true;\n                    callback();\n                });\n            } else {\n                callback();\n            }\n        },\n        createJSONFile: function(test) {\n            c.newEntry().commit().then(function (entry) {\n                var r = entry.getResource(true);\n                return r.putJSON({a: \"v\"}).then(function () {\n                    entry.setRefreshNeeded(true);\n                    return entry.refresh().then(function () {\n                        test.ok(entry.getEntryInfo().getFormat() === \"application/json\", \"Mimetype is not application/json as it should.\");\n                        return r.getJSON().then(function(data) {\n                            test.ok(lang.isObject(data) && data.a === \"v\", \"Json not set correctly.\");\n                            test.done();\n                        });\n                    });\n                });\n            }, function () {\n                test.ok(false, \"Something went wrong when creating a File entry with JSON content.\");\n            });\n        },\n        createTextFile: function(test) {\n            c.newEntry().commit().then(function (entry) {\n                var r = entry.getResource(true);\n                return r.putText(\"test\").then(function () {\n                    entry.setRefreshNeeded(true);\n                    return entry.refresh().then(function () {\n                        test.ok(entry.getEntryInfo().getFormat() === \"text/plain\", \"Mimetype is not text/plain as it should.\");\n                        return r.getText().then(function(data) {\n                            test.ok(lang.isString(data) && data === \"test\", \"Text not set correctly as resource.\");\n                            test.done();\n                        });\n                    });\n                });\n            }, function () {\n                test.ok(false, \"Something went wrong when creating a Fileentry with text content.\");\n            });\n        },\n        createXMLFile: function(test) {\n            c.newEntry().commit().then(function (entry) {\n                var r = entry.getResource(true);\n                var xml = \"<book></book>\";\n                if (has(\"host-browser\")) {\n                    var parser=new DOMParser();\n                    xml = parser.parseFromString(xml, \"text/xml\");\n                }\n                return r.putXML(xml).then(function () {\n                    entry.setRefreshNeeded(true);\n                    return entry.refresh().then(function () {\n                        test.ok(entry.getEntryInfo().getFormat() === \"text/xml\", \"Mimetype is not text/plain as it should.\");\n                        return r.getXML().then(function (data) {\n                            if (has(\"host-browser\")) {\n                                test.ok(data instanceof Document && data.firstChild.nodeName === \"book\",\n                                \"XML not stored correctly, document contains other xml than sent.\");\n                                test.done();\n                            } else {\n                                test.ok(lang.isString(data) && data === \"<book></book>\", \"XMl not set correctly as a resource.\");\n                                test.done();\n                            }\n                        });\n                    });\n                });\n            }, function () {\n                test.ok(false, \"Something went wrong when creating a File entry with xml content.\");\n            });\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/File.js?");

/***/ }),

/***/ "./tests/List.js":
/*!***********************!*\
  !*** ./tests/List.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ */ \"./index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n\n\nconst Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_0__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].repository);\n    var c = es.getContextById(\"1\");\n    var ready;\n    var dct = \"http://purl.org/dc/terms/\";\n    var lst, e1, e2;\n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n        setUp: function(callback) {\n            if (!ready) {\n                es.auth({user: \"Donald\", password: \"donalddonald\"}).then(function() {\n                    c.newList().create().then(function(listentry) {\n                        lst = listentry;\n                        c.newEntry().setParentList(lst).create().then(function(entry1) {\n                            e1 = entry1;\n                            c.newEntry().setParentList(lst).create().then(function(entry2) {\n                                e2 = entry2;\n                                ready = true;\n                                callback();\n                            });\n                        });\n                    });\n                });\n            } else {\n                callback();\n            }\n        },\n\n        members: function(test) {\n            var resource = lst.getResource(true);\n            resource.getEntries().then(function(entries) {\n                test.ok(entries.length >= 2, \"List have to few children\");\n                test.done();\n            });\n        },\n\n        addMember: function(test) {\n            c.newEntry().create().then(function(entry) {\n                var lres = lst.getResource(true);\n                test.ok(entry.getParentLists().length === 0, \"New entry should not belong to a parentList unless explicitly specified.\");\n                test.ok(!entry.needRefresh(), \"New entry should not be in need of a refresh.\");\n                lres.addEntry(entry).then(function() {\n                    lres.getEntries().then(function(entries) {\n                        test.ok(entries.indexOf(entry) >= 0, \"Entry not contained in list, list not refreshed.\");\n                        test.done();\n                    });\n                });\n            });\n        },\n\n        addMemberOnCreate: function(test) {\n            c.newEntry().setParentList(lst).create().then(function(entry) {\n                lst.getResource(true).getEntries().then(function(entries) {\n                    test.ok(entries.indexOf(entry) >= 0, \"Entry not contained in list, list not refreshed or entry not added to list.\");\n                    test.done();\n                });\n            });\n        },\n\n        removeMember: function(test) {\n            c.newEntry().setParentList(lst).create().then(function(entry) {\n                var lres = lst.getResource(true);\n                test.ok(entry.getParentLists().length === 1, \"New entry should belong to the specified parentList provided upon creation.\");\n                test.ok(!entry.needRefresh(), \"New entry should not be in need of a refresh.\");\n                lres.getEntries().then(function(entries) {\n                    test.ok(entries.indexOf(entry) >= 0, \"Entry not contained in list, list not refreshed.\");\n                    lres.removeEntry(entry).then(function() {\n                        test.ok(entry.needRefresh(), \"Entry is removed from a list and should be in need of a refresh!\");\n                        lres.getEntries().then(function(entries2) {\n                            test.ok(entries2.indexOf(entry) == -1, \"Entry not removed from list, either list not refreshed or entry not removed from list.\");\n                            test.done();\n                        })\n                    });\n                });\n            });\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/List.js?");

/***/ }),

/***/ "./tests/Pipeline.js":
/*!***************************!*\
  !*** ./tests/Pipeline.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../ */ \"./index.js\");\nconst lang = __webpack_require__(/*! ../libs/dojo/_base/lang */ \"./libs/dojo/_base/lang.js\");\nconst has = __webpack_require__(/*! ../libs/dojo/has */ \"./libs/dojo/has.js\");\n\n\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_1__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].repository);\n    var c = es.getContextById(\"1\");\n    var ready;\n    var dct = \"http://purl.org/dc/terms/\";\n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n        setUp: function(callback) {\n            if (!ready) {\n                es.getAuth().login(\"Donald\", \"donalddonald\").then(function() {\n                    ready = true;\n                    callback();\n                });\n            } else {\n                callback();\n            }\n        },\n        pipelineAPI: function(test) {\n            var pipeline = c.newPipeline().getResource();\n            test.ok(pipeline.getGraph().isEmpty());\n            var tr = pipeline.addTransform(pipeline.transformTypes.TABULAR, {key1: \"val1\"});\n            test.ok(!pipeline.getGraph().isEmpty(), \"Error, transform not created in graph.\");\n            test.ok(pipeline.getTransforms().length === 1, \"Error, transform not detected correctly in graph.\");\n            test.ok(pipeline.getTransformType(tr) === pipeline.transformTypes.TABULAR, \"Transform type not set correctly in graph.\");\n            test.ok(pipeline.getTransformArguments(tr).key1 === \"val1\", \"Transform arguments not set correctly in graph.\");\n            test.done();\n        },\n        createPipeline: function(test) {\n            var protoPipeline = c.newPipeline();\n            var pipelineResource = protoPipeline.getResource();\n            pipelineResource.addTransform(pipelineResource.transformTypes.TABULAR, {\"key1\": \"value1\"});\n            protoPipeline.commit().then(function(entry) {\n                var pipelineResource2 = entry.getResource(true);\n                var transforms = pipelineResource2.getTransforms();\n                test.ok(transforms.length > 0);\n                test.ok(pipelineResource2.getTransformType(transforms[0]) === pipelineResource2.transformTypes.TABULAR);\n                test.done();\n            }, function() {\n                test.ok(false, \"Something went wrong when creating a Pipeline with a single transform.\");\n            });\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/Pipeline.js?");

/***/ }),

/***/ "./tests/config.js":
/*!*************************!*\
  !*** ./tests/config.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n    tests: [\n        //\"EntryStore\",\n        \"Auth\",\n        //\"Entry\",\n        //\"EntryInfo\",\n        \"Cache\",\n        //\"List\",\n        //\"solr\",\n        //\"File\",\n        //\"Pipeline\"\n        // //\"Inferred\",\n    ],\n    nodeTests: [\n      \"Node\"\n    ],\n    repository: \"http://localhost:8888/store/\",\n    reporter: \"default\"\n});\n\n\n//# sourceURL=webpack:///./tests/config.js?");

/***/ }),

/***/ "./tests/executeAllTests.js":
/*!**********************************!*\
  !*** ./tests/executeAllTests.js ***!
  \**********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Auth */ \"./tests/Auth.js\");\n/* harmony import */ var _Cache__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Cache */ \"./tests/Cache.js\");\n/* harmony import */ var _Entry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Entry */ \"./tests/Entry.js\");\n/* harmony import */ var _EntryInfo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EntryInfo */ \"./tests/EntryInfo.js\");\n/* harmony import */ var _EntryStore__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EntryStore */ \"./tests/EntryStore.js\");\n/* harmony import */ var _File__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./File */ \"./tests/File.js\");\n/* harmony import */ var _List__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./List */ \"./tests/List.js\");\n/* harmony import */ var _Pipeline__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Pipeline */ \"./tests/Pipeline.js\");\n/* harmony import */ var _solr__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./solr */ \"./tests/solr.js\");\n\n\n\n\n\n\n\n\n//import Node from './Node'; // Doing this manually for the time being\n\n\n\n    //var deps = config.tests.map( function(cls) {\n        //return \"tests/\"+cls;\n    //});\n    //if (!has(\"host-browser\") && config.nodeTests) {\n        //array.forEach(config.nodeTests, function(cls) {\n          //deps.push(\"store/tests/\"+cls);\n        //});\n    //}\n        //var testClasses = Array.prototype.slice.call(arguments, 0);\n        //deps.forEach( function(dep, idx) {\n            //var test = testClasses[idx];\n            //if (test.inGroups) {\n                //for (var group in test) if (test.hasOwnProperty(group) && group != \"inGroups\") {\n                    //nuConf[dep+\"_\"+group] = test[group];\n                //}\n            //} else {\n                //nuConf[dep] = test;\n            //}\n        //});\n\n        const nuConf = {\n          Auth: _Auth__WEBPACK_IMPORTED_MODULE_1__[\"default\"],\n          Cache: _Cache__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n          Entry: _Entry__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n          EntryInfo: _EntryInfo__WEBPACK_IMPORTED_MODULE_4__[\"default\"],\n          EntryStore: _EntryStore__WEBPACK_IMPORTED_MODULE_5__[\"default\"],\n          File: _File__WEBPACK_IMPORTED_MODULE_6__[\"default\"],\n          List: _List__WEBPACK_IMPORTED_MODULE_7__[\"default\"],\n          Pipeline: _Pipeline__WEBPACK_IMPORTED_MODULE_8__[\"default\"],\n          solr: _solr__WEBPACK_IMPORTED_MODULE_9__[\"default\"],\n        };\n\n        var reporter = nodeunit.reporter || nodeunit.reporters[_config__WEBPACK_IMPORTED_MODULE_0__[\"default\"].reporter];\n        reporter.run(nuConf);\n\n\n//# sourceURL=webpack:///./tests/executeAllTests.js?");

/***/ }),

/***/ "./tests/solr.js":
/*!***********************!*\
  !*** ./tests/solr.js ***!
  \***********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var ___WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../ */ \"./index.js\");\n/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./config */ \"./tests/config.js\");\n\n\nconst Graph = __webpack_require__(/*! rdfjson/Graph */ \"./node_modules/rdfjson/Graph.js\");\n\nconst EntryStoreUtil = ___WEBPACK_IMPORTED_MODULE_0__[\"EntryStore\"].util;\nconst types = ___WEBPACK_IMPORTED_MODULE_0__[\"EntryStore\"].types;\n\n    var es = new ___WEBPACK_IMPORTED_MODULE_0__[\"EntryStore\"](_config__WEBPACK_IMPORTED_MODULE_1__[\"default\"].repository);\n    var esu = new EntryStoreUtil(es);\n    var c = es.getContextById(\"1\");\n    var ready;\n    var dct = \"http://purl.org/dc/terms/\";\n\n    /* harmony default export */ __webpack_exports__[\"default\"] = (nodeunit.testCase({\n        setUp: function(callback) {\n            if (!ready) {\n                es.getAuth().login(\"admin\", \"adminadmin\").then(function() {\n                    ready = true;\n                    callback();\n                });\n            } else {\n                callback();\n            }\n        },\n        titleSearch: function(test) {\n            es.newSolrQuery().title(\"Donald\").list().getEntries(0).then(function(entries) {\n                    test.ok(entries.length > 0, \"No entries found for title 'Donald', despite that we are searching against disney suite.\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed performing the search, REST call went wrong.\");\n                }\n            );\n        },\n        listSearch: function(test) {\n            es.newSolrQuery().graphType(types.GT_LIST).list().getEntries(0).then(function(entries) {\n                    test.ok(entries.length > 0 && entries[0].isList(), \"No lists found, or entry found was not a list\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed performing the search, REST call went wrong.\");\n                }\n            );\n        },\n        userSearch: function(test) {\n            es.newSolrQuery().graphType(types.GT_USER).list().getEntries(0).then(function(entries) {\n                    test.ok(entries.length > 0 && entries[0].isUser(), \"No users found, or entry found was not a user\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed performing the search, REST call went wrong.\");\n                }\n            );\n        },\n        userAndTitleSearch: function(test) {\n            es.newSolrQuery().graphType(types.GT_USER).title(\"Donald\").list().getEntries(0).then(function(entries) {\n                    test.ok(entries.length > 0 && entries[0].isUser(), \"No users found, or entry found was not a user\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed performing the search, REST call went wrong.\");\n                }\n            );\n        },\n        contextSearch: function(test) {\n            es.newSolrQuery().graphType(types.GT_CONTEXT).list().getEntries(0).then(function(entries) {\n                    test.ok(entries.length > 0 && entries[0].isContext(), \"No context found, or entry found was not a context\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed performing the search, REST call went wrong.\");\n                }\n            );\n        },\n        linkSearch: function(test) {\n            es.newSolrQuery().entryType(types.ET_LINK).list().getEntries(0).then(function(entries) {\n                    test.ok(entries.length > 0 && entries[0].isLink(), \"No link found, or entry found was not a link\");\n                    test.done();\n                }, function() {\n                    test.ok(false, \"Failed performing the search, REST call went wrong.\");\n                }\n            );\n        },\n        literalPropertySearch: function(test) {\n            es.newSolrQuery()\n                .literalProperty(\"dcterms:title\", \"Donald\")\n                .list().getEntries(0)\n                .then(function(entries) {\n                    test.ok(entries.length > 0, \"Cannot find title Donald via property search.\");\n                    test.done();\n                }, function(err) {\n                    test.ok(false, \"Failed performing the search, REST call went wrong: \"+err);\n                    test.done();\n                });\n        },\n        forEachSearch: function(test) {\n            var callbackCount = 0, endReached = false;\n            es.newSolrQuery().graphType(types.GT_USER).limit(2).list().forEach(function(userEntry, idx) {\n                if (endReached) {\n                    test.ok(false, \"End function called before all callbacks.\")\n                }\n                test.ok(callbackCount === idx, \"Callback index is wrong.\")\n                callbackCount++;\n            }).then(function(totalCount) {\n                endReached = true;\n                test.ok(callbackCount === totalCount, \"Total count does not agree with amount of callbacks.\");\n                test.done();\n            }, function(err) {\n                test.ok(false, \"Got error callback from promise unexpectedly: \"+err);\n                test.done();\n            });\n        },\n        forEachSearchBreak: function(test) {\n            es.newSolrQuery().graphType(types.GT_USER).limit(2).list().forEach(function(userEntry, index) {\n                test.ok(index < 3, \"Callbacks continues after attempt to break.\");\n                return index !== 2;\n            }).then(function(totalCount) {\n                test.ok(totalCount === 3, \"Total count is wrong, should be 3 as we stopped iteration after entry 3.\");\n                test.done();\n            }, function(err) {\n                test.ok(false, \"Got error callback from promise unexpectedly: \"+err);\n                test.done();\n            });\n        },\n        getByGraphType: function(test) {\n            esu.getEntryByGraphType(types.GT_USER).then(function(entry) {\n                test.done();\n            }, function(err) {\n                test.ok(false, \"We should be able to find at least one user.\");\n                test.done();\n            });\n        }\n    }));\n\n\n//# sourceURL=webpack:///./tests/solr.js?");

/***/ }),

/***/ "./types.js":
/*!******************!*\
  !*** ./types.js ***!
  \******************/
/*! exports provided: types */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"types\", function() { return types; });\n  /**\n   * Types is a module containing the three different types: GraphType, EntryType and\n   * ResourceType shortened GT, ET and RT.\n   *\n   * @exports {store/types}\n   */\n  const types = {\n    /**\n     * Local entrytype implies that the resource is maintained in the repository.\n     * It can be an uploaded file, a list, a group, a user etc. The nature of the resource\n     * is determined by the graphtype.\n     *\n     * @const\n     * @see store/Entry#isLocal\n     */\n    ET_LOCAL: 'Local',\n\n    /**\n     * Link EntryType implies that the resource is not maintained in the repository, rather the\n     * entry only provides a link to the resource.\n     * The metadata is still maintained in the repository though.\n     *\n     * @const\n     * @see store/Entry#isLink\n     */\n    ET_LINK: 'Link',\n\n    /**\n     * Similar to link, only the metadata is also external to the repository.\n     * In many cases it is possible to access a locally cached version of the external\n     * metadata though.\n     * @see store/Entry#getCachedExternalMetadata\n     * @see store/Entry#isReference\n     */\n    ET_REF: 'Reference',\n\n    /**\n     * Similar to link and reference, only there is both local metadata and external metadata.\n     * @see store/Entry#isLinkReference\n     */\n    ET_LINKREF: 'Linkreference',\n\n    /**\n     * No graph type specified means that no knowledge of the resources character is known.\n     * Hence, no special treatment of the resource is expected.\n     * This is common when handling regular files, web resources or abstract entities.\n     * @see store/Entry#isNone\n     */\n    GT_NONE: 'None',\n\n    /**\n     * The resource is a context, i.e. a container for other entries.\n     *\n     * @see store/Entry#isContext\n     * @see store/Context\n     */\n    GT_CONTEXT: 'Context',\n\n    /**\n     * The resource is one of the special context of this repository, e.g. _contexts or _principals.\n     * @see store/Entry#isSystemContext\n     */\n    GT_SYSTEMCONTEXT: 'Systemcontext',\n\n    /**\n     * The resource is a user.\n     *\n     * @see store/Entry#isUser\n     * @see store/User\n     */\n    GT_USER: 'User',\n\n    /**\n     * The resource is a group.\n     *\n     * @see store/Entry#isGroup\n     * @see store/Group\n     */\n    GT_GROUP: 'Group',\n\n    /**\n     * The resource is a list.\n     *\n     * @see store/Entry#isList\n     * @see store/List\n     */\n    GT_LIST: 'List',\n\n    /**\n     * @todo remains to be supported in this API\n     * @see store/Entry#isResultList\n     */\n    GT_RESULTLIST: 'Resultlist',\n\n    /**\n     * The resource is a RDF graph.\n     * @see store/Entry#isGraph\n     * @see store/Graph\n     */\n    GT_GRAPH: 'Graph',\n\n    /**\n     * The resource is a string.\n     * @see store/Entry#isString\n     * @see store/String\n     */\n    GT_STRING: 'String',\n\n    /**\n     * The resource is a pipeline, e.g. an entry that can somehow be executed on the server side.\n     * @see store/Entry#isPipeline\n     * @see store/Pipeline\n     */\n    GT_PIPELINE: 'Pipeline',\n\n    /**\n     * The resource is a pipelineresult, e.g. the result of the execution of a pipeline\n     * on the server side.\n     * @see store/Entry#isPipelineResult\n     * @see store/Pipeline\n     */\n    GT_PIPELINERESULT: 'PipelineResult',\n\n    /**\n     * The resource is available as a digital representation of some sort.\n     * Opposite to resources that have no representation, referred to as\n     * {@link store/types.NAMEDRESOURCE named}.\n     */\n    RT_INFORMATIONRESOURCE: 'Information',\n\n    /**\n     * The resource is resolvable to another address.\n     * @todo the API has little support for this type currently.\n     */\n    RT_RESOLVABLEINFORMATIONRESOURCE: 'Resolvable',\n\n    /**\n     * The resource is not available digitally, i.e. it has now digital representation that\n     * can be transferred over a network.\n     */\n    RT_NAMEDRESOURCE: 'Named',\n\n    /**\n     * It is unknown if the resource has a representation or not, typically this is the case when\n     * large amounts of resources are harvested from another system and it is not feasible to try\n     * to load them to check weather they have a digital representation or not. At least the check\n     * cannot be done initially and therefore the type is set to unknown.\n     */\n    RT_UNKNOWN: 'Unknown',\n  };\n\n  \n\n\n//# sourceURL=webpack:///./types.js?");

/***/ }),

/***/ "./utils.js":
/*!******************!*\
  !*** ./utils.js ***!
  \******************/
/*! exports provided: utils, isBrowser, isNode, isIE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"utils\", function() { return utils; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isBrowser\", function() { return isBrowser; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isNode\", function() { return isNode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isIE\", function() { return isIE; });\n\nconst utils = {};\n\nutils.getRelatedToEntryURIs = (fromEntry) => {\n  const es = fromEntry.getEntryStore();\n  const base = fromEntry.getEntryStore().getBaseURI();\n  const relatedEntryURIs = [];\n  fromEntry.getMetadata().find().forEach((stmt) => {\n    if (stmt.getType() === 'uri') {\n      const obj = stmt.getValue();\n      if (obj.indexOf(base) === 0) {\n        const uri = es.getEntryURI(es.getContextId(obj), es.getEntryId(obj));\n        relatedEntryURIs.push(uri);\n      }\n    }\n  });\n  return relatedEntryURIs;\n};\n\nutils.getRelatedToEntries = (fromEntry) => {\n  const es = fromEntry.getEntryStore();\n  return Promise.all(utils.getRelatedToEntryURIs(fromEntry).map(uri => es.getEntry(uri)));\n};\n\nutils.remove = (entry) => {\n  const es = entry.getEntryStore();\n  const cache = es.getCache();\n  const refStmts = entry.getReferrersGraph().find();\n  const entryPromises = refStmts.map((stmt) => {\n    const subj = stmt.getSubject();\n    const euri = es.getEntryURI(es.getContextId(subj), es.getEntryId(subj));\n    return es.getEntry(euri);\n  });\n  return entry.del().then(() => Promise.all(entryPromises).then((arr) => {\n    const promises = refStmts.map((stmt, idx) => {\n      const md = arr[idx].getMetadata();\n      md.remove(stmt);\n      return arr[idx].commitMetadata();\n    });\n    const uris = utils.getRelatedToEntryURIs(entry);\n    uris.forEach((uri) => {\n      const e = cache.get(uri);\n      if (e != null) {\n        e.setRefreshNeeded();\n        promises.push(e.refresh());\n      }\n    });\n    return Promise.all(promises);\n  }));\n};\n\nutils.addRelation = (fromEntry, property, toEntry) => {\n  fromEntry.getMetadata().add(fromEntry.getResourceURI(), property, toEntry.getResourceURI());\n  return fromEntry.commitMetadata().then(() => {\n    toEntry.setRefreshNeeded();\n    return toEntry.refresh();\n  });\n};\n\nutils.removeRelation = (fromEntry, property, toEntry) => {\n  fromEntry.getMetadata().remove(fromEntry.getResourceURI(), property, { type: 'uri', value: toEntry.getResourceURI() });\n  return fromEntry.commitMetadata().then(() => {\n    toEntry.setRefreshNeeded();\n    return toEntry.refresh();\n  });\n};\n\n// Relies on there not being a window.document in Node\n// Based off of: https://github.com/flexdinesh/browser-or-node/blob/master/src/index.js\nconst isBrowser = () => typeof window !== 'undefined' && typeof window.document !== 'undefined';\nconst isNode = () => typeof module !== 'undefined' && typeof module.exports !== 'undefined';\nconst isIE = () => window && window.navigator.userAgent.match(/MSIE/) !== null;\n\n\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))\n\n//# sourceURL=webpack:///./utils.js?");

/***/ })

/******/ });
});