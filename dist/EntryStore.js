module.exports =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/blueimp-md5/js/md5.js":
/*!********************************************!*\
  !*** ./node_modules/blueimp-md5/js/md5.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 * JavaScript MD5
 * https://github.com/blueimp/JavaScript-MD5
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * https://opensource.org/licenses/MIT
 *
 * Based on
 * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message
 * Digest Algorithm, as defined in RFC 1321.
 * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for more info.
 */

/* global define */

;(function ($) {
  'use strict'

  /*
  * Add integers, wrapping at 2^32. This uses 16-bit operations internally
  * to work around bugs in some JS interpreters.
  */
  function safeAdd (x, y) {
    var lsw = (x & 0xffff) + (y & 0xffff)
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16)
    return (msw << 16) | (lsw & 0xffff)
  }

  /*
  * Bitwise rotate a 32-bit number to the left.
  */
  function bitRotateLeft (num, cnt) {
    return (num << cnt) | (num >>> (32 - cnt))
  }

  /*
  * These functions implement the four basic operations the algorithm uses.
  */
  function md5cmn (q, a, b, x, s, t) {
    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
  }
  function md5ff (a, b, c, d, x, s, t) {
    return md5cmn((b & c) | (~b & d), a, b, x, s, t)
  }
  function md5gg (a, b, c, d, x, s, t) {
    return md5cmn((b & d) | (c & ~d), a, b, x, s, t)
  }
  function md5hh (a, b, c, d, x, s, t) {
    return md5cmn(b ^ c ^ d, a, b, x, s, t)
  }
  function md5ii (a, b, c, d, x, s, t) {
    return md5cmn(c ^ (b | ~d), a, b, x, s, t)
  }

  /*
  * Calculate the MD5 of an array of little-endian words, and a bit length.
  */
  function binlMD5 (x, len) {
    /* append padding */
    x[len >> 5] |= 0x80 << (len % 32)
    x[((len + 64) >>> 9 << 4) + 14] = len

    var i
    var olda
    var oldb
    var oldc
    var oldd
    var a = 1732584193
    var b = -271733879
    var c = -1732584194
    var d = 271733878

    for (i = 0; i < x.length; i += 16) {
      olda = a
      oldb = b
      oldc = c
      oldd = d

      a = md5ff(a, b, c, d, x[i], 7, -680876936)
      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586)
      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819)
      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330)
      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897)
      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426)
      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341)
      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983)
      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416)
      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417)
      c = md5ff(c, d, a, b, x[i + 10], 17, -42063)
      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162)
      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682)
      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101)
      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290)
      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329)

      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510)
      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632)
      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713)
      b = md5gg(b, c, d, a, x[i], 20, -373897302)
      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691)
      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083)
      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335)
      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848)
      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438)
      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690)
      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961)
      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501)
      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467)
      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784)
      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473)
      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734)

      a = md5hh(a, b, c, d, x[i + 5], 4, -378558)
      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463)
      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562)
      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556)
      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060)
      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353)
      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632)
      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640)
      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174)
      d = md5hh(d, a, b, c, x[i], 11, -358537222)
      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979)
      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189)
      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487)
      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835)
      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520)
      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651)

      a = md5ii(a, b, c, d, x[i], 6, -198630844)
      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415)
      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905)
      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055)
      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571)
      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606)
      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523)
      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799)
      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359)
      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744)
      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380)
      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649)
      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070)
      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379)
      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259)
      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551)

      a = safeAdd(a, olda)
      b = safeAdd(b, oldb)
      c = safeAdd(c, oldc)
      d = safeAdd(d, oldd)
    }
    return [a, b, c, d]
  }

  /*
  * Convert an array of little-endian words to a string
  */
  function binl2rstr (input) {
    var i
    var output = ''
    var length32 = input.length * 32
    for (i = 0; i < length32; i += 8) {
      output += String.fromCharCode((input[i >> 5] >>> (i % 32)) & 0xff)
    }
    return output
  }

  /*
  * Convert a raw string to an array of little-endian words
  * Characters >255 have their high-byte silently ignored.
  */
  function rstr2binl (input) {
    var i
    var output = []
    output[(input.length >> 2) - 1] = undefined
    for (i = 0; i < output.length; i += 1) {
      output[i] = 0
    }
    var length8 = input.length * 8
    for (i = 0; i < length8; i += 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 0xff) << (i % 32)
    }
    return output
  }

  /*
  * Calculate the MD5 of a raw string
  */
  function rstrMD5 (s) {
    return binl2rstr(binlMD5(rstr2binl(s), s.length * 8))
  }

  /*
  * Calculate the HMAC-MD5, of a key and some data (raw strings)
  */
  function rstrHMACMD5 (key, data) {
    var i
    var bkey = rstr2binl(key)
    var ipad = []
    var opad = []
    var hash
    ipad[15] = opad[15] = undefined
    if (bkey.length > 16) {
      bkey = binlMD5(bkey, key.length * 8)
    }
    for (i = 0; i < 16; i += 1) {
      ipad[i] = bkey[i] ^ 0x36363636
      opad[i] = bkey[i] ^ 0x5c5c5c5c
    }
    hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8)
    return binl2rstr(binlMD5(opad.concat(hash), 512 + 128))
  }

  /*
  * Convert a raw string to a hex string
  */
  function rstr2hex (input) {
    var hexTab = '0123456789abcdef'
    var output = ''
    var x
    var i
    for (i = 0; i < input.length; i += 1) {
      x = input.charCodeAt(i)
      output += hexTab.charAt((x >>> 4) & 0x0f) + hexTab.charAt(x & 0x0f)
    }
    return output
  }

  /*
  * Encode a string as utf-8
  */
  function str2rstrUTF8 (input) {
    return unescape(encodeURIComponent(input))
  }

  /*
  * Take string arguments and return either raw or hex encoded strings
  */
  function rawMD5 (s) {
    return rstrMD5(str2rstrUTF8(s))
  }
  function hexMD5 (s) {
    return rstr2hex(rawMD5(s))
  }
  function rawHMACMD5 (k, d) {
    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
  }
  function hexHMACMD5 (k, d) {
    return rstr2hex(rawHMACMD5(k, d))
  }

  function md5 (string, key, raw) {
    if (!key) {
      if (!raw) {
        return hexMD5(string)
      }
      return rawMD5(string)
    }
    if (!raw) {
      return hexHMACMD5(key, string)
    }
    return rawHMACMD5(key, string)
  }

  if (true) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return md5
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
  } else {}
})(this)


/***/ }),

/***/ "./node_modules/charenc/charenc.js":
/*!*****************************************!*\
  !*** ./node_modules/charenc/charenc.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var charenc = {
  // UTF-8 encoding
  utf8: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
    }
  },

  // Binary encoding
  bin: {
    // Convert a string to a byte array
    stringToBytes: function(str) {
      for (var bytes = [], i = 0; i < str.length; i++)
        bytes.push(str.charCodeAt(i) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a string
    bytesToString: function(bytes) {
      for (var str = [], i = 0; i < bytes.length; i++)
        str.push(String.fromCharCode(bytes[i]));
      return str.join('');
    }
  }
};

module.exports = charenc;


/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }
  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};
  var args = [].slice.call(arguments, 1)
    , callbacks = this._callbacks['$' + event];

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "./node_modules/core-js/es/index.js":
/*!******************************************!*\
  !*** ./node_modules/core-js/es/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es.symbol */ "./node_modules/core-js/modules/es.symbol.js");
__webpack_require__(/*! ../modules/es.symbol.async-iterator */ "./node_modules/core-js/modules/es.symbol.async-iterator.js");
__webpack_require__(/*! ../modules/es.symbol.description */ "./node_modules/core-js/modules/es.symbol.description.js");
__webpack_require__(/*! ../modules/es.symbol.has-instance */ "./node_modules/core-js/modules/es.symbol.has-instance.js");
__webpack_require__(/*! ../modules/es.symbol.is-concat-spreadable */ "./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js");
__webpack_require__(/*! ../modules/es.symbol.iterator */ "./node_modules/core-js/modules/es.symbol.iterator.js");
__webpack_require__(/*! ../modules/es.symbol.match */ "./node_modules/core-js/modules/es.symbol.match.js");
__webpack_require__(/*! ../modules/es.symbol.match-all */ "./node_modules/core-js/modules/es.symbol.match-all.js");
__webpack_require__(/*! ../modules/es.symbol.replace */ "./node_modules/core-js/modules/es.symbol.replace.js");
__webpack_require__(/*! ../modules/es.symbol.search */ "./node_modules/core-js/modules/es.symbol.search.js");
__webpack_require__(/*! ../modules/es.symbol.species */ "./node_modules/core-js/modules/es.symbol.species.js");
__webpack_require__(/*! ../modules/es.symbol.split */ "./node_modules/core-js/modules/es.symbol.split.js");
__webpack_require__(/*! ../modules/es.symbol.to-primitive */ "./node_modules/core-js/modules/es.symbol.to-primitive.js");
__webpack_require__(/*! ../modules/es.symbol.to-string-tag */ "./node_modules/core-js/modules/es.symbol.to-string-tag.js");
__webpack_require__(/*! ../modules/es.symbol.unscopables */ "./node_modules/core-js/modules/es.symbol.unscopables.js");
__webpack_require__(/*! ../modules/es.object.assign */ "./node_modules/core-js/modules/es.object.assign.js");
__webpack_require__(/*! ../modules/es.object.create */ "./node_modules/core-js/modules/es.object.create.js");
__webpack_require__(/*! ../modules/es.object.define-property */ "./node_modules/core-js/modules/es.object.define-property.js");
__webpack_require__(/*! ../modules/es.object.define-properties */ "./node_modules/core-js/modules/es.object.define-properties.js");
__webpack_require__(/*! ../modules/es.object.entries */ "./node_modules/core-js/modules/es.object.entries.js");
__webpack_require__(/*! ../modules/es.object.freeze */ "./node_modules/core-js/modules/es.object.freeze.js");
__webpack_require__(/*! ../modules/es.object.from-entries */ "./node_modules/core-js/modules/es.object.from-entries.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-descriptor */ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-descriptors */ "./node_modules/core-js/modules/es.object.get-own-property-descriptors.js");
__webpack_require__(/*! ../modules/es.object.get-own-property-names */ "./node_modules/core-js/modules/es.object.get-own-property-names.js");
__webpack_require__(/*! ../modules/es.object.get-prototype-of */ "./node_modules/core-js/modules/es.object.get-prototype-of.js");
__webpack_require__(/*! ../modules/es.object.is */ "./node_modules/core-js/modules/es.object.is.js");
__webpack_require__(/*! ../modules/es.object.is-extensible */ "./node_modules/core-js/modules/es.object.is-extensible.js");
__webpack_require__(/*! ../modules/es.object.is-frozen */ "./node_modules/core-js/modules/es.object.is-frozen.js");
__webpack_require__(/*! ../modules/es.object.is-sealed */ "./node_modules/core-js/modules/es.object.is-sealed.js");
__webpack_require__(/*! ../modules/es.object.keys */ "./node_modules/core-js/modules/es.object.keys.js");
__webpack_require__(/*! ../modules/es.object.prevent-extensions */ "./node_modules/core-js/modules/es.object.prevent-extensions.js");
__webpack_require__(/*! ../modules/es.object.seal */ "./node_modules/core-js/modules/es.object.seal.js");
__webpack_require__(/*! ../modules/es.object.set-prototype-of */ "./node_modules/core-js/modules/es.object.set-prototype-of.js");
__webpack_require__(/*! ../modules/es.object.values */ "./node_modules/core-js/modules/es.object.values.js");
__webpack_require__(/*! ../modules/es.object.to-string */ "./node_modules/core-js/modules/es.object.to-string.js");
__webpack_require__(/*! ../modules/es.object.define-getter */ "./node_modules/core-js/modules/es.object.define-getter.js");
__webpack_require__(/*! ../modules/es.object.define-setter */ "./node_modules/core-js/modules/es.object.define-setter.js");
__webpack_require__(/*! ../modules/es.object.lookup-getter */ "./node_modules/core-js/modules/es.object.lookup-getter.js");
__webpack_require__(/*! ../modules/es.object.lookup-setter */ "./node_modules/core-js/modules/es.object.lookup-setter.js");
__webpack_require__(/*! ../modules/es.function.bind */ "./node_modules/core-js/modules/es.function.bind.js");
__webpack_require__(/*! ../modules/es.function.name */ "./node_modules/core-js/modules/es.function.name.js");
__webpack_require__(/*! ../modules/es.function.has-instance */ "./node_modules/core-js/modules/es.function.has-instance.js");
__webpack_require__(/*! ../modules/es.array.from */ "./node_modules/core-js/modules/es.array.from.js");
__webpack_require__(/*! ../modules/es.array.is-array */ "./node_modules/core-js/modules/es.array.is-array.js");
__webpack_require__(/*! ../modules/es.array.of */ "./node_modules/core-js/modules/es.array.of.js");
__webpack_require__(/*! ../modules/es.array.concat */ "./node_modules/core-js/modules/es.array.concat.js");
__webpack_require__(/*! ../modules/es.array.copy-within */ "./node_modules/core-js/modules/es.array.copy-within.js");
__webpack_require__(/*! ../modules/es.array.every */ "./node_modules/core-js/modules/es.array.every.js");
__webpack_require__(/*! ../modules/es.array.fill */ "./node_modules/core-js/modules/es.array.fill.js");
__webpack_require__(/*! ../modules/es.array.filter */ "./node_modules/core-js/modules/es.array.filter.js");
__webpack_require__(/*! ../modules/es.array.find */ "./node_modules/core-js/modules/es.array.find.js");
__webpack_require__(/*! ../modules/es.array.find-index */ "./node_modules/core-js/modules/es.array.find-index.js");
__webpack_require__(/*! ../modules/es.array.flat */ "./node_modules/core-js/modules/es.array.flat.js");
__webpack_require__(/*! ../modules/es.array.flat-map */ "./node_modules/core-js/modules/es.array.flat-map.js");
__webpack_require__(/*! ../modules/es.array.for-each */ "./node_modules/core-js/modules/es.array.for-each.js");
__webpack_require__(/*! ../modules/es.array.includes */ "./node_modules/core-js/modules/es.array.includes.js");
__webpack_require__(/*! ../modules/es.array.index-of */ "./node_modules/core-js/modules/es.array.index-of.js");
__webpack_require__(/*! ../modules/es.array.join */ "./node_modules/core-js/modules/es.array.join.js");
__webpack_require__(/*! ../modules/es.array.last-index-of */ "./node_modules/core-js/modules/es.array.last-index-of.js");
__webpack_require__(/*! ../modules/es.array.map */ "./node_modules/core-js/modules/es.array.map.js");
__webpack_require__(/*! ../modules/es.array.reduce */ "./node_modules/core-js/modules/es.array.reduce.js");
__webpack_require__(/*! ../modules/es.array.reduce-right */ "./node_modules/core-js/modules/es.array.reduce-right.js");
__webpack_require__(/*! ../modules/es.array.reverse */ "./node_modules/core-js/modules/es.array.reverse.js");
__webpack_require__(/*! ../modules/es.array.slice */ "./node_modules/core-js/modules/es.array.slice.js");
__webpack_require__(/*! ../modules/es.array.some */ "./node_modules/core-js/modules/es.array.some.js");
__webpack_require__(/*! ../modules/es.array.sort */ "./node_modules/core-js/modules/es.array.sort.js");
__webpack_require__(/*! ../modules/es.array.splice */ "./node_modules/core-js/modules/es.array.splice.js");
__webpack_require__(/*! ../modules/es.array.species */ "./node_modules/core-js/modules/es.array.species.js");
__webpack_require__(/*! ../modules/es.array.unscopables.flat */ "./node_modules/core-js/modules/es.array.unscopables.flat.js");
__webpack_require__(/*! ../modules/es.array.unscopables.flat-map */ "./node_modules/core-js/modules/es.array.unscopables.flat-map.js");
__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
__webpack_require__(/*! ../modules/es.string.from-code-point */ "./node_modules/core-js/modules/es.string.from-code-point.js");
__webpack_require__(/*! ../modules/es.string.raw */ "./node_modules/core-js/modules/es.string.raw.js");
__webpack_require__(/*! ../modules/es.string.code-point-at */ "./node_modules/core-js/modules/es.string.code-point-at.js");
__webpack_require__(/*! ../modules/es.string.ends-with */ "./node_modules/core-js/modules/es.string.ends-with.js");
__webpack_require__(/*! ../modules/es.string.includes */ "./node_modules/core-js/modules/es.string.includes.js");
__webpack_require__(/*! ../modules/es.string.match */ "./node_modules/core-js/modules/es.string.match.js");
__webpack_require__(/*! ../modules/es.string.match-all */ "./node_modules/core-js/modules/es.string.match-all.js");
__webpack_require__(/*! ../modules/es.string.pad-end */ "./node_modules/core-js/modules/es.string.pad-end.js");
__webpack_require__(/*! ../modules/es.string.pad-start */ "./node_modules/core-js/modules/es.string.pad-start.js");
__webpack_require__(/*! ../modules/es.string.repeat */ "./node_modules/core-js/modules/es.string.repeat.js");
__webpack_require__(/*! ../modules/es.string.replace */ "./node_modules/core-js/modules/es.string.replace.js");
__webpack_require__(/*! ../modules/es.string.search */ "./node_modules/core-js/modules/es.string.search.js");
__webpack_require__(/*! ../modules/es.string.split */ "./node_modules/core-js/modules/es.string.split.js");
__webpack_require__(/*! ../modules/es.string.starts-with */ "./node_modules/core-js/modules/es.string.starts-with.js");
__webpack_require__(/*! ../modules/es.string.trim */ "./node_modules/core-js/modules/es.string.trim.js");
__webpack_require__(/*! ../modules/es.string.trim-start */ "./node_modules/core-js/modules/es.string.trim-start.js");
__webpack_require__(/*! ../modules/es.string.trim-end */ "./node_modules/core-js/modules/es.string.trim-end.js");
__webpack_require__(/*! ../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
__webpack_require__(/*! ../modules/es.string.anchor */ "./node_modules/core-js/modules/es.string.anchor.js");
__webpack_require__(/*! ../modules/es.string.big */ "./node_modules/core-js/modules/es.string.big.js");
__webpack_require__(/*! ../modules/es.string.blink */ "./node_modules/core-js/modules/es.string.blink.js");
__webpack_require__(/*! ../modules/es.string.bold */ "./node_modules/core-js/modules/es.string.bold.js");
__webpack_require__(/*! ../modules/es.string.fixed */ "./node_modules/core-js/modules/es.string.fixed.js");
__webpack_require__(/*! ../modules/es.string.fontcolor */ "./node_modules/core-js/modules/es.string.fontcolor.js");
__webpack_require__(/*! ../modules/es.string.fontsize */ "./node_modules/core-js/modules/es.string.fontsize.js");
__webpack_require__(/*! ../modules/es.string.italics */ "./node_modules/core-js/modules/es.string.italics.js");
__webpack_require__(/*! ../modules/es.string.link */ "./node_modules/core-js/modules/es.string.link.js");
__webpack_require__(/*! ../modules/es.string.small */ "./node_modules/core-js/modules/es.string.small.js");
__webpack_require__(/*! ../modules/es.string.strike */ "./node_modules/core-js/modules/es.string.strike.js");
__webpack_require__(/*! ../modules/es.string.sub */ "./node_modules/core-js/modules/es.string.sub.js");
__webpack_require__(/*! ../modules/es.string.sup */ "./node_modules/core-js/modules/es.string.sup.js");
__webpack_require__(/*! ../modules/es.regexp.constructor */ "./node_modules/core-js/modules/es.regexp.constructor.js");
__webpack_require__(/*! ../modules/es.regexp.exec */ "./node_modules/core-js/modules/es.regexp.exec.js");
__webpack_require__(/*! ../modules/es.regexp.flags */ "./node_modules/core-js/modules/es.regexp.flags.js");
__webpack_require__(/*! ../modules/es.regexp.to-string */ "./node_modules/core-js/modules/es.regexp.to-string.js");
__webpack_require__(/*! ../modules/es.parse-int */ "./node_modules/core-js/modules/es.parse-int.js");
__webpack_require__(/*! ../modules/es.parse-float */ "./node_modules/core-js/modules/es.parse-float.js");
__webpack_require__(/*! ../modules/es.number.constructor */ "./node_modules/core-js/modules/es.number.constructor.js");
__webpack_require__(/*! ../modules/es.number.epsilon */ "./node_modules/core-js/modules/es.number.epsilon.js");
__webpack_require__(/*! ../modules/es.number.is-finite */ "./node_modules/core-js/modules/es.number.is-finite.js");
__webpack_require__(/*! ../modules/es.number.is-integer */ "./node_modules/core-js/modules/es.number.is-integer.js");
__webpack_require__(/*! ../modules/es.number.is-nan */ "./node_modules/core-js/modules/es.number.is-nan.js");
__webpack_require__(/*! ../modules/es.number.is-safe-integer */ "./node_modules/core-js/modules/es.number.is-safe-integer.js");
__webpack_require__(/*! ../modules/es.number.max-safe-integer */ "./node_modules/core-js/modules/es.number.max-safe-integer.js");
__webpack_require__(/*! ../modules/es.number.min-safe-integer */ "./node_modules/core-js/modules/es.number.min-safe-integer.js");
__webpack_require__(/*! ../modules/es.number.parse-float */ "./node_modules/core-js/modules/es.number.parse-float.js");
__webpack_require__(/*! ../modules/es.number.parse-int */ "./node_modules/core-js/modules/es.number.parse-int.js");
__webpack_require__(/*! ../modules/es.number.to-fixed */ "./node_modules/core-js/modules/es.number.to-fixed.js");
__webpack_require__(/*! ../modules/es.number.to-precision */ "./node_modules/core-js/modules/es.number.to-precision.js");
__webpack_require__(/*! ../modules/es.math.acosh */ "./node_modules/core-js/modules/es.math.acosh.js");
__webpack_require__(/*! ../modules/es.math.asinh */ "./node_modules/core-js/modules/es.math.asinh.js");
__webpack_require__(/*! ../modules/es.math.atanh */ "./node_modules/core-js/modules/es.math.atanh.js");
__webpack_require__(/*! ../modules/es.math.cbrt */ "./node_modules/core-js/modules/es.math.cbrt.js");
__webpack_require__(/*! ../modules/es.math.clz32 */ "./node_modules/core-js/modules/es.math.clz32.js");
__webpack_require__(/*! ../modules/es.math.cosh */ "./node_modules/core-js/modules/es.math.cosh.js");
__webpack_require__(/*! ../modules/es.math.expm1 */ "./node_modules/core-js/modules/es.math.expm1.js");
__webpack_require__(/*! ../modules/es.math.fround */ "./node_modules/core-js/modules/es.math.fround.js");
__webpack_require__(/*! ../modules/es.math.hypot */ "./node_modules/core-js/modules/es.math.hypot.js");
__webpack_require__(/*! ../modules/es.math.imul */ "./node_modules/core-js/modules/es.math.imul.js");
__webpack_require__(/*! ../modules/es.math.log10 */ "./node_modules/core-js/modules/es.math.log10.js");
__webpack_require__(/*! ../modules/es.math.log1p */ "./node_modules/core-js/modules/es.math.log1p.js");
__webpack_require__(/*! ../modules/es.math.log2 */ "./node_modules/core-js/modules/es.math.log2.js");
__webpack_require__(/*! ../modules/es.math.sign */ "./node_modules/core-js/modules/es.math.sign.js");
__webpack_require__(/*! ../modules/es.math.sinh */ "./node_modules/core-js/modules/es.math.sinh.js");
__webpack_require__(/*! ../modules/es.math.tanh */ "./node_modules/core-js/modules/es.math.tanh.js");
__webpack_require__(/*! ../modules/es.math.to-string-tag */ "./node_modules/core-js/modules/es.math.to-string-tag.js");
__webpack_require__(/*! ../modules/es.math.trunc */ "./node_modules/core-js/modules/es.math.trunc.js");
__webpack_require__(/*! ../modules/es.date.now */ "./node_modules/core-js/modules/es.date.now.js");
__webpack_require__(/*! ../modules/es.date.to-json */ "./node_modules/core-js/modules/es.date.to-json.js");
__webpack_require__(/*! ../modules/es.date.to-iso-string */ "./node_modules/core-js/modules/es.date.to-iso-string.js");
__webpack_require__(/*! ../modules/es.date.to-string */ "./node_modules/core-js/modules/es.date.to-string.js");
__webpack_require__(/*! ../modules/es.date.to-primitive */ "./node_modules/core-js/modules/es.date.to-primitive.js");
__webpack_require__(/*! ../modules/es.json.to-string-tag */ "./node_modules/core-js/modules/es.json.to-string-tag.js");
__webpack_require__(/*! ../modules/es.promise */ "./node_modules/core-js/modules/es.promise.js");
__webpack_require__(/*! ../modules/es.promise.finally */ "./node_modules/core-js/modules/es.promise.finally.js");
__webpack_require__(/*! ../modules/es.map */ "./node_modules/core-js/modules/es.map.js");
__webpack_require__(/*! ../modules/es.set */ "./node_modules/core-js/modules/es.set.js");
__webpack_require__(/*! ../modules/es.weak-map */ "./node_modules/core-js/modules/es.weak-map.js");
__webpack_require__(/*! ../modules/es.weak-set */ "./node_modules/core-js/modules/es.weak-set.js");
__webpack_require__(/*! ../modules/es.array-buffer.constructor */ "./node_modules/core-js/modules/es.array-buffer.constructor.js");
__webpack_require__(/*! ../modules/es.array-buffer.is-view */ "./node_modules/core-js/modules/es.array-buffer.is-view.js");
__webpack_require__(/*! ../modules/es.array-buffer.slice */ "./node_modules/core-js/modules/es.array-buffer.slice.js");
__webpack_require__(/*! ../modules/es.data-view */ "./node_modules/core-js/modules/es.data-view.js");
__webpack_require__(/*! ../modules/es.typed-array.int8-array */ "./node_modules/core-js/modules/es.typed-array.int8-array.js");
__webpack_require__(/*! ../modules/es.typed-array.uint8-array */ "./node_modules/core-js/modules/es.typed-array.uint8-array.js");
__webpack_require__(/*! ../modules/es.typed-array.uint8-clamped-array */ "./node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js");
__webpack_require__(/*! ../modules/es.typed-array.int16-array */ "./node_modules/core-js/modules/es.typed-array.int16-array.js");
__webpack_require__(/*! ../modules/es.typed-array.uint16-array */ "./node_modules/core-js/modules/es.typed-array.uint16-array.js");
__webpack_require__(/*! ../modules/es.typed-array.int32-array */ "./node_modules/core-js/modules/es.typed-array.int32-array.js");
__webpack_require__(/*! ../modules/es.typed-array.uint32-array */ "./node_modules/core-js/modules/es.typed-array.uint32-array.js");
__webpack_require__(/*! ../modules/es.typed-array.float32-array */ "./node_modules/core-js/modules/es.typed-array.float32-array.js");
__webpack_require__(/*! ../modules/es.typed-array.float64-array */ "./node_modules/core-js/modules/es.typed-array.float64-array.js");
__webpack_require__(/*! ../modules/es.typed-array.from */ "./node_modules/core-js/modules/es.typed-array.from.js");
__webpack_require__(/*! ../modules/es.typed-array.of */ "./node_modules/core-js/modules/es.typed-array.of.js");
__webpack_require__(/*! ../modules/es.typed-array.copy-within */ "./node_modules/core-js/modules/es.typed-array.copy-within.js");
__webpack_require__(/*! ../modules/es.typed-array.every */ "./node_modules/core-js/modules/es.typed-array.every.js");
__webpack_require__(/*! ../modules/es.typed-array.fill */ "./node_modules/core-js/modules/es.typed-array.fill.js");
__webpack_require__(/*! ../modules/es.typed-array.filter */ "./node_modules/core-js/modules/es.typed-array.filter.js");
__webpack_require__(/*! ../modules/es.typed-array.find */ "./node_modules/core-js/modules/es.typed-array.find.js");
__webpack_require__(/*! ../modules/es.typed-array.find-index */ "./node_modules/core-js/modules/es.typed-array.find-index.js");
__webpack_require__(/*! ../modules/es.typed-array.for-each */ "./node_modules/core-js/modules/es.typed-array.for-each.js");
__webpack_require__(/*! ../modules/es.typed-array.includes */ "./node_modules/core-js/modules/es.typed-array.includes.js");
__webpack_require__(/*! ../modules/es.typed-array.index-of */ "./node_modules/core-js/modules/es.typed-array.index-of.js");
__webpack_require__(/*! ../modules/es.typed-array.iterator */ "./node_modules/core-js/modules/es.typed-array.iterator.js");
__webpack_require__(/*! ../modules/es.typed-array.join */ "./node_modules/core-js/modules/es.typed-array.join.js");
__webpack_require__(/*! ../modules/es.typed-array.last-index-of */ "./node_modules/core-js/modules/es.typed-array.last-index-of.js");
__webpack_require__(/*! ../modules/es.typed-array.map */ "./node_modules/core-js/modules/es.typed-array.map.js");
__webpack_require__(/*! ../modules/es.typed-array.reduce */ "./node_modules/core-js/modules/es.typed-array.reduce.js");
__webpack_require__(/*! ../modules/es.typed-array.reduce-right */ "./node_modules/core-js/modules/es.typed-array.reduce-right.js");
__webpack_require__(/*! ../modules/es.typed-array.reverse */ "./node_modules/core-js/modules/es.typed-array.reverse.js");
__webpack_require__(/*! ../modules/es.typed-array.set */ "./node_modules/core-js/modules/es.typed-array.set.js");
__webpack_require__(/*! ../modules/es.typed-array.slice */ "./node_modules/core-js/modules/es.typed-array.slice.js");
__webpack_require__(/*! ../modules/es.typed-array.some */ "./node_modules/core-js/modules/es.typed-array.some.js");
__webpack_require__(/*! ../modules/es.typed-array.sort */ "./node_modules/core-js/modules/es.typed-array.sort.js");
__webpack_require__(/*! ../modules/es.typed-array.subarray */ "./node_modules/core-js/modules/es.typed-array.subarray.js");
__webpack_require__(/*! ../modules/es.typed-array.to-locale-string */ "./node_modules/core-js/modules/es.typed-array.to-locale-string.js");
__webpack_require__(/*! ../modules/es.typed-array.to-string */ "./node_modules/core-js/modules/es.typed-array.to-string.js");
__webpack_require__(/*! ../modules/es.reflect.apply */ "./node_modules/core-js/modules/es.reflect.apply.js");
__webpack_require__(/*! ../modules/es.reflect.construct */ "./node_modules/core-js/modules/es.reflect.construct.js");
__webpack_require__(/*! ../modules/es.reflect.define-property */ "./node_modules/core-js/modules/es.reflect.define-property.js");
__webpack_require__(/*! ../modules/es.reflect.delete-property */ "./node_modules/core-js/modules/es.reflect.delete-property.js");
__webpack_require__(/*! ../modules/es.reflect.get */ "./node_modules/core-js/modules/es.reflect.get.js");
__webpack_require__(/*! ../modules/es.reflect.get-own-property-descriptor */ "./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js");
__webpack_require__(/*! ../modules/es.reflect.get-prototype-of */ "./node_modules/core-js/modules/es.reflect.get-prototype-of.js");
__webpack_require__(/*! ../modules/es.reflect.has */ "./node_modules/core-js/modules/es.reflect.has.js");
__webpack_require__(/*! ../modules/es.reflect.is-extensible */ "./node_modules/core-js/modules/es.reflect.is-extensible.js");
__webpack_require__(/*! ../modules/es.reflect.own-keys */ "./node_modules/core-js/modules/es.reflect.own-keys.js");
__webpack_require__(/*! ../modules/es.reflect.prevent-extensions */ "./node_modules/core-js/modules/es.reflect.prevent-extensions.js");
__webpack_require__(/*! ../modules/es.reflect.set */ "./node_modules/core-js/modules/es.reflect.set.js");
__webpack_require__(/*! ../modules/es.reflect.set-prototype-of */ "./node_modules/core-js/modules/es.reflect.set-prototype-of.js");

module.exports = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");


/***/ }),

/***/ "./node_modules/core-js/internals/a-function.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/a-possible-prototype.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/a-possible-prototype.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  hide(ArrayPrototype, UNSCOPABLES, create(null));
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "./node_modules/core-js/internals/advance-string-index.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-instance.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/an-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer-view-core.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer-view-core.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var DataView = global.DataView;
var DataViewPrototype = DataView && DataView.prototype;
var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
var NATIVE_ARRAY_BUFFER = !!(global.ArrayBuffer && DataView);
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf;
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportProto = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportStatic = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    hide(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

// WebKit bug - the same parent prototype for typed arrays and data view
if (NATIVE_ARRAY_BUFFER && setPrototypeOf && getPrototypeOf(DataViewPrototype) !== ObjectPrototype) {
  setPrototypeOf(DataViewPrototype, ObjectPrototype);
}

module.exports = {
  NATIVE_ARRAY_BUFFER: NATIVE_ARRAY_BUFFER,
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportProto: exportProto,
  exportStatic: exportStatic,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-buffer.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER;
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndex = __webpack_require__(/*! ../internals/to-index */ "./node_modules/core-js/internals/to-index.js");
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var arrayFill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError;
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

// IEEE754 conversions based on https://github.com/feross/ieee754
var packIEEE754 = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpackIEEE754 = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, NativeArrayBuffer[key]);
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }
  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataView[PROTOTYPE].setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;


/***/ }),

/***/ "./node_modules/core-js/internals/array-copy-within.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/array-copy-within.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-fill.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-fill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-for-each.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-for-each.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = sloppyArrayMethod('forEach') ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;


/***/ }),

/***/ "./node_modules/core-js/internals/array-from.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/array-from.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var index = 0;
  var iteratorMethod = getIteratorMethod(O);
  var length, result, step, iterator;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    result = new C();
    for (;!(step = iterator.next()).done; index++) {
      createProperty(result, index, mapping
        ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true)
        : step.value
      );
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-includes.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-iteration.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/array-iteration.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-last-index-of.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/array-last-index-of.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('lastIndexOf');

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = (NEGATIVE_ZERO || SLOPPY_METHOD) ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),

/***/ "./node_modules/core-js/internals/array-method-has-species-support.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/array-method-has-species-support.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  return !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-reduce.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/array-species-create.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/bind-context.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/bind-context.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/internals/call-with-safe-iteration-closing.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/check-correctness-of-iteration.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/internals/check-correctness-of-iteration.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof-raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/classof-raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "./node_modules/core-js/internals/classof.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classofRaw = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-strong.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/collection-strong.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fastKey = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").fastKey;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection-weak.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/collection-weak.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var getWeakData = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").getWeakData;
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var ArrayIterationModule = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js");
var $has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) this.entries.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && $has(data, state.id) && delete data[state.id];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && $has(data, state.id);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return C;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/collection.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/collection.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common, IS_MAP, IS_WEAK) {
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var ADDER = IS_MAP ? 'set' : 'add';
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(a) {
        nativeMethod.call(this, a === 0 ? 0 : a);
        return this;
      } : KEY == 'delete' ? function (a) {
        return IS_WEAK && !isObject(a) ? false : nativeMethod.call(this, a === 0 ? 0 : a);
      } : KEY == 'get' ? function get(a) {
        return IS_WEAK && !isObject(a) ? undefined : nativeMethod.call(this, a === 0 ? 0 : a);
      } : KEY == 'has' ? function has(a) {
        return IS_WEAK && !isObject(a) ? false : nativeMethod.call(this, a === 0 ? 0 : a);
      } : function set(a, b) {
        nativeMethod.call(this, a === 0 ? 0 : a, b);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/copy-constructor-properties.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/copy-constructor-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-is-regexp-logic.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-is-regexp-logic.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "./node_modules/core-js/internals/correct-prototype-getter.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/correct-prototype-getter.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "./node_modules/core-js/internals/create-html.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/create-html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-iterator-constructor.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-iterator-constructor.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js").IteratorPrototype;
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property-descriptor.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/internals/create-property-descriptor.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "./node_modules/core-js/internals/create-property.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/create-property.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/date-to-iso-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/date-to-iso-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var padStart = __webpack_require__(/*! ../internals/string-pad */ "./node_modules/core-js/internals/string-pad.js").start;

var abs = Math.abs;
var DatePrototype = Date.prototype;
var getTime = DatePrototype.getTime;
var nativeDateToISOString = DatePrototype.toISOString;

// `Date.prototype.toISOString` method implementation
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit fails here:
module.exports = (fails(function () {
  return nativeDateToISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  nativeDateToISOString.call(new Date(NaN));
})) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var date = this;
  var year = date.getUTCFullYear();
  var milliseconds = date.getUTCMilliseconds();
  var sign = year < 0 ? '-' : year > 9999 ? '+' : '';
  return sign + padStart(abs(year), sign ? 6 : 4, 0) +
    '-' + padStart(date.getUTCMonth() + 1, 2, 0) +
    '-' + padStart(date.getUTCDate(), 2, 0) +
    'T' + padStart(date.getUTCHours(), 2, 0) +
    ':' + padStart(date.getUTCMinutes(), 2, 0) +
    ':' + padStart(date.getUTCSeconds(), 2, 0) +
    '.' + padStart(milliseconds, 3, 0) +
    'Z';
} : nativeDateToISOString;


/***/ }),

/***/ "./node_modules/core-js/internals/date-to-primitive.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/date-to-primitive.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

module.exports = function (hint) {
  if (hint !== 'string' && hint !== 'number' && hint !== 'default') {
    throw TypeError('Incorrect hint');
  } return toPrimitive(anObject(this), hint !== 'number');
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/define-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var IteratorsCore = __webpack_require__(/*! ../internals/iterators-core */ "./node_modules/core-js/internals/iterators-core.js");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          hide(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    hide(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "./node_modules/core-js/internals/define-well-known-symbol.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/define-well-known-symbol.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/wrapped-well-known-symbol */ "./node_modules/core-js/internals/wrapped-well-known-symbol.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/descriptors.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/document-create-element.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/document-create-element.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "./node_modules/core-js/internals/dom-iterables.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/dom-iterables.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "./node_modules/core-js/internals/enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "./node_modules/core-js/internals/export.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      hide(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fails.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/internals/fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;
    re.exec = function () { execCalled = true; return null; };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
    }

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
    if (sham) hide(RegExp.prototype[SYMBOL], 'sham', true);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/flatten-into-array.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/flatten-into-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ "./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js ***!
  \*************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// Forced replacement object prototype accessors methods
module.exports = IS_PURE || !fails(function () {
  var key = Math.random();
  // In FF throws only define methods
  // eslint-disable-next-line no-undef, no-useless-call
  __defineSetter__.call(null, key, function () { /* empty */ });
  delete global[key];
});


/***/ }),

/***/ "./node_modules/core-js/internals/forced-string-html-method.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/forced-string-html-method.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/forced-string-trim-method.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/forced-string-trim-method.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/freezing.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/freezing.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "./node_modules/core-js/internals/function-bind.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/function-bind.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ "./node_modules/core-js/internals/function-to-string.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/function-to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");

module.exports = shared('native-function-to-string', Function.toString);


/***/ }),

/***/ "./node_modules/core-js/internals/get-built-in.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-built-in.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "./node_modules/core-js/internals/get-iterator.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/get-iterator.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");

module.exports = function (it) {
  var iteratorMethod = getIteratorMethod(it);
  if (typeof iteratorMethod != 'function') {
    throw TypeError(String(it) + ' is not iterable');
  } return anObject(iteratorMethod.call(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/global.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var O = 'object';
var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == O && globalThis) ||
  check(typeof window == O && window) ||
  check(typeof self == O && self) ||
  check(typeof global == O && global) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/core-js/internals/has.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "./node_modules/core-js/internals/hidden-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/hidden-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/hide.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/hide.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "./node_modules/core-js/internals/host-report-errors.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/internals/host-report-errors.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/html.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "./node_modules/core-js/internals/ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "./node_modules/core-js/internals/indexed-object.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/indexed-object.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "./node_modules/core-js/internals/inherit-if-required.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/inherit-if-required.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "./node_modules/core-js/internals/internal-metadata.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/internal-metadata.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/internal-state.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/internal-state.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var objectHas = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    hide(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array-iterator-method.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/is-array-iterator-method.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-array.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-forced.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-forced.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "./node_modules/core-js/internals/is-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/is-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var floor = Math.floor;

// `Number.isInteger` method implementation
// https://tc39.github.io/ecma262/#sec-number.isinteger
module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "./node_modules/core-js/internals/is-pure.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/is-pure.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "./node_modules/core-js/internals/is-regexp.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/is-regexp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterate.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/iterate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var callWithSafeIterationClosing = __webpack_require__(/*! ../internals/call-with-safe-iteration-closing */ "./node_modules/core-js/internals/call-with-safe-iteration-closing.js");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  while (!(step = iterator.next()).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators-core.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/internals/iterators-core.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) hide(IteratorPrototype, ITERATOR, returnThis);

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "./node_modules/core-js/internals/iterators.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "./node_modules/core-js/internals/math-expm1.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-expm1.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var nativeExpm1 = Math.expm1;
var exp = Math.exp;

// `Math.expm1` method implementation
// https://tc39.github.io/ecma262/#sec-math.expm1
module.exports = (!nativeExpm1
  // Old FF bug
  || nativeExpm1(10) > 22025.465794806719 || nativeExpm1(10) < 22025.4657948067165168
  // Tor Browser bug
  || nativeExpm1(-2e-17) != -2e-17
) ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : exp(x) - 1;
} : nativeExpm1;


/***/ }),

/***/ "./node_modules/core-js/internals/math-fround.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/math-fround.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var sign = __webpack_require__(/*! ../internals/math-sign */ "./node_modules/core-js/internals/math-sign.js");

var abs = Math.abs;
var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function (n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

// `Math.fround` method implementation
// https://tc39.github.io/ecma262/#sec-math.fround
module.exports = Math.fround || function fround(x) {
  var $abs = abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs);
  // eslint-disable-next-line no-self-compare
  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-log1p.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/math-log1p.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var log = Math.log;

// `Math.log1p` method implementation
// https://tc39.github.io/ecma262/#sec-math.log1p
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : log(1 + x);
};


/***/ }),

/***/ "./node_modules/core-js/internals/math-sign.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/math-sign.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `Math.sign` method implementation
// https://tc39.github.io/ecma262/#sec-math.sign
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};


/***/ }),

/***/ "./node_modules/core-js/internals/microtask.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/microtask.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var macrotask = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !/(iphone|ipod|ipad).*applewebkit/i.test(userAgent)) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true }); // eslint-disable-line no-new
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    notify = function () {
      promise.then(flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "./node_modules/core-js/internals/native-symbol.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/native-symbol.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-url.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/native-url.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = !fails(function () {
  var url = new URL('b?e=1', 'http://a');
  var searchParams = url.searchParams;
  url.pathname = 'c%20d';
  return (IS_PURE && !url.toJSON)
    || !searchParams.sort
    || url.href !== 'http://a/c%20d?e=1'
    || searchParams.get('e') !== '1'
    || String(new URLSearchParams('?a=1')) !== 'a=1'
    || !searchParams[ITERATOR]
    // throws in Edge
    || new URL('https://a@b').username !== 'a'
    || new URLSearchParams(new URLSearchParams('a=b')).get('a') !== 'b'
    // not punycoded in Edge
    || new URL('http://тест').host !== 'xn--e1aybc'
    // not escaped in Chrome 62-
    || new URL('http://a#б').hash !== '#%D0%B1';
});


/***/ }),

/***/ "./node_modules/core-js/internals/native-weak-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/native-weak-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(nativeFunctionToString.call(WeakMap));


/***/ }),

/***/ "./node_modules/core-js/internals/new-promise-capability.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/new-promise-capability.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "./node_modules/core-js/internals/not-a-regexp.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/not-a-regexp.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/number-is-finite.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/number-is-finite.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");

var globalIsFinite = global.isFinite;

// `Number.isFinite` method
// https://tc39.github.io/ecma262/#sec-number.isfinite
module.exports = Number.isFinite || function isFinite(it) {
  return typeof it == 'number' && globalIsFinite(it);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-assign.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-assign.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");

var nativeAssign = Object.assign;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
// should work with symbols and should have deterministic property order (V8 bug)
module.exports = !nativeAssign || fails(function () {
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;


/***/ }),

/***/ "./node_modules/core-js/internals/object-create.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var documentCreateElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var IE_PROTO = sharedKey('IE_PROTO');

var PROTOTYPE = 'prototype';
var Empty = function () { /* empty */ };

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var createDict = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var length = enumBugKeys.length;
  var lt = '<';
  var script = 'script';
  var gt = '>';
  var js = 'java' + script + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  iframe.src = String(js);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + script + gt + 'document.F=Object' + lt + '/' + script + gt);
  iframeDocument.close();
  createDict = iframeDocument.F;
  while (length--) delete createDict[PROTOTYPE][enumBugKeys[length]];
  return createDict();
};

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = createDict();
  return Properties === undefined ? result : defineProperties(result, Properties);
};

hiddenKeys[IE_PROTO] = true;


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-properties.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-properties.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-define-property.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-define-property.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-descriptor.js":
/*!******************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-descriptor.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var IE8_DOM_DEFINE = __webpack_require__(/*! ../internals/ie8-dom-define */ "./node_modules/core-js/internals/ie8-dom-define.js");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names-external.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names-external.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-names.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-names.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-own-property-symbols.js":
/*!***************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-own-property-symbols.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "./node_modules/core-js/internals/object-get-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-get-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys-internal.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-keys.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__(/*! ../internals/object-keys-internal */ "./node_modules/core-js/internals/object-keys-internal.js");
var enumBugKeys = __webpack_require__(/*! ../internals/enum-bug-keys */ "./node_modules/core-js/internals/enum-bug-keys.js");

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-property-is-enumerable.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/internals/object-property-is-enumerable.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "./node_modules/core-js/internals/object-set-prototype-of.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/object-set-prototype-of.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var propertyIsEnumerable = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js").f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "./node_modules/core-js/internals/object-to-string.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/object-to-string.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = String(test) !== '[object z]' ? function toString() {
  return '[object ' + classof(this) + ']';
} : test.toString;


/***/ }),

/***/ "./node_modules/core-js/internals/own-keys.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "./node_modules/core-js/internals/parse-float.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/parse-float.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var nativeParseFloat = global.parseFloat;
var FORCED = 1 / nativeParseFloat(whitespaces + '-0') !== -Infinity;

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
module.exports = FORCED ? function parseFloat(string) {
  var trimmedString = trim(String(string));
  var result = nativeParseFloat(trimmedString);
  return result === 0 && trimmedString.charAt(0) == '-' ? -0 : result;
} : nativeParseFloat;


/***/ }),

/***/ "./node_modules/core-js/internals/parse-int.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/parse-int.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var nativeParseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = nativeParseInt(whitespaces + '08') !== 8 || nativeParseInt(whitespaces + '0x16') !== 22;

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(String(string));
  return nativeParseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
} : nativeParseInt;


/***/ }),

/***/ "./node_modules/core-js/internals/path.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/path.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");


/***/ }),

/***/ "./node_modules/core-js/internals/perform.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/internals/perform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/promise-resolve.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/internals/promise-resolve.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var newPromiseCapability = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "./node_modules/core-js/internals/punycode-to-ascii.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/punycode-to-ascii.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// based on https://github.com/bestiejs/punycode.js/blob/master/punycode.js
var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'
var regexNonASCII = /[^\0-\u007E]/; // non-ASCII chars
var regexSeparators = /[.\u3002\uFF0E\uFF61]/g; // RFC 3490 separators
var OVERFLOW_ERROR = 'Overflow: input needs wider integers to process';
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 */
var ucs2decode = function (string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  while (counter < length) {
    var value = string.charCodeAt(counter++);
    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // It's a high surrogate, and there is a next character.
      var extra = string.charCodeAt(counter++);
      if ((extra & 0xFC00) == 0xDC00) { // Low surrogate.
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // It's an unmatched surrogate; only append this code unit, in case the
        // next code unit is the high surrogate of a surrogate pair.
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
};

/**
 * Converts a digit/integer into a basic code point.
 */
var digitToBasic = function (digit) {
  //  0..25 map to ASCII a..z or A..Z
  // 26..35 map to ASCII 0..9
  return digit + 22 + 75 * (digit < 26);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 */
var adapt = function (delta, numPoints, firstTime) {
  var k = 0;
  delta = firstTime ? floor(delta / damp) : delta >> 1;
  delta += floor(delta / numPoints);
  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
    delta = floor(delta / baseMinusTMin);
  }
  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 */
// eslint-disable-next-line  max-statements
var encode = function (input) {
  var output = [];

  // Convert the input in UCS-2 to an array of Unicode code points.
  input = ucs2decode(input);

  // Cache the length.
  var inputLength = input.length;

  // Initialize the state.
  var n = initialN;
  var delta = 0;
  var bias = initialBias;
  var i, currentValue;

  // Handle the basic code points.
  for (i = 0; i < input.length; i++) {
    currentValue = input[i];
    if (currentValue < 0x80) {
      output.push(stringFromCharCode(currentValue));
    }
  }

  var basicLength = output.length; // number of basic code points.
  var handledCPCount = basicLength; // number of code points that have been handled;

  // Finish the basic string with a delimiter unless it's empty.
  if (basicLength) {
    output.push(delimiter);
  }

  // Main encoding loop:
  while (handledCPCount < inputLength) {
    // All non-basic code points < n have been handled already. Find the next larger one:
    var m = maxInt;
    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue >= n && currentValue < m) {
        m = currentValue;
      }
    }

    // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>, but guard against overflow.
    var handledCPCountPlusOne = handledCPCount + 1;
    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
      throw RangeError(OVERFLOW_ERROR);
    }

    delta += (m - n) * handledCPCountPlusOne;
    n = m;

    for (i = 0; i < input.length; i++) {
      currentValue = input[i];
      if (currentValue < n && ++delta > maxInt) {
        throw RangeError(OVERFLOW_ERROR);
      }
      if (currentValue == n) {
        // Represent delta as a generalized variable-length integer.
        var q = delta;
        for (var k = base; /* no condition */; k += base) {
          var t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
          if (q < t) break;
          var qMinusT = q - t;
          var baseMinusT = base - t;
          output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
          q = floor(qMinusT / baseMinusT);
        }

        output.push(stringFromCharCode(digitToBasic(q)));
        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
        delta = 0;
        ++handledCPCount;
      }
    }

    ++delta;
    ++n;
  }
  return output.join('');
};

module.exports = function (input) {
  var encoded = [];
  var labels = input.toLowerCase().replace(regexSeparators, '\u002E').split('.');
  var i, label;
  for (i = 0; i < labels.length; i++) {
    label = labels[i];
    encoded.push(regexNonASCII.test(label) ? 'xn--' + encode(label) : label);
  }
  return encoded.join('.');
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine-all.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "./node_modules/core-js/internals/redefine.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var nativeFunctionToString = __webpack_require__(/*! ../internals/function-to-string */ "./node_modules/core-js/internals/function-to-string.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(nativeFunctionToString).split('toString');

shared('inspectSource', function (it) {
  return nativeFunctionToString.call(it);
});

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) hide(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else hide(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || nativeFunctionToString.call(this);
});


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var regexpExec = __webpack_require__(/*! ./regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "./node_modules/core-js/internals/regexp-exec.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__(/*! ./regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "./node_modules/core-js/internals/regexp-flags.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/regexp-flags.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/require-object-coercible.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/internals/require-object-coercible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "./node_modules/core-js/internals/same-value.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/same-value.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-global.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/set-global.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");

module.exports = function (key, value) {
  try {
    hide(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-species.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/set-species.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared-key.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "./node_modules/core-js/internals/shared.js":
/*!**************************************************!*\
  !*** ./node_modules/core-js/internals/shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setGlobal = __webpack_require__(/*! ../internals/set-global */ "./node_modules/core-js/internals/set-global.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.1.3',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "./node_modules/core-js/internals/sloppy-array-method.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/sloppy-array-method.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !method || !fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "./node_modules/core-js/internals/species-constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/internals/species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-multibyte.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/string-multibyte.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-pad.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/string-pad.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

var ceil = Math.ceil;

// `String.prototype.{ padStart, padEnd }` methods implementation
var createMethod = function (IS_END) {
  return function ($this, maxLength, fillString) {
    var S = String(requireObjectCoercible($this));
    var stringLength = S.length;
    var fillStr = fillString === undefined ? ' ' : String(fillString);
    var intMaxLength = toLength(maxLength);
    var fillLen, stringFiller;
    if (intMaxLength <= stringLength || fillStr == '') return S;
    fillLen = intMaxLength - stringLength;
    stringFiller = repeat.call(fillStr, ceil(fillLen / fillStr.length));
    if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
    return IS_END ? S + stringFiller : stringFiller + S;
  };
};

module.exports = {
  // `String.prototype.padStart` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padstart
  start: createMethod(false),
  // `String.prototype.padEnd` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.padend
  end: createMethod(true)
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-repeat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/internals/string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/string-trim.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/string-trim.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var whitespaces = __webpack_require__(/*! ../internals/whitespaces */ "./node_modules/core-js/internals/whitespaces.js");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "./node_modules/core-js/internals/task.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/internals/task.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var html = __webpack_require__(/*! ../internals/html */ "./node_modules/core-js/internals/html.js");
var createElement = __webpack_require__(/*! ../internals/document-create-element */ "./node_modules/core-js/internals/document-create-element.js");

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts && !fails(post)) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "./node_modules/core-js/internals/this-number-value.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/this-number-value.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

// `thisNumberValue` abstract operation
// https://tc39.github.io/ecma262/#sec-thisnumbervalue
module.exports = function (value) {
  if (typeof value != 'number' && classof(value) != 'Number') {
    throw TypeError('Incorrect invocation');
  }
  return +value;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-absolute-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(length, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-index.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/internals/to-index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-indexed-object.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/to-indexed-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-integer.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-length.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-object.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-offset.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/internals/to-offset.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");

module.exports = function (it, BYTES) {
  var offset = toInteger(it);
  if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "./node_modules/core-js/internals/to-primitive.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/internals/to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "./node_modules/core-js/internals/typed-array-constructor.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-array-constructor.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(/*! ../internals/typed-arrays-constructors-requires-wrappers */ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndex = __webpack_require__(/*! ../internals/to-index */ "./node_modules/core-js/internals/to-index.js");
var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var typedArrayFrom = __webpack_require__(/*! ../internals/typed-array-from */ "./node_modules/core-js/internals/typed-array-from.js");
var forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  // eslint-disable-next-line max-statements
  module.exports = function (TYPE, BYTES, wrapper, CLAMPED) {
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
        if (isArrayBuffer(data)) return $length !== undefined
          ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
          : typedArrayOffset !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
            : new NativeTypedArrayConstructor(data);
        if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
        return typedArrayFrom.call(TypedArrayConstructor, data);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) hide(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      hide(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) hide(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      hide(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      hide(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "./node_modules/core-js/internals/typed-array-from.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-array-from.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var isArrayIteratorMethod = __webpack_require__(/*! ../internals/is-array-iterator-method */ "./node_modules/core-js/internals/is-array-iterator-method.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var aTypedArrayConstructor = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    O = [];
    while (!(step = iterator.next()).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js ***!
  \***************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new */
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari 11 bug
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ "./node_modules/core-js/internals/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/core-js/internals/uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "./node_modules/core-js/internals/user-agent.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/internals/user-agent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "./node_modules/core-js/internals/webkit-string-pad-bug.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/internals/webkit-string-pad-bug.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/zloirock/core-js/issues/280
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");

// eslint-disable-next-line unicorn/no-unsafe-regex
module.exports = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);


/***/ }),

/***/ "./node_modules/core-js/internals/well-known-symbol.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/internals/well-known-symbol.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");

var Symbol = global.Symbol;
var store = shared('wks');

module.exports = function (name) {
  return store[name] || (store[name] = NATIVE_SYMBOL && Symbol[name]
    || (NATIVE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};


/***/ }),

/***/ "./node_modules/core-js/internals/whitespaces.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/internals/whitespaces.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "./node_modules/core-js/internals/wrapped-well-known-symbol.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/internals/wrapped-well-known-symbol.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.constructor.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.constructor.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var arrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var ArrayBuffer = arrayBufferModule[ARRAY_BUFFER];
var NativeArrayBuffer = global[ARRAY_BUFFER];

// `ArrayBuffer` constructor
// https://tc39.github.io/ecma262/#sec-arraybuffer-constructor
$({ global: true, forced: NativeArrayBuffer !== ArrayBuffer }, {
  ArrayBuffer: ArrayBuffer
});

setSpecies(ARRAY_BUFFER);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.is-view.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.is-view.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");

var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

// `ArrayBuffer.isView` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.isview
$({ target: 'ArrayBuffer', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
  isView: ArrayBufferViewCore.isView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array-buffer.slice.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array-buffer.slice.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");

var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var nativeArrayBufferSlice = ArrayBuffer.prototype.slice;

var INCORRECT_SLICE = fails(function () {
  return !new ArrayBuffer(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
$({ target: 'ArrayBuffer', proto: true, unsafe: true, forced: INCORRECT_SLICE }, {
  slice: function slice(start, end) {
    if (nativeArrayBufferSlice !== undefined && end === undefined) {
      return nativeArrayBufferSlice.call(anObject(this), start); // FF fix
    }
    var length = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    var result = new (speciesConstructor(this, ArrayBuffer))(toLength(fin - first));
    var viewSource = new DataView(this);
    var viewTarget = new DataView(result);
    var index = 0;
    while (first < fin) {
      viewTarget.setUint8(index++, viewSource.getUint8(first++));
    } return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.concat.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.concat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

var IS_CONCAT_SPREADABLE_SUPPORT = !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.copy-within.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.copy-within.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var copyWithin = __webpack_require__(/*! ../internals/array-copy-within */ "./node_modules/core-js/internals/array-copy-within.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
$({ target: 'Array', proto: true }, {
  copyWithin: copyWithin
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('copyWithin');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.every.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.every.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $every = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").every;
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('every') }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.fill.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.fill.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.filter.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.filter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $filter = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('filter') }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.find-index.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $findIndex = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").findIndex;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.find.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.find.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $find = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

var FIND = 'find';
var SKIPS_HOLES = true;

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.flat-map.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.flat-map.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var flattenIntoArray = __webpack_require__(/*! ../internals/flatten-into-array */ "./node_modules/core-js/internals/flatten-into-array.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

// `Array.prototype.flatMap` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flatMap: function flatMap(callbackfn /* , thisArg */) {
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A;
    aFunction(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.flat.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.flat.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var flattenIntoArray = __webpack_require__(/*! ../internals/flatten-into-array */ "./node_modules/core-js/internals/flatten-into-array.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");

// `Array.prototype.flat` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.for-each.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.for-each.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.from.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.from.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var from = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.includes.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.includes.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $includes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes;
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.index-of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.index-of.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var SLOPPY_METHOD = sloppyArrayMethod('indexOf');

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || SLOPPY_METHOD }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.is-array.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.is-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");

// `Array.isArray` method
// https://tc39.github.io/ecma262/#sec-array.isarray
$({ target: 'Array', stat: true }, {
  isArray: isArray
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.iterator.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");
var Iterators = __webpack_require__(/*! ../internals/iterators */ "./node_modules/core-js/internals/iterators.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.join.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.join.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var IndexedObject = __webpack_require__(/*! ../internals/indexed-object */ "./node_modules/core-js/internals/indexed-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var SLOPPY_METHOD = sloppyArrayMethod('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || SLOPPY_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.last-index-of.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.last-index-of.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var lastIndexOf = __webpack_require__(/*! ../internals/array-last-index-of */ "./node_modules/core-js/internals/array-last-index-of.js");

// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
$({ target: 'Array', proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.map.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.map.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $map = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").map;
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('map') }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.of.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.of.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

var ISNT_GENERIC = fails(function () {
  function F() { /* empty */ }
  return !(Array.of.call(F) instanceof F);
});

// `Array.of` method
// https://tc39.github.io/ecma262/#sec-array.of
// WebKit Array.of isn't generic
$({ target: 'Array', stat: true, forced: ISNT_GENERIC }, {
  of: function of(/* ...args */) {
    var index = 0;
    var argumentsLength = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(argumentsLength);
    while (argumentsLength > index) createProperty(result, index, arguments[index++]);
    result.length = argumentsLength;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce-right.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce-right.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $reduceRight = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").right;
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

// `Array.prototype.reduceRight` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduceRight') }, {
  reduceRight: function reduceRight(callbackfn /* , initialValue */) {
    return $reduceRight(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reduce.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reduce.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $reduce = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").left;
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('reduce') }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.reverse.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.reverse.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");

var nativeReverse = [].reverse;
var test = [1, 2];

// `Array.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reverse
// fix for Safari 12.0 bug
// https://bugs.webkit.org/show_bug.cgi?id=188794
$({ target: 'Array', proto: true, forced: String(test) === String(test.reverse()) }, {
  reverse: function reverse() {
    if (isArray(this)) this.length = this.length;
    return nativeReverse.call(this);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.slice.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.slice.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('slice') }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.some.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.some.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $some = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").some;
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: sloppyArrayMethod('some') }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.sort.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.sort.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var sloppyArrayMethod = __webpack_require__(/*! ../internals/sloppy-array-method */ "./node_modules/core-js/internals/sloppy-array-method.js");

var nativeSort = [].sort;
var test = [1, 2, 3];

// IE8-
var FAILS_ON_UNDEFINED = fails(function () {
  test.sort(undefined);
});
// V8 bug
var FAILS_ON_NULL = fails(function () {
  test.sort(null);
});
// Old WebKit
var SLOPPY_METHOD = sloppyArrayMethod('sort');

var FORCED = FAILS_ON_UNDEFINED || !FAILS_ON_NULL || SLOPPY_METHOD;

// `Array.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-array.prototype.sort
$({ target: 'Array', proto: true, forced: FORCED }, {
  sort: function sort(comparefn) {
    return comparefn === undefined
      ? nativeSort.call(toObject(this))
      : nativeSort.call(toObject(this), aFunction(comparefn));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.species.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.species.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");

// `Array[@@species]` getter
// https://tc39.github.io/ecma262/#sec-get-array-@@species
setSpecies('Array');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.splice.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.splice.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var arraySpeciesCreate = __webpack_require__(/*! ../internals/array-species-create */ "./node_modules/core-js/internals/array-species-create.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");
var arrayMethodHasSpeciesSupport = __webpack_require__(/*! ../internals/array-method-has-species-support */ "./node_modules/core-js/internals/array-method-has-species-support.js");

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !arrayMethodHasSpeciesSupport('splice') }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.unscopables.flat-map.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.unscopables.flat-map.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

addToUnscopables('flatMap');


/***/ }),

/***/ "./node_modules/core-js/modules/es.array.unscopables.flat.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.array.unscopables.flat.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__(/*! ../internals/add-to-unscopables */ "./node_modules/core-js/internals/add-to-unscopables.js");

addToUnscopables('flat');


/***/ }),

/***/ "./node_modules/core-js/modules/es.data-view.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.data-view.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ArrayBufferModule = __webpack_require__(/*! ../internals/array-buffer */ "./node_modules/core-js/internals/array-buffer.js");
var NATIVE_ARRAY_BUFFER = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js").NATIVE_ARRAY_BUFFER;

// `DataView` constructor
// https://tc39.github.io/ecma262/#sec-dataview-constructor
$({ global: true, forced: !NATIVE_ARRAY_BUFFER }, {
  DataView: ArrayBufferModule.DataView
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.now.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.now.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Date.now` method
// https://tc39.github.io/ecma262/#sec-date.now
$({ target: 'Date', stat: true }, {
  now: function now() {
    return new Date().getTime();
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-iso-string.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-iso-string.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toISOString = __webpack_require__(/*! ../internals/date-to-iso-string */ "./node_modules/core-js/internals/date-to-iso-string.js");

// `Date.prototype.toISOString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.toisostring
// PhantomJS / old WebKit has a broken implementations
$({ target: 'Date', proto: true, forced: Date.prototype.toISOString !== toISOString }, {
  toISOString: toISOString
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");

var FORCED = fails(function () {
  return new Date(NaN).toJSON() !== null
    || Date.prototype.toJSON.call({ toISOString: function () { return 1; } }) !== 1;
});

// `Date.prototype.toJSON` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tojson
$({ target: 'Date', proto: true, forced: FORCED }, {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-primitive.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-primitive.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var dateToPrimitive = __webpack_require__(/*! ../internals/date-to-primitive */ "./node_modules/core-js/internals/date-to-primitive.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var DatePrototype = Date.prototype;

// `Date.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-date.prototype-@@toprimitive
if (!(TO_PRIMITIVE in DatePrototype)) hide(DatePrototype, TO_PRIMITIVE, dateToPrimitive);


/***/ }),

/***/ "./node_modules/core-js/modules/es.date.to-string.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.date.to-string.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");

var DatePrototype = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var nativeDateToString = DatePrototype[TO_STRING];
var getTime = DatePrototype.getTime;

// `Date.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-date.prototype.tostring
if (new Date(NaN) + '' != INVALID_DATE) {
  redefine(DatePrototype, TO_STRING, function toString() {
    var value = getTime.call(this);
    // eslint-disable-next-line no-self-compare
    return value === value ? nativeDateToString.call(this) : INVALID_DATE;
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.bind.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.bind.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");

// `Function.prototype.bind` method
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
$({ target: 'Function', proto: true }, {
  bind: bind
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.has-instance.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.has-instance.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var HAS_INSTANCE = wellKnownSymbol('hasInstance');
var FunctionPrototype = Function.prototype;

// `Function.prototype[@@hasInstance]` method
// https://tc39.github.io/ecma262/#sec-function.prototype-@@hasinstance
if (!(HAS_INSTANCE in FunctionPrototype)) {
  definePropertyModule.f(FunctionPrototype, HAS_INSTANCE, { value: function (O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this;
    // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:
    while (O = getPrototypeOf(O)) if (this.prototype === O) return true;
    return false;
  } });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.function.name.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.function.name.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.json.to-string-tag.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.json.to-string-tag.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

// JSON[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-json-@@tostringtag
setToStringTag(global.JSON, 'JSON', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.map.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Map` constructor
// https://tc39.github.io/ecma262/#sec-map-objects
module.exports = collection('Map', function (get) {
  return function Map() { return get(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong, true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.acosh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.acosh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var log1p = __webpack_require__(/*! ../internals/math-log1p */ "./node_modules/core-js/internals/math-log1p.js");

var nativeAcosh = Math.acosh;
var log = Math.log;
var sqrt = Math.sqrt;
var LN2 = Math.LN2;

var FORCED = !nativeAcosh
  // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
  || Math.floor(nativeAcosh(Number.MAX_VALUE)) != 710
  // Tor Browser bug: Math.acosh(Infinity) -> NaN
  || nativeAcosh(Infinity) != Infinity;

// `Math.acosh` method
// https://tc39.github.io/ecma262/#sec-math.acosh
$({ target: 'Math', stat: true, forced: FORCED }, {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156
      ? log(x) + LN2
      : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.asinh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.asinh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var nativeAsinh = Math.asinh;
var log = Math.log;
var sqrt = Math.sqrt;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : log(x + sqrt(x * x + 1));
}

// `Math.asinh` method
// https://tc39.github.io/ecma262/#sec-math.asinh
// Tor Browser bug: Math.asinh(0) -> -0
$({ target: 'Math', stat: true, forced: !(nativeAsinh && 1 / nativeAsinh(0) > 0) }, {
  asinh: asinh
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.atanh.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.atanh.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var nativeAtanh = Math.atanh;
var log = Math.log;

// `Math.atanh` method
// https://tc39.github.io/ecma262/#sec-math.atanh
// Tor Browser bug: Math.atanh(-0) -> 0
$({ target: 'Math', stat: true, forced: !(nativeAtanh && 1 / nativeAtanh(-0) < 0) }, {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : log((1 + x) / (1 - x)) / 2;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.cbrt.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.cbrt.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var sign = __webpack_require__(/*! ../internals/math-sign */ "./node_modules/core-js/internals/math-sign.js");

var abs = Math.abs;
var pow = Math.pow;

// `Math.cbrt` method
// https://tc39.github.io/ecma262/#sec-math.cbrt
$({ target: 'Math', stat: true }, {
  cbrt: function cbrt(x) {
    return sign(x = +x) * pow(abs(x), 1 / 3);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.clz32.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.clz32.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var floor = Math.floor;
var log = Math.log;
var LOG2E = Math.LOG2E;

// `Math.clz32` method
// https://tc39.github.io/ecma262/#sec-math.clz32
$({ target: 'Math', stat: true }, {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - floor(log(x + 0.5) * LOG2E) : 32;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.cosh.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.cosh.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var expm1 = __webpack_require__(/*! ../internals/math-expm1 */ "./node_modules/core-js/internals/math-expm1.js");

var nativeCosh = Math.cosh;
var abs = Math.abs;
var E = Math.E;

// `Math.cosh` method
// https://tc39.github.io/ecma262/#sec-math.cosh
$({ target: 'Math', stat: true, forced: !nativeCosh || nativeCosh(710) === Infinity }, {
  cosh: function cosh(x) {
    var t = expm1(abs(x) - 1) + 1;
    return (t + 1 / (t * E * E)) * (E / 2);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.expm1.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.expm1.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var expm1 = __webpack_require__(/*! ../internals/math-expm1 */ "./node_modules/core-js/internals/math-expm1.js");

// `Math.expm1` method
// https://tc39.github.io/ecma262/#sec-math.expm1
$({ target: 'Math', stat: true, forced: expm1 != Math.expm1 }, { expm1: expm1 });


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.fround.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.fround.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fround = __webpack_require__(/*! ../internals/math-fround */ "./node_modules/core-js/internals/math-fround.js");

// `Math.fround` method
// https://tc39.github.io/ecma262/#sec-math.fround
$({ target: 'Math', stat: true }, { fround: fround });


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.hypot.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.hypot.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var abs = Math.abs;
var sqrt = Math.sqrt;

// `Math.hypot` method
// https://tc39.github.io/ecma262/#sec-math.hypot
$({ target: 'Math', stat: true }, {
  hypot: function hypot(value1, value2) { // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;
    while (i < aLen) {
      arg = abs(arguments[i++]);
      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }
    return larg === Infinity ? Infinity : larg * sqrt(sum);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.imul.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.imul.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeImul = Math.imul;

var FORCED = fails(function () {
  return nativeImul(0xFFFFFFFF, 5) != -5 || nativeImul.length != 2;
});

// `Math.imul` method
// https://tc39.github.io/ecma262/#sec-math.imul
// some WebKit versions fails with big numbers, some has wrong arity
$({ target: 'Math', stat: true, forced: FORCED }, {
  imul: function imul(x, y) {
    var UINT16 = 0xFFFF;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.log10.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.log10.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var log = Math.log;
var LOG10E = Math.LOG10E;

// `Math.log10` method
// https://tc39.github.io/ecma262/#sec-math.log10
$({ target: 'Math', stat: true }, {
  log10: function log10(x) {
    return log(x) * LOG10E;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.log1p.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.log1p.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var log1p = __webpack_require__(/*! ../internals/math-log1p */ "./node_modules/core-js/internals/math-log1p.js");

// `Math.log1p` method
// https://tc39.github.io/ecma262/#sec-math.log1p
$({ target: 'Math', stat: true }, { log1p: log1p });


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.log2.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.log2.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var log = Math.log;
var LN2 = Math.LN2;

// `Math.log2` method
// https://tc39.github.io/ecma262/#sec-math.log2
$({ target: 'Math', stat: true }, {
  log2: function log2(x) {
    return log(x) / LN2;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.sign.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.sign.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var sign = __webpack_require__(/*! ../internals/math-sign */ "./node_modules/core-js/internals/math-sign.js");

// `Math.sign` method
// https://tc39.github.io/ecma262/#sec-math.sign
$({ target: 'Math', stat: true }, {
  sign: sign
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.sinh.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.sinh.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var expm1 = __webpack_require__(/*! ../internals/math-expm1 */ "./node_modules/core-js/internals/math-expm1.js");

var abs = Math.abs;
var exp = Math.exp;
var E = Math.E;

var FORCED = fails(function () {
  return Math.sinh(-2e-17) != -2e-17;
});

// `Math.sinh` method
// https://tc39.github.io/ecma262/#sec-math.sinh
// V8 near Chromium 38 has a problem with very small numbers
$({ target: 'Math', stat: true, forced: FORCED }, {
  sinh: function sinh(x) {
    return abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (E / 2);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.tanh.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.tanh.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var expm1 = __webpack_require__(/*! ../internals/math-expm1 */ "./node_modules/core-js/internals/math-expm1.js");

var exp = Math.exp;

// `Math.tanh` method
// https://tc39.github.io/ecma262/#sec-math.tanh
$({ target: 'Math', stat: true }, {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.to-string-tag.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.to-string-tag.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");

// Math[@@toStringTag] property
// https://tc39.github.io/ecma262/#sec-math-@@tostringtag
setToStringTag(Math, 'Math', true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.math.trunc.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.math.trunc.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

var ceil = Math.ceil;
var floor = Math.floor;

// `Math.trunc` method
// https://tc39.github.io/ecma262/#sec-math.trunc
$({ target: 'Math', stat: true }, {
  trunc: function trunc(it) {
    return (it > 0 ? floor : ceil)(it);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.epsilon.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.epsilon.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Number.EPSILON` constant
// https://tc39.github.io/ecma262/#sec-number.epsilon
$({ target: 'Number', stat: true }, {
  EPSILON: Math.pow(2, -52)
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.is-finite.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.is-finite.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var numberIsFinite = __webpack_require__(/*! ../internals/number-is-finite */ "./node_modules/core-js/internals/number-is-finite.js");

// `Number.isFinite` method
// https://tc39.github.io/ecma262/#sec-number.isfinite
$({ target: 'Number', stat: true }, { isFinite: numberIsFinite });


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.is-integer.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.is-integer.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isInteger = __webpack_require__(/*! ../internals/is-integer */ "./node_modules/core-js/internals/is-integer.js");

// `Number.isInteger` method
// https://tc39.github.io/ecma262/#sec-number.isinteger
$({ target: 'Number', stat: true }, {
  isInteger: isInteger
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.is-nan.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.is-nan.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Number.isNaN` method
// https://tc39.github.io/ecma262/#sec-number.isnan
$({ target: 'Number', stat: true }, {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.is-safe-integer.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.is-safe-integer.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isInteger = __webpack_require__(/*! ../internals/is-integer */ "./node_modules/core-js/internals/is-integer.js");

var abs = Math.abs;

// `Number.isSafeInteger` method
// https://tc39.github.io/ecma262/#sec-number.issafeinteger
$({ target: 'Number', stat: true }, {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1FFFFFFFFFFFFF;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.max-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.max-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Number.MAX_SAFE_INTEGER` constant
// https://tc39.github.io/ecma262/#sec-number.max_safe_integer
$({ target: 'Number', stat: true }, {
  MAX_SAFE_INTEGER: 0x1FFFFFFFFFFFFF
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.min-safe-integer.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.min-safe-integer.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Number.MIN_SAFE_INTEGER` constant
// https://tc39.github.io/ecma262/#sec-number.min_safe_integer
$({ target: 'Number', stat: true }, {
  MIN_SAFE_INTEGER: -0x1FFFFFFFFFFFFF
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.parse-float.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.parse-float.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseFloat = __webpack_require__(/*! ../internals/parse-float */ "./node_modules/core-js/internals/parse-float.js");

// `Number.parseFloat` method
// https://tc39.github.io/ecma262/#sec-number.parseFloat
$({ target: 'Number', stat: true, forced: Number.parseFloat != parseFloat }, {
  parseFloat: parseFloat
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.parse-int.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.parse-int.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseInt = __webpack_require__(/*! ../internals/parse-int */ "./node_modules/core-js/internals/parse-int.js");

// `Number.parseInt` method
// https://tc39.github.io/ecma262/#sec-number.parseint
$({ target: 'Number', stat: true, forced: Number.parseInt != parseInt }, {
  parseInt: parseInt
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.to-fixed.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.to-fixed.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");
var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeToFixed = 1.0.toFixed;
var floor = Math.floor;

var pow = function (x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function (x) {
  var n = 0;
  var x2 = x;
  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }
  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  } return n;
};

var FORCED = nativeToFixed && (
  0.00008.toFixed(3) !== '0.000' ||
  0.9.toFixed(0) !== '1' ||
  1.255.toFixed(2) !== '1.25' ||
  1000000000000000128.0.toFixed(0) !== '1000000000000000128'
) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToFixed.call({});
});

// `Number.prototype.toFixed` method
// https://tc39.github.io/ecma262/#sec-number.prototype.tofixed
$({ target: 'Number', proto: true, forced: FORCED }, {
  // eslint-disable-next-line max-statements
  toFixed: function toFixed(fractionDigits) {
    var number = thisNumberValue(this);
    var fractDigits = toInteger(fractionDigits);
    var data = [0, 0, 0, 0, 0, 0];
    var sign = '';
    var result = '0';
    var e, z, j, k;

    var multiply = function (n, c) {
      var index = -1;
      var c2 = c;
      while (++index < 6) {
        c2 += n * data[index];
        data[index] = c2 % 1e7;
        c2 = floor(c2 / 1e7);
      }
    };

    var divide = function (n) {
      var index = 6;
      var c = 0;
      while (--index >= 0) {
        c += data[index];
        data[index] = floor(c / n);
        c = (c % n) * 1e7;
      }
    };

    var dataToString = function () {
      var index = 6;
      var s = '';
      while (--index >= 0) {
        if (s !== '' || index === 0 || data[index] !== 0) {
          var t = String(data[index]);
          s = s === '' ? t : s + repeat.call('0', 7 - t.length) + t;
        }
      } return s;
    };

    if (fractDigits < 0 || fractDigits > 20) throw RangeError('Incorrect fraction digits');
    // eslint-disable-next-line no-self-compare
    if (number != number) return 'NaN';
    if (number <= -1e21 || number >= 1e21) return String(number);
    if (number < 0) {
      sign = '-';
      number = -number;
    }
    if (number > 1e-21) {
      e = log(number * pow(2, 69, 1)) - 69;
      z = e < 0 ? number * pow(2, -e, 1) : number / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;
      if (e > 0) {
        multiply(0, z);
        j = fractDigits;
        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }
        multiply(pow(10, j, 1), 0);
        j = e - 1;
        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }
        divide(1 << j);
        multiply(1, 1);
        divide(2);
        result = dataToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        result = dataToString() + repeat.call('0', fractDigits);
      }
    }
    if (fractDigits > 0) {
      k = result.length;
      result = sign + (k <= fractDigits
        ? '0.' + repeat.call('0', fractDigits - k) + result
        : result.slice(0, k - fractDigits) + '.' + result.slice(k - fractDigits));
    } else {
      result = sign + result;
    } return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.number.to-precision.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.number.to-precision.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var thisNumberValue = __webpack_require__(/*! ../internals/this-number-value */ "./node_modules/core-js/internals/this-number-value.js");

var nativeToPrecision = 1.0.toPrecision;

var FORCED = fails(function () {
  // IE7-
  return nativeToPrecision.call(1, undefined) !== '1';
}) || !fails(function () {
  // V8 ~ Android 4.3-
  nativeToPrecision.call({});
});

// `Number.prototype.toPrecision` method
// https://tc39.github.io/ecma262/#sec-number.prototype.toprecision
$({ target: 'Number', proto: true, forced: FORCED }, {
  toPrecision: function toPrecision(precision) {
    return precision === undefined
      ? nativeToPrecision.call(thisNumberValue(this))
      : nativeToPrecision.call(thisNumberValue(this), precision);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.assign.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.assign.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.create.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.create.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  create: create
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-getter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-getter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/forced-object-prototype-accessors-methods */ "./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

// `Object.prototype.__defineGetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__defineGetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __defineGetter__: function __defineGetter__(P, getter) {
      definePropertyModule.f(toObject(this), P, { get: aFunction(getter), enumerable: true, configurable: true });
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-properties.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-properties.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperties: defineProperties
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-property.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-property.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var objectDefinePropertyModile = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
$({ target: 'Object', stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
  defineProperty: objectDefinePropertyModile.f
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.define-setter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.define-setter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/forced-object-prototype-accessors-methods */ "./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");

// `Object.prototype.__defineSetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__defineSetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __defineSetter__: function __defineSetter__(P, setter) {
      definePropertyModule.f(toObject(this), P, { set: aFunction(setter), enumerable: true, configurable: true });
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.entries.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.entries.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $entries = __webpack_require__(/*! ../internals/object-to-array */ "./node_modules/core-js/internals/object-to-array.js").entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.freeze.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.freeze.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var onFreeze = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").onFreeze;

var nativeFreeze = Object.freeze;
var FAILS_ON_PRIMITIVES = fails(function () { nativeFreeze(1); });

// `Object.freeze` method
// https://tc39.github.io/ecma262/#sec-object.freeze
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  freeze: function freeze(it) {
    return nativeFreeze && isObject(it) ? nativeFreeze(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.from-entries.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.from-entries.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({ target: 'Object', stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, undefined, true);
    return obj;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js ***!
  \*******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var nativeGetOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-descriptors.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-descriptors.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var createProperty = __webpack_require__(/*! ../internals/create-property */ "./node_modules/core-js/internals/create-property.js");

// `Object.getOwnPropertyDescriptors` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
$({ target: 'Object', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIndexedObject(object);
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    var keys = ownKeys(O);
    var result = {};
    var index = 0;
    var key, descriptor;
    while (keys.length > index) {
      descriptor = getOwnPropertyDescriptor(O, key = keys[index++]);
      if (descriptor !== undefined) createProperty(result, key, descriptor);
    }
    return result;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-own-property-names.js":
/*!**************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-own-property-names.js ***!
  \**************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var nativeGetOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js").f;

var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.get-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.get-prototype-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "./node_modules/core-js/modules/es.object.is-extensible.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.is-extensible.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var nativeIsExtensible = Object.isExtensible;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsExtensible(1); });

// `Object.isExtensible` method
// https://tc39.github.io/ecma262/#sec-object.isextensible
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isExtensible: function isExtensible(it) {
    return isObject(it) ? nativeIsExtensible ? nativeIsExtensible(it) : true : false;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.is-frozen.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.is-frozen.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var nativeIsFrozen = Object.isFrozen;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsFrozen(1); });

// `Object.isFrozen` method
// https://tc39.github.io/ecma262/#sec-object.isfrozen
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isFrozen: function isFrozen(it) {
    return isObject(it) ? nativeIsFrozen ? nativeIsFrozen(it) : false : true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.is-sealed.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.is-sealed.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");

var nativeIsSealed = Object.isSealed;
var FAILS_ON_PRIMITIVES = fails(function () { nativeIsSealed(1); });

// `Object.isSealed` method
// https://tc39.github.io/ecma262/#sec-object.issealed
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  isSealed: function isSealed(it) {
    return isObject(it) ? nativeIsSealed ? nativeIsSealed(it) : false : true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.is.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.is.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var is = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");

// `Object.is` method
// https://tc39.github.io/ecma262/#sec-object.is
$({ target: 'Object', stat: true }, {
  is: is
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.keys.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.keys.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var nativeKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.lookup-getter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.lookup-getter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/forced-object-prototype-accessors-methods */ "./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

// `Object.prototype.__lookupGetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupGetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __lookupGetter__: function __lookupGetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.get;
      } while (O = getPrototypeOf(O));
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.lookup-setter.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.lookup-setter.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var FORCED = __webpack_require__(/*! ../internals/forced-object-prototype-accessors-methods */ "./node_modules/core-js/internals/forced-object-prototype-accessors-methods.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

// `Object.prototype.__lookupSetter__` method
// https://tc39.github.io/ecma262/#sec-object.prototype.__lookupSetter__
if (DESCRIPTORS) {
  $({ target: 'Object', proto: true, forced: FORCED }, {
    __lookupSetter__: function __lookupSetter__(P) {
      var O = toObject(this);
      var key = toPrimitive(P, true);
      var desc;
      do {
        if (desc = getOwnPropertyDescriptor(O, key)) return desc.set;
      } while (O = getPrototypeOf(O));
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.prevent-extensions.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.prevent-extensions.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var onFreeze = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").onFreeze;
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativePreventExtensions = Object.preventExtensions;
var FAILS_ON_PRIMITIVES = fails(function () { nativePreventExtensions(1); });

// `Object.preventExtensions` method
// https://tc39.github.io/ecma262/#sec-object.preventextensions
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  preventExtensions: function preventExtensions(it) {
    return nativePreventExtensions && isObject(it) ? nativePreventExtensions(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.seal.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.seal.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var onFreeze = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js").onFreeze;
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeSeal = Object.seal;
var FAILS_ON_PRIMITIVES = fails(function () { nativeSeal(1); });

// `Object.seal` method
// https://tc39.github.io/ecma262/#sec-object.seal
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !FREEZING }, {
  seal: function seal(it) {
    return nativeSeal && isObject(it) ? nativeSeal(onFreeze(it)) : it;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.set-prototype-of.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.set-prototype-of.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var setPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
$({ target: 'Object', stat: true }, {
  setPrototypeOf: setPrototypeOf
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var toString = __webpack_require__(/*! ../internals/object-to-string */ "./node_modules/core-js/internals/object-to-string.js");

var ObjectPrototype = Object.prototype;

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (toString !== ObjectPrototype.toString) {
  redefine(ObjectPrototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.object.values.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.object.values.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $values = __webpack_require__(/*! ../internals/object-to-array */ "./node_modules/core-js/internals/object-to-array.js").values;

// `Object.values` method
// https://tc39.github.io/ecma262/#sec-object.values
$({ target: 'Object', stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-float.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-float.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseFloatImplementation = __webpack_require__(/*! ../internals/parse-float */ "./node_modules/core-js/internals/parse-float.js");

// `parseFloat` method
// https://tc39.github.io/ecma262/#sec-parsefloat-string
$({ global: true, forced: parseFloat != parseFloatImplementation }, {
  parseFloat: parseFloatImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.parse-int.js":
/*!******************************************************!*\
  !*** ./node_modules/core-js/modules/es.parse-int.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var parseIntImplementation = __webpack_require__(/*! ../internals/parse-int */ "./node_modules/core-js/internals/parse-int.js");

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
$({ global: true, forced: parseInt != parseIntImplementation }, {
  parseInt: parseIntImplementation
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.finally.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.finally.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ "./node_modules/core-js/internals/promise-resolve.js");

// `Promise.prototype.finally` method
// https://tc39.github.io/ecma262/#sec-promise.prototype.finally
$({ target: 'Promise', proto: true, real: true }, {
  'finally': function (onFinally) {
    var C = speciesConstructor(this, getBuiltIn('Promise'));
    var isFunction = typeof onFinally == 'function';
    return this.then(
      isFunction ? function (x) {
        return promiseResolve(C, onFinally()).then(function () { return x; });
      } : onFinally,
      isFunction ? function (e) {
        return promiseResolve(C, onFinally()).then(function () { throw e; });
      } : onFinally
    );
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.promise.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/es.promise.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var path = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");
var iterate = __webpack_require__(/*! ../internals/iterate */ "./node_modules/core-js/internals/iterate.js");
var checkCorrectnessOfIteration = __webpack_require__(/*! ../internals/check-correctness-of-iteration */ "./node_modules/core-js/internals/check-correctness-of-iteration.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js").set;
var microtask = __webpack_require__(/*! ../internals/microtask */ "./node_modules/core-js/internals/microtask.js");
var promiseResolve = __webpack_require__(/*! ../internals/promise-resolve */ "./node_modules/core-js/internals/promise-resolve.js");
var hostReportErrors = __webpack_require__(/*! ../internals/host-report-errors */ "./node_modules/core-js/internals/host-report-errors.js");
var newPromiseCapabilityModule = __webpack_require__(/*! ../internals/new-promise-capability */ "./node_modules/core-js/internals/new-promise-capability.js");
var perform = __webpack_require__(/*! ../internals/perform */ "./node_modules/core-js/internals/perform.js");
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = global[PROMISE];
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = global.fetch;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper;

var FORCED = isForced(PROMISE, function () {
  // correct subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var empty = function () { /* empty */ };
  var FakePromise = (promise.constructor = {})[SPECIES] = function (exec) {
    exec(empty, empty);
  };
  // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
  return !((IS_NODE || typeof PromiseRejectionEvent == 'function')
    && (!IS_PURE || promise['finally'])
    && promise.then(empty) instanceof FakePromise
    // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0
    && userAgent.indexOf('Chrome/66') === -1);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  // wrap fetch result
  if (!IS_PURE && typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
    // eslint-disable-next-line no-unused-vars
    fetch: function fetch(input) {
      return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
    }
  });
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = path[PROMISE];

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.apply.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.apply.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeApply = getBuiltIn('Reflect', 'apply');
var functionApply = Function.apply;

// MS Edge argumentsList argument is optional
var OPTIONAL_ARGUMENTS_LIST = !fails(function () {
  nativeApply(function () { /* empty */ });
});

// `Reflect.apply` method
// https://tc39.github.io/ecma262/#sec-reflect.apply
$({ target: 'Reflect', stat: true, forced: OPTIONAL_ARGUMENTS_LIST }, {
  apply: function apply(target, thisArgument, argumentsList) {
    aFunction(target);
    anObject(argumentsList);
    return nativeApply
      ? nativeApply(target, thisArgument, argumentsList)
      : functionApply.call(target, thisArgument, argumentsList);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.construct.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var create = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var bind = __webpack_require__(/*! ../internals/function-bind */ "./node_modules/core-js/internals/function-bind.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.define-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.define-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

// MS Edge has broken Reflect.defineProperty - throwing instead of returning false
var ERROR_INSTEAD_OF_FALSE = fails(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(definePropertyModule.f({}, 1, { value: 1 }), 1, { value: 2 });
});

// `Reflect.defineProperty` method
// https://tc39.github.io/ecma262/#sec-reflect.defineproperty
$({ target: 'Reflect', stat: true, forced: ERROR_INSTEAD_OF_FALSE, sham: !DESCRIPTORS }, {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    var key = toPrimitive(propertyKey, true);
    anObject(attributes);
    try {
      definePropertyModule.f(target, key, attributes);
      return true;
    } catch (error) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.delete-property.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.delete-property.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getOwnPropertyDescriptor = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js").f;

// `Reflect.deleteProperty` method
// https://tc39.github.io/ecma262/#sec-reflect.deleteproperty
$({ target: 'Reflect', stat: true }, {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var descriptor = getOwnPropertyDescriptor(anObject(target), propertyKey);
    return descriptor && !descriptor.configurable ? false : delete target[propertyKey];
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js":
/*!********************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.get-own-property-descriptor.js ***!
  \********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");

// `Reflect.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-reflect.getownpropertydescriptor
$({ target: 'Reflect', stat: true, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.get-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.get-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var objectGetPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__(/*! ../internals/correct-prototype-getter */ "./node_modules/core-js/internals/correct-prototype-getter.js");

// `Reflect.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-reflect.getprototypeof
$({ target: 'Reflect', stat: true, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(target) {
    return objectGetPrototypeOf(anObject(target));
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.get.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.get.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");

// `Reflect.get` method
// https://tc39.github.io/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.has.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.has.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `Reflect.has` method
// https://tc39.github.io/ecma262/#sec-reflect.has
$({ target: 'Reflect', stat: true }, {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.is-extensible.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.is-extensible.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");

var objectIsExtensible = Object.isExtensible;

// `Reflect.isExtensible` method
// https://tc39.github.io/ecma262/#sec-reflect.isextensible
$({ target: 'Reflect', stat: true }, {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return objectIsExtensible ? objectIsExtensible(target) : true;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.own-keys.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.own-keys.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var ownKeys = __webpack_require__(/*! ../internals/own-keys */ "./node_modules/core-js/internals/own-keys.js");

// `Reflect.ownKeys` method
// https://tc39.github.io/ecma262/#sec-reflect.ownkeys
$({ target: 'Reflect', stat: true }, {
  ownKeys: ownKeys
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.prevent-extensions.js":
/*!***********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.prevent-extensions.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var getBuiltIn = __webpack_require__(/*! ../internals/get-built-in */ "./node_modules/core-js/internals/get-built-in.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var FREEZING = __webpack_require__(/*! ../internals/freezing */ "./node_modules/core-js/internals/freezing.js");

// `Reflect.preventExtensions` method
// https://tc39.github.io/ecma262/#sec-reflect.preventextensions
$({ target: 'Reflect', stat: true, sham: !FREEZING }, {
  preventExtensions: function preventExtensions(target) {
    anObject(target);
    try {
      var objectPreventExtensions = getBuiltIn('Object', 'preventExtensions');
      if (objectPreventExtensions) objectPreventExtensions(target);
      return true;
    } catch (error) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.set-prototype-of.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.set-prototype-of.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var aPossiblePrototype = __webpack_require__(/*! ../internals/a-possible-prototype */ "./node_modules/core-js/internals/a-possible-prototype.js");
var objectSetPrototypeOf = __webpack_require__(/*! ../internals/object-set-prototype-of */ "./node_modules/core-js/internals/object-set-prototype-of.js");

// `Reflect.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-reflect.setprototypeof
if (objectSetPrototypeOf) $({ target: 'Reflect', stat: true }, {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    anObject(target);
    aPossiblePrototype(proto);
    try {
      objectSetPrototypeOf(target, proto);
      return true;
    } catch (error) {
      return false;
    }
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.reflect.set.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.reflect.set.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var getPrototypeOf = __webpack_require__(/*! ../internals/object-get-prototype-of */ "./node_modules/core-js/internals/object-get-prototype-of.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");

// `Reflect.set` method
// https://tc39.github.io/ecma262/#sec-reflect.set
function set(target, propertyKey, V /* , receiver */) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDescriptor = getOwnPropertyDescriptorModule.f(anObject(target), propertyKey);
  var existingDescriptor, prototype;
  if (!ownDescriptor) {
    if (isObject(prototype = getPrototypeOf(target))) {
      return set(prototype, propertyKey, V, receiver);
    }
    ownDescriptor = createPropertyDescriptor(0);
  }
  if (has(ownDescriptor, 'value')) {
    if (ownDescriptor.writable === false || !isObject(receiver)) return false;
    if (existingDescriptor = getOwnPropertyDescriptorModule.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      definePropertyModule.f(receiver, propertyKey, existingDescriptor);
    } else definePropertyModule.f(receiver, propertyKey, createPropertyDescriptor(0, V));
    return true;
  }
  return ownDescriptor.set === undefined ? false : (ownDescriptor.set.call(receiver, V), true);
}

$({ target: 'Reflect', stat: true }, {
  set: set
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.constructor.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var isForced = __webpack_require__(/*! ../internals/is-forced */ "./node_modules/core-js/internals/is-forced.js");
var inheritIfRequired = __webpack_require__(/*! ../internals/inherit-if-required */ "./node_modules/core-js/internals/inherit-if-required.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var getOwnPropertyNames = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js").f;
var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var getFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var setSpecies = __webpack_require__(/*! ../internals/set-species */ "./node_modules/core-js/internals/set-species.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    return !thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined ? pattern
      : inheritIfRequired(CORRECT_NEW
        ? new NativeRegExp(patternIsRegExp && !flagsAreUndefined ? pattern.source : pattern, flags)
        : NativeRegExp((patternIsRegExp = pattern instanceof RegExpWrapper)
          ? pattern.source
          : pattern, patternIsRegExp && flagsAreUndefined ? getFlags.call(pattern) : flags)
      , thisIsRegExp ? this : RegExpPrototype, RegExpWrapper);
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.exec.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.exec.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var exec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");

$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.flags.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.flags.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var objectDefinePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var regExpFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

// `RegExp.prototype.flags` getter
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
if (DESCRIPTORS && /./g.flags != 'g') {
  objectDefinePropertyModule.f(RegExp.prototype, 'flags', {
    configurable: true,
    get: regExpFlags
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.regexp.to-string.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.regexp.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var flags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.set.js":
/*!************************************************!*\
  !*** ./node_modules/core-js/modules/es.set.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionStrong = __webpack_require__(/*! ../internals/collection-strong */ "./node_modules/core-js/internals/collection-strong.js");

// `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects
module.exports = collection('Set', function (get) {
  return function Set() { return get(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.anchor.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.anchor.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.anchor` method
// https://tc39.github.io/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.big.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.big.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.big` method
// https://tc39.github.io/ecma262/#sec-string.prototype.big
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('big') }, {
  big: function big() {
    return createHTML(this, 'big', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.blink.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.blink.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.blink` method
// https://tc39.github.io/ecma262/#sec-string.prototype.blink
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('blink') }, {
  blink: function blink() {
    return createHTML(this, 'blink', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.bold.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.bold.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.bold` method
// https://tc39.github.io/ecma262/#sec-string.prototype.bold
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('bold') }, {
  bold: function bold() {
    return createHTML(this, 'b', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.code-point-at.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.code-point-at.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var codeAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").codeAt;

// `String.prototype.codePointAt` method
// https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
$({ target: 'String', proto: true }, {
  codePointAt: function codePointAt(pos) {
    return codeAt(this, pos);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.ends-with.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.ends-with.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

var nativeEndsWith = ''.endsWith;
var min = Math.min;

// `String.prototype.endsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('endsWith') }, {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith
      ? nativeEndsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.fixed.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.fixed.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.fixed` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fixed
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fixed') }, {
  fixed: function fixed() {
    return createHTML(this, 'tt', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.fontcolor.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.fontcolor.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.fontcolor` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fontcolor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fontcolor') }, {
  fontcolor: function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.fontsize.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.fontsize.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.fontsize` method
// https://tc39.github.io/ecma262/#sec-string.prototype.fontsize
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('fontsize') }, {
  fontsize: function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.from-code-point.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.from-code-point.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var nativeFromCodePoint = String.fromCodePoint;

// length should be 1, old FF problem
var INCORRECT_LENGTH = !!nativeFromCodePoint && nativeFromCodePoint.length != 1;

// `String.fromCodePoint` method
// https://tc39.github.io/ecma262/#sec-string.fromcodepoint
$({ target: 'String', stat: true, forced: INCORRECT_LENGTH }, {
  fromCodePoint: function fromCodePoint(x) { // eslint-disable-line no-unused-vars
    var elements = [];
    var length = arguments.length;
    var i = 0;
    var code;
    while (length > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10FFFF) !== code) throw RangeError(code + ' is not a valid code point');
      elements.push(code < 0x10000
        ? fromCharCode(code)
        : fromCharCode(((code -= 0x10000) >> 10) + 0xD800, code % 0x400 + 0xDC00)
      );
    } return elements.join('');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.includes.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.includes.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.italics.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.italics.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.italics` method
// https://tc39.github.io/ecma262/#sec-string.prototype.italics
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('italics') }, {
  italics: function italics() {
    return createHTML(this, 'i', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").charAt;
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var defineIterator = __webpack_require__(/*! ../internals/define-iterator */ "./node_modules/core-js/internals/define-iterator.js");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.link.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.link.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.link` method
// https://tc39.github.io/ecma262/#sec-string.prototype.link
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('link') }, {
  link: function link(url) {
    return createHTML(this, 'a', 'href', url);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.match-all.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.match-all.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var aFunction = __webpack_require__(/*! ../internals/a-function */ "./node_modules/core-js/internals/a-function.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var classof = __webpack_require__(/*! ../internals/classof */ "./node_modules/core-js/internals/classof.js");
var getFlags = __webpack_require__(/*! ../internals/regexp-flags */ "./node_modules/core-js/internals/regexp-flags.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");

var MATCH_ALL = wellKnownSymbol('matchAll');
var REGEXP_STRING = 'RegExp String';
var REGEXP_STRING_ITERATOR = REGEXP_STRING + ' Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(REGEXP_STRING_ITERATOR);
var RegExpPrototype = RegExp.prototype;
var regExpBuiltinExec = RegExpPrototype.exec;

var regExpExec = function (R, S) {
  var exec = R.exec;
  var result;
  if (typeof exec == 'function') {
    result = exec.call(R, S);
    if (typeof result != 'object') throw TypeError('Incorrect exec result');
    return result;
  } return regExpBuiltinExec.call(R, S);
};

// eslint-disable-next-line max-len
var $RegExpStringIterator = createIteratorConstructor(function RegExpStringIterator(regexp, string, global, fullUnicode) {
  setInternalState(this, {
    type: REGEXP_STRING_ITERATOR,
    regexp: regexp,
    string: string,
    global: global,
    unicode: fullUnicode,
    done: false
  });
}, REGEXP_STRING, function next() {
  var state = getInternalState(this);
  if (state.done) return { value: undefined, done: true };
  var R = state.regexp;
  var S = state.string;
  var match = regExpExec(R, S);
  if (match === null) return { value: undefined, done: state.done = true };
  if (state.global) {
    if (String(match[0]) == '') R.lastIndex = advanceStringIndex(S, toLength(R.lastIndex), state.unicode);
    return { value: match, done: false };
  }
  state.done = true;
  return { value: match, done: false };
});

var $matchAll = function (string) {
  var R = anObject(this);
  var S = String(string);
  var C, flagsValue, flags, matcher, global, fullUnicode;
  C = speciesConstructor(R, RegExp);
  flagsValue = R.flags;
  if (flagsValue === undefined && R instanceof RegExp && !('flags' in RegExpPrototype)) {
    flagsValue = getFlags.call(R);
  }
  flags = flagsValue === undefined ? '' : String(flagsValue);
  matcher = new C(C === RegExp ? R.source : R, flags);
  global = !!~flags.indexOf('g');
  fullUnicode = !!~flags.indexOf('u');
  matcher.lastIndex = toLength(R.lastIndex);
  return new $RegExpStringIterator(matcher, S, global, fullUnicode);
};

// `String.prototype.matchAll` method
// https://github.com/tc39/proposal-string-matchall
$({ target: 'String', proto: true }, {
  matchAll: function matchAll(regexp) {
    var O = requireObjectCoercible(this);
    var S, matcher, rx;
    if (regexp != null) {
      matcher = regexp[MATCH_ALL];
      if (matcher === undefined && IS_PURE && classof(regexp) == 'RegExp') matcher = $matchAll;
      if (matcher != null) return aFunction(matcher).call(regexp, O);
    }
    S = String(O);
    rx = new RegExp(regexp, 'g');
    return IS_PURE ? $matchAll.call(rx, S) : rx[MATCH_ALL](S);
  }
});

IS_PURE || MATCH_ALL in RegExpPrototype || hide(RegExpPrototype, MATCH_ALL, $matchAll);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.match.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.match.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.pad-end.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.pad-end.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $padEnd = __webpack_require__(/*! ../internals/string-pad */ "./node_modules/core-js/internals/string-pad.js").end;
var WEBKIT_BUG = __webpack_require__(/*! ../internals/webkit-string-pad-bug */ "./node_modules/core-js/internals/webkit-string-pad-bug.js");

// `String.prototype.padEnd` method
// https://tc39.github.io/ecma262/#sec-string.prototype.padend
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padEnd: function padEnd(maxLength /* , fillString = ' ' */) {
    return $padEnd(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.pad-start.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.pad-start.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $padStart = __webpack_require__(/*! ../internals/string-pad */ "./node_modules/core-js/internals/string-pad.js").start;
var WEBKIT_BUG = __webpack_require__(/*! ../internals/webkit-string-pad-bug */ "./node_modules/core-js/internals/webkit-string-pad-bug.js");

// `String.prototype.padStart` method
// https://tc39.github.io/ecma262/#sec-string.prototype.padstart
$({ target: 'String', proto: true, forced: WEBKIT_BUG }, {
  padStart: function padStart(maxLength /* , fillString = ' ' */) {
    return $padStart(this, maxLength, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.raw.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.raw.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");

// `String.raw` method
// https://tc39.github.io/ecma262/#sec-string.raw
$({ target: 'String', stat: true }, {
  raw: function raw(template) {
    var rawTemplate = toIndexedObject(template.raw);
    var literalSegments = toLength(rawTemplate.length);
    var argumentsLength = arguments.length;
    var elements = [];
    var i = 0;
    while (literalSegments > i) {
      elements.push(String(rawTemplate[i++]));
      if (i < argumentsLength) elements.push(String(arguments[i]));
    } return elements.join('');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.repeat.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.repeat.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var repeat = __webpack_require__(/*! ../internals/string-repeat */ "./node_modules/core-js/internals/string-repeat.js");

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
$({ target: 'String', proto: true }, {
  repeat: repeat
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.replace.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toInteger = __webpack_require__(/*! ../internals/to-integer */ "./node_modules/core-js/internals/to-integer.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative) {
  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.search.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var sameValue = __webpack_require__(/*! ../internals/same-value */ "./node_modules/core-js/internals/same-value.js");
var regExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.small.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.small.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.small` method
// https://tc39.github.io/ecma262/#sec-string.prototype.small
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('small') }, {
  small: function small() {
    return createHTML(this, 'small', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.split.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.split.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__(/*! ../internals/fix-regexp-well-known-symbol-logic */ "./node_modules/core-js/internals/fix-regexp-well-known-symbol-logic.js");
var isRegExp = __webpack_require__(/*! ../internals/is-regexp */ "./node_modules/core-js/internals/is-regexp.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var advanceStringIndex = __webpack_require__(/*! ../internals/advance-string-index */ "./node_modules/core-js/internals/advance-string-index.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var callRegExpExec = __webpack_require__(/*! ../internals/regexp-exec-abstract */ "./node_modules/core-js/internals/regexp-exec-abstract.js");
var regexpExec = __webpack_require__(/*! ../internals/regexp-exec */ "./node_modules/core-js/internals/regexp-exec.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.starts-with.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.starts-with.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var notARegExp = __webpack_require__(/*! ../internals/not-a-regexp */ "./node_modules/core-js/internals/not-a-regexp.js");
var requireObjectCoercible = __webpack_require__(/*! ../internals/require-object-coercible */ "./node_modules/core-js/internals/require-object-coercible.js");
var correctIsRegExpLogic = __webpack_require__(/*! ../internals/correct-is-regexp-logic */ "./node_modules/core-js/internals/correct-is-regexp-logic.js");

var nativeStartsWith = ''.startsWith;
var min = Math.min;

// `String.prototype.startsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('startsWith') }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith
      ? nativeStartsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.strike.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.strike.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.strike` method
// https://tc39.github.io/ecma262/#sec-string.prototype.strike
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('strike') }, {
  strike: function strike() {
    return createHTML(this, 'strike', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.sub.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.sub.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.sub` method
// https://tc39.github.io/ecma262/#sec-string.prototype.sub
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('sub') }, {
  sub: function sub() {
    return createHTML(this, 'sub', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.sup.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.sup.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var createHTML = __webpack_require__(/*! ../internals/create-html */ "./node_modules/core-js/internals/create-html.js");
var forcedStringHTMLMethod = __webpack_require__(/*! ../internals/forced-string-html-method */ "./node_modules/core-js/internals/forced-string-html-method.js");

// `String.prototype.sup` method
// https://tc39.github.io/ecma262/#sec-string.prototype.sup
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('sup') }, {
  sup: function sup() {
    return createHTML(this, 'sup', '', '');
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.trim-end.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.trim-end.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $trimEnd = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").end;
var forcedStringTrimMethod = __webpack_require__(/*! ../internals/forced-string-trim-method */ "./node_modules/core-js/internals/forced-string-trim-method.js");

var FORCED = forcedStringTrimMethod('trimEnd');

var trimEnd = FORCED ? function trimEnd() {
  return $trimEnd(this);
} : ''.trimEnd;

// `String.prototype.{ trimEnd, trimRight }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
$({ target: 'String', proto: true, forced: FORCED }, {
  trimEnd: trimEnd,
  trimRight: trimEnd
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.trim-start.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.trim-start.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $trimStart = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").start;
var forcedStringTrimMethod = __webpack_require__(/*! ../internals/forced-string-trim-method */ "./node_modules/core-js/internals/forced-string-trim-method.js");

var FORCED = forcedStringTrimMethod('trimStart');

var trimStart = FORCED ? function trimStart() {
  return $trimStart(this);
} : ''.trimStart;

// `String.prototype.{ trimStart, trimLeft }` methods
// https://github.com/tc39/ecmascript-string-left-right-trim
$({ target: 'String', proto: true, forced: FORCED }, {
  trimStart: trimStart,
  trimLeft: trimStart
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.string.trim.js":
/*!********************************************************!*\
  !*** ./node_modules/core-js/modules/es.string.trim.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var $trim = __webpack_require__(/*! ../internals/string-trim */ "./node_modules/core-js/internals/string-trim.js").trim;
var forcedStringTrimMethod = __webpack_require__(/*! ../internals/forced-string-trim-method */ "./node_modules/core-js/internals/forced-string-trim-method.js");

// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.async-iterator.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.async-iterator.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.asyncIterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.asynciterator
defineWellKnownSymbol('asyncIterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.description.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.description.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var defineProperty = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js").f;
var copyConstructorProperties = __webpack_require__(/*! ../internals/copy-constructor-properties */ "./node_modules/core-js/internals/copy-constructor-properties.js");

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.has-instance.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.has-instance.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.hasInstance` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.hasinstance
defineWellKnownSymbol('hasInstance');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js":
/*!************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.is-concat-spreadable.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.isConcatSpreadable` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.isconcatspreadable
defineWellKnownSymbol('isConcatSpreadable');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.iterator.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.iterator.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.js":
/*!***************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var IS_PURE = __webpack_require__(/*! ../internals/is-pure */ "./node_modules/core-js/internals/is-pure.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var NATIVE_SYMBOL = __webpack_require__(/*! ../internals/native-symbol */ "./node_modules/core-js/internals/native-symbol.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var isArray = __webpack_require__(/*! ../internals/is-array */ "./node_modules/core-js/internals/is-array.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var toIndexedObject = __webpack_require__(/*! ../internals/to-indexed-object */ "./node_modules/core-js/internals/to-indexed-object.js");
var toPrimitive = __webpack_require__(/*! ../internals/to-primitive */ "./node_modules/core-js/internals/to-primitive.js");
var createPropertyDescriptor = __webpack_require__(/*! ../internals/create-property-descriptor */ "./node_modules/core-js/internals/create-property-descriptor.js");
var nativeObjectCreate = __webpack_require__(/*! ../internals/object-create */ "./node_modules/core-js/internals/object-create.js");
var objectKeys = __webpack_require__(/*! ../internals/object-keys */ "./node_modules/core-js/internals/object-keys.js");
var getOwnPropertyNamesModule = __webpack_require__(/*! ../internals/object-get-own-property-names */ "./node_modules/core-js/internals/object-get-own-property-names.js");
var getOwnPropertyNamesExternal = __webpack_require__(/*! ../internals/object-get-own-property-names-external */ "./node_modules/core-js/internals/object-get-own-property-names-external.js");
var getOwnPropertySymbolsModule = __webpack_require__(/*! ../internals/object-get-own-property-symbols */ "./node_modules/core-js/internals/object-get-own-property-symbols.js");
var getOwnPropertyDescriptorModule = __webpack_require__(/*! ../internals/object-get-own-property-descriptor */ "./node_modules/core-js/internals/object-get-own-property-descriptor.js");
var definePropertyModule = __webpack_require__(/*! ../internals/object-define-property */ "./node_modules/core-js/internals/object-define-property.js");
var propertyIsEnumerableModule = __webpack_require__(/*! ../internals/object-property-is-enumerable */ "./node_modules/core-js/internals/object-property-is-enumerable.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var shared = __webpack_require__(/*! ../internals/shared */ "./node_modules/core-js/internals/shared.js");
var sharedKey = __webpack_require__(/*! ../internals/shared-key */ "./node_modules/core-js/internals/shared-key.js");
var hiddenKeys = __webpack_require__(/*! ../internals/hidden-keys */ "./node_modules/core-js/internals/hidden-keys.js");
var uid = __webpack_require__(/*! ../internals/uid */ "./node_modules/core-js/internals/uid.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");
var wrappedWellKnownSymbolModule = __webpack_require__(/*! ../internals/wrapped-well-known-symbol */ "./node_modules/core-js/internals/wrapped-well-known-symbol.js");
var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var JSON = global.JSON;
var nativeJSONStringify = JSON && JSON.stringify;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = NATIVE_SYMBOL && typeof $Symbol.iterator == 'symbol' ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
JSON && $({ target: 'JSON', stat: true, forced: !NATIVE_SYMBOL || fails(function () {
  var symbol = $Symbol();
  // MS Edge converts symbol values to JSON as {}
  return nativeJSONStringify([symbol]) != '[null]'
    // WebKit converts symbol values to JSON as null
    || nativeJSONStringify({ a: symbol }) != '{}'
    // V8 throws on boxed symbols
    || nativeJSONStringify(Object(symbol)) != '{}';
}) }, {
  stringify: function stringify(it) {
    var args = [it];
    var index = 1;
    var replacer, $replacer;
    while (arguments.length > index) args.push(arguments[index++]);
    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
    if (!isArray(replacer)) replacer = function (key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return nativeJSONStringify.apply(JSON, args);
  }
});

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) hide($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.match-all.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.match-all.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.matchAll` well-known symbol
defineWellKnownSymbol('matchAll');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.match.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.match.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.match` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.match
defineWellKnownSymbol('match');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.replace.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.replace.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.replace` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.replace
defineWellKnownSymbol('replace');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.search.js":
/*!**********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.search.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.search` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.search
defineWellKnownSymbol('search');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.species.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.species.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.species` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.species
defineWellKnownSymbol('species');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.split.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.split.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.split` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.split
defineWellKnownSymbol('split');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.to-primitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.to-primitive.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.toPrimitive` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.toprimitive
defineWellKnownSymbol('toPrimitive');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.to-string-tag.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.to-string-tag.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.toStringTag` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.tostringtag
defineWellKnownSymbol('toStringTag');


/***/ }),

/***/ "./node_modules/core-js/modules/es.symbol.unscopables.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.symbol.unscopables.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__(/*! ../internals/define-well-known-symbol */ "./node_modules/core-js/internals/define-well-known-symbol.js");

// `Symbol.unscopables` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.unscopables
defineWellKnownSymbol('unscopables');


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.copy-within.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.copy-within.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $copyWithin = __webpack_require__(/*! ../internals/array-copy-within */ "./node_modules/core-js/internals/array-copy-within.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
ArrayBufferViewCore.exportProto('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.every.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.every.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $every = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
ArrayBufferViewCore.exportProto('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.fill.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.fill.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $fill = __webpack_require__(/*! ../internals/array-fill */ "./node_modules/core-js/internals/array-fill.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.filter.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.filter.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $filter = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").filter;
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
ArrayBufferViewCore.exportProto('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.find-index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.find-index.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $findIndex = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
ArrayBufferViewCore.exportProto('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.find.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.find.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $find = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
ArrayBufferViewCore.exportProto('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.float32-array.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.float32-array.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Float32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.float64-array.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.float64-array.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Float64Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.for-each.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.for-each.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $forEach = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
ArrayBufferViewCore.exportProto('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.from.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.from.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(/*! ../internals/typed-arrays-constructors-requires-wrappers */ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var typedArrayFrom = __webpack_require__(/*! ../internals/typed-array-from */ "./node_modules/core-js/internals/typed-array-from.js");

// `%TypedArray%.from` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.from
ArrayBufferViewCore.exportStatic('from', typedArrayFrom, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.includes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.includes.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $includes = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
ArrayBufferViewCore.exportProto('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.index-of.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.index-of.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $indexOf = __webpack_require__(/*! ../internals/array-includes */ "./node_modules/core-js/internals/array-includes.js").indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
ArrayBufferViewCore.exportProto('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.int16-array.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.int16-array.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Int16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.int32-array.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.int32-array.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Int32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.int8-array.js":
/*!*******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.int8-array.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Int8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.iterator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.iterator.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var ArrayIterators = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportProto = ArrayBufferViewCore.exportProto;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportProto('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportProto('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportProto('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportProto(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.join.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.join.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.last-index-of.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.last-index-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $lastIndexOf = __webpack_require__(/*! ../internals/array-last-index-of */ "./node_modules/core-js/internals/array-last-index-of.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
ArrayBufferViewCore.exportProto('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.map.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.map.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $map = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").map;
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
ArrayBufferViewCore.exportProto('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.of.js":
/*!***********************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.of.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__(/*! ../internals/typed-arrays-constructors-requires-wrappers */ "./node_modules/core-js/internals/typed-arrays-constructors-requires-wrappers.js");

var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;

// `%TypedArray%.of` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.of
ArrayBufferViewCore.exportStatic('of', function of(/* ...items */) {
  var index = 0;
  var length = arguments.length;
  var result = new (aTypedArrayConstructor(this))(length);
  while (length > index) result[index] = arguments[index++];
  return result;
}, TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reduce-right.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reduce-right.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $reduceRight = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
ArrayBufferViewCore.exportProto('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reduce.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reduce.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $reduce = __webpack_require__(/*! ../internals/array-reduce */ "./node_modules/core-js/internals/array-reduce.js").left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
ArrayBufferViewCore.exportProto('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.reverse.js":
/*!****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.reverse.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
ArrayBufferViewCore.exportProto('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.set.js":
/*!************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.set.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toOffset = __webpack_require__(/*! ../internals/to-offset */ "./node_modules/core-js/internals/to-offset.js");
var toObject = __webpack_require__(/*! ../internals/to-object */ "./node_modules/core-js/internals/to-object.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
ArrayBufferViewCore.exportProto('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.slice.js":
/*!**************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.slice.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var $slice = [].slice;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
ArrayBufferViewCore.exportProto('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.some.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.some.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var $some = __webpack_require__(/*! ../internals/array-iteration */ "./node_modules/core-js/internals/array-iteration.js").some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
ArrayBufferViewCore.exportProto('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.sort.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.sort.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
ArrayBufferViewCore.exportProto('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.subarray.js":
/*!*****************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.subarray.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var toLength = __webpack_require__(/*! ../internals/to-length */ "./node_modules/core-js/internals/to-length.js");
var toAbsoluteIndex = __webpack_require__(/*! ../internals/to-absolute-index */ "./node_modules/core-js/internals/to-absolute-index.js");
var speciesConstructor = __webpack_require__(/*! ../internals/species-constructor */ "./node_modules/core-js/internals/species-constructor.js");

var aTypedArray = ArrayBufferViewCore.aTypedArray;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
ArrayBufferViewCore.exportProto('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-locale-string.js":
/*!*************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-locale-string.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
ArrayBufferViewCore.exportProto('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.to-string.js":
/*!******************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.to-string.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var ArrayBufferViewCore = __webpack_require__(/*! ../internals/array-buffer-view-core */ "./node_modules/core-js/internals/array-buffer-view-core.js");
var fails = __webpack_require__(/*! ../internals/fails */ "./node_modules/core-js/internals/fails.js");

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype;
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
ArrayBufferViewCore.exportProto('toString', arrayToString, (Uint8ArrayPrototype || {}).toString != arrayToString);


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint16-array.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint16-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Uint16Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint32-array.js":
/*!*********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint32-array.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Uint32Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint8-array.js":
/*!********************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint8-array.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "./node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js":
/*!****************************************************************************!*\
  !*** ./node_modules/core-js/modules/es.typed-array.uint8-clamped-array.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var typedArrayConstructor = __webpack_require__(/*! ../internals/typed-array-constructor */ "./node_modules/core-js/internals/typed-array-constructor.js");

// `Uint8ClampedArray` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
typedArrayConstructor('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-map.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-map.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var InternalMetadataModule = __webpack_require__(/*! ../internals/internal-metadata */ "./node_modules/core-js/internals/internal-metadata.js");
var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var enforceIternalState = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js").enforce;
var NATIVE_WEAK_MAP = __webpack_require__(/*! ../internals/native-weak-map */ "./node_modules/core-js/internals/native-weak-map.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var isExtensible = Object.isExtensible;
var InternalWeakMap;

var wrapper = function (get) {
  return function WeakMap() {
    return get(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.github.io/ecma262/#sec-weakmap-constructor
var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak, true, true);

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.REQUIRED = true;
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = WeakMapPrototype['delete'];
  var nativeHas = WeakMapPrototype.has;
  var nativeGet = WeakMapPrototype.get;
  var nativeSet = WeakMapPrototype.set;
  redefineAll(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete.call(this, key) || state.frozen['delete'](key);
      } return nativeDelete.call(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) || state.frozen.has(key);
      } return nativeHas.call(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
      } return nativeGet.call(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
      } else nativeSet.call(this, key, value);
      return this;
    }
  });
}


/***/ }),

/***/ "./node_modules/core-js/modules/es.weak-set.js":
/*!*****************************************************!*\
  !*** ./node_modules/core-js/modules/es.weak-set.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__(/*! ../internals/collection */ "./node_modules/core-js/internals/collection.js");
var collectionWeak = __webpack_require__(/*! ../internals/collection-weak */ "./node_modules/core-js/internals/collection-weak.js");

// `WeakSet` constructor
// https://tc39.github.io/ecma262/#sec-weakset-constructor
collection('WeakSet', function (get) {
  return function WeakSet() { return get(this, arguments.length ? arguments[0] : undefined); };
}, collectionWeak, false, true);


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.for-each.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.for-each.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var forEach = __webpack_require__(/*! ../internals/array-for-each */ "./node_modules/core-js/internals/array-for-each.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    hide(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.dom-collections.iterator.js":
/*!**********************************************************************!*\
  !*** ./node_modules/core-js/modules/web.dom-collections.iterator.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var DOMIterables = __webpack_require__(/*! ../internals/dom-iterables */ "./node_modules/core-js/internals/dom-iterables.js");
var ArrayIteratorMethods = __webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var hide = __webpack_require__(/*! ../internals/hide */ "./node_modules/core-js/internals/hide.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      hide(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) hide(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        hide(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "./node_modules/core-js/modules/web.immediate.js":
/*!*******************************************************!*\
  !*** ./node_modules/core-js/modules/web.immediate.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var task = __webpack_require__(/*! ../internals/task */ "./node_modules/core-js/internals/task.js");

var FORCED = !global.setImmediate || !global.clearImmediate;

// http://w3c.github.io/setImmediate/
__webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js")({ global: true, bind: true, enumerable: true, forced: FORCED }, {
  // `setImmediate` method
  // http://w3c.github.io/setImmediate/#si-setImmediate
  setImmediate: task.set,
  // `clearImmediate` method
  // http://w3c.github.io/setImmediate/#si-clearImmediate
  clearImmediate: task.clear
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.queue-microtask.js":
/*!*************************************************************!*\
  !*** ./node_modules/core-js/modules/web.queue-microtask.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var microtask = __webpack_require__(/*! ../internals/microtask */ "./node_modules/core-js/internals/microtask.js");
var classof = __webpack_require__(/*! ../internals/classof-raw */ "./node_modules/core-js/internals/classof-raw.js");

var process = global.process;
var isNode = classof(process) == 'process';

// `queueMicrotask` method
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-queuemicrotask
$({ global: true, enumerable: true, noTargetGet: true }, {
  queueMicrotask: function queueMicrotask(fn) {
    var domain = isNode && process.domain;
    microtask(domain ? domain.bind(fn) : fn);
  }
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.timers.js":
/*!****************************************************!*\
  !*** ./node_modules/core-js/modules/web.timers.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var userAgent = __webpack_require__(/*! ../internals/user-agent */ "./node_modules/core-js/internals/user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function (scheduler) {
  return function (handler, timeout /* , ...arguments */) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : undefined;
    return scheduler(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof handler == 'function' ? handler : Function(handler)).apply(this, args);
    } : handler, timeout);
  };
};

// ie9- setTimeout & setInterval additional parameters fix
// https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
$({ global: true, bind: true, forced: MSIE }, {
  // `setTimeout` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-settimeout
  setTimeout: wrap(global.setTimeout),
  // `setInterval` method
  // https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#dom-setinterval
  setInterval: wrap(global.setInterval)
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.url-search-params.js":
/*!***************************************************************!*\
  !*** ./node_modules/core-js/modules/web.url-search-params.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.array.iterator */ "./node_modules/core-js/modules/es.array.iterator.js");
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var redefineAll = __webpack_require__(/*! ../internals/redefine-all */ "./node_modules/core-js/internals/redefine-all.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var createIteratorConstructor = __webpack_require__(/*! ../internals/create-iterator-constructor */ "./node_modules/core-js/internals/create-iterator-constructor.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var hasOwn = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var bind = __webpack_require__(/*! ../internals/bind-context */ "./node_modules/core-js/internals/bind-context.js");
var anObject = __webpack_require__(/*! ../internals/an-object */ "./node_modules/core-js/internals/an-object.js");
var isObject = __webpack_require__(/*! ../internals/is-object */ "./node_modules/core-js/internals/is-object.js");
var getIterator = __webpack_require__(/*! ../internals/get-iterator */ "./node_modules/core-js/internals/get-iterator.js");
var getIteratorMethod = __webpack_require__(/*! ../internals/get-iterator-method */ "./node_modules/core-js/internals/get-iterator-method.js");
var wellKnownSymbol = __webpack_require__(/*! ../internals/well-known-symbol */ "./node_modules/core-js/internals/well-known-symbol.js");

var ITERATOR = wellKnownSymbol('iterator');
var URL_SEARCH_PARAMS = 'URLSearchParams';
var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + 'Iterator';
var setInternalState = InternalStateModule.set;
var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);

var plus = /\+/g;
var sequences = Array(4);

var percentSequence = function (bytes) {
  return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp('((?:%[\\da-f]{2}){' + bytes + '})', 'gi'));
};

var percentDecode = function (sequence) {
  try {
    return decodeURIComponent(sequence);
  } catch (error) {
    return sequence;
  }
};

var deserialize = function (it) {
  var result = it.replace(plus, ' ');
  var bytes = 4;
  try {
    return decodeURIComponent(result);
  } catch (error) {
    while (bytes) {
      result = result.replace(percentSequence(bytes--), percentDecode);
    }
    return result;
  }
};

var find = /[!'()~]|%20/g;

var replace = {
  '!': '%21',
  "'": '%27',
  '(': '%28',
  ')': '%29',
  '~': '%7E',
  '%20': '+'
};

var replacer = function (match) {
  return replace[match];
};

var serialize = function (it) {
  return encodeURIComponent(it).replace(find, replacer);
};

var parseSearchParams = function (result, query) {
  if (query) {
    var attributes = query.split('&');
    var index = 0;
    var attribute, entry;
    while (index < attributes.length) {
      attribute = attributes[index++];
      if (attribute.length) {
        entry = attribute.split('=');
        result.push({
          key: deserialize(entry.shift()),
          value: deserialize(entry.join('='))
        });
      }
    }
  }
};

var updateSearchParams = function (query) {
  this.entries.length = 0;
  parseSearchParams(this.entries, query);
};

var validateArgumentsLength = function (passed, required) {
  if (passed < required) throw TypeError('Not enough arguments');
};

var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
  setInternalState(this, {
    type: URL_SEARCH_PARAMS_ITERATOR,
    iterator: getIterator(getInternalParamsState(params).entries),
    kind: kind
  });
}, 'Iterator', function next() {
  var state = getInternalIteratorState(this);
  var kind = state.kind;
  var step = state.iterator.next();
  var entry = step.value;
  if (!step.done) {
    step.value = kind === 'keys' ? entry.key : kind === 'values' ? entry.value : [entry.key, entry.value];
  } return step;
});

// `URLSearchParams` constructor
// https://url.spec.whatwg.org/#interface-urlsearchparams
var URLSearchParamsConstructor = function URLSearchParams(/* init */) {
  anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
  var init = arguments.length > 0 ? arguments[0] : undefined;
  var that = this;
  var entries = [];
  var iteratorMethod, iterator, step, entryIterator, first, second, key;

  setInternalState(that, {
    type: URL_SEARCH_PARAMS,
    entries: entries,
    updateURL: function () { /* empty */ },
    updateSearchParams: updateSearchParams
  });

  if (init !== undefined) {
    if (isObject(init)) {
      iteratorMethod = getIteratorMethod(init);
      if (typeof iteratorMethod === 'function') {
        iterator = iteratorMethod.call(init);
        while (!(step = iterator.next()).done) {
          entryIterator = getIterator(anObject(step.value));
          if (
            (first = entryIterator.next()).done ||
            (second = entryIterator.next()).done ||
            !entryIterator.next().done
          ) throw TypeError('Expected sequence with length 2');
          entries.push({ key: first.value + '', value: second.value + '' });
        }
      } else for (key in init) if (hasOwn(init, key)) entries.push({ key: key, value: init[key] + '' });
    } else {
      parseSearchParams(entries, typeof init === 'string' ? init.charAt(0) === '?' ? init.slice(1) : init : init + '');
    }
  }
};

var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;

redefineAll(URLSearchParamsPrototype, {
  // `URLSearchParams.prototype.appent` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-append
  append: function append(name, value) {
    validateArgumentsLength(arguments.length, 2);
    var state = getInternalParamsState(this);
    state.entries.push({ key: name + '', value: value + '' });
    state.updateURL();
  },
  // `URLSearchParams.prototype.delete` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-delete
  'delete': function (name) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index].key === key) entries.splice(index, 1);
      else index++;
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.get` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-get
  get: function get(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) return entries[index].value;
    }
    return null;
  },
  // `URLSearchParams.prototype.getAll` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-getall
  getAll: function getAll(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var result = [];
    var index = 0;
    for (; index < entries.length; index++) {
      if (entries[index].key === key) result.push(entries[index].value);
    }
    return result;
  },
  // `URLSearchParams.prototype.has` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-has
  has: function has(name) {
    validateArgumentsLength(arguments.length, 1);
    var entries = getInternalParamsState(this).entries;
    var key = name + '';
    var index = 0;
    while (index < entries.length) {
      if (entries[index++].key === key) return true;
    }
    return false;
  },
  // `URLSearchParams.prototype.set` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-set
  set: function set(name, value) {
    validateArgumentsLength(arguments.length, 1);
    var state = getInternalParamsState(this);
    var entries = state.entries;
    var found = false;
    var key = name + '';
    var val = value + '';
    var index = 0;
    var entry;
    for (; index < entries.length; index++) {
      entry = entries[index];
      if (entry.key === key) {
        if (found) entries.splice(index--, 1);
        else {
          found = true;
          entry.value = val;
        }
      }
    }
    if (!found) entries.push({ key: key, value: val });
    state.updateURL();
  },
  // `URLSearchParams.prototype.sort` method
  // https://url.spec.whatwg.org/#dom-urlsearchparams-sort
  sort: function sort() {
    var state = getInternalParamsState(this);
    var entries = state.entries;
    // Array#sort is not stable in some engines
    var slice = entries.slice();
    var entry, entriesIndex, sliceIndex;
    entries.length = 0;
    for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
      entry = slice[sliceIndex];
      for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
        if (entries[entriesIndex].key > entry.key) {
          entries.splice(entriesIndex, 0, entry);
          break;
        }
      }
      if (entriesIndex === sliceIndex) entries.push(entry);
    }
    state.updateURL();
  },
  // `URLSearchParams.prototype.forEach` method
  forEach: function forEach(callback /* , thisArg */) {
    var entries = getInternalParamsState(this).entries;
    var boundFunction = bind(callback, arguments.length > 1 ? arguments[1] : undefined, 3);
    var index = 0;
    var entry;
    while (index < entries.length) {
      entry = entries[index++];
      boundFunction(entry.value, entry.key, this);
    }
  },
  // `URLSearchParams.prototype.keys` method
  keys: function keys() {
    return new URLSearchParamsIterator(this, 'keys');
  },
  // `URLSearchParams.prototype.values` method
  values: function values() {
    return new URLSearchParamsIterator(this, 'values');
  },
  // `URLSearchParams.prototype.entries` method
  entries: function entries() {
    return new URLSearchParamsIterator(this, 'entries');
  }
}, { enumerable: true });

// `URLSearchParams.prototype[@@iterator]` method
redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries);

// `URLSearchParams.prototype.toString` method
// https://url.spec.whatwg.org/#urlsearchparams-stringification-behavior
redefine(URLSearchParamsPrototype, 'toString', function toString() {
  var entries = getInternalParamsState(this).entries;
  var result = [];
  var index = 0;
  var entry;
  while (index < entries.length) {
    entry = entries[index++];
    result.push(serialize(entry.key) + '=' + serialize(entry.value));
  } return result.join('&');
}, { enumerable: true });

setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);

$({ global: true, forced: !USE_NATIVE_URL }, {
  URLSearchParams: URLSearchParamsConstructor
});

module.exports = {
  URLSearchParams: URLSearchParamsConstructor,
  getState: getInternalParamsState
};


/***/ }),

/***/ "./node_modules/core-js/modules/web.url.js":
/*!*************************************************!*\
  !*** ./node_modules/core-js/modules/web.url.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: in core-js@4, move /modules/ dependencies to public entries for better optimization by tools like `preset-env`
__webpack_require__(/*! ../modules/es.string.iterator */ "./node_modules/core-js/modules/es.string.iterator.js");
var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");
var DESCRIPTORS = __webpack_require__(/*! ../internals/descriptors */ "./node_modules/core-js/internals/descriptors.js");
var USE_NATIVE_URL = __webpack_require__(/*! ../internals/native-url */ "./node_modules/core-js/internals/native-url.js");
var global = __webpack_require__(/*! ../internals/global */ "./node_modules/core-js/internals/global.js");
var defineProperties = __webpack_require__(/*! ../internals/object-define-properties */ "./node_modules/core-js/internals/object-define-properties.js");
var redefine = __webpack_require__(/*! ../internals/redefine */ "./node_modules/core-js/internals/redefine.js");
var anInstance = __webpack_require__(/*! ../internals/an-instance */ "./node_modules/core-js/internals/an-instance.js");
var has = __webpack_require__(/*! ../internals/has */ "./node_modules/core-js/internals/has.js");
var assign = __webpack_require__(/*! ../internals/object-assign */ "./node_modules/core-js/internals/object-assign.js");
var arrayFrom = __webpack_require__(/*! ../internals/array-from */ "./node_modules/core-js/internals/array-from.js");
var codeAt = __webpack_require__(/*! ../internals/string-multibyte */ "./node_modules/core-js/internals/string-multibyte.js").codeAt;
var toASCII = __webpack_require__(/*! ../internals/punycode-to-ascii */ "./node_modules/core-js/internals/punycode-to-ascii.js");
var setToStringTag = __webpack_require__(/*! ../internals/set-to-string-tag */ "./node_modules/core-js/internals/set-to-string-tag.js");
var URLSearchParamsModule = __webpack_require__(/*! ../modules/web.url-search-params */ "./node_modules/core-js/modules/web.url-search-params.js");
var InternalStateModule = __webpack_require__(/*! ../internals/internal-state */ "./node_modules/core-js/internals/internal-state.js");

var NativeURL = global.URL;
var URLSearchParams = URLSearchParamsModule.URLSearchParams;
var getInternalSearchParamsState = URLSearchParamsModule.getState;
var setInternalState = InternalStateModule.set;
var getInternalURLState = InternalStateModule.getterFor('URL');
var floor = Math.floor;
var pow = Math.pow;

var INVALID_AUTHORITY = 'Invalid authority';
var INVALID_SCHEME = 'Invalid scheme';
var INVALID_HOST = 'Invalid host';
var INVALID_PORT = 'Invalid port';

var ALPHA = /[A-Za-z]/;
var ALPHANUMERIC = /[\d+\-.A-Za-z]/;
var DIGIT = /\d/;
var HEX_START = /^(0x|0X)/;
var OCT = /^[0-7]+$/;
var DEC = /^\d+$/;
var HEX = /^[\dA-Fa-f]+$/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT = /[\u0000\u0009\u000A\u000D #%/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\u0000\u0009\u000A\u000D #/:?@[\\]]/;
// eslint-disable-next-line no-control-regex
var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u001F ]+|[\u0000-\u001F ]+$/g;
// eslint-disable-next-line no-control-regex
var TAB_AND_NEW_LINE = /[\u0009\u000A\u000D]/g;
var EOF;

var parseHost = function (url, input) {
  var result, codePoints, index;
  if (input.charAt(0) == '[') {
    if (input.charAt(input.length - 1) != ']') return INVALID_HOST;
    result = parseIPv6(input.slice(1, -1));
    if (!result) return INVALID_HOST;
    url.host = result;
  // opaque host
  } else if (!isSpecial(url)) {
    if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input)) return INVALID_HOST;
    result = '';
    codePoints = arrayFrom(input);
    for (index = 0; index < codePoints.length; index++) {
      result += percentEncode(codePoints[index], C0ControlPercentEncodeSet);
    }
    url.host = result;
  } else {
    input = toASCII(input);
    if (FORBIDDEN_HOST_CODE_POINT.test(input)) return INVALID_HOST;
    result = parseIPv4(input);
    if (result === null) return INVALID_HOST;
    url.host = result;
  }
};

var parseIPv4 = function (input) {
  var parts = input.split('.');
  var partsLength, numbers, index, part, radix, number, ipv4;
  if (parts.length && parts[parts.length - 1] == '') {
    parts.pop();
  }
  partsLength = parts.length;
  if (partsLength > 4) return input;
  numbers = [];
  for (index = 0; index < partsLength; index++) {
    part = parts[index];
    if (part == '') return input;
    radix = 10;
    if (part.length > 1 && part.charAt(0) == '0') {
      radix = HEX_START.test(part) ? 16 : 8;
      part = part.slice(radix == 8 ? 1 : 2);
    }
    if (part === '') {
      number = 0;
    } else {
      if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part)) return input;
      number = parseInt(part, radix);
    }
    numbers.push(number);
  }
  for (index = 0; index < partsLength; index++) {
    number = numbers[index];
    if (index == partsLength - 1) {
      if (number >= pow(256, 5 - partsLength)) return null;
    } else if (number > 255) return null;
  }
  ipv4 = numbers.pop();
  for (index = 0; index < numbers.length; index++) {
    ipv4 += numbers[index] * pow(256, 3 - index);
  }
  return ipv4;
};

// eslint-disable-next-line max-statements
var parseIPv6 = function (input) {
  var address = [0, 0, 0, 0, 0, 0, 0, 0];
  var pieceIndex = 0;
  var compress = null;
  var pointer = 0;
  var value, length, numbersSeen, ipv4Piece, number, swaps, swap;

  var char = function () {
    return input.charAt(pointer);
  };

  if (char() == ':') {
    if (input.charAt(1) != ':') return;
    pointer += 2;
    pieceIndex++;
    compress = pieceIndex;
  }
  while (char()) {
    if (pieceIndex == 8) return;
    if (char() == ':') {
      if (compress !== null) return;
      pointer++;
      pieceIndex++;
      compress = pieceIndex;
      continue;
    }
    value = length = 0;
    while (length < 4 && HEX.test(char())) {
      value = value * 16 + parseInt(char(), 16);
      pointer++;
      length++;
    }
    if (char() == '.') {
      if (length == 0) return;
      pointer -= length;
      if (pieceIndex > 6) return;
      numbersSeen = 0;
      while (char()) {
        ipv4Piece = null;
        if (numbersSeen > 0) {
          if (char() == '.' && numbersSeen < 4) pointer++;
          else return;
        }
        if (!DIGIT.test(char())) return;
        while (DIGIT.test(char())) {
          number = parseInt(char(), 10);
          if (ipv4Piece === null) ipv4Piece = number;
          else if (ipv4Piece == 0) return;
          else ipv4Piece = ipv4Piece * 10 + number;
          if (ipv4Piece > 255) return;
          pointer++;
        }
        address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
        numbersSeen++;
        if (numbersSeen == 2 || numbersSeen == 4) pieceIndex++;
      }
      if (numbersSeen != 4) return;
      break;
    } else if (char() == ':') {
      pointer++;
      if (!char()) return;
    } else if (char()) return;
    address[pieceIndex++] = value;
  }
  if (compress !== null) {
    swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex != 0 && swaps > 0) {
      swap = address[pieceIndex];
      address[pieceIndex--] = address[compress + swaps - 1];
      address[compress + --swaps] = swap;
    }
  } else if (pieceIndex != 8) return;
  return address;
};

var findLongestZeroSequence = function (ipv6) {
  var maxIndex = null;
  var maxLength = 1;
  var currStart = null;
  var currLength = 0;
  var index = 0;
  for (; index < 8; index++) {
    if (ipv6[index] !== 0) {
      if (currLength > maxLength) {
        maxIndex = currStart;
        maxLength = currLength;
      }
      currStart = null;
      currLength = 0;
    } else {
      if (currStart === null) currStart = index;
      ++currLength;
    }
  }
  if (currLength > maxLength) {
    maxIndex = currStart;
    maxLength = currLength;
  }
  return maxIndex;
};

var serializeHost = function (host) {
  var result, index, compress, ignore0;
  // ipv4
  if (typeof host == 'number') {
    result = [];
    for (index = 0; index < 4; index++) {
      result.unshift(host % 256);
      host = floor(host / 256);
    } return result.join('.');
  // ipv6
  } else if (typeof host == 'object') {
    result = '';
    compress = findLongestZeroSequence(host);
    for (index = 0; index < 8; index++) {
      if (ignore0 && host[index] === 0) continue;
      if (ignore0) ignore0 = false;
      if (compress === index) {
        result += index ? ':' : '::';
        ignore0 = true;
      } else {
        result += host[index].toString(16);
        if (index < 7) result += ':';
      }
    }
    return '[' + result + ']';
  } return host;
};

var C0ControlPercentEncodeSet = {};
var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
  ' ': 1, '"': 1, '<': 1, '>': 1, '`': 1
});
var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
  '#': 1, '?': 1, '{': 1, '}': 1
});
var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
  '/': 1, ':': 1, ';': 1, '=': 1, '@': 1, '[': 1, '\\': 1, ']': 1, '^': 1, '|': 1
});

var percentEncode = function (char, set) {
  var code = codeAt(char, 0);
  return code > 0x20 && code < 0x7F && !has(set, char) ? char : encodeURIComponent(char);
};

var specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

var isSpecial = function (url) {
  return has(specialSchemes, url.scheme);
};

var includesCredentials = function (url) {
  return url.username != '' || url.password != '';
};

var cannotHaveUsernamePasswordPort = function (url) {
  return !url.host || url.cannotBeABaseURL || url.scheme == 'file';
};

var isWindowsDriveLetter = function (string, normalized) {
  var second;
  return string.length == 2 && ALPHA.test(string.charAt(0))
    && ((second = string.charAt(1)) == ':' || (!normalized && second == '|'));
};

var startsWithWindowsDriveLetter = function (string) {
  var third;
  return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (
    string.length == 2 ||
    ((third = string.charAt(2)) === '/' || third === '\\' || third === '?' || third === '#')
  );
};

var shortenURLsPath = function (url) {
  var path = url.path;
  var pathSize = path.length;
  if (pathSize && (url.scheme != 'file' || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
    path.pop();
  }
};

var isSingleDot = function (segment) {
  return segment === '.' || segment.toLowerCase() === '%2e';
};

var isDoubleDot = function (segment) {
  segment = segment.toLowerCase();
  return segment === '..' || segment === '%2e.' || segment === '.%2e' || segment === '%2e%2e';
};

// States:
var SCHEME_START = {};
var SCHEME = {};
var NO_SCHEME = {};
var SPECIAL_RELATIVE_OR_AUTHORITY = {};
var PATH_OR_AUTHORITY = {};
var RELATIVE = {};
var RELATIVE_SLASH = {};
var SPECIAL_AUTHORITY_SLASHES = {};
var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
var AUTHORITY = {};
var HOST = {};
var HOSTNAME = {};
var PORT = {};
var FILE = {};
var FILE_SLASH = {};
var FILE_HOST = {};
var PATH_START = {};
var PATH = {};
var CANNOT_BE_A_BASE_URL_PATH = {};
var QUERY = {};
var FRAGMENT = {};

// eslint-disable-next-line max-statements
var parseURL = function (url, input, stateOverride, base) {
  var state = stateOverride || SCHEME_START;
  var pointer = 0;
  var buffer = '';
  var seenAt = false;
  var seenBracket = false;
  var seenPasswordToken = false;
  var codePoints, char, bufferCodePoints, failure;

  if (!stateOverride) {
    url.scheme = '';
    url.username = '';
    url.password = '';
    url.host = null;
    url.port = null;
    url.path = [];
    url.query = null;
    url.fragment = null;
    url.cannotBeABaseURL = false;
    input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, '');
  }

  input = input.replace(TAB_AND_NEW_LINE, '');

  codePoints = arrayFrom(input);

  while (pointer <= codePoints.length) {
    char = codePoints[pointer];
    switch (state) {
      case SCHEME_START:
        if (char && ALPHA.test(char)) {
          buffer += char.toLowerCase();
          state = SCHEME;
        } else if (!stateOverride) {
          state = NO_SCHEME;
          continue;
        } else return INVALID_SCHEME;
        break;

      case SCHEME:
        if (char && (ALPHANUMERIC.test(char) || char == '+' || char == '-' || char == '.')) {
          buffer += char.toLowerCase();
        } else if (char == ':') {
          if (stateOverride && (
            (isSpecial(url) != has(specialSchemes, buffer)) ||
            (buffer == 'file' && (includesCredentials(url) || url.port !== null)) ||
            (url.scheme == 'file' && !url.host)
          )) return;
          url.scheme = buffer;
          if (stateOverride) {
            if (isSpecial(url) && specialSchemes[url.scheme] == url.port) url.port = null;
            return;
          }
          buffer = '';
          if (url.scheme == 'file') {
            state = FILE;
          } else if (isSpecial(url) && base && base.scheme == url.scheme) {
            state = SPECIAL_RELATIVE_OR_AUTHORITY;
          } else if (isSpecial(url)) {
            state = SPECIAL_AUTHORITY_SLASHES;
          } else if (codePoints[pointer + 1] == '/') {
            state = PATH_OR_AUTHORITY;
            pointer++;
          } else {
            url.cannotBeABaseURL = true;
            url.path.push('');
            state = CANNOT_BE_A_BASE_URL_PATH;
          }
        } else if (!stateOverride) {
          buffer = '';
          state = NO_SCHEME;
          pointer = 0;
          continue;
        } else return INVALID_SCHEME;
        break;

      case NO_SCHEME:
        if (!base || (base.cannotBeABaseURL && char != '#')) return INVALID_SCHEME;
        if (base.cannotBeABaseURL && char == '#') {
          url.scheme = base.scheme;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          url.cannotBeABaseURL = true;
          state = FRAGMENT;
          break;
        }
        state = base.scheme == 'file' ? FILE : RELATIVE;
        continue;

      case SPECIAL_RELATIVE_OR_AUTHORITY:
        if (char == '/' && codePoints[pointer + 1] == '/') {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
          pointer++;
        } else {
          state = RELATIVE;
          continue;
        } break;

      case PATH_OR_AUTHORITY:
        if (char == '/') {
          state = AUTHORITY;
          break;
        } else {
          state = PATH;
          continue;
        }

      case RELATIVE:
        url.scheme = base.scheme;
        if (char == EOF) {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
        } else if (char == '/' || (char == '\\' && isSpecial(url))) {
          state = RELATIVE_SLASH;
        } else if (char == '?') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.query = base.query;
          url.fragment = '';
          state = FRAGMENT;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          url.path = base.path.slice();
          url.path.pop();
          state = PATH;
          continue;
        } break;

      case RELATIVE_SLASH:
        if (isSpecial(url) && (char == '/' || char == '\\')) {
          state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        } else if (char == '/') {
          state = AUTHORITY;
        } else {
          url.username = base.username;
          url.password = base.password;
          url.host = base.host;
          url.port = base.port;
          state = PATH;
          continue;
        } break;

      case SPECIAL_AUTHORITY_SLASHES:
        state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
        if (char != '/' || buffer.charAt(pointer + 1) != '/') continue;
        pointer++;
        break;

      case SPECIAL_AUTHORITY_IGNORE_SLASHES:
        if (char != '/' && char != '\\') {
          state = AUTHORITY;
          continue;
        } break;

      case AUTHORITY:
        if (char == '@') {
          if (seenAt) buffer = '%40' + buffer;
          seenAt = true;
          bufferCodePoints = arrayFrom(buffer);
          for (var i = 0; i < bufferCodePoints.length; i++) {
            var codePoint = bufferCodePoints[i];
            if (codePoint == ':' && !seenPasswordToken) {
              seenPasswordToken = true;
              continue;
            }
            var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
            if (seenPasswordToken) url.password += encodedCodePoints;
            else url.username += encodedCodePoints;
          }
          buffer = '';
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (seenAt && buffer == '') return INVALID_AUTHORITY;
          pointer -= arrayFrom(buffer).length + 1;
          buffer = '';
          state = HOST;
        } else buffer += char;
        break;

      case HOST:
      case HOSTNAME:
        if (stateOverride && url.scheme == 'file') {
          state = FILE_HOST;
          continue;
        } else if (char == ':' && !seenBracket) {
          if (buffer == '') return INVALID_HOST;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PORT;
          if (stateOverride == HOSTNAME) return;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url))
        ) {
          if (isSpecial(url) && buffer == '') return INVALID_HOST;
          if (stateOverride && buffer == '' && (includesCredentials(url) || url.port !== null)) return;
          failure = parseHost(url, buffer);
          if (failure) return failure;
          buffer = '';
          state = PATH_START;
          if (stateOverride) return;
          continue;
        } else {
          if (char == '[') seenBracket = true;
          else if (char == ']') seenBracket = false;
          buffer += char;
        } break;

      case PORT:
        if (DIGIT.test(char)) {
          buffer += char;
        } else if (
          char == EOF || char == '/' || char == '?' || char == '#' ||
          (char == '\\' && isSpecial(url)) ||
          stateOverride
        ) {
          if (buffer != '') {
            var port = parseInt(buffer, 10);
            if (port > 0xFFFF) return INVALID_PORT;
            url.port = (isSpecial(url) && port === specialSchemes[url.scheme]) ? null : port;
            buffer = '';
          }
          if (stateOverride) return;
          state = PATH_START;
          continue;
        } else return INVALID_PORT;
        break;

      case FILE:
        url.scheme = 'file';
        if (char == '/' || char == '\\') state = FILE_SLASH;
        else if (base && base.scheme == 'file') {
          if (char == EOF) {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
          } else if (char == '?') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.host = base.host;
            url.path = base.path.slice();
            url.query = base.query;
            url.fragment = '';
            state = FRAGMENT;
          } else {
            if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
              url.host = base.host;
              url.path = base.path.slice();
              shortenURLsPath(url);
            }
            state = PATH;
            continue;
          }
        } else {
          state = PATH;
          continue;
        } break;

      case FILE_SLASH:
        if (char == '/' || char == '\\') {
          state = FILE_HOST;
          break;
        }
        if (base && base.scheme == 'file' && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(''))) {
          if (isWindowsDriveLetter(base.path[0], true)) url.path.push(base.path[0]);
          else url.host = base.host;
        }
        state = PATH;
        continue;

      case FILE_HOST:
        if (char == EOF || char == '/' || char == '\\' || char == '?' || char == '#') {
          if (!stateOverride && isWindowsDriveLetter(buffer)) {
            state = PATH;
          } else if (buffer == '') {
            url.host = '';
            if (stateOverride) return;
            state = PATH_START;
          } else {
            failure = parseHost(url, buffer);
            if (failure) return failure;
            if (url.host == 'localhost') url.host = '';
            if (stateOverride) return;
            buffer = '';
            state = PATH_START;
          } continue;
        } else buffer += char;
        break;

      case PATH_START:
        if (isSpecial(url)) {
          state = PATH;
          if (char != '/' && char != '\\') continue;
        } else if (!stateOverride && char == '?') {
          url.query = '';
          state = QUERY;
        } else if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          state = PATH;
          if (char != '/') continue;
        } break;

      case PATH:
        if (
          char == EOF || char == '/' ||
          (char == '\\' && isSpecial(url)) ||
          (!stateOverride && (char == '?' || char == '#'))
        ) {
          if (isDoubleDot(buffer)) {
            shortenURLsPath(url);
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else if (isSingleDot(buffer)) {
            if (char != '/' && !(char == '\\' && isSpecial(url))) {
              url.path.push('');
            }
          } else {
            if (url.scheme == 'file' && !url.path.length && isWindowsDriveLetter(buffer)) {
              if (url.host) url.host = '';
              buffer = buffer.charAt(0) + ':'; // normalize windows drive letter
            }
            url.path.push(buffer);
          }
          buffer = '';
          if (url.scheme == 'file' && (char == EOF || char == '?' || char == '#')) {
            while (url.path.length > 1 && url.path[0] === '') {
              url.path.shift();
            }
          }
          if (char == '?') {
            url.query = '';
            state = QUERY;
          } else if (char == '#') {
            url.fragment = '';
            state = FRAGMENT;
          }
        } else {
          buffer += percentEncode(char, pathPercentEncodeSet);
        } break;

      case CANNOT_BE_A_BASE_URL_PATH:
        if (char == '?') {
          url.query = '';
          state = QUERY;
        } else if (char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          url.path[0] += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case QUERY:
        if (!stateOverride && char == '#') {
          url.fragment = '';
          state = FRAGMENT;
        } else if (char != EOF) {
          if (char == "'" && isSpecial(url)) url.query += '%27';
          else if (char == '#') url.query += '%23';
          else url.query += percentEncode(char, C0ControlPercentEncodeSet);
        } break;

      case FRAGMENT:
        if (char != EOF) url.fragment += percentEncode(char, fragmentPercentEncodeSet);
        break;
    }

    pointer++;
  }
};

// `URL` constructor
// https://url.spec.whatwg.org/#url-class
var URLConstructor = function URL(url /* , base */) {
  var that = anInstance(this, URLConstructor, 'URL');
  var base = arguments.length > 1 ? arguments[1] : undefined;
  var urlString = String(url);
  var state = setInternalState(that, { type: 'URL' });
  var baseState, failure;
  if (base !== undefined) {
    if (base instanceof URLConstructor) baseState = getInternalURLState(base);
    else {
      failure = parseURL(baseState = {}, String(base));
      if (failure) throw TypeError(failure);
    }
  }
  failure = parseURL(state, urlString, null, baseState);
  if (failure) throw TypeError(failure);
  var searchParams = state.searchParams = new URLSearchParams();
  var searchParamsState = getInternalSearchParamsState(searchParams);
  searchParamsState.updateSearchParams(state.query);
  searchParamsState.updateURL = function () {
    state.query = String(searchParams) || null;
  };
  if (!DESCRIPTORS) {
    that.href = serializeURL.call(that);
    that.origin = getOrigin.call(that);
    that.protocol = getProtocol.call(that);
    that.username = getUsername.call(that);
    that.password = getPassword.call(that);
    that.host = getHost.call(that);
    that.hostname = getHostname.call(that);
    that.port = getPort.call(that);
    that.pathname = getPathname.call(that);
    that.search = getSearch.call(that);
    that.searchParams = getSearchParams.call(that);
    that.hash = getHash.call(that);
  }
};

var URLPrototype = URLConstructor.prototype;

var serializeURL = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var username = url.username;
  var password = url.password;
  var host = url.host;
  var port = url.port;
  var path = url.path;
  var query = url.query;
  var fragment = url.fragment;
  var output = scheme + ':';
  if (host !== null) {
    output += '//';
    if (includesCredentials(url)) {
      output += username + (password ? ':' + password : '') + '@';
    }
    output += serializeHost(host);
    if (port !== null) output += ':' + port;
  } else if (scheme == 'file') output += '//';
  output += url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
  if (query !== null) output += '?' + query;
  if (fragment !== null) output += '#' + fragment;
  return output;
};

var getOrigin = function () {
  var url = getInternalURLState(this);
  var scheme = url.scheme;
  var port = url.port;
  if (scheme == 'blob') try {
    return new URL(scheme.path[0]).origin;
  } catch (error) {
    return 'null';
  }
  if (scheme == 'file' || !isSpecial(url)) return 'null';
  return scheme + '://' + serializeHost(url.host) + (port !== null ? ':' + port : '');
};

var getProtocol = function () {
  return getInternalURLState(this).scheme + ':';
};

var getUsername = function () {
  return getInternalURLState(this).username;
};

var getPassword = function () {
  return getInternalURLState(this).password;
};

var getHost = function () {
  var url = getInternalURLState(this);
  var host = url.host;
  var port = url.port;
  return host === null ? ''
    : port === null ? serializeHost(host)
    : serializeHost(host) + ':' + port;
};

var getHostname = function () {
  var host = getInternalURLState(this).host;
  return host === null ? '' : serializeHost(host);
};

var getPort = function () {
  var port = getInternalURLState(this).port;
  return port === null ? '' : String(port);
};

var getPathname = function () {
  var url = getInternalURLState(this);
  var path = url.path;
  return url.cannotBeABaseURL ? path[0] : path.length ? '/' + path.join('/') : '';
};

var getSearch = function () {
  var query = getInternalURLState(this).query;
  return query ? '?' + query : '';
};

var getSearchParams = function () {
  return getInternalURLState(this).searchParams;
};

var getHash = function () {
  var fragment = getInternalURLState(this).fragment;
  return fragment ? '#' + fragment : '';
};

var accessorDescriptor = function (getter, setter) {
  return { get: getter, set: setter, configurable: true, enumerable: true };
};

if (DESCRIPTORS) {
  defineProperties(URLPrototype, {
    // `URL.prototype.href` accessors pair
    // https://url.spec.whatwg.org/#dom-url-href
    href: accessorDescriptor(serializeURL, function (href) {
      var url = getInternalURLState(this);
      var urlString = String(href);
      var failure = parseURL(url, urlString);
      if (failure) throw TypeError(failure);
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.origin` getter
    // https://url.spec.whatwg.org/#dom-url-origin
    origin: accessorDescriptor(getOrigin),
    // `URL.prototype.protocol` accessors pair
    // https://url.spec.whatwg.org/#dom-url-protocol
    protocol: accessorDescriptor(getProtocol, function (protocol) {
      var url = getInternalURLState(this);
      parseURL(url, String(protocol) + ':', SCHEME_START);
    }),
    // `URL.prototype.username` accessors pair
    // https://url.spec.whatwg.org/#dom-url-username
    username: accessorDescriptor(getUsername, function (username) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(username));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.username = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.password` accessors pair
    // https://url.spec.whatwg.org/#dom-url-password
    password: accessorDescriptor(getPassword, function (password) {
      var url = getInternalURLState(this);
      var codePoints = arrayFrom(String(password));
      if (cannotHaveUsernamePasswordPort(url)) return;
      url.password = '';
      for (var i = 0; i < codePoints.length; i++) {
        url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
      }
    }),
    // `URL.prototype.host` accessors pair
    // https://url.spec.whatwg.org/#dom-url-host
    host: accessorDescriptor(getHost, function (host) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(host), HOST);
    }),
    // `URL.prototype.hostname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hostname
    hostname: accessorDescriptor(getHostname, function (hostname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      parseURL(url, String(hostname), HOSTNAME);
    }),
    // `URL.prototype.port` accessors pair
    // https://url.spec.whatwg.org/#dom-url-port
    port: accessorDescriptor(getPort, function (port) {
      var url = getInternalURLState(this);
      if (cannotHaveUsernamePasswordPort(url)) return;
      port = String(port);
      if (port == '') url.port = null;
      else parseURL(url, port, PORT);
    }),
    // `URL.prototype.pathname` accessors pair
    // https://url.spec.whatwg.org/#dom-url-pathname
    pathname: accessorDescriptor(getPathname, function (pathname) {
      var url = getInternalURLState(this);
      if (url.cannotBeABaseURL) return;
      url.path = [];
      parseURL(url, pathname + '', PATH_START);
    }),
    // `URL.prototype.search` accessors pair
    // https://url.spec.whatwg.org/#dom-url-search
    search: accessorDescriptor(getSearch, function (search) {
      var url = getInternalURLState(this);
      search = String(search);
      if (search == '') {
        url.query = null;
      } else {
        if ('?' == search.charAt(0)) search = search.slice(1);
        url.query = '';
        parseURL(url, search, QUERY);
      }
      getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
    }),
    // `URL.prototype.searchParams` getter
    // https://url.spec.whatwg.org/#dom-url-searchparams
    searchParams: accessorDescriptor(getSearchParams),
    // `URL.prototype.hash` accessors pair
    // https://url.spec.whatwg.org/#dom-url-hash
    hash: accessorDescriptor(getHash, function (hash) {
      var url = getInternalURLState(this);
      hash = String(hash);
      if (hash == '') {
        url.fragment = null;
        return;
      }
      if ('#' == hash.charAt(0)) hash = hash.slice(1);
      url.fragment = '';
      parseURL(url, hash, FRAGMENT);
    })
  });
}

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
redefine(URLPrototype, 'toJSON', function toJSON() {
  return serializeURL.call(this);
}, { enumerable: true });

// `URL.prototype.toString` method
// https://url.spec.whatwg.org/#URL-stringification-behavior
redefine(URLPrototype, 'toString', function toString() {
  return serializeURL.call(this);
}, { enumerable: true });

if (NativeURL) {
  var nativeCreateObjectURL = NativeURL.createObjectURL;
  var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
  // `URL.createObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeCreateObjectURL) redefine(URLConstructor, 'createObjectURL', function createObjectURL(blob) {
    return nativeCreateObjectURL.apply(NativeURL, arguments);
  });
  // `URL.revokeObjectURL` method
  // https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL
  // eslint-disable-next-line no-unused-vars
  if (nativeRevokeObjectURL) redefine(URLConstructor, 'revokeObjectURL', function revokeObjectURL(url) {
    return nativeRevokeObjectURL.apply(NativeURL, arguments);
  });
}

setToStringTag(URLConstructor, 'URL');

$({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
  URL: URLConstructor
});


/***/ }),

/***/ "./node_modules/core-js/modules/web.url.to-json.js":
/*!*********************************************************!*\
  !*** ./node_modules/core-js/modules/web.url.to-json.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__(/*! ../internals/export */ "./node_modules/core-js/internals/export.js");

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({ target: 'URL', proto: true, enumerable: true }, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});


/***/ }),

/***/ "./node_modules/core-js/stable/index.js":
/*!**********************************************!*\
  !*** ./node_modules/core-js/stable/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../es */ "./node_modules/core-js/es/index.js");
__webpack_require__(/*! ../web */ "./node_modules/core-js/web/index.js");

module.exports = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");


/***/ }),

/***/ "./node_modules/core-js/web/index.js":
/*!*******************************************!*\
  !*** ./node_modules/core-js/web/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.dom-collections.for-each */ "./node_modules/core-js/modules/web.dom-collections.for-each.js");
__webpack_require__(/*! ../modules/web.dom-collections.iterator */ "./node_modules/core-js/modules/web.dom-collections.iterator.js");
__webpack_require__(/*! ../modules/web.immediate */ "./node_modules/core-js/modules/web.immediate.js");
__webpack_require__(/*! ../modules/web.queue-microtask */ "./node_modules/core-js/modules/web.queue-microtask.js");
__webpack_require__(/*! ../modules/web.timers */ "./node_modules/core-js/modules/web.timers.js");
__webpack_require__(/*! ../modules/web.url */ "./node_modules/core-js/modules/web.url.js");
__webpack_require__(/*! ../modules/web.url.to-json */ "./node_modules/core-js/modules/web.url.to-json.js");
__webpack_require__(/*! ../modules/web.url-search-params */ "./node_modules/core-js/modules/web.url-search-params.js");

module.exports = __webpack_require__(/*! ../internals/path */ "./node_modules/core-js/internals/path.js");


/***/ }),

/***/ "./node_modules/crypt/crypt.js":
/*!*************************************!*\
  !*** ./node_modules/crypt/crypt.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

(function() {
  var base64map
      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',

  crypt = {
    // Bit-wise rotation left
    rotl: function(n, b) {
      return (n << b) | (n >>> (32 - b));
    },

    // Bit-wise rotation right
    rotr: function(n, b) {
      return (n << (32 - b)) | (n >>> b);
    },

    // Swap big-endian to little-endian and vice versa
    endian: function(n) {
      // If number given, swap endian
      if (n.constructor == Number) {
        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;
      }

      // Else, assume array and swap all items
      for (var i = 0; i < n.length; i++)
        n[i] = crypt.endian(n[i]);
      return n;
    },

    // Generate an array of any length of random bytes
    randomBytes: function(n) {
      for (var bytes = []; n > 0; n--)
        bytes.push(Math.floor(Math.random() * 256));
      return bytes;
    },

    // Convert a byte array to big-endian 32-bit words
    bytesToWords: function(bytes) {
      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
        words[b >>> 5] |= bytes[i] << (24 - b % 32);
      return words;
    },

    // Convert big-endian 32-bit words to a byte array
    wordsToBytes: function(words) {
      for (var bytes = [], b = 0; b < words.length * 32; b += 8)
        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);
      return bytes;
    },

    // Convert a byte array to a hex string
    bytesToHex: function(bytes) {
      for (var hex = [], i = 0; i < bytes.length; i++) {
        hex.push((bytes[i] >>> 4).toString(16));
        hex.push((bytes[i] & 0xF).toString(16));
      }
      return hex.join('');
    },

    // Convert a hex string to a byte array
    hexToBytes: function(hex) {
      for (var bytes = [], c = 0; c < hex.length; c += 2)
        bytes.push(parseInt(hex.substr(c, 2), 16));
      return bytes;
    },

    // Convert a byte array to a base-64 string
    bytesToBase64: function(bytes) {
      for (var base64 = [], i = 0; i < bytes.length; i += 3) {
        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];
        for (var j = 0; j < 4; j++)
          if (i * 8 + j * 6 <= bytes.length * 8)
            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));
          else
            base64.push('=');
      }
      return base64.join('');
    },

    // Convert a base-64 string to a byte array
    base64ToBytes: function(base64) {
      // Remove non-base-64 characters
      base64 = base64.replace(/[^A-Z0-9+\/]/ig, '');

      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;
          imod4 = ++i % 4) {
        if (imod4 == 0) continue;
        bytes.push(((base64map.indexOf(base64.charAt(i - 1))
            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))
            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));
      }
      return bytes;
    }
  };

  module.exports = crypt;
})();


/***/ }),

/***/ "./node_modules/he/he.js":
/*!*******************************!*\
  !*** ./node_modules/he/he.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/he v1.2.0 by @mathias | MIT license */
;(function(root) {

	// Detect free variables `exports`.
	var freeExports =  true && exports;

	// Detect free variable `module`.
	var freeModule =  true && module &&
		module.exports == freeExports && module;

	// Detect free variable `global`, from Node.js or Browserified code,
	// and use it as `root`.
	var freeGlobal = typeof global == 'object' && global;
	if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
		root = freeGlobal;
	}

	/*--------------------------------------------------------------------------*/

	// All astral symbols.
	var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
	// All ASCII symbols (not just printable ASCII) except those listed in the
	// first column of the overrides table.
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides
	var regexAsciiWhitelist = /[\x01-\x7F]/g;
	// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or
	// code points listed in the first column of the overrides table on
	// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.
	var regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g;

	var regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g;
	var encodeMap = {'\xAD':'shy','\u200C':'zwnj','\u200D':'zwj','\u200E':'lrm','\u2063':'ic','\u2062':'it','\u2061':'af','\u200F':'rlm','\u200B':'ZeroWidthSpace','\u2060':'NoBreak','\u0311':'DownBreve','\u20DB':'tdot','\u20DC':'DotDot','\t':'Tab','\n':'NewLine','\u2008':'puncsp','\u205F':'MediumSpace','\u2009':'thinsp','\u200A':'hairsp','\u2004':'emsp13','\u2002':'ensp','\u2005':'emsp14','\u2003':'emsp','\u2007':'numsp','\xA0':'nbsp','\u205F\u200A':'ThickSpace','\u203E':'oline','_':'lowbar','\u2010':'dash','\u2013':'ndash','\u2014':'mdash','\u2015':'horbar',',':'comma',';':'semi','\u204F':'bsemi',':':'colon','\u2A74':'Colone','!':'excl','\xA1':'iexcl','?':'quest','\xBF':'iquest','.':'period','\u2025':'nldr','\u2026':'mldr','\xB7':'middot','\'':'apos','\u2018':'lsquo','\u2019':'rsquo','\u201A':'sbquo','\u2039':'lsaquo','\u203A':'rsaquo','"':'quot','\u201C':'ldquo','\u201D':'rdquo','\u201E':'bdquo','\xAB':'laquo','\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\u2308':'lceil','\u2309':'rceil','\u230A':'lfloor','\u230B':'rfloor','\u2985':'lopar','\u2986':'ropar','\u298B':'lbrke','\u298C':'rbrke','\u298D':'lbrkslu','\u298E':'rbrksld','\u298F':'lbrksld','\u2990':'rbrkslu','\u2991':'langd','\u2992':'rangd','\u2993':'lparlt','\u2994':'rpargt','\u2995':'gtlPar','\u2996':'ltrPar','\u27E6':'lobrk','\u27E7':'robrk','\u27E8':'lang','\u27E9':'rang','\u27EA':'Lang','\u27EB':'Rang','\u27EC':'loang','\u27ED':'roang','\u2772':'lbbrk','\u2773':'rbbrk','\u2016':'Vert','\xA7':'sect','\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\u2030':'permil','\u2031':'pertenk','\u2020':'dagger','\u2021':'Dagger','\u2022':'bull','\u2043':'hybull','\u2032':'prime','\u2033':'Prime','\u2034':'tprime','\u2057':'qprime','\u2035':'bprime','\u2041':'caret','`':'grave','\xB4':'acute','\u02DC':'tilde','^':'Hat','\xAF':'macr','\u02D8':'breve','\u02D9':'dot','\xA8':'die','\u02DA':'ring','\u02DD':'dblac','\xB8':'cedil','\u02DB':'ogon','\u02C6':'circ','\u02C7':'caron','\xB0':'deg','\xA9':'copy','\xAE':'reg','\u2117':'copysr','\u2118':'wp','\u211E':'rx','\u2127':'mho','\u2129':'iiota','\u2190':'larr','\u219A':'nlarr','\u2192':'rarr','\u219B':'nrarr','\u2191':'uarr','\u2193':'darr','\u2194':'harr','\u21AE':'nharr','\u2195':'varr','\u2196':'nwarr','\u2197':'nearr','\u2198':'searr','\u2199':'swarr','\u219D':'rarrw','\u219D\u0338':'nrarrw','\u219E':'Larr','\u219F':'Uarr','\u21A0':'Rarr','\u21A1':'Darr','\u21A2':'larrtl','\u21A3':'rarrtl','\u21A4':'mapstoleft','\u21A5':'mapstoup','\u21A6':'map','\u21A7':'mapstodown','\u21A9':'larrhk','\u21AA':'rarrhk','\u21AB':'larrlp','\u21AC':'rarrlp','\u21AD':'harrw','\u21B0':'lsh','\u21B1':'rsh','\u21B2':'ldsh','\u21B3':'rdsh','\u21B5':'crarr','\u21B6':'cularr','\u21B7':'curarr','\u21BA':'olarr','\u21BB':'orarr','\u21BC':'lharu','\u21BD':'lhard','\u21BE':'uharr','\u21BF':'uharl','\u21C0':'rharu','\u21C1':'rhard','\u21C2':'dharr','\u21C3':'dharl','\u21C4':'rlarr','\u21C5':'udarr','\u21C6':'lrarr','\u21C7':'llarr','\u21C8':'uuarr','\u21C9':'rrarr','\u21CA':'ddarr','\u21CB':'lrhar','\u21CC':'rlhar','\u21D0':'lArr','\u21CD':'nlArr','\u21D1':'uArr','\u21D2':'rArr','\u21CF':'nrArr','\u21D3':'dArr','\u21D4':'iff','\u21CE':'nhArr','\u21D5':'vArr','\u21D6':'nwArr','\u21D7':'neArr','\u21D8':'seArr','\u21D9':'swArr','\u21DA':'lAarr','\u21DB':'rAarr','\u21DD':'zigrarr','\u21E4':'larrb','\u21E5':'rarrb','\u21F5':'duarr','\u21FD':'loarr','\u21FE':'roarr','\u21FF':'hoarr','\u2200':'forall','\u2201':'comp','\u2202':'part','\u2202\u0338':'npart','\u2203':'exist','\u2204':'nexist','\u2205':'empty','\u2207':'Del','\u2208':'in','\u2209':'notin','\u220B':'ni','\u220C':'notni','\u03F6':'bepsi','\u220F':'prod','\u2210':'coprod','\u2211':'sum','+':'plus','\xB1':'pm','\xF7':'div','\xD7':'times','<':'lt','\u226E':'nlt','<\u20D2':'nvlt','=':'equals','\u2260':'ne','=\u20E5':'bne','\u2A75':'Equal','>':'gt','\u226F':'ngt','>\u20D2':'nvgt','\xAC':'not','|':'vert','\xA6':'brvbar','\u2212':'minus','\u2213':'mp','\u2214':'plusdo','\u2044':'frasl','\u2216':'setmn','\u2217':'lowast','\u2218':'compfn','\u221A':'Sqrt','\u221D':'prop','\u221E':'infin','\u221F':'angrt','\u2220':'ang','\u2220\u20D2':'nang','\u2221':'angmsd','\u2222':'angsph','\u2223':'mid','\u2224':'nmid','\u2225':'par','\u2226':'npar','\u2227':'and','\u2228':'or','\u2229':'cap','\u2229\uFE00':'caps','\u222A':'cup','\u222A\uFE00':'cups','\u222B':'int','\u222C':'Int','\u222D':'tint','\u2A0C':'qint','\u222E':'oint','\u222F':'Conint','\u2230':'Cconint','\u2231':'cwint','\u2232':'cwconint','\u2233':'awconint','\u2234':'there4','\u2235':'becaus','\u2236':'ratio','\u2237':'Colon','\u2238':'minusd','\u223A':'mDDot','\u223B':'homtht','\u223C':'sim','\u2241':'nsim','\u223C\u20D2':'nvsim','\u223D':'bsim','\u223D\u0331':'race','\u223E':'ac','\u223E\u0333':'acE','\u223F':'acd','\u2240':'wr','\u2242':'esim','\u2242\u0338':'nesim','\u2243':'sime','\u2244':'nsime','\u2245':'cong','\u2247':'ncong','\u2246':'simne','\u2248':'ap','\u2249':'nap','\u224A':'ape','\u224B':'apid','\u224B\u0338':'napid','\u224C':'bcong','\u224D':'CupCap','\u226D':'NotCupCap','\u224D\u20D2':'nvap','\u224E':'bump','\u224E\u0338':'nbump','\u224F':'bumpe','\u224F\u0338':'nbumpe','\u2250':'doteq','\u2250\u0338':'nedot','\u2251':'eDot','\u2252':'efDot','\u2253':'erDot','\u2254':'colone','\u2255':'ecolon','\u2256':'ecir','\u2257':'cire','\u2259':'wedgeq','\u225A':'veeeq','\u225C':'trie','\u225F':'equest','\u2261':'equiv','\u2262':'nequiv','\u2261\u20E5':'bnequiv','\u2264':'le','\u2270':'nle','\u2264\u20D2':'nvle','\u2265':'ge','\u2271':'nge','\u2265\u20D2':'nvge','\u2266':'lE','\u2266\u0338':'nlE','\u2267':'gE','\u2267\u0338':'ngE','\u2268\uFE00':'lvnE','\u2268':'lnE','\u2269':'gnE','\u2269\uFE00':'gvnE','\u226A':'ll','\u226A\u0338':'nLtv','\u226A\u20D2':'nLt','\u226B':'gg','\u226B\u0338':'nGtv','\u226B\u20D2':'nGt','\u226C':'twixt','\u2272':'lsim','\u2274':'nlsim','\u2273':'gsim','\u2275':'ngsim','\u2276':'lg','\u2278':'ntlg','\u2277':'gl','\u2279':'ntgl','\u227A':'pr','\u2280':'npr','\u227B':'sc','\u2281':'nsc','\u227C':'prcue','\u22E0':'nprcue','\u227D':'sccue','\u22E1':'nsccue','\u227E':'prsim','\u227F':'scsim','\u227F\u0338':'NotSucceedsTilde','\u2282':'sub','\u2284':'nsub','\u2282\u20D2':'vnsub','\u2283':'sup','\u2285':'nsup','\u2283\u20D2':'vnsup','\u2286':'sube','\u2288':'nsube','\u2287':'supe','\u2289':'nsupe','\u228A\uFE00':'vsubne','\u228A':'subne','\u228B\uFE00':'vsupne','\u228B':'supne','\u228D':'cupdot','\u228E':'uplus','\u228F':'sqsub','\u228F\u0338':'NotSquareSubset','\u2290':'sqsup','\u2290\u0338':'NotSquareSuperset','\u2291':'sqsube','\u22E2':'nsqsube','\u2292':'sqsupe','\u22E3':'nsqsupe','\u2293':'sqcap','\u2293\uFE00':'sqcaps','\u2294':'sqcup','\u2294\uFE00':'sqcups','\u2295':'oplus','\u2296':'ominus','\u2297':'otimes','\u2298':'osol','\u2299':'odot','\u229A':'ocir','\u229B':'oast','\u229D':'odash','\u229E':'plusb','\u229F':'minusb','\u22A0':'timesb','\u22A1':'sdotb','\u22A2':'vdash','\u22AC':'nvdash','\u22A3':'dashv','\u22A4':'top','\u22A5':'bot','\u22A7':'models','\u22A8':'vDash','\u22AD':'nvDash','\u22A9':'Vdash','\u22AE':'nVdash','\u22AA':'Vvdash','\u22AB':'VDash','\u22AF':'nVDash','\u22B0':'prurel','\u22B2':'vltri','\u22EA':'nltri','\u22B3':'vrtri','\u22EB':'nrtri','\u22B4':'ltrie','\u22EC':'nltrie','\u22B4\u20D2':'nvltrie','\u22B5':'rtrie','\u22ED':'nrtrie','\u22B5\u20D2':'nvrtrie','\u22B6':'origof','\u22B7':'imof','\u22B8':'mumap','\u22B9':'hercon','\u22BA':'intcal','\u22BB':'veebar','\u22BD':'barvee','\u22BE':'angrtvb','\u22BF':'lrtri','\u22C0':'Wedge','\u22C1':'Vee','\u22C2':'xcap','\u22C3':'xcup','\u22C4':'diam','\u22C5':'sdot','\u22C6':'Star','\u22C7':'divonx','\u22C8':'bowtie','\u22C9':'ltimes','\u22CA':'rtimes','\u22CB':'lthree','\u22CC':'rthree','\u22CD':'bsime','\u22CE':'cuvee','\u22CF':'cuwed','\u22D0':'Sub','\u22D1':'Sup','\u22D2':'Cap','\u22D3':'Cup','\u22D4':'fork','\u22D5':'epar','\u22D6':'ltdot','\u22D7':'gtdot','\u22D8':'Ll','\u22D8\u0338':'nLl','\u22D9':'Gg','\u22D9\u0338':'nGg','\u22DA\uFE00':'lesg','\u22DA':'leg','\u22DB':'gel','\u22DB\uFE00':'gesl','\u22DE':'cuepr','\u22DF':'cuesc','\u22E6':'lnsim','\u22E7':'gnsim','\u22E8':'prnsim','\u22E9':'scnsim','\u22EE':'vellip','\u22EF':'ctdot','\u22F0':'utdot','\u22F1':'dtdot','\u22F2':'disin','\u22F3':'isinsv','\u22F4':'isins','\u22F5':'isindot','\u22F5\u0338':'notindot','\u22F6':'notinvc','\u22F7':'notinvb','\u22F9':'isinE','\u22F9\u0338':'notinE','\u22FA':'nisd','\u22FB':'xnis','\u22FC':'nis','\u22FD':'notnivc','\u22FE':'notnivb','\u2305':'barwed','\u2306':'Barwed','\u230C':'drcrop','\u230D':'dlcrop','\u230E':'urcrop','\u230F':'ulcrop','\u2310':'bnot','\u2312':'profline','\u2313':'profsurf','\u2315':'telrec','\u2316':'target','\u231C':'ulcorn','\u231D':'urcorn','\u231E':'dlcorn','\u231F':'drcorn','\u2322':'frown','\u2323':'smile','\u232D':'cylcty','\u232E':'profalar','\u2336':'topbot','\u233D':'ovbar','\u233F':'solbar','\u237C':'angzarr','\u23B0':'lmoust','\u23B1':'rmoust','\u23B4':'tbrk','\u23B5':'bbrk','\u23B6':'bbrktbrk','\u23DC':'OverParenthesis','\u23DD':'UnderParenthesis','\u23DE':'OverBrace','\u23DF':'UnderBrace','\u23E2':'trpezium','\u23E7':'elinters','\u2423':'blank','\u2500':'boxh','\u2502':'boxv','\u250C':'boxdr','\u2510':'boxdl','\u2514':'boxur','\u2518':'boxul','\u251C':'boxvr','\u2524':'boxvl','\u252C':'boxhd','\u2534':'boxhu','\u253C':'boxvh','\u2550':'boxH','\u2551':'boxV','\u2552':'boxdR','\u2553':'boxDr','\u2554':'boxDR','\u2555':'boxdL','\u2556':'boxDl','\u2557':'boxDL','\u2558':'boxuR','\u2559':'boxUr','\u255A':'boxUR','\u255B':'boxuL','\u255C':'boxUl','\u255D':'boxUL','\u255E':'boxvR','\u255F':'boxVr','\u2560':'boxVR','\u2561':'boxvL','\u2562':'boxVl','\u2563':'boxVL','\u2564':'boxHd','\u2565':'boxhD','\u2566':'boxHD','\u2567':'boxHu','\u2568':'boxhU','\u2569':'boxHU','\u256A':'boxvH','\u256B':'boxVh','\u256C':'boxVH','\u2580':'uhblk','\u2584':'lhblk','\u2588':'block','\u2591':'blk14','\u2592':'blk12','\u2593':'blk34','\u25A1':'squ','\u25AA':'squf','\u25AB':'EmptyVerySmallSquare','\u25AD':'rect','\u25AE':'marker','\u25B1':'fltns','\u25B3':'xutri','\u25B4':'utrif','\u25B5':'utri','\u25B8':'rtrif','\u25B9':'rtri','\u25BD':'xdtri','\u25BE':'dtrif','\u25BF':'dtri','\u25C2':'ltrif','\u25C3':'ltri','\u25CA':'loz','\u25CB':'cir','\u25EC':'tridot','\u25EF':'xcirc','\u25F8':'ultri','\u25F9':'urtri','\u25FA':'lltri','\u25FB':'EmptySmallSquare','\u25FC':'FilledSmallSquare','\u2605':'starf','\u2606':'star','\u260E':'phone','\u2640':'female','\u2642':'male','\u2660':'spades','\u2663':'clubs','\u2665':'hearts','\u2666':'diams','\u266A':'sung','\u2713':'check','\u2717':'cross','\u2720':'malt','\u2736':'sext','\u2758':'VerticalSeparator','\u27C8':'bsolhsub','\u27C9':'suphsol','\u27F5':'xlarr','\u27F6':'xrarr','\u27F7':'xharr','\u27F8':'xlArr','\u27F9':'xrArr','\u27FA':'xhArr','\u27FC':'xmap','\u27FF':'dzigrarr','\u2902':'nvlArr','\u2903':'nvrArr','\u2904':'nvHarr','\u2905':'Map','\u290C':'lbarr','\u290D':'rbarr','\u290E':'lBarr','\u290F':'rBarr','\u2910':'RBarr','\u2911':'DDotrahd','\u2912':'UpArrowBar','\u2913':'DownArrowBar','\u2916':'Rarrtl','\u2919':'latail','\u291A':'ratail','\u291B':'lAtail','\u291C':'rAtail','\u291D':'larrfs','\u291E':'rarrfs','\u291F':'larrbfs','\u2920':'rarrbfs','\u2923':'nwarhk','\u2924':'nearhk','\u2925':'searhk','\u2926':'swarhk','\u2927':'nwnear','\u2928':'toea','\u2929':'tosa','\u292A':'swnwar','\u2933':'rarrc','\u2933\u0338':'nrarrc','\u2935':'cudarrr','\u2936':'ldca','\u2937':'rdca','\u2938':'cudarrl','\u2939':'larrpl','\u293C':'curarrm','\u293D':'cularrp','\u2945':'rarrpl','\u2948':'harrcir','\u2949':'Uarrocir','\u294A':'lurdshar','\u294B':'ldrushar','\u294E':'LeftRightVector','\u294F':'RightUpDownVector','\u2950':'DownLeftRightVector','\u2951':'LeftUpDownVector','\u2952':'LeftVectorBar','\u2953':'RightVectorBar','\u2954':'RightUpVectorBar','\u2955':'RightDownVectorBar','\u2956':'DownLeftVectorBar','\u2957':'DownRightVectorBar','\u2958':'LeftUpVectorBar','\u2959':'LeftDownVectorBar','\u295A':'LeftTeeVector','\u295B':'RightTeeVector','\u295C':'RightUpTeeVector','\u295D':'RightDownTeeVector','\u295E':'DownLeftTeeVector','\u295F':'DownRightTeeVector','\u2960':'LeftUpTeeVector','\u2961':'LeftDownTeeVector','\u2962':'lHar','\u2963':'uHar','\u2964':'rHar','\u2965':'dHar','\u2966':'luruhar','\u2967':'ldrdhar','\u2968':'ruluhar','\u2969':'rdldhar','\u296A':'lharul','\u296B':'llhard','\u296C':'rharul','\u296D':'lrhard','\u296E':'udhar','\u296F':'duhar','\u2970':'RoundImplies','\u2971':'erarr','\u2972':'simrarr','\u2973':'larrsim','\u2974':'rarrsim','\u2975':'rarrap','\u2976':'ltlarr','\u2978':'gtrarr','\u2979':'subrarr','\u297B':'suplarr','\u297C':'lfisht','\u297D':'rfisht','\u297E':'ufisht','\u297F':'dfisht','\u299A':'vzigzag','\u299C':'vangrt','\u299D':'angrtvbd','\u29A4':'ange','\u29A5':'range','\u29A6':'dwangle','\u29A7':'uwangle','\u29A8':'angmsdaa','\u29A9':'angmsdab','\u29AA':'angmsdac','\u29AB':'angmsdad','\u29AC':'angmsdae','\u29AD':'angmsdaf','\u29AE':'angmsdag','\u29AF':'angmsdah','\u29B0':'bemptyv','\u29B1':'demptyv','\u29B2':'cemptyv','\u29B3':'raemptyv','\u29B4':'laemptyv','\u29B5':'ohbar','\u29B6':'omid','\u29B7':'opar','\u29B9':'operp','\u29BB':'olcross','\u29BC':'odsold','\u29BE':'olcir','\u29BF':'ofcir','\u29C0':'olt','\u29C1':'ogt','\u29C2':'cirscir','\u29C3':'cirE','\u29C4':'solb','\u29C5':'bsolb','\u29C9':'boxbox','\u29CD':'trisb','\u29CE':'rtriltri','\u29CF':'LeftTriangleBar','\u29CF\u0338':'NotLeftTriangleBar','\u29D0':'RightTriangleBar','\u29D0\u0338':'NotRightTriangleBar','\u29DC':'iinfin','\u29DD':'infintie','\u29DE':'nvinfin','\u29E3':'eparsl','\u29E4':'smeparsl','\u29E5':'eqvparsl','\u29EB':'lozf','\u29F4':'RuleDelayed','\u29F6':'dsol','\u2A00':'xodot','\u2A01':'xoplus','\u2A02':'xotime','\u2A04':'xuplus','\u2A06':'xsqcup','\u2A0D':'fpartint','\u2A10':'cirfnint','\u2A11':'awint','\u2A12':'rppolint','\u2A13':'scpolint','\u2A14':'npolint','\u2A15':'pointint','\u2A16':'quatint','\u2A17':'intlarhk','\u2A22':'pluscir','\u2A23':'plusacir','\u2A24':'simplus','\u2A25':'plusdu','\u2A26':'plussim','\u2A27':'plustwo','\u2A29':'mcomma','\u2A2A':'minusdu','\u2A2D':'loplus','\u2A2E':'roplus','\u2A2F':'Cross','\u2A30':'timesd','\u2A31':'timesbar','\u2A33':'smashp','\u2A34':'lotimes','\u2A35':'rotimes','\u2A36':'otimesas','\u2A37':'Otimes','\u2A38':'odiv','\u2A39':'triplus','\u2A3A':'triminus','\u2A3B':'tritime','\u2A3C':'iprod','\u2A3F':'amalg','\u2A40':'capdot','\u2A42':'ncup','\u2A43':'ncap','\u2A44':'capand','\u2A45':'cupor','\u2A46':'cupcap','\u2A47':'capcup','\u2A48':'cupbrcap','\u2A49':'capbrcup','\u2A4A':'cupcup','\u2A4B':'capcap','\u2A4C':'ccups','\u2A4D':'ccaps','\u2A50':'ccupssm','\u2A53':'And','\u2A54':'Or','\u2A55':'andand','\u2A56':'oror','\u2A57':'orslope','\u2A58':'andslope','\u2A5A':'andv','\u2A5B':'orv','\u2A5C':'andd','\u2A5D':'ord','\u2A5F':'wedbar','\u2A66':'sdote','\u2A6A':'simdot','\u2A6D':'congdot','\u2A6D\u0338':'ncongdot','\u2A6E':'easter','\u2A6F':'apacir','\u2A70':'apE','\u2A70\u0338':'napE','\u2A71':'eplus','\u2A72':'pluse','\u2A73':'Esim','\u2A77':'eDDot','\u2A78':'equivDD','\u2A79':'ltcir','\u2A7A':'gtcir','\u2A7B':'ltquest','\u2A7C':'gtquest','\u2A7D':'les','\u2A7D\u0338':'nles','\u2A7E':'ges','\u2A7E\u0338':'nges','\u2A7F':'lesdot','\u2A80':'gesdot','\u2A81':'lesdoto','\u2A82':'gesdoto','\u2A83':'lesdotor','\u2A84':'gesdotol','\u2A85':'lap','\u2A86':'gap','\u2A87':'lne','\u2A88':'gne','\u2A89':'lnap','\u2A8A':'gnap','\u2A8B':'lEg','\u2A8C':'gEl','\u2A8D':'lsime','\u2A8E':'gsime','\u2A8F':'lsimg','\u2A90':'gsiml','\u2A91':'lgE','\u2A92':'glE','\u2A93':'lesges','\u2A94':'gesles','\u2A95':'els','\u2A96':'egs','\u2A97':'elsdot','\u2A98':'egsdot','\u2A99':'el','\u2A9A':'eg','\u2A9D':'siml','\u2A9E':'simg','\u2A9F':'simlE','\u2AA0':'simgE','\u2AA1':'LessLess','\u2AA1\u0338':'NotNestedLessLess','\u2AA2':'GreaterGreater','\u2AA2\u0338':'NotNestedGreaterGreater','\u2AA4':'glj','\u2AA5':'gla','\u2AA6':'ltcc','\u2AA7':'gtcc','\u2AA8':'lescc','\u2AA9':'gescc','\u2AAA':'smt','\u2AAB':'lat','\u2AAC':'smte','\u2AAC\uFE00':'smtes','\u2AAD':'late','\u2AAD\uFE00':'lates','\u2AAE':'bumpE','\u2AAF':'pre','\u2AAF\u0338':'npre','\u2AB0':'sce','\u2AB0\u0338':'nsce','\u2AB3':'prE','\u2AB4':'scE','\u2AB5':'prnE','\u2AB6':'scnE','\u2AB7':'prap','\u2AB8':'scap','\u2AB9':'prnap','\u2ABA':'scnap','\u2ABB':'Pr','\u2ABC':'Sc','\u2ABD':'subdot','\u2ABE':'supdot','\u2ABF':'subplus','\u2AC0':'supplus','\u2AC1':'submult','\u2AC2':'supmult','\u2AC3':'subedot','\u2AC4':'supedot','\u2AC5':'subE','\u2AC5\u0338':'nsubE','\u2AC6':'supE','\u2AC6\u0338':'nsupE','\u2AC7':'subsim','\u2AC8':'supsim','\u2ACB\uFE00':'vsubnE','\u2ACB':'subnE','\u2ACC\uFE00':'vsupnE','\u2ACC':'supnE','\u2ACF':'csub','\u2AD0':'csup','\u2AD1':'csube','\u2AD2':'csupe','\u2AD3':'subsup','\u2AD4':'supsub','\u2AD5':'subsub','\u2AD6':'supsup','\u2AD7':'suphsub','\u2AD8':'supdsub','\u2AD9':'forkv','\u2ADA':'topfork','\u2ADB':'mlcp','\u2AE4':'Dashv','\u2AE6':'Vdashl','\u2AE7':'Barv','\u2AE8':'vBar','\u2AE9':'vBarv','\u2AEB':'Vbar','\u2AEC':'Not','\u2AED':'bNot','\u2AEE':'rnmid','\u2AEF':'cirmid','\u2AF0':'midcir','\u2AF1':'topcir','\u2AF2':'nhpar','\u2AF3':'parsim','\u2AFD':'parsl','\u2AFD\u20E5':'nparsl','\u266D':'flat','\u266E':'natur','\u266F':'sharp','\xA4':'curren','\xA2':'cent','$':'dollar','\xA3':'pound','\xA5':'yen','\u20AC':'euro','\xB9':'sup1','\xBD':'half','\u2153':'frac13','\xBC':'frac14','\u2155':'frac15','\u2159':'frac16','\u215B':'frac18','\xB2':'sup2','\u2154':'frac23','\u2156':'frac25','\xB3':'sup3','\xBE':'frac34','\u2157':'frac35','\u215C':'frac38','\u2158':'frac45','\u215A':'frac56','\u215D':'frac58','\u215E':'frac78','\uD835\uDCB6':'ascr','\uD835\uDD52':'aopf','\uD835\uDD1E':'afr','\uD835\uDD38':'Aopf','\uD835\uDD04':'Afr','\uD835\uDC9C':'Ascr','\xAA':'ordf','\xE1':'aacute','\xC1':'Aacute','\xE0':'agrave','\xC0':'Agrave','\u0103':'abreve','\u0102':'Abreve','\xE2':'acirc','\xC2':'Acirc','\xE5':'aring','\xC5':'angst','\xE4':'auml','\xC4':'Auml','\xE3':'atilde','\xC3':'Atilde','\u0105':'aogon','\u0104':'Aogon','\u0101':'amacr','\u0100':'Amacr','\xE6':'aelig','\xC6':'AElig','\uD835\uDCB7':'bscr','\uD835\uDD53':'bopf','\uD835\uDD1F':'bfr','\uD835\uDD39':'Bopf','\u212C':'Bscr','\uD835\uDD05':'Bfr','\uD835\uDD20':'cfr','\uD835\uDCB8':'cscr','\uD835\uDD54':'copf','\u212D':'Cfr','\uD835\uDC9E':'Cscr','\u2102':'Copf','\u0107':'cacute','\u0106':'Cacute','\u0109':'ccirc','\u0108':'Ccirc','\u010D':'ccaron','\u010C':'Ccaron','\u010B':'cdot','\u010A':'Cdot','\xE7':'ccedil','\xC7':'Ccedil','\u2105':'incare','\uD835\uDD21':'dfr','\u2146':'dd','\uD835\uDD55':'dopf','\uD835\uDCB9':'dscr','\uD835\uDC9F':'Dscr','\uD835\uDD07':'Dfr','\u2145':'DD','\uD835\uDD3B':'Dopf','\u010F':'dcaron','\u010E':'Dcaron','\u0111':'dstrok','\u0110':'Dstrok','\xF0':'eth','\xD0':'ETH','\u2147':'ee','\u212F':'escr','\uD835\uDD22':'efr','\uD835\uDD56':'eopf','\u2130':'Escr','\uD835\uDD08':'Efr','\uD835\uDD3C':'Eopf','\xE9':'eacute','\xC9':'Eacute','\xE8':'egrave','\xC8':'Egrave','\xEA':'ecirc','\xCA':'Ecirc','\u011B':'ecaron','\u011A':'Ecaron','\xEB':'euml','\xCB':'Euml','\u0117':'edot','\u0116':'Edot','\u0119':'eogon','\u0118':'Eogon','\u0113':'emacr','\u0112':'Emacr','\uD835\uDD23':'ffr','\uD835\uDD57':'fopf','\uD835\uDCBB':'fscr','\uD835\uDD09':'Ffr','\uD835\uDD3D':'Fopf','\u2131':'Fscr','\uFB00':'fflig','\uFB03':'ffilig','\uFB04':'ffllig','\uFB01':'filig','fj':'fjlig','\uFB02':'fllig','\u0192':'fnof','\u210A':'gscr','\uD835\uDD58':'gopf','\uD835\uDD24':'gfr','\uD835\uDCA2':'Gscr','\uD835\uDD3E':'Gopf','\uD835\uDD0A':'Gfr','\u01F5':'gacute','\u011F':'gbreve','\u011E':'Gbreve','\u011D':'gcirc','\u011C':'Gcirc','\u0121':'gdot','\u0120':'Gdot','\u0122':'Gcedil','\uD835\uDD25':'hfr','\u210E':'planckh','\uD835\uDCBD':'hscr','\uD835\uDD59':'hopf','\u210B':'Hscr','\u210C':'Hfr','\u210D':'Hopf','\u0125':'hcirc','\u0124':'Hcirc','\u210F':'hbar','\u0127':'hstrok','\u0126':'Hstrok','\uD835\uDD5A':'iopf','\uD835\uDD26':'ifr','\uD835\uDCBE':'iscr','\u2148':'ii','\uD835\uDD40':'Iopf','\u2110':'Iscr','\u2111':'Im','\xED':'iacute','\xCD':'Iacute','\xEC':'igrave','\xCC':'Igrave','\xEE':'icirc','\xCE':'Icirc','\xEF':'iuml','\xCF':'Iuml','\u0129':'itilde','\u0128':'Itilde','\u0130':'Idot','\u012F':'iogon','\u012E':'Iogon','\u012B':'imacr','\u012A':'Imacr','\u0133':'ijlig','\u0132':'IJlig','\u0131':'imath','\uD835\uDCBF':'jscr','\uD835\uDD5B':'jopf','\uD835\uDD27':'jfr','\uD835\uDCA5':'Jscr','\uD835\uDD0D':'Jfr','\uD835\uDD41':'Jopf','\u0135':'jcirc','\u0134':'Jcirc','\u0237':'jmath','\uD835\uDD5C':'kopf','\uD835\uDCC0':'kscr','\uD835\uDD28':'kfr','\uD835\uDCA6':'Kscr','\uD835\uDD42':'Kopf','\uD835\uDD0E':'Kfr','\u0137':'kcedil','\u0136':'Kcedil','\uD835\uDD29':'lfr','\uD835\uDCC1':'lscr','\u2113':'ell','\uD835\uDD5D':'lopf','\u2112':'Lscr','\uD835\uDD0F':'Lfr','\uD835\uDD43':'Lopf','\u013A':'lacute','\u0139':'Lacute','\u013E':'lcaron','\u013D':'Lcaron','\u013C':'lcedil','\u013B':'Lcedil','\u0142':'lstrok','\u0141':'Lstrok','\u0140':'lmidot','\u013F':'Lmidot','\uD835\uDD2A':'mfr','\uD835\uDD5E':'mopf','\uD835\uDCC2':'mscr','\uD835\uDD10':'Mfr','\uD835\uDD44':'Mopf','\u2133':'Mscr','\uD835\uDD2B':'nfr','\uD835\uDD5F':'nopf','\uD835\uDCC3':'nscr','\u2115':'Nopf','\uD835\uDCA9':'Nscr','\uD835\uDD11':'Nfr','\u0144':'nacute','\u0143':'Nacute','\u0148':'ncaron','\u0147':'Ncaron','\xF1':'ntilde','\xD1':'Ntilde','\u0146':'ncedil','\u0145':'Ncedil','\u2116':'numero','\u014B':'eng','\u014A':'ENG','\uD835\uDD60':'oopf','\uD835\uDD2C':'ofr','\u2134':'oscr','\uD835\uDCAA':'Oscr','\uD835\uDD12':'Ofr','\uD835\uDD46':'Oopf','\xBA':'ordm','\xF3':'oacute','\xD3':'Oacute','\xF2':'ograve','\xD2':'Ograve','\xF4':'ocirc','\xD4':'Ocirc','\xF6':'ouml','\xD6':'Ouml','\u0151':'odblac','\u0150':'Odblac','\xF5':'otilde','\xD5':'Otilde','\xF8':'oslash','\xD8':'Oslash','\u014D':'omacr','\u014C':'Omacr','\u0153':'oelig','\u0152':'OElig','\uD835\uDD2D':'pfr','\uD835\uDCC5':'pscr','\uD835\uDD61':'popf','\u2119':'Popf','\uD835\uDD13':'Pfr','\uD835\uDCAB':'Pscr','\uD835\uDD62':'qopf','\uD835\uDD2E':'qfr','\uD835\uDCC6':'qscr','\uD835\uDCAC':'Qscr','\uD835\uDD14':'Qfr','\u211A':'Qopf','\u0138':'kgreen','\uD835\uDD2F':'rfr','\uD835\uDD63':'ropf','\uD835\uDCC7':'rscr','\u211B':'Rscr','\u211C':'Re','\u211D':'Ropf','\u0155':'racute','\u0154':'Racute','\u0159':'rcaron','\u0158':'Rcaron','\u0157':'rcedil','\u0156':'Rcedil','\uD835\uDD64':'sopf','\uD835\uDCC8':'sscr','\uD835\uDD30':'sfr','\uD835\uDD4A':'Sopf','\uD835\uDD16':'Sfr','\uD835\uDCAE':'Sscr','\u24C8':'oS','\u015B':'sacute','\u015A':'Sacute','\u015D':'scirc','\u015C':'Scirc','\u0161':'scaron','\u0160':'Scaron','\u015F':'scedil','\u015E':'Scedil','\xDF':'szlig','\uD835\uDD31':'tfr','\uD835\uDCC9':'tscr','\uD835\uDD65':'topf','\uD835\uDCAF':'Tscr','\uD835\uDD17':'Tfr','\uD835\uDD4B':'Topf','\u0165':'tcaron','\u0164':'Tcaron','\u0163':'tcedil','\u0162':'Tcedil','\u2122':'trade','\u0167':'tstrok','\u0166':'Tstrok','\uD835\uDCCA':'uscr','\uD835\uDD66':'uopf','\uD835\uDD32':'ufr','\uD835\uDD4C':'Uopf','\uD835\uDD18':'Ufr','\uD835\uDCB0':'Uscr','\xFA':'uacute','\xDA':'Uacute','\xF9':'ugrave','\xD9':'Ugrave','\u016D':'ubreve','\u016C':'Ubreve','\xFB':'ucirc','\xDB':'Ucirc','\u016F':'uring','\u016E':'Uring','\xFC':'uuml','\xDC':'Uuml','\u0171':'udblac','\u0170':'Udblac','\u0169':'utilde','\u0168':'Utilde','\u0173':'uogon','\u0172':'Uogon','\u016B':'umacr','\u016A':'Umacr','\uD835\uDD33':'vfr','\uD835\uDD67':'vopf','\uD835\uDCCB':'vscr','\uD835\uDD19':'Vfr','\uD835\uDD4D':'Vopf','\uD835\uDCB1':'Vscr','\uD835\uDD68':'wopf','\uD835\uDCCC':'wscr','\uD835\uDD34':'wfr','\uD835\uDCB2':'Wscr','\uD835\uDD4E':'Wopf','\uD835\uDD1A':'Wfr','\u0175':'wcirc','\u0174':'Wcirc','\uD835\uDD35':'xfr','\uD835\uDCCD':'xscr','\uD835\uDD69':'xopf','\uD835\uDD4F':'Xopf','\uD835\uDD1B':'Xfr','\uD835\uDCB3':'Xscr','\uD835\uDD36':'yfr','\uD835\uDCCE':'yscr','\uD835\uDD6A':'yopf','\uD835\uDCB4':'Yscr','\uD835\uDD1C':'Yfr','\uD835\uDD50':'Yopf','\xFD':'yacute','\xDD':'Yacute','\u0177':'ycirc','\u0176':'Ycirc','\xFF':'yuml','\u0178':'Yuml','\uD835\uDCCF':'zscr','\uD835\uDD37':'zfr','\uD835\uDD6B':'zopf','\u2128':'Zfr','\u2124':'Zopf','\uD835\uDCB5':'Zscr','\u017A':'zacute','\u0179':'Zacute','\u017E':'zcaron','\u017D':'Zcaron','\u017C':'zdot','\u017B':'Zdot','\u01B5':'imped','\xFE':'thorn','\xDE':'THORN','\u0149':'napos','\u03B1':'alpha','\u0391':'Alpha','\u03B2':'beta','\u0392':'Beta','\u03B3':'gamma','\u0393':'Gamma','\u03B4':'delta','\u0394':'Delta','\u03B5':'epsi','\u03F5':'epsiv','\u0395':'Epsilon','\u03DD':'gammad','\u03DC':'Gammad','\u03B6':'zeta','\u0396':'Zeta','\u03B7':'eta','\u0397':'Eta','\u03B8':'theta','\u03D1':'thetav','\u0398':'Theta','\u03B9':'iota','\u0399':'Iota','\u03BA':'kappa','\u03F0':'kappav','\u039A':'Kappa','\u03BB':'lambda','\u039B':'Lambda','\u03BC':'mu','\xB5':'micro','\u039C':'Mu','\u03BD':'nu','\u039D':'Nu','\u03BE':'xi','\u039E':'Xi','\u03BF':'omicron','\u039F':'Omicron','\u03C0':'pi','\u03D6':'piv','\u03A0':'Pi','\u03C1':'rho','\u03F1':'rhov','\u03A1':'Rho','\u03C3':'sigma','\u03A3':'Sigma','\u03C2':'sigmaf','\u03C4':'tau','\u03A4':'Tau','\u03C5':'upsi','\u03A5':'Upsilon','\u03D2':'Upsi','\u03C6':'phi','\u03D5':'phiv','\u03A6':'Phi','\u03C7':'chi','\u03A7':'Chi','\u03C8':'psi','\u03A8':'Psi','\u03C9':'omega','\u03A9':'ohm','\u0430':'acy','\u0410':'Acy','\u0431':'bcy','\u0411':'Bcy','\u0432':'vcy','\u0412':'Vcy','\u0433':'gcy','\u0413':'Gcy','\u0453':'gjcy','\u0403':'GJcy','\u0434':'dcy','\u0414':'Dcy','\u0452':'djcy','\u0402':'DJcy','\u0435':'iecy','\u0415':'IEcy','\u0451':'iocy','\u0401':'IOcy','\u0454':'jukcy','\u0404':'Jukcy','\u0436':'zhcy','\u0416':'ZHcy','\u0437':'zcy','\u0417':'Zcy','\u0455':'dscy','\u0405':'DScy','\u0438':'icy','\u0418':'Icy','\u0456':'iukcy','\u0406':'Iukcy','\u0457':'yicy','\u0407':'YIcy','\u0439':'jcy','\u0419':'Jcy','\u0458':'jsercy','\u0408':'Jsercy','\u043A':'kcy','\u041A':'Kcy','\u045C':'kjcy','\u040C':'KJcy','\u043B':'lcy','\u041B':'Lcy','\u0459':'ljcy','\u0409':'LJcy','\u043C':'mcy','\u041C':'Mcy','\u043D':'ncy','\u041D':'Ncy','\u045A':'njcy','\u040A':'NJcy','\u043E':'ocy','\u041E':'Ocy','\u043F':'pcy','\u041F':'Pcy','\u0440':'rcy','\u0420':'Rcy','\u0441':'scy','\u0421':'Scy','\u0442':'tcy','\u0422':'Tcy','\u045B':'tshcy','\u040B':'TSHcy','\u0443':'ucy','\u0423':'Ucy','\u045E':'ubrcy','\u040E':'Ubrcy','\u0444':'fcy','\u0424':'Fcy','\u0445':'khcy','\u0425':'KHcy','\u0446':'tscy','\u0426':'TScy','\u0447':'chcy','\u0427':'CHcy','\u045F':'dzcy','\u040F':'DZcy','\u0448':'shcy','\u0428':'SHcy','\u0449':'shchcy','\u0429':'SHCHcy','\u044A':'hardcy','\u042A':'HARDcy','\u044B':'ycy','\u042B':'Ycy','\u044C':'softcy','\u042C':'SOFTcy','\u044D':'ecy','\u042D':'Ecy','\u044E':'yucy','\u042E':'YUcy','\u044F':'yacy','\u042F':'YAcy','\u2135':'aleph','\u2136':'beth','\u2137':'gimel','\u2138':'daleth'};

	var regexEscape = /["&'<>`]/g;
	var escapeMap = {
		'"': '&quot;',
		'&': '&amp;',
		'\'': '&#x27;',
		'<': '&lt;',
		// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the
		// following is not strictly necessary unless it’s part of a tag or an
		// unquoted attribute value. We’re only escaping it to support those
		// situations, and for XML support.
		'>': '&gt;',
		// In Internet Explorer ≤ 8, the backtick character can be used
		// to break out of (un)quoted attribute values or HTML comments.
		// See http://html5sec.org/#102, http://html5sec.org/#108, and
		// http://html5sec.org/#133.
		'`': '&#x60;'
	};

	var regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;
	var regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
	var regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g;
	var decodeMap = {'aacute':'\xE1','Aacute':'\xC1','abreve':'\u0103','Abreve':'\u0102','ac':'\u223E','acd':'\u223F','acE':'\u223E\u0333','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','acy':'\u0430','Acy':'\u0410','aelig':'\xE6','AElig':'\xC6','af':'\u2061','afr':'\uD835\uDD1E','Afr':'\uD835\uDD04','agrave':'\xE0','Agrave':'\xC0','alefsym':'\u2135','aleph':'\u2135','alpha':'\u03B1','Alpha':'\u0391','amacr':'\u0101','Amacr':'\u0100','amalg':'\u2A3F','amp':'&','AMP':'&','and':'\u2227','And':'\u2A53','andand':'\u2A55','andd':'\u2A5C','andslope':'\u2A58','andv':'\u2A5A','ang':'\u2220','ange':'\u29A4','angle':'\u2220','angmsd':'\u2221','angmsdaa':'\u29A8','angmsdab':'\u29A9','angmsdac':'\u29AA','angmsdad':'\u29AB','angmsdae':'\u29AC','angmsdaf':'\u29AD','angmsdag':'\u29AE','angmsdah':'\u29AF','angrt':'\u221F','angrtvb':'\u22BE','angrtvbd':'\u299D','angsph':'\u2222','angst':'\xC5','angzarr':'\u237C','aogon':'\u0105','Aogon':'\u0104','aopf':'\uD835\uDD52','Aopf':'\uD835\uDD38','ap':'\u2248','apacir':'\u2A6F','ape':'\u224A','apE':'\u2A70','apid':'\u224B','apos':'\'','ApplyFunction':'\u2061','approx':'\u2248','approxeq':'\u224A','aring':'\xE5','Aring':'\xC5','ascr':'\uD835\uDCB6','Ascr':'\uD835\uDC9C','Assign':'\u2254','ast':'*','asymp':'\u2248','asympeq':'\u224D','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','awconint':'\u2233','awint':'\u2A11','backcong':'\u224C','backepsilon':'\u03F6','backprime':'\u2035','backsim':'\u223D','backsimeq':'\u22CD','Backslash':'\u2216','Barv':'\u2AE7','barvee':'\u22BD','barwed':'\u2305','Barwed':'\u2306','barwedge':'\u2305','bbrk':'\u23B5','bbrktbrk':'\u23B6','bcong':'\u224C','bcy':'\u0431','Bcy':'\u0411','bdquo':'\u201E','becaus':'\u2235','because':'\u2235','Because':'\u2235','bemptyv':'\u29B0','bepsi':'\u03F6','bernou':'\u212C','Bernoullis':'\u212C','beta':'\u03B2','Beta':'\u0392','beth':'\u2136','between':'\u226C','bfr':'\uD835\uDD1F','Bfr':'\uD835\uDD05','bigcap':'\u22C2','bigcirc':'\u25EF','bigcup':'\u22C3','bigodot':'\u2A00','bigoplus':'\u2A01','bigotimes':'\u2A02','bigsqcup':'\u2A06','bigstar':'\u2605','bigtriangledown':'\u25BD','bigtriangleup':'\u25B3','biguplus':'\u2A04','bigvee':'\u22C1','bigwedge':'\u22C0','bkarow':'\u290D','blacklozenge':'\u29EB','blacksquare':'\u25AA','blacktriangle':'\u25B4','blacktriangledown':'\u25BE','blacktriangleleft':'\u25C2','blacktriangleright':'\u25B8','blank':'\u2423','blk12':'\u2592','blk14':'\u2591','blk34':'\u2593','block':'\u2588','bne':'=\u20E5','bnequiv':'\u2261\u20E5','bnot':'\u2310','bNot':'\u2AED','bopf':'\uD835\uDD53','Bopf':'\uD835\uDD39','bot':'\u22A5','bottom':'\u22A5','bowtie':'\u22C8','boxbox':'\u29C9','boxdl':'\u2510','boxdL':'\u2555','boxDl':'\u2556','boxDL':'\u2557','boxdr':'\u250C','boxdR':'\u2552','boxDr':'\u2553','boxDR':'\u2554','boxh':'\u2500','boxH':'\u2550','boxhd':'\u252C','boxhD':'\u2565','boxHd':'\u2564','boxHD':'\u2566','boxhu':'\u2534','boxhU':'\u2568','boxHu':'\u2567','boxHU':'\u2569','boxminus':'\u229F','boxplus':'\u229E','boxtimes':'\u22A0','boxul':'\u2518','boxuL':'\u255B','boxUl':'\u255C','boxUL':'\u255D','boxur':'\u2514','boxuR':'\u2558','boxUr':'\u2559','boxUR':'\u255A','boxv':'\u2502','boxV':'\u2551','boxvh':'\u253C','boxvH':'\u256A','boxVh':'\u256B','boxVH':'\u256C','boxvl':'\u2524','boxvL':'\u2561','boxVl':'\u2562','boxVL':'\u2563','boxvr':'\u251C','boxvR':'\u255E','boxVr':'\u255F','boxVR':'\u2560','bprime':'\u2035','breve':'\u02D8','Breve':'\u02D8','brvbar':'\xA6','bscr':'\uD835\uDCB7','Bscr':'\u212C','bsemi':'\u204F','bsim':'\u223D','bsime':'\u22CD','bsol':'\\','bsolb':'\u29C5','bsolhsub':'\u27C8','bull':'\u2022','bullet':'\u2022','bump':'\u224E','bumpe':'\u224F','bumpE':'\u2AAE','bumpeq':'\u224F','Bumpeq':'\u224E','cacute':'\u0107','Cacute':'\u0106','cap':'\u2229','Cap':'\u22D2','capand':'\u2A44','capbrcup':'\u2A49','capcap':'\u2A4B','capcup':'\u2A47','capdot':'\u2A40','CapitalDifferentialD':'\u2145','caps':'\u2229\uFE00','caret':'\u2041','caron':'\u02C7','Cayleys':'\u212D','ccaps':'\u2A4D','ccaron':'\u010D','Ccaron':'\u010C','ccedil':'\xE7','Ccedil':'\xC7','ccirc':'\u0109','Ccirc':'\u0108','Cconint':'\u2230','ccups':'\u2A4C','ccupssm':'\u2A50','cdot':'\u010B','Cdot':'\u010A','cedil':'\xB8','Cedilla':'\xB8','cemptyv':'\u29B2','cent':'\xA2','centerdot':'\xB7','CenterDot':'\xB7','cfr':'\uD835\uDD20','Cfr':'\u212D','chcy':'\u0447','CHcy':'\u0427','check':'\u2713','checkmark':'\u2713','chi':'\u03C7','Chi':'\u03A7','cir':'\u25CB','circ':'\u02C6','circeq':'\u2257','circlearrowleft':'\u21BA','circlearrowright':'\u21BB','circledast':'\u229B','circledcirc':'\u229A','circleddash':'\u229D','CircleDot':'\u2299','circledR':'\xAE','circledS':'\u24C8','CircleMinus':'\u2296','CirclePlus':'\u2295','CircleTimes':'\u2297','cire':'\u2257','cirE':'\u29C3','cirfnint':'\u2A10','cirmid':'\u2AEF','cirscir':'\u29C2','ClockwiseContourIntegral':'\u2232','CloseCurlyDoubleQuote':'\u201D','CloseCurlyQuote':'\u2019','clubs':'\u2663','clubsuit':'\u2663','colon':':','Colon':'\u2237','colone':'\u2254','Colone':'\u2A74','coloneq':'\u2254','comma':',','commat':'@','comp':'\u2201','compfn':'\u2218','complement':'\u2201','complexes':'\u2102','cong':'\u2245','congdot':'\u2A6D','Congruent':'\u2261','conint':'\u222E','Conint':'\u222F','ContourIntegral':'\u222E','copf':'\uD835\uDD54','Copf':'\u2102','coprod':'\u2210','Coproduct':'\u2210','copy':'\xA9','COPY':'\xA9','copysr':'\u2117','CounterClockwiseContourIntegral':'\u2233','crarr':'\u21B5','cross':'\u2717','Cross':'\u2A2F','cscr':'\uD835\uDCB8','Cscr':'\uD835\uDC9E','csub':'\u2ACF','csube':'\u2AD1','csup':'\u2AD0','csupe':'\u2AD2','ctdot':'\u22EF','cudarrl':'\u2938','cudarrr':'\u2935','cuepr':'\u22DE','cuesc':'\u22DF','cularr':'\u21B6','cularrp':'\u293D','cup':'\u222A','Cup':'\u22D3','cupbrcap':'\u2A48','cupcap':'\u2A46','CupCap':'\u224D','cupcup':'\u2A4A','cupdot':'\u228D','cupor':'\u2A45','cups':'\u222A\uFE00','curarr':'\u21B7','curarrm':'\u293C','curlyeqprec':'\u22DE','curlyeqsucc':'\u22DF','curlyvee':'\u22CE','curlywedge':'\u22CF','curren':'\xA4','curvearrowleft':'\u21B6','curvearrowright':'\u21B7','cuvee':'\u22CE','cuwed':'\u22CF','cwconint':'\u2232','cwint':'\u2231','cylcty':'\u232D','dagger':'\u2020','Dagger':'\u2021','daleth':'\u2138','darr':'\u2193','dArr':'\u21D3','Darr':'\u21A1','dash':'\u2010','dashv':'\u22A3','Dashv':'\u2AE4','dbkarow':'\u290F','dblac':'\u02DD','dcaron':'\u010F','Dcaron':'\u010E','dcy':'\u0434','Dcy':'\u0414','dd':'\u2146','DD':'\u2145','ddagger':'\u2021','ddarr':'\u21CA','DDotrahd':'\u2911','ddotseq':'\u2A77','deg':'\xB0','Del':'\u2207','delta':'\u03B4','Delta':'\u0394','demptyv':'\u29B1','dfisht':'\u297F','dfr':'\uD835\uDD21','Dfr':'\uD835\uDD07','dHar':'\u2965','dharl':'\u21C3','dharr':'\u21C2','DiacriticalAcute':'\xB4','DiacriticalDot':'\u02D9','DiacriticalDoubleAcute':'\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\u02DC','diam':'\u22C4','diamond':'\u22C4','Diamond':'\u22C4','diamondsuit':'\u2666','diams':'\u2666','die':'\xA8','DifferentialD':'\u2146','digamma':'\u03DD','disin':'\u22F2','div':'\xF7','divide':'\xF7','divideontimes':'\u22C7','divonx':'\u22C7','djcy':'\u0452','DJcy':'\u0402','dlcorn':'\u231E','dlcrop':'\u230D','dollar':'$','dopf':'\uD835\uDD55','Dopf':'\uD835\uDD3B','dot':'\u02D9','Dot':'\xA8','DotDot':'\u20DC','doteq':'\u2250','doteqdot':'\u2251','DotEqual':'\u2250','dotminus':'\u2238','dotplus':'\u2214','dotsquare':'\u22A1','doublebarwedge':'\u2306','DoubleContourIntegral':'\u222F','DoubleDot':'\xA8','DoubleDownArrow':'\u21D3','DoubleLeftArrow':'\u21D0','DoubleLeftRightArrow':'\u21D4','DoubleLeftTee':'\u2AE4','DoubleLongLeftArrow':'\u27F8','DoubleLongLeftRightArrow':'\u27FA','DoubleLongRightArrow':'\u27F9','DoubleRightArrow':'\u21D2','DoubleRightTee':'\u22A8','DoubleUpArrow':'\u21D1','DoubleUpDownArrow':'\u21D5','DoubleVerticalBar':'\u2225','downarrow':'\u2193','Downarrow':'\u21D3','DownArrow':'\u2193','DownArrowBar':'\u2913','DownArrowUpArrow':'\u21F5','DownBreve':'\u0311','downdownarrows':'\u21CA','downharpoonleft':'\u21C3','downharpoonright':'\u21C2','DownLeftRightVector':'\u2950','DownLeftTeeVector':'\u295E','DownLeftVector':'\u21BD','DownLeftVectorBar':'\u2956','DownRightTeeVector':'\u295F','DownRightVector':'\u21C1','DownRightVectorBar':'\u2957','DownTee':'\u22A4','DownTeeArrow':'\u21A7','drbkarow':'\u2910','drcorn':'\u231F','drcrop':'\u230C','dscr':'\uD835\uDCB9','Dscr':'\uD835\uDC9F','dscy':'\u0455','DScy':'\u0405','dsol':'\u29F6','dstrok':'\u0111','Dstrok':'\u0110','dtdot':'\u22F1','dtri':'\u25BF','dtrif':'\u25BE','duarr':'\u21F5','duhar':'\u296F','dwangle':'\u29A6','dzcy':'\u045F','DZcy':'\u040F','dzigrarr':'\u27FF','eacute':'\xE9','Eacute':'\xC9','easter':'\u2A6E','ecaron':'\u011B','Ecaron':'\u011A','ecir':'\u2256','ecirc':'\xEA','Ecirc':'\xCA','ecolon':'\u2255','ecy':'\u044D','Ecy':'\u042D','eDDot':'\u2A77','edot':'\u0117','eDot':'\u2251','Edot':'\u0116','ee':'\u2147','efDot':'\u2252','efr':'\uD835\uDD22','Efr':'\uD835\uDD08','eg':'\u2A9A','egrave':'\xE8','Egrave':'\xC8','egs':'\u2A96','egsdot':'\u2A98','el':'\u2A99','Element':'\u2208','elinters':'\u23E7','ell':'\u2113','els':'\u2A95','elsdot':'\u2A97','emacr':'\u0113','Emacr':'\u0112','empty':'\u2205','emptyset':'\u2205','EmptySmallSquare':'\u25FB','emptyv':'\u2205','EmptyVerySmallSquare':'\u25AB','emsp':'\u2003','emsp13':'\u2004','emsp14':'\u2005','eng':'\u014B','ENG':'\u014A','ensp':'\u2002','eogon':'\u0119','Eogon':'\u0118','eopf':'\uD835\uDD56','Eopf':'\uD835\uDD3C','epar':'\u22D5','eparsl':'\u29E3','eplus':'\u2A71','epsi':'\u03B5','epsilon':'\u03B5','Epsilon':'\u0395','epsiv':'\u03F5','eqcirc':'\u2256','eqcolon':'\u2255','eqsim':'\u2242','eqslantgtr':'\u2A96','eqslantless':'\u2A95','Equal':'\u2A75','equals':'=','EqualTilde':'\u2242','equest':'\u225F','Equilibrium':'\u21CC','equiv':'\u2261','equivDD':'\u2A78','eqvparsl':'\u29E5','erarr':'\u2971','erDot':'\u2253','escr':'\u212F','Escr':'\u2130','esdot':'\u2250','esim':'\u2242','Esim':'\u2A73','eta':'\u03B7','Eta':'\u0397','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','euro':'\u20AC','excl':'!','exist':'\u2203','Exists':'\u2203','expectation':'\u2130','exponentiale':'\u2147','ExponentialE':'\u2147','fallingdotseq':'\u2252','fcy':'\u0444','Fcy':'\u0424','female':'\u2640','ffilig':'\uFB03','fflig':'\uFB00','ffllig':'\uFB04','ffr':'\uD835\uDD23','Ffr':'\uD835\uDD09','filig':'\uFB01','FilledSmallSquare':'\u25FC','FilledVerySmallSquare':'\u25AA','fjlig':'fj','flat':'\u266D','fllig':'\uFB02','fltns':'\u25B1','fnof':'\u0192','fopf':'\uD835\uDD57','Fopf':'\uD835\uDD3D','forall':'\u2200','ForAll':'\u2200','fork':'\u22D4','forkv':'\u2AD9','Fouriertrf':'\u2131','fpartint':'\u2A0D','frac12':'\xBD','frac13':'\u2153','frac14':'\xBC','frac15':'\u2155','frac16':'\u2159','frac18':'\u215B','frac23':'\u2154','frac25':'\u2156','frac34':'\xBE','frac35':'\u2157','frac38':'\u215C','frac45':'\u2158','frac56':'\u215A','frac58':'\u215D','frac78':'\u215E','frasl':'\u2044','frown':'\u2322','fscr':'\uD835\uDCBB','Fscr':'\u2131','gacute':'\u01F5','gamma':'\u03B3','Gamma':'\u0393','gammad':'\u03DD','Gammad':'\u03DC','gap':'\u2A86','gbreve':'\u011F','Gbreve':'\u011E','Gcedil':'\u0122','gcirc':'\u011D','Gcirc':'\u011C','gcy':'\u0433','Gcy':'\u0413','gdot':'\u0121','Gdot':'\u0120','ge':'\u2265','gE':'\u2267','gel':'\u22DB','gEl':'\u2A8C','geq':'\u2265','geqq':'\u2267','geqslant':'\u2A7E','ges':'\u2A7E','gescc':'\u2AA9','gesdot':'\u2A80','gesdoto':'\u2A82','gesdotol':'\u2A84','gesl':'\u22DB\uFE00','gesles':'\u2A94','gfr':'\uD835\uDD24','Gfr':'\uD835\uDD0A','gg':'\u226B','Gg':'\u22D9','ggg':'\u22D9','gimel':'\u2137','gjcy':'\u0453','GJcy':'\u0403','gl':'\u2277','gla':'\u2AA5','glE':'\u2A92','glj':'\u2AA4','gnap':'\u2A8A','gnapprox':'\u2A8A','gne':'\u2A88','gnE':'\u2269','gneq':'\u2A88','gneqq':'\u2269','gnsim':'\u22E7','gopf':'\uD835\uDD58','Gopf':'\uD835\uDD3E','grave':'`','GreaterEqual':'\u2265','GreaterEqualLess':'\u22DB','GreaterFullEqual':'\u2267','GreaterGreater':'\u2AA2','GreaterLess':'\u2277','GreaterSlantEqual':'\u2A7E','GreaterTilde':'\u2273','gscr':'\u210A','Gscr':'\uD835\uDCA2','gsim':'\u2273','gsime':'\u2A8E','gsiml':'\u2A90','gt':'>','Gt':'\u226B','GT':'>','gtcc':'\u2AA7','gtcir':'\u2A7A','gtdot':'\u22D7','gtlPar':'\u2995','gtquest':'\u2A7C','gtrapprox':'\u2A86','gtrarr':'\u2978','gtrdot':'\u22D7','gtreqless':'\u22DB','gtreqqless':'\u2A8C','gtrless':'\u2277','gtrsim':'\u2273','gvertneqq':'\u2269\uFE00','gvnE':'\u2269\uFE00','Hacek':'\u02C7','hairsp':'\u200A','half':'\xBD','hamilt':'\u210B','hardcy':'\u044A','HARDcy':'\u042A','harr':'\u2194','hArr':'\u21D4','harrcir':'\u2948','harrw':'\u21AD','Hat':'^','hbar':'\u210F','hcirc':'\u0125','Hcirc':'\u0124','hearts':'\u2665','heartsuit':'\u2665','hellip':'\u2026','hercon':'\u22B9','hfr':'\uD835\uDD25','Hfr':'\u210C','HilbertSpace':'\u210B','hksearow':'\u2925','hkswarow':'\u2926','hoarr':'\u21FF','homtht':'\u223B','hookleftarrow':'\u21A9','hookrightarrow':'\u21AA','hopf':'\uD835\uDD59','Hopf':'\u210D','horbar':'\u2015','HorizontalLine':'\u2500','hscr':'\uD835\uDCBD','Hscr':'\u210B','hslash':'\u210F','hstrok':'\u0127','Hstrok':'\u0126','HumpDownHump':'\u224E','HumpEqual':'\u224F','hybull':'\u2043','hyphen':'\u2010','iacute':'\xED','Iacute':'\xCD','ic':'\u2063','icirc':'\xEE','Icirc':'\xCE','icy':'\u0438','Icy':'\u0418','Idot':'\u0130','iecy':'\u0435','IEcy':'\u0415','iexcl':'\xA1','iff':'\u21D4','ifr':'\uD835\uDD26','Ifr':'\u2111','igrave':'\xEC','Igrave':'\xCC','ii':'\u2148','iiiint':'\u2A0C','iiint':'\u222D','iinfin':'\u29DC','iiota':'\u2129','ijlig':'\u0133','IJlig':'\u0132','Im':'\u2111','imacr':'\u012B','Imacr':'\u012A','image':'\u2111','ImaginaryI':'\u2148','imagline':'\u2110','imagpart':'\u2111','imath':'\u0131','imof':'\u22B7','imped':'\u01B5','Implies':'\u21D2','in':'\u2208','incare':'\u2105','infin':'\u221E','infintie':'\u29DD','inodot':'\u0131','int':'\u222B','Int':'\u222C','intcal':'\u22BA','integers':'\u2124','Integral':'\u222B','intercal':'\u22BA','Intersection':'\u22C2','intlarhk':'\u2A17','intprod':'\u2A3C','InvisibleComma':'\u2063','InvisibleTimes':'\u2062','iocy':'\u0451','IOcy':'\u0401','iogon':'\u012F','Iogon':'\u012E','iopf':'\uD835\uDD5A','Iopf':'\uD835\uDD40','iota':'\u03B9','Iota':'\u0399','iprod':'\u2A3C','iquest':'\xBF','iscr':'\uD835\uDCBE','Iscr':'\u2110','isin':'\u2208','isindot':'\u22F5','isinE':'\u22F9','isins':'\u22F4','isinsv':'\u22F3','isinv':'\u2208','it':'\u2062','itilde':'\u0129','Itilde':'\u0128','iukcy':'\u0456','Iukcy':'\u0406','iuml':'\xEF','Iuml':'\xCF','jcirc':'\u0135','Jcirc':'\u0134','jcy':'\u0439','Jcy':'\u0419','jfr':'\uD835\uDD27','Jfr':'\uD835\uDD0D','jmath':'\u0237','jopf':'\uD835\uDD5B','Jopf':'\uD835\uDD41','jscr':'\uD835\uDCBF','Jscr':'\uD835\uDCA5','jsercy':'\u0458','Jsercy':'\u0408','jukcy':'\u0454','Jukcy':'\u0404','kappa':'\u03BA','Kappa':'\u039A','kappav':'\u03F0','kcedil':'\u0137','Kcedil':'\u0136','kcy':'\u043A','Kcy':'\u041A','kfr':'\uD835\uDD28','Kfr':'\uD835\uDD0E','kgreen':'\u0138','khcy':'\u0445','KHcy':'\u0425','kjcy':'\u045C','KJcy':'\u040C','kopf':'\uD835\uDD5C','Kopf':'\uD835\uDD42','kscr':'\uD835\uDCC0','Kscr':'\uD835\uDCA6','lAarr':'\u21DA','lacute':'\u013A','Lacute':'\u0139','laemptyv':'\u29B4','lagran':'\u2112','lambda':'\u03BB','Lambda':'\u039B','lang':'\u27E8','Lang':'\u27EA','langd':'\u2991','langle':'\u27E8','lap':'\u2A85','Laplacetrf':'\u2112','laquo':'\xAB','larr':'\u2190','lArr':'\u21D0','Larr':'\u219E','larrb':'\u21E4','larrbfs':'\u291F','larrfs':'\u291D','larrhk':'\u21A9','larrlp':'\u21AB','larrpl':'\u2939','larrsim':'\u2973','larrtl':'\u21A2','lat':'\u2AAB','latail':'\u2919','lAtail':'\u291B','late':'\u2AAD','lates':'\u2AAD\uFE00','lbarr':'\u290C','lBarr':'\u290E','lbbrk':'\u2772','lbrace':'{','lbrack':'[','lbrke':'\u298B','lbrksld':'\u298F','lbrkslu':'\u298D','lcaron':'\u013E','Lcaron':'\u013D','lcedil':'\u013C','Lcedil':'\u013B','lceil':'\u2308','lcub':'{','lcy':'\u043B','Lcy':'\u041B','ldca':'\u2936','ldquo':'\u201C','ldquor':'\u201E','ldrdhar':'\u2967','ldrushar':'\u294B','ldsh':'\u21B2','le':'\u2264','lE':'\u2266','LeftAngleBracket':'\u27E8','leftarrow':'\u2190','Leftarrow':'\u21D0','LeftArrow':'\u2190','LeftArrowBar':'\u21E4','LeftArrowRightArrow':'\u21C6','leftarrowtail':'\u21A2','LeftCeiling':'\u2308','LeftDoubleBracket':'\u27E6','LeftDownTeeVector':'\u2961','LeftDownVector':'\u21C3','LeftDownVectorBar':'\u2959','LeftFloor':'\u230A','leftharpoondown':'\u21BD','leftharpoonup':'\u21BC','leftleftarrows':'\u21C7','leftrightarrow':'\u2194','Leftrightarrow':'\u21D4','LeftRightArrow':'\u2194','leftrightarrows':'\u21C6','leftrightharpoons':'\u21CB','leftrightsquigarrow':'\u21AD','LeftRightVector':'\u294E','LeftTee':'\u22A3','LeftTeeArrow':'\u21A4','LeftTeeVector':'\u295A','leftthreetimes':'\u22CB','LeftTriangle':'\u22B2','LeftTriangleBar':'\u29CF','LeftTriangleEqual':'\u22B4','LeftUpDownVector':'\u2951','LeftUpTeeVector':'\u2960','LeftUpVector':'\u21BF','LeftUpVectorBar':'\u2958','LeftVector':'\u21BC','LeftVectorBar':'\u2952','leg':'\u22DA','lEg':'\u2A8B','leq':'\u2264','leqq':'\u2266','leqslant':'\u2A7D','les':'\u2A7D','lescc':'\u2AA8','lesdot':'\u2A7F','lesdoto':'\u2A81','lesdotor':'\u2A83','lesg':'\u22DA\uFE00','lesges':'\u2A93','lessapprox':'\u2A85','lessdot':'\u22D6','lesseqgtr':'\u22DA','lesseqqgtr':'\u2A8B','LessEqualGreater':'\u22DA','LessFullEqual':'\u2266','LessGreater':'\u2276','lessgtr':'\u2276','LessLess':'\u2AA1','lesssim':'\u2272','LessSlantEqual':'\u2A7D','LessTilde':'\u2272','lfisht':'\u297C','lfloor':'\u230A','lfr':'\uD835\uDD29','Lfr':'\uD835\uDD0F','lg':'\u2276','lgE':'\u2A91','lHar':'\u2962','lhard':'\u21BD','lharu':'\u21BC','lharul':'\u296A','lhblk':'\u2584','ljcy':'\u0459','LJcy':'\u0409','ll':'\u226A','Ll':'\u22D8','llarr':'\u21C7','llcorner':'\u231E','Lleftarrow':'\u21DA','llhard':'\u296B','lltri':'\u25FA','lmidot':'\u0140','Lmidot':'\u013F','lmoust':'\u23B0','lmoustache':'\u23B0','lnap':'\u2A89','lnapprox':'\u2A89','lne':'\u2A87','lnE':'\u2268','lneq':'\u2A87','lneqq':'\u2268','lnsim':'\u22E6','loang':'\u27EC','loarr':'\u21FD','lobrk':'\u27E6','longleftarrow':'\u27F5','Longleftarrow':'\u27F8','LongLeftArrow':'\u27F5','longleftrightarrow':'\u27F7','Longleftrightarrow':'\u27FA','LongLeftRightArrow':'\u27F7','longmapsto':'\u27FC','longrightarrow':'\u27F6','Longrightarrow':'\u27F9','LongRightArrow':'\u27F6','looparrowleft':'\u21AB','looparrowright':'\u21AC','lopar':'\u2985','lopf':'\uD835\uDD5D','Lopf':'\uD835\uDD43','loplus':'\u2A2D','lotimes':'\u2A34','lowast':'\u2217','lowbar':'_','LowerLeftArrow':'\u2199','LowerRightArrow':'\u2198','loz':'\u25CA','lozenge':'\u25CA','lozf':'\u29EB','lpar':'(','lparlt':'\u2993','lrarr':'\u21C6','lrcorner':'\u231F','lrhar':'\u21CB','lrhard':'\u296D','lrm':'\u200E','lrtri':'\u22BF','lsaquo':'\u2039','lscr':'\uD835\uDCC1','Lscr':'\u2112','lsh':'\u21B0','Lsh':'\u21B0','lsim':'\u2272','lsime':'\u2A8D','lsimg':'\u2A8F','lsqb':'[','lsquo':'\u2018','lsquor':'\u201A','lstrok':'\u0142','Lstrok':'\u0141','lt':'<','Lt':'\u226A','LT':'<','ltcc':'\u2AA6','ltcir':'\u2A79','ltdot':'\u22D6','lthree':'\u22CB','ltimes':'\u22C9','ltlarr':'\u2976','ltquest':'\u2A7B','ltri':'\u25C3','ltrie':'\u22B4','ltrif':'\u25C2','ltrPar':'\u2996','lurdshar':'\u294A','luruhar':'\u2966','lvertneqq':'\u2268\uFE00','lvnE':'\u2268\uFE00','macr':'\xAF','male':'\u2642','malt':'\u2720','maltese':'\u2720','map':'\u21A6','Map':'\u2905','mapsto':'\u21A6','mapstodown':'\u21A7','mapstoleft':'\u21A4','mapstoup':'\u21A5','marker':'\u25AE','mcomma':'\u2A29','mcy':'\u043C','Mcy':'\u041C','mdash':'\u2014','mDDot':'\u223A','measuredangle':'\u2221','MediumSpace':'\u205F','Mellintrf':'\u2133','mfr':'\uD835\uDD2A','Mfr':'\uD835\uDD10','mho':'\u2127','micro':'\xB5','mid':'\u2223','midast':'*','midcir':'\u2AF0','middot':'\xB7','minus':'\u2212','minusb':'\u229F','minusd':'\u2238','minusdu':'\u2A2A','MinusPlus':'\u2213','mlcp':'\u2ADB','mldr':'\u2026','mnplus':'\u2213','models':'\u22A7','mopf':'\uD835\uDD5E','Mopf':'\uD835\uDD44','mp':'\u2213','mscr':'\uD835\uDCC2','Mscr':'\u2133','mstpos':'\u223E','mu':'\u03BC','Mu':'\u039C','multimap':'\u22B8','mumap':'\u22B8','nabla':'\u2207','nacute':'\u0144','Nacute':'\u0143','nang':'\u2220\u20D2','nap':'\u2249','napE':'\u2A70\u0338','napid':'\u224B\u0338','napos':'\u0149','napprox':'\u2249','natur':'\u266E','natural':'\u266E','naturals':'\u2115','nbsp':'\xA0','nbump':'\u224E\u0338','nbumpe':'\u224F\u0338','ncap':'\u2A43','ncaron':'\u0148','Ncaron':'\u0147','ncedil':'\u0146','Ncedil':'\u0145','ncong':'\u2247','ncongdot':'\u2A6D\u0338','ncup':'\u2A42','ncy':'\u043D','Ncy':'\u041D','ndash':'\u2013','ne':'\u2260','nearhk':'\u2924','nearr':'\u2197','neArr':'\u21D7','nearrow':'\u2197','nedot':'\u2250\u0338','NegativeMediumSpace':'\u200B','NegativeThickSpace':'\u200B','NegativeThinSpace':'\u200B','NegativeVeryThinSpace':'\u200B','nequiv':'\u2262','nesear':'\u2928','nesim':'\u2242\u0338','NestedGreaterGreater':'\u226B','NestedLessLess':'\u226A','NewLine':'\n','nexist':'\u2204','nexists':'\u2204','nfr':'\uD835\uDD2B','Nfr':'\uD835\uDD11','nge':'\u2271','ngE':'\u2267\u0338','ngeq':'\u2271','ngeqq':'\u2267\u0338','ngeqslant':'\u2A7E\u0338','nges':'\u2A7E\u0338','nGg':'\u22D9\u0338','ngsim':'\u2275','ngt':'\u226F','nGt':'\u226B\u20D2','ngtr':'\u226F','nGtv':'\u226B\u0338','nharr':'\u21AE','nhArr':'\u21CE','nhpar':'\u2AF2','ni':'\u220B','nis':'\u22FC','nisd':'\u22FA','niv':'\u220B','njcy':'\u045A','NJcy':'\u040A','nlarr':'\u219A','nlArr':'\u21CD','nldr':'\u2025','nle':'\u2270','nlE':'\u2266\u0338','nleftarrow':'\u219A','nLeftarrow':'\u21CD','nleftrightarrow':'\u21AE','nLeftrightarrow':'\u21CE','nleq':'\u2270','nleqq':'\u2266\u0338','nleqslant':'\u2A7D\u0338','nles':'\u2A7D\u0338','nless':'\u226E','nLl':'\u22D8\u0338','nlsim':'\u2274','nlt':'\u226E','nLt':'\u226A\u20D2','nltri':'\u22EA','nltrie':'\u22EC','nLtv':'\u226A\u0338','nmid':'\u2224','NoBreak':'\u2060','NonBreakingSpace':'\xA0','nopf':'\uD835\uDD5F','Nopf':'\u2115','not':'\xAC','Not':'\u2AEC','NotCongruent':'\u2262','NotCupCap':'\u226D','NotDoubleVerticalBar':'\u2226','NotElement':'\u2209','NotEqual':'\u2260','NotEqualTilde':'\u2242\u0338','NotExists':'\u2204','NotGreater':'\u226F','NotGreaterEqual':'\u2271','NotGreaterFullEqual':'\u2267\u0338','NotGreaterGreater':'\u226B\u0338','NotGreaterLess':'\u2279','NotGreaterSlantEqual':'\u2A7E\u0338','NotGreaterTilde':'\u2275','NotHumpDownHump':'\u224E\u0338','NotHumpEqual':'\u224F\u0338','notin':'\u2209','notindot':'\u22F5\u0338','notinE':'\u22F9\u0338','notinva':'\u2209','notinvb':'\u22F7','notinvc':'\u22F6','NotLeftTriangle':'\u22EA','NotLeftTriangleBar':'\u29CF\u0338','NotLeftTriangleEqual':'\u22EC','NotLess':'\u226E','NotLessEqual':'\u2270','NotLessGreater':'\u2278','NotLessLess':'\u226A\u0338','NotLessSlantEqual':'\u2A7D\u0338','NotLessTilde':'\u2274','NotNestedGreaterGreater':'\u2AA2\u0338','NotNestedLessLess':'\u2AA1\u0338','notni':'\u220C','notniva':'\u220C','notnivb':'\u22FE','notnivc':'\u22FD','NotPrecedes':'\u2280','NotPrecedesEqual':'\u2AAF\u0338','NotPrecedesSlantEqual':'\u22E0','NotReverseElement':'\u220C','NotRightTriangle':'\u22EB','NotRightTriangleBar':'\u29D0\u0338','NotRightTriangleEqual':'\u22ED','NotSquareSubset':'\u228F\u0338','NotSquareSubsetEqual':'\u22E2','NotSquareSuperset':'\u2290\u0338','NotSquareSupersetEqual':'\u22E3','NotSubset':'\u2282\u20D2','NotSubsetEqual':'\u2288','NotSucceeds':'\u2281','NotSucceedsEqual':'\u2AB0\u0338','NotSucceedsSlantEqual':'\u22E1','NotSucceedsTilde':'\u227F\u0338','NotSuperset':'\u2283\u20D2','NotSupersetEqual':'\u2289','NotTilde':'\u2241','NotTildeEqual':'\u2244','NotTildeFullEqual':'\u2247','NotTildeTilde':'\u2249','NotVerticalBar':'\u2224','npar':'\u2226','nparallel':'\u2226','nparsl':'\u2AFD\u20E5','npart':'\u2202\u0338','npolint':'\u2A14','npr':'\u2280','nprcue':'\u22E0','npre':'\u2AAF\u0338','nprec':'\u2280','npreceq':'\u2AAF\u0338','nrarr':'\u219B','nrArr':'\u21CF','nrarrc':'\u2933\u0338','nrarrw':'\u219D\u0338','nrightarrow':'\u219B','nRightarrow':'\u21CF','nrtri':'\u22EB','nrtrie':'\u22ED','nsc':'\u2281','nsccue':'\u22E1','nsce':'\u2AB0\u0338','nscr':'\uD835\uDCC3','Nscr':'\uD835\uDCA9','nshortmid':'\u2224','nshortparallel':'\u2226','nsim':'\u2241','nsime':'\u2244','nsimeq':'\u2244','nsmid':'\u2224','nspar':'\u2226','nsqsube':'\u22E2','nsqsupe':'\u22E3','nsub':'\u2284','nsube':'\u2288','nsubE':'\u2AC5\u0338','nsubset':'\u2282\u20D2','nsubseteq':'\u2288','nsubseteqq':'\u2AC5\u0338','nsucc':'\u2281','nsucceq':'\u2AB0\u0338','nsup':'\u2285','nsupe':'\u2289','nsupE':'\u2AC6\u0338','nsupset':'\u2283\u20D2','nsupseteq':'\u2289','nsupseteqq':'\u2AC6\u0338','ntgl':'\u2279','ntilde':'\xF1','Ntilde':'\xD1','ntlg':'\u2278','ntriangleleft':'\u22EA','ntrianglelefteq':'\u22EC','ntriangleright':'\u22EB','ntrianglerighteq':'\u22ED','nu':'\u03BD','Nu':'\u039D','num':'#','numero':'\u2116','numsp':'\u2007','nvap':'\u224D\u20D2','nvdash':'\u22AC','nvDash':'\u22AD','nVdash':'\u22AE','nVDash':'\u22AF','nvge':'\u2265\u20D2','nvgt':'>\u20D2','nvHarr':'\u2904','nvinfin':'\u29DE','nvlArr':'\u2902','nvle':'\u2264\u20D2','nvlt':'<\u20D2','nvltrie':'\u22B4\u20D2','nvrArr':'\u2903','nvrtrie':'\u22B5\u20D2','nvsim':'\u223C\u20D2','nwarhk':'\u2923','nwarr':'\u2196','nwArr':'\u21D6','nwarrow':'\u2196','nwnear':'\u2927','oacute':'\xF3','Oacute':'\xD3','oast':'\u229B','ocir':'\u229A','ocirc':'\xF4','Ocirc':'\xD4','ocy':'\u043E','Ocy':'\u041E','odash':'\u229D','odblac':'\u0151','Odblac':'\u0150','odiv':'\u2A38','odot':'\u2299','odsold':'\u29BC','oelig':'\u0153','OElig':'\u0152','ofcir':'\u29BF','ofr':'\uD835\uDD2C','Ofr':'\uD835\uDD12','ogon':'\u02DB','ograve':'\xF2','Ograve':'\xD2','ogt':'\u29C1','ohbar':'\u29B5','ohm':'\u03A9','oint':'\u222E','olarr':'\u21BA','olcir':'\u29BE','olcross':'\u29BB','oline':'\u203E','olt':'\u29C0','omacr':'\u014D','Omacr':'\u014C','omega':'\u03C9','Omega':'\u03A9','omicron':'\u03BF','Omicron':'\u039F','omid':'\u29B6','ominus':'\u2296','oopf':'\uD835\uDD60','Oopf':'\uD835\uDD46','opar':'\u29B7','OpenCurlyDoubleQuote':'\u201C','OpenCurlyQuote':'\u2018','operp':'\u29B9','oplus':'\u2295','or':'\u2228','Or':'\u2A54','orarr':'\u21BB','ord':'\u2A5D','order':'\u2134','orderof':'\u2134','ordf':'\xAA','ordm':'\xBA','origof':'\u22B6','oror':'\u2A56','orslope':'\u2A57','orv':'\u2A5B','oS':'\u24C8','oscr':'\u2134','Oscr':'\uD835\uDCAA','oslash':'\xF8','Oslash':'\xD8','osol':'\u2298','otilde':'\xF5','Otilde':'\xD5','otimes':'\u2297','Otimes':'\u2A37','otimesas':'\u2A36','ouml':'\xF6','Ouml':'\xD6','ovbar':'\u233D','OverBar':'\u203E','OverBrace':'\u23DE','OverBracket':'\u23B4','OverParenthesis':'\u23DC','par':'\u2225','para':'\xB6','parallel':'\u2225','parsim':'\u2AF3','parsl':'\u2AFD','part':'\u2202','PartialD':'\u2202','pcy':'\u043F','Pcy':'\u041F','percnt':'%','period':'.','permil':'\u2030','perp':'\u22A5','pertenk':'\u2031','pfr':'\uD835\uDD2D','Pfr':'\uD835\uDD13','phi':'\u03C6','Phi':'\u03A6','phiv':'\u03D5','phmmat':'\u2133','phone':'\u260E','pi':'\u03C0','Pi':'\u03A0','pitchfork':'\u22D4','piv':'\u03D6','planck':'\u210F','planckh':'\u210E','plankv':'\u210F','plus':'+','plusacir':'\u2A23','plusb':'\u229E','pluscir':'\u2A22','plusdo':'\u2214','plusdu':'\u2A25','pluse':'\u2A72','PlusMinus':'\xB1','plusmn':'\xB1','plussim':'\u2A26','plustwo':'\u2A27','pm':'\xB1','Poincareplane':'\u210C','pointint':'\u2A15','popf':'\uD835\uDD61','Popf':'\u2119','pound':'\xA3','pr':'\u227A','Pr':'\u2ABB','prap':'\u2AB7','prcue':'\u227C','pre':'\u2AAF','prE':'\u2AB3','prec':'\u227A','precapprox':'\u2AB7','preccurlyeq':'\u227C','Precedes':'\u227A','PrecedesEqual':'\u2AAF','PrecedesSlantEqual':'\u227C','PrecedesTilde':'\u227E','preceq':'\u2AAF','precnapprox':'\u2AB9','precneqq':'\u2AB5','precnsim':'\u22E8','precsim':'\u227E','prime':'\u2032','Prime':'\u2033','primes':'\u2119','prnap':'\u2AB9','prnE':'\u2AB5','prnsim':'\u22E8','prod':'\u220F','Product':'\u220F','profalar':'\u232E','profline':'\u2312','profsurf':'\u2313','prop':'\u221D','Proportion':'\u2237','Proportional':'\u221D','propto':'\u221D','prsim':'\u227E','prurel':'\u22B0','pscr':'\uD835\uDCC5','Pscr':'\uD835\uDCAB','psi':'\u03C8','Psi':'\u03A8','puncsp':'\u2008','qfr':'\uD835\uDD2E','Qfr':'\uD835\uDD14','qint':'\u2A0C','qopf':'\uD835\uDD62','Qopf':'\u211A','qprime':'\u2057','qscr':'\uD835\uDCC6','Qscr':'\uD835\uDCAC','quaternions':'\u210D','quatint':'\u2A16','quest':'?','questeq':'\u225F','quot':'"','QUOT':'"','rAarr':'\u21DB','race':'\u223D\u0331','racute':'\u0155','Racute':'\u0154','radic':'\u221A','raemptyv':'\u29B3','rang':'\u27E9','Rang':'\u27EB','rangd':'\u2992','range':'\u29A5','rangle':'\u27E9','raquo':'\xBB','rarr':'\u2192','rArr':'\u21D2','Rarr':'\u21A0','rarrap':'\u2975','rarrb':'\u21E5','rarrbfs':'\u2920','rarrc':'\u2933','rarrfs':'\u291E','rarrhk':'\u21AA','rarrlp':'\u21AC','rarrpl':'\u2945','rarrsim':'\u2974','rarrtl':'\u21A3','Rarrtl':'\u2916','rarrw':'\u219D','ratail':'\u291A','rAtail':'\u291C','ratio':'\u2236','rationals':'\u211A','rbarr':'\u290D','rBarr':'\u290F','RBarr':'\u2910','rbbrk':'\u2773','rbrace':'}','rbrack':']','rbrke':'\u298C','rbrksld':'\u298E','rbrkslu':'\u2990','rcaron':'\u0159','Rcaron':'\u0158','rcedil':'\u0157','Rcedil':'\u0156','rceil':'\u2309','rcub':'}','rcy':'\u0440','Rcy':'\u0420','rdca':'\u2937','rdldhar':'\u2969','rdquo':'\u201D','rdquor':'\u201D','rdsh':'\u21B3','Re':'\u211C','real':'\u211C','realine':'\u211B','realpart':'\u211C','reals':'\u211D','rect':'\u25AD','reg':'\xAE','REG':'\xAE','ReverseElement':'\u220B','ReverseEquilibrium':'\u21CB','ReverseUpEquilibrium':'\u296F','rfisht':'\u297D','rfloor':'\u230B','rfr':'\uD835\uDD2F','Rfr':'\u211C','rHar':'\u2964','rhard':'\u21C1','rharu':'\u21C0','rharul':'\u296C','rho':'\u03C1','Rho':'\u03A1','rhov':'\u03F1','RightAngleBracket':'\u27E9','rightarrow':'\u2192','Rightarrow':'\u21D2','RightArrow':'\u2192','RightArrowBar':'\u21E5','RightArrowLeftArrow':'\u21C4','rightarrowtail':'\u21A3','RightCeiling':'\u2309','RightDoubleBracket':'\u27E7','RightDownTeeVector':'\u295D','RightDownVector':'\u21C2','RightDownVectorBar':'\u2955','RightFloor':'\u230B','rightharpoondown':'\u21C1','rightharpoonup':'\u21C0','rightleftarrows':'\u21C4','rightleftharpoons':'\u21CC','rightrightarrows':'\u21C9','rightsquigarrow':'\u219D','RightTee':'\u22A2','RightTeeArrow':'\u21A6','RightTeeVector':'\u295B','rightthreetimes':'\u22CC','RightTriangle':'\u22B3','RightTriangleBar':'\u29D0','RightTriangleEqual':'\u22B5','RightUpDownVector':'\u294F','RightUpTeeVector':'\u295C','RightUpVector':'\u21BE','RightUpVectorBar':'\u2954','RightVector':'\u21C0','RightVectorBar':'\u2953','ring':'\u02DA','risingdotseq':'\u2253','rlarr':'\u21C4','rlhar':'\u21CC','rlm':'\u200F','rmoust':'\u23B1','rmoustache':'\u23B1','rnmid':'\u2AEE','roang':'\u27ED','roarr':'\u21FE','robrk':'\u27E7','ropar':'\u2986','ropf':'\uD835\uDD63','Ropf':'\u211D','roplus':'\u2A2E','rotimes':'\u2A35','RoundImplies':'\u2970','rpar':')','rpargt':'\u2994','rppolint':'\u2A12','rrarr':'\u21C9','Rrightarrow':'\u21DB','rsaquo':'\u203A','rscr':'\uD835\uDCC7','Rscr':'\u211B','rsh':'\u21B1','Rsh':'\u21B1','rsqb':']','rsquo':'\u2019','rsquor':'\u2019','rthree':'\u22CC','rtimes':'\u22CA','rtri':'\u25B9','rtrie':'\u22B5','rtrif':'\u25B8','rtriltri':'\u29CE','RuleDelayed':'\u29F4','ruluhar':'\u2968','rx':'\u211E','sacute':'\u015B','Sacute':'\u015A','sbquo':'\u201A','sc':'\u227B','Sc':'\u2ABC','scap':'\u2AB8','scaron':'\u0161','Scaron':'\u0160','sccue':'\u227D','sce':'\u2AB0','scE':'\u2AB4','scedil':'\u015F','Scedil':'\u015E','scirc':'\u015D','Scirc':'\u015C','scnap':'\u2ABA','scnE':'\u2AB6','scnsim':'\u22E9','scpolint':'\u2A13','scsim':'\u227F','scy':'\u0441','Scy':'\u0421','sdot':'\u22C5','sdotb':'\u22A1','sdote':'\u2A66','searhk':'\u2925','searr':'\u2198','seArr':'\u21D8','searrow':'\u2198','sect':'\xA7','semi':';','seswar':'\u2929','setminus':'\u2216','setmn':'\u2216','sext':'\u2736','sfr':'\uD835\uDD30','Sfr':'\uD835\uDD16','sfrown':'\u2322','sharp':'\u266F','shchcy':'\u0449','SHCHcy':'\u0429','shcy':'\u0448','SHcy':'\u0428','ShortDownArrow':'\u2193','ShortLeftArrow':'\u2190','shortmid':'\u2223','shortparallel':'\u2225','ShortRightArrow':'\u2192','ShortUpArrow':'\u2191','shy':'\xAD','sigma':'\u03C3','Sigma':'\u03A3','sigmaf':'\u03C2','sigmav':'\u03C2','sim':'\u223C','simdot':'\u2A6A','sime':'\u2243','simeq':'\u2243','simg':'\u2A9E','simgE':'\u2AA0','siml':'\u2A9D','simlE':'\u2A9F','simne':'\u2246','simplus':'\u2A24','simrarr':'\u2972','slarr':'\u2190','SmallCircle':'\u2218','smallsetminus':'\u2216','smashp':'\u2A33','smeparsl':'\u29E4','smid':'\u2223','smile':'\u2323','smt':'\u2AAA','smte':'\u2AAC','smtes':'\u2AAC\uFE00','softcy':'\u044C','SOFTcy':'\u042C','sol':'/','solb':'\u29C4','solbar':'\u233F','sopf':'\uD835\uDD64','Sopf':'\uD835\uDD4A','spades':'\u2660','spadesuit':'\u2660','spar':'\u2225','sqcap':'\u2293','sqcaps':'\u2293\uFE00','sqcup':'\u2294','sqcups':'\u2294\uFE00','Sqrt':'\u221A','sqsub':'\u228F','sqsube':'\u2291','sqsubset':'\u228F','sqsubseteq':'\u2291','sqsup':'\u2290','sqsupe':'\u2292','sqsupset':'\u2290','sqsupseteq':'\u2292','squ':'\u25A1','square':'\u25A1','Square':'\u25A1','SquareIntersection':'\u2293','SquareSubset':'\u228F','SquareSubsetEqual':'\u2291','SquareSuperset':'\u2290','SquareSupersetEqual':'\u2292','SquareUnion':'\u2294','squarf':'\u25AA','squf':'\u25AA','srarr':'\u2192','sscr':'\uD835\uDCC8','Sscr':'\uD835\uDCAE','ssetmn':'\u2216','ssmile':'\u2323','sstarf':'\u22C6','star':'\u2606','Star':'\u22C6','starf':'\u2605','straightepsilon':'\u03F5','straightphi':'\u03D5','strns':'\xAF','sub':'\u2282','Sub':'\u22D0','subdot':'\u2ABD','sube':'\u2286','subE':'\u2AC5','subedot':'\u2AC3','submult':'\u2AC1','subne':'\u228A','subnE':'\u2ACB','subplus':'\u2ABF','subrarr':'\u2979','subset':'\u2282','Subset':'\u22D0','subseteq':'\u2286','subseteqq':'\u2AC5','SubsetEqual':'\u2286','subsetneq':'\u228A','subsetneqq':'\u2ACB','subsim':'\u2AC7','subsub':'\u2AD5','subsup':'\u2AD3','succ':'\u227B','succapprox':'\u2AB8','succcurlyeq':'\u227D','Succeeds':'\u227B','SucceedsEqual':'\u2AB0','SucceedsSlantEqual':'\u227D','SucceedsTilde':'\u227F','succeq':'\u2AB0','succnapprox':'\u2ABA','succneqq':'\u2AB6','succnsim':'\u22E9','succsim':'\u227F','SuchThat':'\u220B','sum':'\u2211','Sum':'\u2211','sung':'\u266A','sup':'\u2283','Sup':'\u22D1','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','supdot':'\u2ABE','supdsub':'\u2AD8','supe':'\u2287','supE':'\u2AC6','supedot':'\u2AC4','Superset':'\u2283','SupersetEqual':'\u2287','suphsol':'\u27C9','suphsub':'\u2AD7','suplarr':'\u297B','supmult':'\u2AC2','supne':'\u228B','supnE':'\u2ACC','supplus':'\u2AC0','supset':'\u2283','Supset':'\u22D1','supseteq':'\u2287','supseteqq':'\u2AC6','supsetneq':'\u228B','supsetneqq':'\u2ACC','supsim':'\u2AC8','supsub':'\u2AD4','supsup':'\u2AD6','swarhk':'\u2926','swarr':'\u2199','swArr':'\u21D9','swarrow':'\u2199','swnwar':'\u292A','szlig':'\xDF','Tab':'\t','target':'\u2316','tau':'\u03C4','Tau':'\u03A4','tbrk':'\u23B4','tcaron':'\u0165','Tcaron':'\u0164','tcedil':'\u0163','Tcedil':'\u0162','tcy':'\u0442','Tcy':'\u0422','tdot':'\u20DB','telrec':'\u2315','tfr':'\uD835\uDD31','Tfr':'\uD835\uDD17','there4':'\u2234','therefore':'\u2234','Therefore':'\u2234','theta':'\u03B8','Theta':'\u0398','thetasym':'\u03D1','thetav':'\u03D1','thickapprox':'\u2248','thicksim':'\u223C','ThickSpace':'\u205F\u200A','thinsp':'\u2009','ThinSpace':'\u2009','thkap':'\u2248','thksim':'\u223C','thorn':'\xFE','THORN':'\xDE','tilde':'\u02DC','Tilde':'\u223C','TildeEqual':'\u2243','TildeFullEqual':'\u2245','TildeTilde':'\u2248','times':'\xD7','timesb':'\u22A0','timesbar':'\u2A31','timesd':'\u2A30','tint':'\u222D','toea':'\u2928','top':'\u22A4','topbot':'\u2336','topcir':'\u2AF1','topf':'\uD835\uDD65','Topf':'\uD835\uDD4B','topfork':'\u2ADA','tosa':'\u2929','tprime':'\u2034','trade':'\u2122','TRADE':'\u2122','triangle':'\u25B5','triangledown':'\u25BF','triangleleft':'\u25C3','trianglelefteq':'\u22B4','triangleq':'\u225C','triangleright':'\u25B9','trianglerighteq':'\u22B5','tridot':'\u25EC','trie':'\u225C','triminus':'\u2A3A','TripleDot':'\u20DB','triplus':'\u2A39','trisb':'\u29CD','tritime':'\u2A3B','trpezium':'\u23E2','tscr':'\uD835\uDCC9','Tscr':'\uD835\uDCAF','tscy':'\u0446','TScy':'\u0426','tshcy':'\u045B','TSHcy':'\u040B','tstrok':'\u0167','Tstrok':'\u0166','twixt':'\u226C','twoheadleftarrow':'\u219E','twoheadrightarrow':'\u21A0','uacute':'\xFA','Uacute':'\xDA','uarr':'\u2191','uArr':'\u21D1','Uarr':'\u219F','Uarrocir':'\u2949','ubrcy':'\u045E','Ubrcy':'\u040E','ubreve':'\u016D','Ubreve':'\u016C','ucirc':'\xFB','Ucirc':'\xDB','ucy':'\u0443','Ucy':'\u0423','udarr':'\u21C5','udblac':'\u0171','Udblac':'\u0170','udhar':'\u296E','ufisht':'\u297E','ufr':'\uD835\uDD32','Ufr':'\uD835\uDD18','ugrave':'\xF9','Ugrave':'\xD9','uHar':'\u2963','uharl':'\u21BF','uharr':'\u21BE','uhblk':'\u2580','ulcorn':'\u231C','ulcorner':'\u231C','ulcrop':'\u230F','ultri':'\u25F8','umacr':'\u016B','Umacr':'\u016A','uml':'\xA8','UnderBar':'_','UnderBrace':'\u23DF','UnderBracket':'\u23B5','UnderParenthesis':'\u23DD','Union':'\u22C3','UnionPlus':'\u228E','uogon':'\u0173','Uogon':'\u0172','uopf':'\uD835\uDD66','Uopf':'\uD835\uDD4C','uparrow':'\u2191','Uparrow':'\u21D1','UpArrow':'\u2191','UpArrowBar':'\u2912','UpArrowDownArrow':'\u21C5','updownarrow':'\u2195','Updownarrow':'\u21D5','UpDownArrow':'\u2195','UpEquilibrium':'\u296E','upharpoonleft':'\u21BF','upharpoonright':'\u21BE','uplus':'\u228E','UpperLeftArrow':'\u2196','UpperRightArrow':'\u2197','upsi':'\u03C5','Upsi':'\u03D2','upsih':'\u03D2','upsilon':'\u03C5','Upsilon':'\u03A5','UpTee':'\u22A5','UpTeeArrow':'\u21A5','upuparrows':'\u21C8','urcorn':'\u231D','urcorner':'\u231D','urcrop':'\u230E','uring':'\u016F','Uring':'\u016E','urtri':'\u25F9','uscr':'\uD835\uDCCA','Uscr':'\uD835\uDCB0','utdot':'\u22F0','utilde':'\u0169','Utilde':'\u0168','utri':'\u25B5','utrif':'\u25B4','uuarr':'\u21C8','uuml':'\xFC','Uuml':'\xDC','uwangle':'\u29A7','vangrt':'\u299C','varepsilon':'\u03F5','varkappa':'\u03F0','varnothing':'\u2205','varphi':'\u03D5','varpi':'\u03D6','varpropto':'\u221D','varr':'\u2195','vArr':'\u21D5','varrho':'\u03F1','varsigma':'\u03C2','varsubsetneq':'\u228A\uFE00','varsubsetneqq':'\u2ACB\uFE00','varsupsetneq':'\u228B\uFE00','varsupsetneqq':'\u2ACC\uFE00','vartheta':'\u03D1','vartriangleleft':'\u22B2','vartriangleright':'\u22B3','vBar':'\u2AE8','Vbar':'\u2AEB','vBarv':'\u2AE9','vcy':'\u0432','Vcy':'\u0412','vdash':'\u22A2','vDash':'\u22A8','Vdash':'\u22A9','VDash':'\u22AB','Vdashl':'\u2AE6','vee':'\u2228','Vee':'\u22C1','veebar':'\u22BB','veeeq':'\u225A','vellip':'\u22EE','verbar':'|','Verbar':'\u2016','vert':'|','Vert':'\u2016','VerticalBar':'\u2223','VerticalLine':'|','VerticalSeparator':'\u2758','VerticalTilde':'\u2240','VeryThinSpace':'\u200A','vfr':'\uD835\uDD33','Vfr':'\uD835\uDD19','vltri':'\u22B2','vnsub':'\u2282\u20D2','vnsup':'\u2283\u20D2','vopf':'\uD835\uDD67','Vopf':'\uD835\uDD4D','vprop':'\u221D','vrtri':'\u22B3','vscr':'\uD835\uDCCB','Vscr':'\uD835\uDCB1','vsubne':'\u228A\uFE00','vsubnE':'\u2ACB\uFE00','vsupne':'\u228B\uFE00','vsupnE':'\u2ACC\uFE00','Vvdash':'\u22AA','vzigzag':'\u299A','wcirc':'\u0175','Wcirc':'\u0174','wedbar':'\u2A5F','wedge':'\u2227','Wedge':'\u22C0','wedgeq':'\u2259','weierp':'\u2118','wfr':'\uD835\uDD34','Wfr':'\uD835\uDD1A','wopf':'\uD835\uDD68','Wopf':'\uD835\uDD4E','wp':'\u2118','wr':'\u2240','wreath':'\u2240','wscr':'\uD835\uDCCC','Wscr':'\uD835\uDCB2','xcap':'\u22C2','xcirc':'\u25EF','xcup':'\u22C3','xdtri':'\u25BD','xfr':'\uD835\uDD35','Xfr':'\uD835\uDD1B','xharr':'\u27F7','xhArr':'\u27FA','xi':'\u03BE','Xi':'\u039E','xlarr':'\u27F5','xlArr':'\u27F8','xmap':'\u27FC','xnis':'\u22FB','xodot':'\u2A00','xopf':'\uD835\uDD69','Xopf':'\uD835\uDD4F','xoplus':'\u2A01','xotime':'\u2A02','xrarr':'\u27F6','xrArr':'\u27F9','xscr':'\uD835\uDCCD','Xscr':'\uD835\uDCB3','xsqcup':'\u2A06','xuplus':'\u2A04','xutri':'\u25B3','xvee':'\u22C1','xwedge':'\u22C0','yacute':'\xFD','Yacute':'\xDD','yacy':'\u044F','YAcy':'\u042F','ycirc':'\u0177','Ycirc':'\u0176','ycy':'\u044B','Ycy':'\u042B','yen':'\xA5','yfr':'\uD835\uDD36','Yfr':'\uD835\uDD1C','yicy':'\u0457','YIcy':'\u0407','yopf':'\uD835\uDD6A','Yopf':'\uD835\uDD50','yscr':'\uD835\uDCCE','Yscr':'\uD835\uDCB4','yucy':'\u044E','YUcy':'\u042E','yuml':'\xFF','Yuml':'\u0178','zacute':'\u017A','Zacute':'\u0179','zcaron':'\u017E','Zcaron':'\u017D','zcy':'\u0437','Zcy':'\u0417','zdot':'\u017C','Zdot':'\u017B','zeetrf':'\u2128','ZeroWidthSpace':'\u200B','zeta':'\u03B6','Zeta':'\u0396','zfr':'\uD835\uDD37','Zfr':'\u2128','zhcy':'\u0436','ZHcy':'\u0416','zigrarr':'\u21DD','zopf':'\uD835\uDD6B','Zopf':'\u2124','zscr':'\uD835\uDCCF','Zscr':'\uD835\uDCB5','zwj':'\u200D','zwnj':'\u200C'};
	var decodeMapLegacy = {'aacute':'\xE1','Aacute':'\xC1','acirc':'\xE2','Acirc':'\xC2','acute':'\xB4','aelig':'\xE6','AElig':'\xC6','agrave':'\xE0','Agrave':'\xC0','amp':'&','AMP':'&','aring':'\xE5','Aring':'\xC5','atilde':'\xE3','Atilde':'\xC3','auml':'\xE4','Auml':'\xC4','brvbar':'\xA6','ccedil':'\xE7','Ccedil':'\xC7','cedil':'\xB8','cent':'\xA2','copy':'\xA9','COPY':'\xA9','curren':'\xA4','deg':'\xB0','divide':'\xF7','eacute':'\xE9','Eacute':'\xC9','ecirc':'\xEA','Ecirc':'\xCA','egrave':'\xE8','Egrave':'\xC8','eth':'\xF0','ETH':'\xD0','euml':'\xEB','Euml':'\xCB','frac12':'\xBD','frac14':'\xBC','frac34':'\xBE','gt':'>','GT':'>','iacute':'\xED','Iacute':'\xCD','icirc':'\xEE','Icirc':'\xCE','iexcl':'\xA1','igrave':'\xEC','Igrave':'\xCC','iquest':'\xBF','iuml':'\xEF','Iuml':'\xCF','laquo':'\xAB','lt':'<','LT':'<','macr':'\xAF','micro':'\xB5','middot':'\xB7','nbsp':'\xA0','not':'\xAC','ntilde':'\xF1','Ntilde':'\xD1','oacute':'\xF3','Oacute':'\xD3','ocirc':'\xF4','Ocirc':'\xD4','ograve':'\xF2','Ograve':'\xD2','ordf':'\xAA','ordm':'\xBA','oslash':'\xF8','Oslash':'\xD8','otilde':'\xF5','Otilde':'\xD5','ouml':'\xF6','Ouml':'\xD6','para':'\xB6','plusmn':'\xB1','pound':'\xA3','quot':'"','QUOT':'"','raquo':'\xBB','reg':'\xAE','REG':'\xAE','sect':'\xA7','shy':'\xAD','sup1':'\xB9','sup2':'\xB2','sup3':'\xB3','szlig':'\xDF','thorn':'\xFE','THORN':'\xDE','times':'\xD7','uacute':'\xFA','Uacute':'\xDA','ucirc':'\xFB','Ucirc':'\xDB','ugrave':'\xF9','Ugrave':'\xD9','uml':'\xA8','uuml':'\xFC','Uuml':'\xDC','yacute':'\xFD','Yacute':'\xDD','yen':'\xA5','yuml':'\xFF'};
	var decodeMapNumeric = {'0':'\uFFFD','128':'\u20AC','130':'\u201A','131':'\u0192','132':'\u201E','133':'\u2026','134':'\u2020','135':'\u2021','136':'\u02C6','137':'\u2030','138':'\u0160','139':'\u2039','140':'\u0152','142':'\u017D','145':'\u2018','146':'\u2019','147':'\u201C','148':'\u201D','149':'\u2022','150':'\u2013','151':'\u2014','152':'\u02DC','153':'\u2122','154':'\u0161','155':'\u203A','156':'\u0153','158':'\u017E','159':'\u0178'};
	var invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];

	/*--------------------------------------------------------------------------*/

	var stringFromCharCode = String.fromCharCode;

	var object = {};
	var hasOwnProperty = object.hasOwnProperty;
	var has = function(object, propertyName) {
		return hasOwnProperty.call(object, propertyName);
	};

	var contains = function(array, value) {
		var index = -1;
		var length = array.length;
		while (++index < length) {
			if (array[index] == value) {
				return true;
			}
		}
		return false;
	};

	var merge = function(options, defaults) {
		if (!options) {
			return defaults;
		}
		var result = {};
		var key;
		for (key in defaults) {
			// A `hasOwnProperty` check is not needed here, since only recognized
			// option names are used anyway. Any others are ignored.
			result[key] = has(options, key) ? options[key] : defaults[key];
		}
		return result;
	};

	// Modified version of `ucs2encode`; see https://mths.be/punycode.
	var codePointToSymbol = function(codePoint, strict) {
		var output = '';
		if ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {
			// See issue #4:
			// “Otherwise, if the number is in the range 0xD800 to 0xDFFF or is
			// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD
			// REPLACEMENT CHARACTER.”
			if (strict) {
				parseError('character reference outside the permissible Unicode range');
			}
			return '\uFFFD';
		}
		if (has(decodeMapNumeric, codePoint)) {
			if (strict) {
				parseError('disallowed character reference');
			}
			return decodeMapNumeric[codePoint];
		}
		if (strict && contains(invalidReferenceCodePoints, codePoint)) {
			parseError('disallowed character reference');
		}
		if (codePoint > 0xFFFF) {
			codePoint -= 0x10000;
			output += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);
			codePoint = 0xDC00 | codePoint & 0x3FF;
		}
		output += stringFromCharCode(codePoint);
		return output;
	};

	var hexEscape = function(codePoint) {
		return '&#x' + codePoint.toString(16).toUpperCase() + ';';
	};

	var decEscape = function(codePoint) {
		return '&#' + codePoint + ';';
	};

	var parseError = function(message) {
		throw Error('Parse error: ' + message);
	};

	/*--------------------------------------------------------------------------*/

	var encode = function(string, options) {
		options = merge(options, encode.options);
		var strict = options.strict;
		if (strict && regexInvalidRawCodePoint.test(string)) {
			parseError('forbidden code point');
		}
		var encodeEverything = options.encodeEverything;
		var useNamedReferences = options.useNamedReferences;
		var allowUnsafeSymbols = options.allowUnsafeSymbols;
		var escapeCodePoint = options.decimal ? decEscape : hexEscape;

		var escapeBmpSymbol = function(symbol) {
			return escapeCodePoint(symbol.charCodeAt(0));
		};

		if (encodeEverything) {
			// Encode ASCII symbols.
			string = string.replace(regexAsciiWhitelist, function(symbol) {
				// Use named references if requested & possible.
				if (useNamedReferences && has(encodeMap, symbol)) {
					return '&' + encodeMap[symbol] + ';';
				}
				return escapeBmpSymbol(symbol);
			});
			// Shorten a few escapes that represent two symbols, of which at least one
			// is within the ASCII range.
			if (useNamedReferences) {
				string = string
					.replace(/&gt;\u20D2/g, '&nvgt;')
					.replace(/&lt;\u20D2/g, '&nvlt;')
					.replace(/&#x66;&#x6A;/g, '&fjlig;');
			}
			// Encode non-ASCII symbols.
			if (useNamedReferences) {
				// Encode non-ASCII symbols that can be replaced with a named reference.
				string = string.replace(regexEncodeNonAscii, function(string) {
					// Note: there is no need to check `has(encodeMap, string)` here.
					return '&' + encodeMap[string] + ';';
				});
			}
			// Note: any remaining non-ASCII symbols are handled outside of the `if`.
		} else if (useNamedReferences) {
			// Apply named character references.
			// Encode `<>"'&` using named character references.
			if (!allowUnsafeSymbols) {
				string = string.replace(regexEscape, function(string) {
					return '&' + encodeMap[string] + ';'; // no need to check `has()` here
				});
			}
			// Shorten escapes that represent two symbols, of which at least one is
			// `<>"'&`.
			string = string
				.replace(/&gt;\u20D2/g, '&nvgt;')
				.replace(/&lt;\u20D2/g, '&nvlt;');
			// Encode non-ASCII symbols that can be replaced with a named reference.
			string = string.replace(regexEncodeNonAscii, function(string) {
				// Note: there is no need to check `has(encodeMap, string)` here.
				return '&' + encodeMap[string] + ';';
			});
		} else if (!allowUnsafeSymbols) {
			// Encode `<>"'&` using hexadecimal escapes, now that they’re not handled
			// using named character references.
			string = string.replace(regexEscape, escapeBmpSymbol);
		}
		return string
			// Encode astral symbols.
			.replace(regexAstralSymbols, function($0) {
				// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
				var high = $0.charCodeAt(0);
				var low = $0.charCodeAt(1);
				var codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
				return escapeCodePoint(codePoint);
			})
			// Encode any remaining BMP symbols that are not printable ASCII symbols
			// using a hexadecimal escape.
			.replace(regexBmpWhitelist, escapeBmpSymbol);
	};
	// Expose default options (so they can be overridden globally).
	encode.options = {
		'allowUnsafeSymbols': false,
		'encodeEverything': false,
		'strict': false,
		'useNamedReferences': false,
		'decimal' : false
	};

	var decode = function(html, options) {
		options = merge(options, decode.options);
		var strict = options.strict;
		if (strict && regexInvalidEntity.test(html)) {
			parseError('malformed character reference');
		}
		return html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
			var codePoint;
			var semicolon;
			var decDigits;
			var hexDigits;
			var reference;
			var next;

			if ($1) {
				reference = $1;
				// Note: there is no need to check `has(decodeMap, reference)`.
				return decodeMap[reference];
			}

			if ($2) {
				// Decode named character references without trailing `;`, e.g. `&amp`.
				// This is only a parse error if it gets converted to `&`, or if it is
				// followed by `=` in an attribute context.
				reference = $2;
				next = $3;
				if (next && options.isAttributeValue) {
					if (strict && next == '=') {
						parseError('`&` did not start a character reference');
					}
					return $0;
				} else {
					if (strict) {
						parseError(
							'named character reference was not terminated by a semicolon'
						);
					}
					// Note: there is no need to check `has(decodeMapLegacy, reference)`.
					return decodeMapLegacy[reference] + (next || '');
				}
			}

			if ($4) {
				// Decode decimal escapes, e.g. `&#119558;`.
				decDigits = $4;
				semicolon = $5;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(decDigits, 10);
				return codePointToSymbol(codePoint, strict);
			}

			if ($6) {
				// Decode hexadecimal escapes, e.g. `&#x1D306;`.
				hexDigits = $6;
				semicolon = $7;
				if (strict && !semicolon) {
					parseError('character reference was not terminated by a semicolon');
				}
				codePoint = parseInt(hexDigits, 16);
				return codePointToSymbol(codePoint, strict);
			}

			// If we’re still here, `if ($7)` is implied; it’s an ambiguous
			// ampersand for sure. https://mths.be/notes/ambiguous-ampersands
			if (strict) {
				parseError(
					'named character reference was not terminated by a semicolon'
				);
			}
			return $0;
		});
	};
	// Expose default options (so they can be overridden globally).
	decode.options = {
		'isAttributeValue': false,
		'strict': false
	};

	var escape = function(string) {
		return string.replace(regexEscape, function($0) {
			// Note: there is no need to check `has(escapeMap, $0)` here.
			return escapeMap[$0];
		});
	};

	/*--------------------------------------------------------------------------*/

	var he = {
		'version': '1.2.0',
		'encode': encode,
		'decode': decode,
		'escape': escape,
		'unescape': decode
	};

	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return he;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	}	else { var key; }

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/*!*****************************************!*\
  !*** ./node_modules/is-buffer/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}


/***/ }),

/***/ "./node_modules/md5/md5.js":
/*!*********************************!*\
  !*** ./node_modules/md5/md5.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function(){
  var crypt = __webpack_require__(/*! crypt */ "./node_modules/crypt/crypt.js"),
      utf8 = __webpack_require__(/*! charenc */ "./node_modules/charenc/charenc.js").utf8,
      isBuffer = __webpack_require__(/*! is-buffer */ "./node_modules/is-buffer/index.js"),
      bin = __webpack_require__(/*! charenc */ "./node_modules/charenc/charenc.js").bin,

  // The core
  md5 = function (message, options) {
    // Convert to byte array
    if (message.constructor == String)
      if (options && options.encoding === 'binary')
        message = bin.stringToBytes(message);
      else
        message = utf8.stringToBytes(message);
    else if (isBuffer(message))
      message = Array.prototype.slice.call(message, 0);
    else if (!Array.isArray(message))
      message = message.toString();
    // else, assume byte array already

    var m = crypt.bytesToWords(message),
        l = message.length * 8,
        a =  1732584193,
        b = -271733879,
        c = -1732584194,
        d =  271733878;

    // Swap endian
    for (var i = 0; i < m.length; i++) {
      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |
             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;
    }

    // Padding
    m[l >>> 5] |= 0x80 << (l % 32);
    m[(((l + 64) >>> 9) << 4) + 14] = l;

    // Method shortcuts
    var FF = md5._ff,
        GG = md5._gg,
        HH = md5._hh,
        II = md5._ii;

    for (var i = 0; i < m.length; i += 16) {

      var aa = a,
          bb = b,
          cc = c,
          dd = d;

      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);
      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);
      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);
      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);
      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);
      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);
      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);
      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);
      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);
      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);
      c = FF(c, d, a, b, m[i+10], 17, -42063);
      b = FF(b, c, d, a, m[i+11], 22, -1990404162);
      a = FF(a, b, c, d, m[i+12],  7,  1804603682);
      d = FF(d, a, b, c, m[i+13], 12, -40341101);
      c = FF(c, d, a, b, m[i+14], 17, -1502002290);
      b = FF(b, c, d, a, m[i+15], 22,  1236535329);

      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);
      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);
      c = GG(c, d, a, b, m[i+11], 14,  643717713);
      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);
      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);
      d = GG(d, a, b, c, m[i+10],  9,  38016083);
      c = GG(c, d, a, b, m[i+15], 14, -660478335);
      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);
      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);
      d = GG(d, a, b, c, m[i+14],  9, -1019803690);
      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);
      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);
      a = GG(a, b, c, d, m[i+13],  5, -1444681467);
      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);
      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);
      b = GG(b, c, d, a, m[i+12], 20, -1926607734);

      a = HH(a, b, c, d, m[i+ 5],  4, -378558);
      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);
      c = HH(c, d, a, b, m[i+11], 16,  1839030562);
      b = HH(b, c, d, a, m[i+14], 23, -35309556);
      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);
      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);
      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);
      b = HH(b, c, d, a, m[i+10], 23, -1094730640);
      a = HH(a, b, c, d, m[i+13],  4,  681279174);
      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);
      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);
      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);
      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);
      d = HH(d, a, b, c, m[i+12], 11, -421815835);
      c = HH(c, d, a, b, m[i+15], 16,  530742520);
      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);

      a = II(a, b, c, d, m[i+ 0],  6, -198630844);
      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);
      c = II(c, d, a, b, m[i+14], 15, -1416354905);
      b = II(b, c, d, a, m[i+ 5], 21, -57434055);
      a = II(a, b, c, d, m[i+12],  6,  1700485571);
      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);
      c = II(c, d, a, b, m[i+10], 15, -1051523);
      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);
      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);
      d = II(d, a, b, c, m[i+15], 10, -30611744);
      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);
      b = II(b, c, d, a, m[i+13], 21,  1309151649);
      a = II(a, b, c, d, m[i+ 4],  6, -145523070);
      d = II(d, a, b, c, m[i+11], 10, -1120210379);
      c = II(c, d, a, b, m[i+ 2], 15,  718787259);
      b = II(b, c, d, a, m[i+ 9], 21, -343485551);

      a = (a + aa) >>> 0;
      b = (b + bb) >>> 0;
      c = (c + cc) >>> 0;
      d = (d + dd) >>> 0;
    }

    return crypt.endian([a, b, c, d]);
  };

  // Auxiliary functions
  md5._ff  = function (a, b, c, d, x, s, t) {
    var n = a + (b & c | ~b & d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._gg  = function (a, b, c, d, x, s, t) {
    var n = a + (b & d | c & ~d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._hh  = function (a, b, c, d, x, s, t) {
    var n = a + (b ^ c ^ d) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };
  md5._ii  = function (a, b, c, d, x, s, t) {
    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
    return ((n << s) | (n >>> (32 - s))) + b;
  };

  // Package private blocksize
  md5._blocksize = 16;
  md5._digestsize = 16;

  module.exports = function (message, options) {
    if (message === undefined || message === null)
      throw new Error('Illegal argument ' + message);

    var digestbytes = crypt.wordsToBytes(md5(message, options));
    return options && options.asBytes ? digestbytes :
        options && options.asString ? bin.bytesToString(digestbytes) :
        crypt.bytesToHex(digestbytes);
  };

})();


/***/ }),

/***/ "./node_modules/moment/moment.js":
/*!***************************************!*\
  !*** ./node_modules/moment/moment.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {var require;//! moment.js

;(function (global, factory) {
     true ? module.exports = factory() :
    undefined
}(this, (function () { 'use strict';

    var hookCallback;

    function hooks () {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback (callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty           : false,
            unusedTokens    : [],
            unusedInput     : [],
            overflow        : -2,
            charsLeftOver   : 0,
            nullInput       : false,
            invalidMonth    : null,
            invalidFormat   : false,
            userInvalidated : false,
            iso             : false,
            parsedDateParts : [],
            meridiem        : null,
            rfc2822         : false,
            weekdayMismatch : false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function (fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        };
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function (i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) &&
                flags.overflow < 0 &&
                !flags.empty &&
                !flags.invalidMonth &&
                !flags.invalidWeekday &&
                !flags.weekdayMismatch &&
                !flags.nullInput &&
                !flags.invalidFormat &&
                !flags.userInvalidated &&
                (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid &&
                    flags.charsLeftOver === 0 &&
                    flags.unusedTokens.length === 0 &&
                    flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            }
            else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid (flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        }
        else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment (obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor (number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) ||
                (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false &&
                (typeof console !==  'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function () {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2); // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set (config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp(
            (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) +
                '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) &&
                    !hasOwnProp(childConfig, prop) &&
                    isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function (obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        };
    }

    var defaultCalendar = {
        sameDay : '[Today at] LT',
        nextDay : '[Tomorrow at] LT',
        nextWeek : 'dddd [at] LT',
        lastDay : '[Yesterday at] LT',
        lastWeek : '[Last] dddd [at] LT',
        sameElse : 'L'
    };

    function calendar (key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS  : 'h:mm:ss A',
        LT   : 'h:mm A',
        L    : 'MM/DD/YYYY',
        LL   : 'MMMM D, YYYY',
        LLL  : 'MMMM D, YYYY h:mm A',
        LLLL : 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat (key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate () {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal (number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future : 'in %s',
        past   : '%s ago',
        s  : 'a few seconds',
        ss : '%d seconds',
        m  : 'a minute',
        mm : '%d minutes',
        h  : 'an hour',
        hh : '%d hours',
        d  : 'a day',
        dd : '%d days',
        M  : 'a month',
        MM : '%d months',
        y  : 'a year',
        yy : '%d years'
    };

    function relativeTime (number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ?
            output(number, withoutSuffix, string, isFuture) :
            output.replace(/%d/i, number);
    }

    function pastFuture (diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias (unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({unit: u, priority: priorities[u]});
        }
        units.sort(function (a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') +
            Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken (token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function () {
                return this[callback]();
            };
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function () {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            };
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function () {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            };
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0, length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function (mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        };
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1         = /\d/;            //       0 - 9
    var match2         = /\d\d/;          //      00 - 99
    var match3         = /\d{3}/;         //     000 - 999
    var match4         = /\d{4}/;         //    0000 - 9999
    var match6         = /[+-]?\d{6}/;    // -999999 - 999999
    var match1to2      = /\d\d?/;         //       0 - 99
    var match3to4      = /\d\d\d\d?/;     //     999 - 9999
    var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
    var match1to3      = /\d{1,3}/;       //       0 - 999
    var match1to4      = /\d{1,4}/;       //       0 - 9999
    var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

    var matchUnsigned  = /\d+/;           //       0 - inf
    var matchSigned    = /[+-]?\d+/;      //    -inf - inf

    var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken (token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        };
    }

    function getParseRegexForToken (token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken (token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function (input, array) {
                array[callback] = toInt(input);
            };
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken (token, callback) {
        addParseToken(token, function (input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function () {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function () {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY',   4],       0, 'year');
    addFormatToken(0, ['YYYYY',  5],       0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y',      matchSigned);
    addRegexToken('YY',     match1to2, match2);
    addRegexToken('YYYY',   match1to4, match4);
    addRegexToken('YYYYY',  match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function (input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function (input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function (input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    };

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear () {
        return isLeapYear(this.year());
    }

    function makeGetSet (unit, keepTime) {
        return function (value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        };
    }

    function get (mom, unit) {
        return mom.isValid() ?
            mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1 (mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            }
            else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet (units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }


    function stringSet (units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function (o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        };
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function () {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function (format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function (format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M',    match1to2);
    addRegexToken('MM',   match1to2, match2);
    addRegexToken('MMM',  function (isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function (isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function (input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths (m, format) {
        if (!m) {
            return isArray(this._months) ? this._months :
                this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] :
            this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort (m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort :
                this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
            this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse (monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth (mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth (value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth () {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ?
                this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex (isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ?
                this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    }

    function createDate (y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date;
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            date = new Date(y + 400, m, d, h, M, s, ms);
            if (isFinite(date.getFullYear())) {
                date.setFullYear(y);
            }
        } else {
            date = new Date(y, m, d, h, M, s, ms);
        }

        return date;
    }

    function createUTCDate (y) {
        var date;
        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            var args = Array.prototype.slice.call(arguments);
            // preserve leap years using a full 400 year cycle, then reset
            args[0] = y + 400;
            date = new Date(Date.UTC.apply(null, args));
            if (isFinite(date.getUTCFullYear())) {
                date.setUTCFullYear(y);
            }
        } else {
            date = new Date(Date.UTC.apply(null, arguments));
        }

        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
            fwd = 7 + dow - doy,
            // first-week day local weekday -- which local weekday is fwd
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w',  match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W',  match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek (mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow : 0, // Sunday is the first day of the week.
        doy : 6  // The week that contains Jan 6th is the first week of the year.
    };

    function localeFirstDayOfWeek () {
        return this._week.dow;
    }

    function localeFirstDayOfYear () {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek (input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek (input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function (format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function (format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function (format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d',    match1to2);
    addRegexToken('e',    match1to2);
    addRegexToken('E',    match1to2);
    addRegexToken('dd',   function (isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd',   function (isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd',   function (isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES
    function shiftWeekdays (ws, n) {
        return ws.slice(n, 7).concat(ws.slice(0, n));
    }

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays (m, format) {
        var weekdays = isArray(this._weekdays) ? this._weekdays :
            this._weekdays[(m && m !== true && this._weekdays.isFormat.test(format)) ? 'format' : 'standalone'];
        return (m === true) ? shiftWeekdays(weekdays, this._week.dow)
            : (m) ? weekdays[m.day()] : weekdays;
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysShort, this._week.dow)
            : (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin (m) {
        return (m === true) ? shiftWeekdays(this._weekdaysMin, this._week.dow)
            : (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse (weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\\.?') + '$', 'i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\\.?') + '$', 'i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\\.?') + '$', 'i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek (input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ?
                this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ?
                this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex (isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ?
                this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }


    function computeWeekdaysParse () {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
            i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function () {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function () {
        return '' + this.hours() + zeroFill(this.minutes(), 2) +
            zeroFill(this.seconds(), 2);
    });

    function meridiem (token, lowercase) {
        addFormatToken(token, 0, 0, function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem (isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a',  matchMeridiem);
    addRegexToken('A',  matchMeridiem);
    addRegexToken('H',  match1to2);
    addRegexToken('h',  match1to2);
    addRegexToken('k',  match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function (input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function (input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function (input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function (input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function (input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM (input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem (hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }


    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour they want. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') &&
                module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                !(function webpackMissingModule() { var e = new Error("Cannot find module 'undefined'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale (key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            }
            else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            }
            else {
                if ((typeof console !==  'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key +  ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale (name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride',
                        'use moment.updateLocale(localeName, config) to change ' +
                        'an existing locale. moment.defineLocale(localeName, ' +
                        'config) should only be used for creating a new locale ' +
                        'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function (x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);


            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale (key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow (m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow =
                a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
                a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
                a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
                a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
                a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
                a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
                -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray (config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 &&
                config._a[MINUTE] === 0 &&
                config._a[SECOND] === 0 &&
                config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from beginning of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to beginning of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [
        ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
        ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
        ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
        ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
        ['YYYY-DDD', /\d{4}-\d{3}/],
        ['YYYY-MM', /\d{4}-\d\d/, false],
        ['YYYYYYMMDD', /[+-]\d{10}/],
        ['YYYYMMDD', /\d{8}/],
        // YYYYMM is NOT allowed by the standard
        ['GGGG[W]WWE', /\d{4}W\d{3}/],
        ['GGGG[W]WW', /\d{4}W\d{2}/, false],
        ['YYYYDDD', /\d{7}/]
    ];

    // iso time formats and regexes
    var isoTimes = [
        ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
        ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
        ['HH:mm:ss', /\d\d:\d\d:\d\d/],
        ['HH:mm', /\d\d:\d\d/],
        ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
        ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
        ['HHmmss', /\d\d\d\d\d\d/],
        ['HHmm', /\d\d\d\d/],
        ['HH', /\d\d/]
    ];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0, l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0, l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [
            untruncateYear(yearStr),
            defaultLocaleMonthsShort.indexOf(monthStr),
            parseInt(dayStr, 10),
            parseInt(hourStr, 10),
            parseInt(minuteStr, 10)
        ];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').replace(/^\s\s*/, '').replace(/\s\s*$/, '');
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100, h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate(
        'value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' +
        'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' +
        'discouraged and will be removed in an upcoming major release. Please refer to ' +
        'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
        function (config) {
            config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
        }
    );

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function () {};

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function () {};

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i,
            i, parsedInput, tokens, token, skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                }
                else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            }
            else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 &&
            getParsingFlags(config).bigHour === true &&
            config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }


    function meridiemFixWrap (locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,

            scoreToBeat,
            i,
            currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig (config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig (config) {
        var input = config._i,
            format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({nullInput: true});
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        }  else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function (obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC (input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) ||
                (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal (input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate(
        'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other < this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    var prototypeMax = deprecate(
        'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
        function () {
            var other = createLocal.apply(null, arguments);
            if (this.isValid() && other.isValid()) {
                return other > this ? this : other;
            } else {
                return createInvalid();
            }
        }
    );

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max () {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function () {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false; // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration (duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds +
            seconds * 1e3 + // 1000
            minutes * 6e4 + // 1000 * 60
            hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days +
            weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months +
            quarters * 3 +
            years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration (obj) {
        return obj instanceof Duration;
    }

    function absRound (number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset (token, separator) {
        addFormatToken(token, 0, 0, function () {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z',  matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function (input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk   = matches[matches.length - 1] || [];
        var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ?
          0 :
          parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset (m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function () {};

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset (input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone (input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC (keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal (keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset () {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            }
            else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset (input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime () {
        return (
            this.utcOffset() > this.clone().month(0).utcOffset() ||
            this.utcOffset() > this.clone().month(5).utcOffset()
        );
    }

    function isDaylightSavingTimeShifted () {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() &&
                compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal () {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset () {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc () {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration (input, key) {
        var duration = input,
            // matching against regexp is expensive, do it on demand
            match = null,
            sign,
            ret,
            diffRes;

        if (isDuration(input)) {
            duration = {
                ms : input._milliseconds,
                d  : input._days,
                M  : input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y  : 0,
                d  : toInt(match[DATE])                         * sign,
                h  : toInt(match[HOUR])                         * sign,
                m  : toInt(match[MINUTE])                       * sign,
                s  : toInt(match[SECOND])                       * sign,
                ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y : parseIso(match[2], sign),
                M : parseIso(match[3], sign),
                w : parseIso(match[4], sign),
                d : parseIso(match[5], sign),
                h : parseIso(match[6], sign),
                m : parseIso(match[7], sign),
                s : parseIso(match[8], sign)
            };
        } else if (duration == null) {// checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso (inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {};

        res.months = other.month() - base.month() +
            (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {milliseconds: 0, months: 0};
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
                'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val; val = period; period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        };
    }

    function addSubtract (mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add      = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' :
                diff < -1 ? 'lastWeek' :
                diff < 0 ? 'lastDay' :
                diff < 1 ? 'sameDay' :
                diff < 2 ? 'nextDay' :
                diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1 (time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone () {
        return new Moment(this);
    }

    function isAfter (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween (from, to, units, inclusivity) {
        var localFrom = isMoment(from) ? from : createLocal(from),
            localTo = isMoment(to) ? to : createLocal(to);
        if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
            return false;
        }
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) &&
            (inclusivity[1] === ')' ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
    }

    function isSame (input, units) {
        var localInput = isMoment(input) ? input : createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units) || 'millisecond';
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter (input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore (input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff (input, units, asFloat) {
        var that,
            zoneDelta,
            output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
            case 'year': output = monthDiff(this, that) / 12; break;
            case 'month': output = monthDiff(this, that); break;
            case 'quarter': output = monthDiff(this, that) / 3; break;
            case 'second': output = (this - that) / 1e3; break; // 1000
            case 'minute': output = (this - that) / 6e4; break; // 1000 * 60
            case 'hour': output = (this - that) / 36e5; break; // 1000 * 60 * 60
            case 'day': output = (this - that - zoneDelta) / 864e5; break; // 1000 * 60 * 60 * 24, negate dst
            case 'week': output = (this - that - zoneDelta) / 6048e5; break; // 1000 * 60 * 60 * 24 * 7, negate dst
            default: output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff (a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            // b is in (anchor - 1 month, anchor + 1 month)
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString () {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
     * Return a human readable representation of a moment that can
     * also be evaluated to get a new moment which is the same
     *
     * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
     */
    function inspect () {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format (inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow (withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to (time, withoutSuffix) {
        if (this.isValid() &&
                ((isMoment(time) && time.isValid()) ||
                 createLocal(time).isValid())) {
            return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow (withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale (key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate(
        'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
        function (key) {
            if (key === undefined) {
                return this.localeData();
            } else {
                return this.locale(key);
            }
        }
    );

    function localeData () {
        return this._locale;
    }

    var MS_PER_SECOND = 1000;
    var MS_PER_MINUTE = 60 * MS_PER_SECOND;
    var MS_PER_HOUR = 60 * MS_PER_MINUTE;
    var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;

    // actual modulo - handles negative numbers (for dates before 1970):
    function mod$1(dividend, divisor) {
        return (dividend % divisor + divisor) % divisor;
    }

    function localStartOfDate(y, m, d) {
        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return new Date(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return new Date(y, m, d).valueOf();
        }
    }

    function utcStartOfDate(y, m, d) {
        // Date.UTC remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0) {
            // preserve leap years using a full 400 year cycle, then reset
            return Date.UTC(y + 400, m, d) - MS_PER_400_YEARS;
        } else {
            return Date.UTC(y, m, d);
        }
    }

    function startOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year(), 0, 1);
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                break;
            case 'month':
                time = startOfDate(this.year(), this.month(), 1);
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date());
                break;
            case 'hour':
                time = this._d.valueOf();
                time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                break;
            case 'minute':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_MINUTE);
                break;
            case 'second':
                time = this._d.valueOf();
                time -= mod$1(time, MS_PER_SECOND);
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function endOf (units) {
        var time;
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond' || !this.isValid()) {
            return this;
        }

        var startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;

        switch (units) {
            case 'year':
                time = startOfDate(this.year() + 1, 0, 1) - 1;
                break;
            case 'quarter':
                time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                break;
            case 'month':
                time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                break;
            case 'week':
                time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                break;
            case 'isoWeek':
                time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                break;
            case 'day':
            case 'date':
                time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                break;
            case 'hour':
                time = this._d.valueOf();
                time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                break;
            case 'minute':
                time = this._d.valueOf();
                time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                break;
            case 'second':
                time = this._d.valueOf();
                time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
                break;
        }

        this._d.setTime(time);
        hooks.updateOffset(this, true);
        return this;
    }

    function valueOf () {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix () {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate () {
        return new Date(this.valueOf());
    }

    function toArray () {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject () {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON () {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2 () {
        return isValid(this);
    }

    function parsingFlags () {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt () {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function () {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function () {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken (token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg',     'weekYear');
    addWeekYearFormatToken('ggggg',    'weekYear');
    addWeekYearFormatToken('GGGG',  'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);


    // PARSING

    addRegexToken('G',      matchSigned);
    addRegexToken('g',      matchSigned);
    addRegexToken('GG',     match1to2, match2);
    addRegexToken('gg',     match1to2, match2);
    addRegexToken('GGGG',   match1to4, match4);
    addRegexToken('gggg',   match1to4, match4);
    addRegexToken('GGGGG',  match1to6, match6);
    addRegexToken('ggggg',  match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input,
                this.week(),
                this.weekday(),
                this.localeData()._week.dow,
                this.localeData()._week.doy);
    }

    function getSetISOWeekYear (input) {
        return getSetWeekYearHelper.call(this,
                input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear () {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear () {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function (input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter (input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIORITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D',  match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function (isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ?
          (locale._dayOfMonthOrdinalParse || locale._ordinalParse) :
          locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function (input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD',  match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function (input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear (input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m',  match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s',  match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function () {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function () {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function () {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function () {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function () {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function () {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
        return this.millisecond() * 1000000;
    });


    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S',    match1to3, match1);
    addRegexToken('SS',   match1to3, match2);
    addRegexToken('SSS',  match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z',  0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr () {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName () {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add               = add;
    proto.calendar          = calendar$1;
    proto.clone             = clone;
    proto.diff              = diff;
    proto.endOf             = endOf;
    proto.format            = format;
    proto.from              = from;
    proto.fromNow           = fromNow;
    proto.to                = to;
    proto.toNow             = toNow;
    proto.get               = stringGet;
    proto.invalidAt         = invalidAt;
    proto.isAfter           = isAfter;
    proto.isBefore          = isBefore;
    proto.isBetween         = isBetween;
    proto.isSame            = isSame;
    proto.isSameOrAfter     = isSameOrAfter;
    proto.isSameOrBefore    = isSameOrBefore;
    proto.isValid           = isValid$2;
    proto.lang              = lang;
    proto.locale            = locale;
    proto.localeData        = localeData;
    proto.max               = prototypeMax;
    proto.min               = prototypeMin;
    proto.parsingFlags      = parsingFlags;
    proto.set               = stringSet;
    proto.startOf           = startOf;
    proto.subtract          = subtract;
    proto.toArray           = toArray;
    proto.toObject          = toObject;
    proto.toDate            = toDate;
    proto.toISOString       = toISOString;
    proto.inspect           = inspect;
    proto.toJSON            = toJSON;
    proto.toString          = toString;
    proto.unix              = unix;
    proto.valueOf           = valueOf;
    proto.creationData      = creationData;
    proto.year       = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear    = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month       = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week           = proto.weeks        = getSetWeek;
    proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
    proto.weeksInYear    = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date       = getSetDayOfMonth;
    proto.day        = proto.days             = getSetDayOfWeek;
    proto.weekday    = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear  = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset            = getSetOffset;
    proto.utc                  = setOffsetToUTC;
    proto.local                = setOffsetToLocal;
    proto.parseZone            = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST                = isDaylightSavingTime;
    proto.isLocal              = isLocal;
    proto.isUtcOffset          = isUtcOffset;
    proto.isUtc                = isUtc;
    proto.isUTC                = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix (input) {
        return createLocal(input * 1000);
    }

    function createInZone () {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat (string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar        = calendar;
    proto$1.longDateFormat  = longDateFormat;
    proto$1.invalidDate     = invalidDate;
    proto$1.ordinal         = ordinal;
    proto$1.preparse        = preParsePostFormat;
    proto$1.postformat      = preParsePostFormat;
    proto$1.relativeTime    = relativeTime;
    proto$1.pastFuture      = pastFuture;
    proto$1.set             = set;

    proto$1.months            =        localeMonths;
    proto$1.monthsShort       =        localeMonthsShort;
    proto$1.monthsParse       =        localeMonthsParse;
    proto$1.monthsRegex       = monthsRegex;
    proto$1.monthsShortRegex  = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays       =        localeWeekdays;
    proto$1.weekdaysMin    =        localeWeekdaysMin;
    proto$1.weekdaysShort  =        localeWeekdaysShort;
    proto$1.weekdaysParse  =        localeWeekdaysParse;

    proto$1.weekdaysRegex       =        weekdaysRegex;
    proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
    proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1 (format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl (format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl (localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale(),
            shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths (format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort (format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin (localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal : function (number) {
            var b = number % 10,
                output = (toInt(number % 100 / 10) === 1) ? 'th' :
                (b === 1) ? 'st' :
                (b === 2) ? 'nd' :
                (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs () {
        var data           = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days         = mathAbs(this._days);
        this._months       = mathAbs(this._months);

        data.milliseconds  = mathAbs(data.milliseconds);
        data.seconds       = mathAbs(data.seconds);
        data.minutes       = mathAbs(data.minutes);
        data.hours         = mathAbs(data.hours);
        data.months        = mathAbs(data.months);
        data.years         = mathAbs(data.years);

        return this;
    }

    function addSubtract$1 (duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days         += direction * other._days;
        duration._months       += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1 (input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1 (input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil (number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble () {
        var milliseconds = this._milliseconds;
        var days         = this._days;
        var months       = this._months;
        var data         = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
                (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds           = absFloor(milliseconds / 1000);
        data.seconds      = seconds % 60;

        minutes           = absFloor(seconds / 60);
        data.minutes      = minutes % 60;

        hours             = absFloor(minutes / 60);
        data.hours        = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days   = days;
        data.months = months;
        data.years  = years;

        return this;
    }

    function daysToMonths (days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays (months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as (units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'quarter' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            switch (units) {
                case 'month':   return months;
                case 'quarter': return months / 3;
                case 'year':    return months / 12;
            }
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
                case 'week'   : return days / 7     + milliseconds / 6048e5;
                case 'day'    : return days         + milliseconds / 864e5;
                case 'hour'   : return days * 24    + milliseconds / 36e5;
                case 'minute' : return days * 1440  + milliseconds / 6e4;
                case 'second' : return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
                case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
                default: throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1 () {
        if (!this.isValid()) {
            return NaN;
        }
        return (
            this._milliseconds +
            this._days * 864e5 +
            (this._months % 12) * 2592e6 +
            toInt(this._months / 12) * 31536e6
        );
    }

    function makeAs (alias) {
        return function () {
            return this.as(alias);
        };
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds      = makeAs('s');
    var asMinutes      = makeAs('m');
    var asHours        = makeAs('h');
    var asDays         = makeAs('d');
    var asWeeks        = makeAs('w');
    var asMonths       = makeAs('M');
    var asQuarters     = makeAs('Q');
    var asYears        = makeAs('y');

    function clone$1 () {
        return createDuration(this);
    }

    function get$2 (units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function () {
            return this.isValid() ? this._data[name] : NaN;
        };
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds      = makeGetter('seconds');
    var minutes      = makeGetter('minutes');
    var hours        = makeGetter('hours');
    var days         = makeGetter('days');
    var months       = makeGetter('months');
    var years        = makeGetter('years');

    function weeks () {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,         // a few seconds to seconds
        s : 45,         // seconds to minute
        m : 45,         // minutes to hour
        h : 22,         // hours to day
        d : 26,         // days to month
        M : 11          // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds  = round(duration.as('s'));
        var minutes  = round(duration.as('m'));
        var hours    = round(duration.as('h'));
        var days     = round(duration.as('d'));
        var months   = round(duration.as('M'));
        var years    = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds]  ||
                seconds < thresholds.s   && ['ss', seconds] ||
                minutes <= 1             && ['m']           ||
                minutes < thresholds.m   && ['mm', minutes] ||
                hours   <= 1             && ['h']           ||
                hours   < thresholds.h   && ['hh', hours]   ||
                days    <= 1             && ['d']           ||
                days    < thresholds.d   && ['dd', days]    ||
                months  <= 1             && ['M']           ||
                months  < thresholds.M   && ['MM', months]  ||
                years   <= 1             && ['y']           || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding (roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof(roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold (threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize (withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days         = abs$1(this._days);
        var months       = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes           = absFloor(seconds / 60);
        hours             = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years  = absFloor(months / 12);
        months %= 12;


        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' +
            (Y ? ymSign + Y + 'Y' : '') +
            (M ? ymSign + M + 'M' : '') +
            (D ? daysSign + D + 'D' : '') +
            ((h || m || s) ? 'T' : '') +
            (h ? hmsSign + h + 'H' : '') +
            (m ? hmsSign + m + 'M' : '') +
            (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid        = isValid$1;
    proto$2.abs            = abs;
    proto$2.add            = add$1;
    proto$2.subtract       = subtract$1;
    proto$2.as             = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds      = asSeconds;
    proto$2.asMinutes      = asMinutes;
    proto$2.asHours        = asHours;
    proto$2.asDays         = asDays;
    proto$2.asWeeks        = asWeeks;
    proto$2.asMonths       = asMonths;
    proto$2.asQuarters     = asQuarters;
    proto$2.asYears        = asYears;
    proto$2.valueOf        = valueOf$1;
    proto$2._bubble        = bubble;
    proto$2.clone          = clone$1;
    proto$2.get            = get$2;
    proto$2.milliseconds   = milliseconds;
    proto$2.seconds        = seconds;
    proto$2.minutes        = minutes;
    proto$2.hours          = hours;
    proto$2.days           = days;
    proto$2.weeks          = weeks;
    proto$2.months         = months;
    proto$2.years          = years;
    proto$2.humanize       = humanize;
    proto$2.toISOString    = toISOString$1;
    proto$2.toString       = toISOString$1;
    proto$2.toJSON         = toISOString$1;
    proto$2.locale         = locale;
    proto$2.localeData     = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function (input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function (input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports


    hooks.version = '2.24.0';

    setHookCallback(createLocal);

    hooks.fn                    = proto;
    hooks.min                   = min;
    hooks.max                   = max;
    hooks.now                   = now;
    hooks.utc                   = createUTC;
    hooks.unix                  = createUnix;
    hooks.months                = listMonths;
    hooks.isDate                = isDate;
    hooks.locale                = getSetGlobalLocale;
    hooks.invalid               = createInvalid;
    hooks.duration              = createDuration;
    hooks.isMoment              = isMoment;
    hooks.weekdays              = listWeekdays;
    hooks.parseZone             = createInZone;
    hooks.localeData            = getLocale;
    hooks.isDuration            = isDuration;
    hooks.monthsShort           = listMonthsShort;
    hooks.weekdaysMin           = listWeekdaysMin;
    hooks.defineLocale          = defineLocale;
    hooks.updateLocale          = updateLocale;
    hooks.locales               = listLocales;
    hooks.weekdaysShort         = listWeekdaysShort;
    hooks.normalizeUnits        = normalizeUnits;
    hooks.relativeTimeRounding  = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat        = getCalendarFormat;
    hooks.prototype             = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',             // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',  // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',   // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',                             // <input type="date" />
        TIME: 'HH:mm',                                  // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',                       // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',                        // <input type="time" step="0.001" />
        WEEK: 'GGGG-[W]WW',                             // <input type="week" />
        MONTH: 'YYYY-MM'                                // <input type="month" />
    };

    return hooks;

})));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "./node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/rdfjson/main.js":
/*!**************************************!*\
  !*** ./node_modules/rdfjson/main.js ***!
  \**************************************/
/*! exports provided: namespaces, converters, Graph, Statement, utils, print */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _src_namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/namespaces */ "./node_modules/rdfjson/src/namespaces.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namespaces", function() { return _src_namespaces__WEBPACK_IMPORTED_MODULE_0__["default"]; });

/* harmony import */ var _src_formats_converters__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./src/formats/converters */ "./node_modules/rdfjson/src/formats/converters.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "converters", function() { return _src_formats_converters__WEBPACK_IMPORTED_MODULE_1__["default"]; });

/* harmony import */ var _src_Graph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./src/Graph */ "./node_modules/rdfjson/src/Graph.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Graph", function() { return _src_Graph__WEBPACK_IMPORTED_MODULE_2__["default"]; });

/* harmony import */ var _src_Statement__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/Statement */ "./node_modules/rdfjson/src/Statement.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Statement", function() { return _src_Statement__WEBPACK_IMPORTED_MODULE_3__["default"]; });

/* harmony import */ var _src_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./src/utils */ "./node_modules/rdfjson/src/utils.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _src_utils__WEBPACK_IMPORTED_MODULE_4__["default"]; });

/* harmony import */ var _src_print__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./src/print */ "./node_modules/rdfjson/src/print.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "print", function() { return _src_print__WEBPACK_IMPORTED_MODULE_5__["default"]; });









/***/ }),

/***/ "./node_modules/rdfjson/src/Graph.js":
/*!*******************************************!*\
  !*** ./node_modules/rdfjson/src/Graph.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Graph; });
/* harmony import */ var _formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./formats/rdfjson/util */ "./node_modules/rdfjson/src/formats/rdfjson/util.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/rdfjson/src/namespaces.js");
/* harmony import */ var _Statement__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Statement */ "./node_modules/rdfjson/src/Statement.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils */ "./node_modules/rdfjson/src/utils.js");





/**
 * @param {Array} arr
 * @returns {*}
 * @private
 */
const zeroOrOne = arr => (arr.length === 0 ? arr : [arr[0]]);

/**
 * @param {rdfjson/Graph} graph
 * @param {rdfjson/Statement[]} statements an array
 * @param {Boolean=} perSubject if true means that all consecutive calls will be focused on
 * all the subjects of the specified statments, otherwise the resource objects of the statements
 * will be the focus. Assumed to be false unless explicitly set to true.
 *
 * @returns {{object: Function, objects: Function, constr: Function, each: Function, nodes:
 * Function, values: Function, firstValue: Function}}
 * @private
 */
const perStatement = (graph, statements, perSubject) => ({
  object(predicate) {
    for (let i = 0; i < statements.length; i++) {
      let subj;
      if (perSubject) {
        subj = statements[i].getSubject();
      } else {
        const t = statements[i].getType();
        if (t === 'uri' || t === 'bnode') {
          // eslint-disable-next-line no-continue
          continue;
        }
        subj = statements[i].getValue();
      }
      const stmts = graph.find(subj, predicate);
      if (stmts.length > 0) {
        perStatement(graph, [stmts[0]]);
      }
    }
    return perStatement(graph, []);
  },
  objects(predicate) {
    let nstats = [];
    let i;
    if (perSubject === true) {
      for (i = 0; i < statements.length; i++) {
        nstats = nstats.concat(graph.find(statements[i].getSubject(), predicate));
      }
    } else {
      for (i = 0; i < statements.length; i++) {
        const t = statements[i].getType();
        if (t === 'uri' || t === 'bnode') {
          nstats = nstats.concat(graph.find(statements[i].getValue(), predicate));
        }
      }
    }
    return perStatement(graph, nstats);
  },
  constr(predicate, object) {
    let _object = object;
    if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].isString(_object)) {
      _object = { type: 'uri', value: _object };
    }
    const nstats = [];
    for (let i = 0; i < statements.length; i++) {
      const subj = perSubject ? statements[i].getSubject() : statements[i].getValue();
      if (graph.find(subj, predicate, _object).length > 0) {
        nstats.push(statements[i]);
      }
    }
    return perStatement(graph, nstats, perSubject);
  },
  /**
   * For each match the callback will be called with a focused iterator.
   */
  each(callback, type) {
    if (perSubject === true) {
      for (let i = 0; i < statements.length; i++) {
        const subj = statements[i].getSubject();
        const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';
        if (type == null || type === t) {
          callback(perStatement(graph, statements[i], perSubject));
        }
      }
    } else {
      for (let j = 0; j < statements.length; j++) {
        callback(perStatement(graph, statements[j], perSubject));
      }
    }
  },
  nodes(type) {
    const res = [];
    if (perSubject === true) {
      for (let i = 0; i < statements.length; i++) {
        const subj = statements[i].getSubject();
        const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';
        if (type == null || type === t) {
          res.push({ type: t, value: statements[i].getSubject() });
        }
      }
    } else {
      for (let j = 0; j < statements.length; j++) {
        if (type == null || type === statements[j].getType()) {
          res.push(statements[j].getObject());
        }
      }
    }
    return res;
  },
  values(type) {
    const res = [];
    if (perSubject === true) {
      for (let i = 0; i < statements.length; i++) {
        const subj = statements[i].getSubject();
        const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';
        if (type == null || type === t) {
          res.push(statements[i].getSubject());
        }
      }
    } else {
      for (let j = 0; j < statements.length; j++) {
        if (type == null || type === statements[j].getType()) {
          res.push(statements[j].getValue());
        }
      }
    }
    return res;
  },
  firstValue(type) {
    if (perSubject === true) {
      for (let i = 0; i < statements.length; i++) {
        const subj = statements[i].getSubject();
        const t = subj.substring(0, 2) === '_:' ? 'bnode' : 'uri';
        if (type == null || type === t) {
          return statements[i].getSubject();
        }
      }
    } else {
      for (let j = 0; j < statements.length; j++) {
        if (type == null || type === statements[j].getType()) {
          return statements[j].getValue();
        }
      }
    }
    return undefined;
  },
});

/**
 * Provides an API for accessing and manipulating an RDF Graph.
 *
 * The Graph API wraps a pure RDF JSON object to make it easy to access and manipulate on the
 * level of rdfjson/Statements.
 * Note that for efficiency reasons the RDF JSON object will be extended, hence it will
 * contain attributes that goes beyond the specification.
 *
 * The pure RDF JSON object:
 * <ul><li>can still be inspected independently, it will contain the correct RDF expression.
 *     </li>
 *     <li>cannot be modified directly since it will conflict with manipulations via this
 *     class, the exception is the statement object attributes which can be updated.</li>
 *     <li>is now unsuitable to be communicated for instance back to a server storage
 *      due to the extra attributes. Use the exportRDFJSON function to get a clean RDF
 *      JSON object.</li></ul>
 *
 * @exports rdfjson/Graph
 */
class Graph {
  /**
   * The constructor is sheap, no indexes or additional statements are created until requested
   * or created.
   * @param {Object=} graph a pure RDF JSON object according to the specification that will be
   * manipulated internally.
   * @param {Boolean=} validate indicates wether to validate the graph directly or not.
   */
  constructor(graph = null, validate) {
    this._graph = graph || {};
    /**
     * Internal index of bnodes, will never shrink after creation of this graph instance.
     * New bnodes will be added but bnodes contained in removed statements will be kept
     * in case the statement is only temporarily unasserted.
     */
    this._bnodes = {};
    /**
     * If true the graph has been iterated through and all found bnodes have been added to index.
     */
    this._bnodesIndexed = false;

    if (validate !== false) {
      this.validate();
    }
    this._changed = false;
  }

  /**
   * @return {Boolean} true if the graph contains no asserted statements.
   */
  isEmpty() {
    return !Object.keys(this._graph).find((s) => {
      const props = this._graph[s];
      return Object.keys(props).find(p =>
        props[p].find(o => o._statement == null || o._statement.isAsserted()));
    });
  }

  // eslint-disable-next-line class-methods-use-this
  onChange() {
  }

  setChanged(changed) {
    this._changed = !!(changed === true || changed == null);
    if (this._changed) {
      this.onChange();
    }
  }

  isChanged() {
    return this._changed;
  }

  /**
   * Adds all statements of a graph to the current graph.
   * Will create new blank nodes ids in the source graph to avoid clashes with target graph.
   *
   * @param graph
   */
  addAll(graph, ng) {
    const bnodeIdx = {};
    let bn;
    const stmts = graph.find();
    for (let i = 0; i < stmts.length; i++) {
      const stmt = stmts[i];
      let s = stmt.getSubject();
      let p = stmt.getPredicate();
      const o = stmt.getCleanObject();
      if (ng) {
        o.ng = ng;
      }

      if (s.indexOf('_:') === 0) {
        bn = bnodeIdx[s] || this._newBNode();
        bnodeIdx[s] = bn;
        s = bn;
      }
      if (p.indexOf('_:') === 0) {
        bn = bnodeIdx[p] || this._newBNode();
        bnodeIdx[p] = bn;
        p = bn;
      }
      if (o.type === 'bnode') {
        bn = bnodeIdx[o.value] || this._newBNode();
        bnodeIdx[o.value] = bn;
        o.value = bn;
      }
      this.add(s, p, o);
    }
  }

  /**
   * Adds a statement to the graph, either an existing statement or creates an new one from the
   * triple pattern. If a statement instance is used it may originate from another graph, although
   * potential bnodes are not renamed.
   *
   * @param {rdfjson/Statement|string} s either the subject in a triple pattern or a Statement
   * instance to add,
   * in the latter case the other parameters must be undefined.
   * @param {string|null} p the predicate of the triple to add.
   * @param {Object|string} o the object where the attributes type, value, lang and datatype are
   * used to describe the object.
   * @param {boolean} [silent=false] silent if the change should mark the graph as changed
   * @returns {rdfjson/Statement}
   */
  add(s, p = null, o = null, silent = false) {
    if (s instanceof _Statement__WEBPACK_IMPORTED_MODULE_2__["default"]) {
      const _p = s.getPredicate();
      const _o = s.getObject();
      const _s = s.getSubject();
      this._trackBNodes(_s, _p, _o);
      const o1 = this._graphObject(_o);
      const o2 = _formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].add(this._graph, _s, _p, o1);
      if (silent !== true) {
        this.setChanged();
      }
      return this._get(_s, _p, o2, true);
    }
    return this.create(s, p, o, true, silent);
  }

  addL(s, p, value, lang) {
    const o = { type: 'literal', value };
    if (typeof lang === 'string') {
      o.lang = lang;
    }
    return this.create(s, p, o, true);
  }

  addD(s, p, value, datatype) {
    const o = { type: 'literal', value };
    if (typeof datatype === 'string') {
      o.datatype = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(datatype);
    }
    return this.create(s, p, o, true);
  }

  /**
   * Creates a new statement and associates it to the graph, unless assert is explicitly set to
   * false it is also added to the graph.
   *
   * @param {String=} s the subject as a uri, if undefined a new blank node is created.
   * @param {String} p the predicate as a uri, if undefined a new blank node is created.
   * @param {Object} o the object in the form of an object containing the attributes:
   * 'type', 'value', 'lang', and 'datatype'. If undefined a new blank node is created.
   *  If a string is provided it is assumed to be a url, i.e. sending in "the url" is the same as
   *  sending in {type: "uri", value: "the url"}.
   * @param {Boolean} [assert=true] indicated if the statement should be added to the graph directly.
   * If not specified true is assumed.
   * @param {boolean} [silent=false] silent if the change should mark the graph as changed
   * @returns {rdfjson/Statement}
   * @see rdfjson/rdfjson#add
   */
  create(s = null, p = null, o = null, assert = true, silent = false) {
    let _s = s;
    let _p = p;
    let _o = o;
    if (_s == null) {
      _s = this._newBNode();
    } else {
      _s = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_s);
    }
    if (_p == null) {
      _p = this._newBNode();
    } else {
      _p = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_p);
    }

    if (_o == null) {
      _o = { type: 'bnode', value: this._newBNode() };
    } else if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].isString(_o)) {
      _o = { type: 'uri', value: _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_o) };
    } else {
      // The object is copied to avoid reuse of same object in multiple places of the graph
      // leading to strange updates.
      _o = { type: _o.type, value: _o.value, lang: _o.lang, datatype: _o.datatype };
      if (_o.type === 'uri' && _o.value != null) {
        _o.value = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_o.value);
      }
      if (_o.datatype) {
        _o.datatype = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_o.datatype);
      }
    }
    if (assert !== false) {
      const o1 = _formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].add(this._graph, _s, _p, _o);
      if (silent !== true) {
        this.setChanged();
      }
      return this._getOrCreate(_s, _p, o1, true);
    }
    return new _Statement__WEBPACK_IMPORTED_MODULE_2__["default"](this, _s, _p, _o, false);
  }

  /**
   * Convenience function that combines the find and remove functions.
   * @param {String=} s the subject
   * @param {String=} p the predicate
   * @param {Object=} o the object
   * @param {boolean} [silent=false] silent if the change should mark the graph as changed
   * @see rdfjson/Graph#find
   * @see rdfjson/Graph#remove
   */
  findAndRemove(s, p, o, silent = false) {
    const stmts = this.find(s, p, o);
    for (let i = 0; i < stmts.length; i++) {
      this.remove(stmts[i], silent);
    }
  }

  /**
   * Removes the given statement from the graph.
   * If you plan to keep the statement around and assert it later,
   * it is recommended to only use the rdfjson/Statement#setAsserted method instead.
   *
   * @param {rdfjson/Statement} statement the statement to remove from the graph.
   * @param {boolean} [silent=false] silent if the change should mark the graph as changed
   * @see rdfjson/Statement#setAsserted
   */
  remove(statement, silent = false) {
    const s = statement.getSubject();
    const p = statement.getPredicate();
    const o = statement.getObject();
    this._trackBNodes(s, p, o);
    if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].remove(this._graph, s, p, o) != null) {
      if (silent !== true) {
        this.setChanged();
      }
    }
  }

  /**
   * Finds all statements that fulfills the given pattern. Any combination of the arguments may
   * be left out.
   *
   * @param {String=} s the subject in the statements to be returned, undefined indicates that
   * any subject is ok.
   * @param {String=} p the predicate in the statements to be returned, undefined indicates
   * that any predicate is ok.
   * @param {Object=} o the object in the statements to be returned, undefined indicates that
   * any object is ok.
   * Objets of matching statements have to be equal according to the objectEquals method.
   * @return {rdfjson/Statement[]}
   * @see rdfjson/rdfjson#objectEquals
   */
  find(s, p, o) {
    let _s = s;
    let _p = p;
    let _o = o;
    // none, s, p, s&p
    if (typeof _s === 'string') {
      _s = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_s);
    }
    if (typeof _p === 'string') {
      _p = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_p);
    }
    if (typeof _o === 'object' && _o !== null && _o.type === 'uri') {
      _o.value = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_o.value);
    } else if (typeof _o === 'string') {
      _o = { type: 'uri', value: _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(_o) };
    }
    if (_o == null) {
      // none, s
      if (_p == null) {
        if (_s == null) {
          return this._find();
        }
        return this._findS(_s);

        // p, s&p
      }
      // p
      if (_s == null) {
        return this._findP(_p);
        // s&p
      }
      return this._findSP(_s, _p);
    }
    // o, s&o
    if (_p == null) {
      if (_s == null) {
        return this._findO(_o);
      }
      return this._findSO(_s, _o);
    }

    // p&o
    if (_s == null) {
      return this._findPO(_p, _o);
    }

    // s&p&o
    const stmt = this._get(_s, _p, _formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].contains(this._graph, _s, _p, _o), true);
    if (stmt == null) {
      return [];
    }
    return [stmt];
  }

  /**
   * Convenience method that returns the value of object of the first matching Statement
   * for the given subject and predicate.
   *
   * @param {String=} s the subject
   * @param {String=} p the predicate
   * @return {String} the value, may be a literal or a URI, if undefined no matching statement
   * (and value) could be found.
   * @see rdfjson/Graph#find
   */
  findFirstValue(s, p) {
    const arr = this.find(s, p);
    if (arr.length > 0) {
      return arr[0].getValue();
    }
    return undefined;
  }

  /**
   * Retrieves a projection, a plain object with simple attribute value pairs given a subject
   * and a mapping.
   * The mapping is an object where the same attributes appear but with the predicates are values.
   * Hence, each attribute gives rise to a search for all statements with the given subject and
   * the predicate specified by the attribute.
   * The result object will contain the mapping attributes with values from the the first
   * matched statements object value if there are any.
   * To access additional information like multiple statement or the statements
   * (type, language, datatype) a "*" prepended version of each attribute can be provided that
   * contains a list of matching Statements if so indicated by the multipleValueStyle parameter.
   *
   * @param {String} s the subject to use for the projection.
   * @param {Object} mapping the mapping configuration
   * @param {String} multipleValueStyle if provided an array is provided for that property
   * prefixed with "*", the array should be indicated to be either
   * "statements", "values" or "objects".
   * @returns {Object}
   * @example
   * var proj = graph.projection("http://example.com", {
   *     "title":       "http://purl.org/dc/terms/title",
   *     "description": "http://purl.org/dc/terms/description"
   * });
   * // The object proj now has the attributes title, *title, description, and *description.
   *
   * // Accessing the title of http://example.com
   * console.log(proj.title);
   *
   * // To get hold of additional information available in the statement,
   * // for instance the language of a literal:
   * console.log(proj["*title"][0].getLanguage())
   *
   */
  projection(s, mapping, multipleValueStyle) {
    const mapped = {};
    Object.keys(mapping).forEach((key) => {
      const prop = mapping[key];
      const values = this.find(s, prop);
      if (values.length > 0) {
        if (key[0] === '*') {
          mapped[key.substr(1)] = values.map(val => val.getValue());
        } else {
          mapped[key] = values[0].getValue();
        }
        switch (multipleValueStyle || 'none') {
          case 'statement':
            mapped[`*${key}`] = values;
            break;
          case 'objects':
            mapped[`*${key}`] = values.map(v => v.getCleanObject());
            break;
          case 'values':
            mapped[`*${key}`] = values.map(v => v.getValue());
            break;
          default:
        }
      }
    });
    return mapped;
  }

  subjects(p, o) {
    return perStatement(this, this.find(null, p, o), true);
  }

  subject(p, o) {
    return perStatement(this, zeroOrOne(this.find(null, p, o)), true);
  }

  objects(s, p) {
    return perStatement(this, this.find(s, p, null));
  }

  object(s, p) {
    return perStatement(this, zeroOrOne(this.find(s, p, null)));
  }


  /**
   * Constructs a rdf:List for the provided array.
   * @param {array} list an array of objects, same as the object parameter to the add method.
   * @returns {String} the blank node id, or rdf:nil if the list is empty
   */
  addList(list) {
    return this._addList(list, 'add');
  }

  /**
   * Constructs a rdf:List for the provided array of literals with the common language.
   * @param {array[string]} an array of literals.
   * @param {string} the language common to all the literals in the array
   * (if this is not what you want you have to use the addList method with objects instead).
   * @returns {String} the blank node id, or rdf:nil if the list is empty
   */
  addListL(list, language) {
    return this._addList(list, 'addL', language);
  }

  /**
   * Constructs a rdf:List for the provided array of literals with the common datatype.
   * @param {array[string]} an array of literals.
   * @param {string} the datatype common to all the literals in the array
   * (if this is not what you want you have to use the addList method with objects instead).
   * @returns {String} the blank node id, or rdf:nil if the list is empty
   */
  addListD(list, datatype) {
    return this._addList(list, 'addD', datatype);
  }

  _addList(list, method, langorDatatype) {
    let listnode;
    if (!Array.isArray(list) || list.length === 0) {
      listnode = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand('rdf:nil');
    } else {
      listnode = this._newBNode();
      let cursor = listnode;
      const nilPosition = list.length - 1;
      list.forEach((member, idx) => {
        this[method](cursor, 'rdf:first', member, langorDatatype);
        if (idx !== nilPosition) {
          cursor = this.add(cursor, 'rdf:rest').getValue();
        } else {
          this.add(cursor, 'rdf:rest', 'rdf:nil');
        }
      });
    }
    return listnode;
  }

  /**
   * Removes all tripples that makes up the list starting from the given resource.
   * @param o - the resource from which the list starts.
   * @return {boolean} true if the list was identifed as a valid list and removed.
   */
  removeList(o) {
    let listFound = false;
    let cursor = typeof o === 'object' ? o.value : o;
    try {
      const nil = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand('rdf:nil');
      listFound = cursor === nil;
      while (cursor !== nil && cursor != null) {
        const next = this.findFirstValue(cursor, 'rdf:rest');
        this.findAndRemove(cursor);
        cursor = next;
        listFound = cursor != null;
      }
    } catch (e) {
      console.warn(`Invalid list for object: ${cursor}`);
      return false;
    }
    return listFound;
  }

  /**
   * Extracts the rdf:List instance.
   * @param {String} o - the first resource node of the (linked) list.
   * @returns {Array} of objects (the same as is returned from Statement.getObject())
   */
  getList(o) {
    let cursor = typeof o === 'object' ? o.value : o;
    const list = [];
    try {
      const nil = _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand('rdf:nil');
      while (cursor !== nil && cursor != null) {
        list.push(this.find(cursor, 'rdf:first')[0].getObject());
        cursor = this.findFirstValue(cursor, 'rdf:rest');
      }
    } catch (e) {
      console.warn(`Invalid list for object: ${cursor}`);
    }
    return list;
  }

  /**
   * Extracts the first list to be found given a subject and predicate.
   *
   * @param {String} s - the subject
   * @param {String} p - the predicate
   * @returns {String[]} array of strings, assuming the nodetype, datatype or
   * language is either not present or vital.
   */
  findFirstListAsValues(s, p) {
    return this.getList(this.findFirstValue(s, p)).map(obj => obj.value);
  }

  /**
   * Finds and removes all matched lists including the triples pointing to them.
   * @param {string} s - the subject
   * @param {string} p - the predicate
   * @return {boolean} true if at least one list was removed
   */
  findAndRemoveLists(s, p) {
    let removed = false;
    this.find(s, p).forEach((stmt) => {
      if (this.removeList(stmt.getValue())) {
        this.remove(stmt);
        removed = true;
      }
    });
    return removed;
  }


  /**
   * @return {Object} a plain RDF JSON object without the additional artifacts created by this
   * Graph class.
   * The returned object is suitable for serilization and communicated with other systems.
   */
  exportRDFJSON() {
    const graph = this._graph;
    const ngraph = {};
    Object.keys(graph).forEach((s) => {
      const subj = graph[s];
      ngraph[s] = {};
      Object.keys(subj).forEach((p) => {
        const nObjArr = [];
        ngraph[s][p] = nObjArr;
        subj[p].forEach((o) => {
          const no = { type: o.type, value: o.value };
          if (o.ng != null) {
            no.ng = o.ng;
          }
          if (o.lang != null) {
            no.lang = o.lang;
          }
          if (o.datatype != null) {
            no.datatype = o.datatype;
          }
          nObjArr.push(no);
        });
      });
    });
    return ngraph;
  }

  /**
   * Replaces a URI in subject position with another,
   * assuming the target URI does not exist in the graph already.
   *
   * @param sourceURI
   * @param targetURI
   * @returns {Graph}
   * @deprecated Use replaceURI instead.
   */
  replaceSubject(sourceURI, targetURI) {
    return this.replaceURI(sourceURI, targetURI);
  }

  /**
   * Replaces all occurences of a URI in the graph with another URI.
   * Assumes the target URI does not exist in the graph already.
   *
   * @param sourceURI
   * @param targetURI
   * @returns {Graph}
   */
  replaceURI(sourceURI, targetURI) {
    const graph = this._graph;
    if (graph.hasOwnProperty(sourceURI)) {
      if (!graph.hasOwnProperty((targetURI))) {
        graph[targetURI] = graph[sourceURI];
        delete graph[sourceURI];
      } else {
        throw new Error('Cannot replace subject with target URI since it already exists.');
      }

      this.forEach((s, p, o) => {
        if (o.type === 'uri' && o.value === sourceURI) {
          o.value = targetURI;
        }
        if (s === targetURI && o._statement) {
          o._statement._s = targetURI;
        }
      });
    }

    return this;
  }

  replaceBlankWithURI(sourceBlank, targetURI) {
    const graph = this._graph;
    if (graph.hasOwnProperty(sourceBlank)) {
      if (!graph.hasOwnProperty((targetURI))) {
        graph[targetURI] = graph[sourceBlank];
        delete graph[sourceBlank];
      } else {
        throw new Error('Cannot replace subject with target URI since it already exists.');
      }

      this.forEach((s, p, o) => {
        if (o.type === 'bnode' && o.value === sourceBlank) {
          o.value = targetURI;
          o.type = 'uri';
        }
        if (s === targetURI && o._statement) {
          o._statement._s = targetURI;
        }
      });
    }
    delete this._bnodes[sourceBlank];

    return this;
  }

  /**
   * Clones this graph.
   * @returns {rdfjson/Graph}
   */
  clone() {
    return new Graph(this.exportRDFJSON());
  }

  /**
   * Finds all properties for a given subject.
   * Note: Optimal.
   * @param {String} s the subject to find properties for
   * @return {Array[String]} of strings
   */
  findProperties(s) {
    return Object.keys(this._graph[s] || {});
  }

  /**
   * Validates the graph and returns a report.
   * If errors are detected an exception is thrown.
   * The validation report is a object with a valid attribute which is either false or true.
   * If it is false an array of errors are provided where each error is an object containing
   * a message and information regarding which subject,predicate and object index in the
   * rdjson javascript object that caused the error..
   *
   * @returns {undefined} if there where no errors
   * @throws {Object} the validation report.
   */
  validate() {
    this.report = this._validate();
    if (!this.report.valid) {
      throw (this.report);
    }
    return this.report;
  }

  /**
   * You should not use this function unless you are VERY certain of what you are doing.
   *
   * @private
   * @param {String} bNodeId
   */
  registerBNode(bNodeId) {
    this._bnodes[bNodeId] = true;
  }

  /**
   * Iterates through all statements of the graph and calls the provided function on them.
   *
   * @param {Function} f are called for each statement with the three arguments
   *  (in order) subject, predicate, and object.
   */
  forEach(f) {
    const graph = this._graph;
    Object.keys(graph).forEach((s) => {
      const subj = graph[s];
      Object.keys(subj).forEach((p) => {
        subj[p].forEach((o) => {
          f(s, p, o);
        });
      });
    });
  }

  /**
   * Iterates through all statements of the graph and calls the provided function on them and
   * returns an array of the results.
   *
   * @param {Function} f are called for each statement with the three arguments
   *  (in order) subject, predicate, and object, f should return a value that is added to the
   *  array
   * @return {array} an array with the value of the function applied for each statement.
   */
  map(f) {
    const arr = [];
    this.forEach((stmt) => {
      arr.push(f(stmt));
    });
    return arr;
  }

  /**
   * Compares this graph with another, true if they are isomorphic.
   * Comparision is done using the fingerprint mechanism. Hence, this method is not fullproof.
   *
   * @param {rdfjson/Graph} graph to compare to
   * @param {array} excludeProperties an array of properties to exclude in comparision check
   * @return {boolean} true if the graphs are isomorphic disregarding the excluded properties.
   * @see {rdfjson/utils#fingerprint}
   */
  equals(graph, excludeProperties) {
    return _utils__WEBPACK_IMPORTED_MODULE_3__["default"].fingerprint(this, excludeProperties) === _utils__WEBPACK_IMPORTED_MODULE_3__["default"].fingerprint(graph, excludeProperties);
  }

  /**
   * Calculates the amounts of triples in the graph.
   * @returns {number}
   */
  size() {
    let size = 0;
    Object.values(this._graph).forEach((subjObj) => {
      Object.values(subjObj).forEach((objects) => {
        size += objects.length;
      });
    });
    return size;
  }

  // ===================================================
  // Private methods
  // ===================================================

  /**
   * If the object already contains a statement that is returned, otherwise a new is created.
   * If the object is not specified undefined is returned.
   * @return {Statement|undefined} a statement that belongs to this graph.
   * @private
   */
  _get(s, p, o, asserted) {
    if (o == null) {
      return undefined;
    }

    return this._getOrCreate(s, p, o, asserted);
  }

  /**
   * If the object already contains a statement that is returned, otherwise a new is created.
   * @return {rdfjson/Statement} a statement that belongs to this graph.
   * @private
   */
  _getOrCreate(s, p, o, asserted) {
    if (o._statement == null) {
      o._statement = new _Statement__WEBPACK_IMPORTED_MODULE_2__["default"](this, s, p, o, asserted);
    }
    return o._statement;
  }

  /**
   * @return {Object} if the object originates from another graph a copy is made.
   * @private
   */
  _graphObject(o) {
    if (o._statement == null ||
      o._statement._graph === this) {
      return o;
    }
    return { type: o.type, value: o.value, lang: o.lang, datatype: o.datatype };
  }

  /**
   * Finds all statements with a given subject and object.
   * @param {String} s
   * @param {String} p
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _findSP(s, p) {
    if (this._graph[s] == null || this._graph[s][p] == null) {
      return [];
    }
    return this._graph[s][p].map(o => this._get(s, p, o, true));
  }

  /**
   * Finds all statements with a given subject.
   * Note: Optimal.
   * @param {String} s
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _findS(s) {
    const subj = this._graph[s];
    const spArrs = Object.keys(subj || {}).map(p => this._findSP(s, p));
    return Array.prototype.concat.apply([], spArrs);
  }

  /**
   * Generates statements for the entire graph.
   * Note: Optimal.
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _find() {
    const arr = [];
    this.forEach((s1, p1, o1) => {
      arr.push(this._get(s1, p1, o1, true));
    });
    return arr;
  }

  /**
   * Finds all statements with a given predicate.
   * Note: Close to optimal without further indexing, to many checks due to iteration via _map.
   * @param {String} p
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _findP(p) {
    const arr = [];
    this.forEach((s1, p1, o1) => {
      if (p === p1) {
        arr.push(this._get(s1, p1, o1, true));
      }
    });
    return arr;
  }

  /**
   * Iterates through all statements to find those with specified object.
   * Note: Optimal without additional indexing.
   * @param {Object} o
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _findO(o) {
    const arr = [];
    this.forEach((s1, p1, o1) => {
      if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].objectEquals(o, o1)) {
        arr.push(this._get(s1, p1, o1, true));
      }
    });
    return arr;
  }

  /**
   * Finds all statements with a given subject and object.
   * Note: Close to optimal without further indexing, to many checks due to iteration via _map.
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _findSO(s, o) {
    const arr = [];
    this.forEach((s1, p1, o1) => {
      if (s === s1 && _formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].objectEquals(o, o1)) {
        arr.push(this._get(s1, p1, o1, true));
      }
    });
    return arr;
  }

  /**
   * Finds all statements with a given predicate and object.
   * Note: Close to optimal without further indexing, to many checks due to iteration via _map.
   * @returns {rdfjson/Statement[]}
   * @private
   */
  _findPO(p, o) {
    const arr = [];
    this.forEach((s1, p1, o1) => {
      if (p === p1 && _formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].objectEquals(o, o1)) {
        arr.push(this._get(s1, p1, o1, true));
      }
    });
    return arr;
  }

  /**
   * @private
   */
  _validate() {
    const graph = this._graph;
    const report = { valid: true, errors: [], nr: 0 };
    Object.keys(graph).forEach((s) => {
      const subj = graph[s];
      if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(subj)) {
        Object.keys(subj).forEach((p) => {
          const objArr = subj[p];
          if (Array.isArray(objArr)) {
            objArr.forEach((o, oindex) => {
              if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(o)) {
                if (o.type != null) {
                  if (_formats_rdfjson_util__WEBPACK_IMPORTED_MODULE_0__["default"].isString(o.value)) {
                    report.nr += 1;
                  } else {
                    report.errors.push({
                      s,
                      p,
                      oindex: (oindex + 1),
                      message: `Object ${oindex + 1} in object array must have the 'value' attribute pointing to a string.`
                    });
                    report.valid = false;
                  }
                } else {
                  report.errors.push({
                    s,
                    p,
                    oindex: (oindex + 1),
                    message: `Object ${oindex + 1} in object array lacks the attribute type, must be either 'literal', 'resource' or 'bnode'.`
                  });
                  report.valid = false;
                }
              } else {
                report.errors.push({
                  s,
                  p,
                  oindex: (oindex + 1),
                  message: `Element ${oindex + 1} in object array is not an object.`
                });
                report.valid = false;
              }
            });
          } else {
            report.errors.push({ s, p, message: 'Predicate must point to an array of objects.' });
            report.valid = false;
          }
        });
      } else {
        report.errors.push({ s, message: 'Subject must point to an object.' });
        report.valid = false;
      }
    });
    return report;
  }

  /**
   * Creates a new bnode that is unique in the current graph.
   * Bnodes in temporarily unasserted statements (currently removed from the graph)
   * are avoided as well.
   * @returns {String}
   * @private
   */
  _newBNode() {
    this._indexBNodes();
    let p;
    let n;
    let bnode;
    for (p = 1; p < 20; p++) {
      for (n = 1; n <= p; n++) {
        bnode = `_:${Math.floor(Math.random() * (Math.pow(10, p) + 1))}`;
        if (this._bnodes[bnode] !== true) {
          this._bnodes[bnode] = true;
          return bnode;
        }
      }
    }
    throw new Error('Failed creating a new blank node, increadible unprobable...');
  }

  /**
   * Adds the bnodes in the graph to the bnode index.
   * The index can be calculated late, just before the first call to create.
   * (Bnodes in statements that are removed are added in advance to the index as
   * they may be only temporarily unasserted and when they are asserted again
   * they should not overlap with newly created bnodes.)
   * After the index is created all statemnts added update the index.
   * @private
   */
  _indexBNodes() {
    if (this._bnodesIndexed) {
      return;
    }
    const graph = this._graph;
    Object.keys(graph).forEach((s) => {
      if (s.indexOf('_:') === 0) {
        this._bnodes[s] = true;
      }
      const subj = graph[s];
      Object.keys(subj).forEach((p) => {
        if (p.indexOf('_:') === 0) {
          this._bnodes[p] = true;
        }
        subj[p].forEach((o) => {
          if (o.type === 'bnode') {
            this._bnodes[o.value] = true;
          }
        });
      });
    });
    this._bnodesIndexed = true;
  }

  /**
   * Adds any bnodes in the given parameters to the index (the index may still be incomplete).
   * @param {String} s the subject in a statement.
   * @param {String} p the predicate in a statement.
   * @param {Object} o the object in a statement.
   * @private
   */
  _trackBNodes(s, p, o) {
    if (s.indexOf('_:') === 0) {
      this._bnodes[s] = true;
    }
    if (p.indexOf('_:') === 0) {
      this._bnodes[p] = true;
    }
    if (o.type === 'bnode') {
      this._bnodes[o.value] = true;
    }
  }
};


/***/ }),

/***/ "./node_modules/rdfjson/src/Statement.js":
/*!***********************************************!*\
  !*** ./node_modules/rdfjson/src/Statement.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Statement; });
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/rdfjson/src/namespaces.js");


/**
 * rdfjson.Statement Represents a statement in a graph.
 * Never create directly, use the methods in rdfjson.Graph.
 * Constructs a statement from the provided parts, the object is assumed to be the same
 * actual javascript object as is used in the graph.
 *
 * @exports rdfjson/Statment
 */
class Statement {
  /**
   * @param {rdfjson/Graph} graph the rdfjson.Graph we will manipulate.
   * @param {String} s the subject in the statement
   * @param {String} p the predicate in the statement.
   * @param {Object} o the object in the statement.
   * @param {Boolean} asserted indicates if the statement is asserted in the accompanied graph.
   * @constructor
   */
  constructor(graph, s, p, o, asserted) {
    this._graph = graph;
    this._s = s;
    this._p = p;
    this._o = o;
    this._o._statement = this;
    this._asserted = asserted;
  }

  /**
   * The Graph this Statement is associated with.
   * @returns {rdfjson.Graph}
   */
  getGraph() {
    return this._graph;
  }

  /**
   * An asserted statement is present in its associated Graph
   * @param {Boolean} asserted
   */
  setAsserted(asserted) {
    if (asserted !== this._asserted) {
      if (asserted) {
        this._graph.add(this, undefined, undefined, this._silentValue);
      } else {
        this._graph.remove(this, this._silentValue);
      }
      this._asserted = asserted;
    }
  }

  /**
   * True if the Statement is asserted in the Graph.
   * @returns {Boolean}
   */
  isAsserted() {
    return this._asserted;
  }

  /**
   * The subject of this statement.
   * @returns {String}
   */
  getSubject() {
    return this._s;
  }

  isSubjectBlank() {
    if (this._sIsBlank !== true && this._sIsBlank !== false) {
      this._sIsBlank = this._s.indexOf('_:') === 0;
      // this._sIsBlank = this._graph._bnodes[this._s] === true;
    }
    return this._sIsBlank;
  }

  isObjectBlank() {
    return this.getType() === 'bnode';
  }

  /**
   * Sets the subject of this statement, other Statements with this resource as subject or object
   * is not affected.
   * @param {String} s must be a valid URI.
   */
  setSubject(s) {
    this._silentValue = false;
    const _s = _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].expand(s);
    if (this._asserted) {
      this._graph.remove(this);
      this._s = _s;
      this._graph.add(this);
      delete this._sIsBlank;
    } else {
      this._s = _s;
    }
  }

  /**
   * The predicate of this Statement.
   * @returns {String}
   */
  getPredicate() {
    return this._p;
  }

  /**
   * Sets the predicate of this statement.
   * @param {String} p must be a valid URI.
   */
  setPredicate(p) {
    this._silentValue = false;
    const _p = _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].expand(p);
    if (this._asserted) {
      this._graph.remove(this);
      this._p = _p;
      this._graph.add(this);
    } else {
      this._p = _p;
    }
  }

  /**
   * @returns {String|undefined}
   */
  getNamedGraph() {
    return this._o.ng;
  }

  /**
   * @param ng
   */
  setNamedGraph(ng) {
    this._o.ng = ng;
  }

  /**
   * The object of the Statement.
   *
   * @returns {Object}
   */
  getObject() {
    return this._o;
  }



  /**
   * The object of the Statement.
   *
   * @returns {Object}
   */
  getCleanObject() {
    const _o = this._o;
    const o = {
      value: _o.value,
      type: _o.type,
    };
    if (this._o.ng) {
      o.ng = _o.ng;
    }
    if (_o.lang) {
      o.lang = _o.lang;
    }
    if (this._o.datatype) {
      o.datatype = _o.datatype;
    }
    return o;
  }

  /**
   * @returns {String} one of uri, bnode and literal
   */
  getType() {
    return this._o.type;
  }

  /**
   * @param {String} type must be one of uri, bnode and literal.
   */
// eslint-disable-next-line no-unused-vars,class-methods-use-this
  setType(type) {
    throw new Error('Changing the type of an object is not supported, create a new' +
      ' statement instead.');
  }

  /**
   * If type is uri it is a URI, if type is a literal it is the literal string.
   * If type is a bnode the value is a internal bnode identity, should only be used for
   * references within the current graph.
   * @returns {String}
   */
  getValue() {
    return this._o.value;
  }

  /**
   * Sets the uri, literal or bnode of the current Statement depending on the type.
   * @param {String} value must be a uri if the type so indicates.
   * @param {boolean} [silent=false] the graph is not marked as "changed" if set to true
   */
  setValue(value, silent = false) {
    this._silentValue = silent === true;
    if (value !== this._o.value) {
      this._o.value = value;
      if (this.isAsserted() && silent !== true) {
        this._graph.setChanged();
      }
    }
  }

  /**
   * @returns {String} a language expressed using RFC-3066
   */
  getLanguage() {
    return this._o.lang;
  }

  /**
   * Sets the language of the object, only acceptable if the type is literal.
   * @param {String} lang the language expressed using RFC-30-66
   */
  setLanguage(lang, silent) {
    this._silentValue = silent === true;
    if (this._o.type !== 'literal') {
      throw new Error('Cannot set the language for a resource, has to be a literal');
    }
    if (this._o.lang !== lang) {
      this._o.lang = lang;
      if (this.isAsserted() && silent !== true) {
        this._graph.setChanged();
      }
    }
  }

  /**
   * The datatype of this object, only acceptable if the type is literal.
   * @returns {String} the datatype is always represented via a URI.
   */
  getDatatype() {
    return this._o.datatype;
  }

  /**
   * Set the datatype, only acceptable if the type is literal and no language is set.
   * @param {String} datatype the datatype expressed as a URI.
   */
  setDatatype(datatype, silent) {
    this._silentValue = silent === true;
    if (this._o.type !== 'literal' || this._o.lang != null) {
      throw new Error('Cannot set the datatype for a resource, has to be a literal');
    }
    if (this._o.datatype !== datatype) {
      this._o.datatype = datatype;
      if (this.isAsserted() && silent !== true) {
        this._graph.setChanged();
      }
    }
  }
};


/***/ }),

/***/ "./node_modules/rdfjson/src/formats/converters.js":
/*!********************************************************!*\
  !*** ./node_modules/rdfjson/src/formats/converters.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var xmldom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xmldom */ "./node_modules/xmldom/dom-parser.js");
/* harmony import */ var xmldom__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xmldom__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Graph */ "./node_modules/rdfjson/src/Graph.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../namespaces */ "./node_modules/rdfjson/src/namespaces.js");
/* harmony import */ var _rdfjson_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./rdfjson/util */ "./node_modules/rdfjson/src/formats/rdfjson/util.js");
/* harmony import */ var _rdfxml_Rdfparser__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rdfxml/Rdfparser */ "./node_modules/rdfjson/src/formats/rdfxml/Rdfparser.js");
/* harmony import */ var _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./rdfxml/terms */ "./node_modules/rdfjson/src/formats/rdfxml/terms.js");







const sp = '  ';
const sp2 = '    ';

let xml2string;
let string2xml;

if (typeof window !== 'undefined' && (typeof window.DOMParser !== 'undefined' || typeof ActiveXObject !== 'undefined')) { // In browser
  xml2string = xml => xml.xml;

  string2xml = (text) => {
    let doc;
    try {
      if (window.DOMParser) {
        const parser = new DOMParser();
        doc = parser.parseFromString(text, 'text/xml');
      } else { // Internet Explorer
        doc = new ActiveXObject('Microsoft.XMLDOM');
        doc.async = 'false';
        doc.loadXML(text);
      }
    } catch (e) {
      doc = null;
    }
    if (!doc || !doc.documentElement || doc.getElementsByTagName('parsererror').length) {
      throw new Error('Could not parse text as xml');
    }

    return doc;
  };
} else { // Not in browser
         // Non-browser environment, requires the XMLSerializer and xmldom libraries.
  xml2string = xml => new XMLSerializer().serializeToString(xml);

  const DOMParser = xmldom__WEBPACK_IMPORTED_MODULE_0___default.a.DOMParser;
  string2xml = text => new DOMParser().parseFromString(text, 'text/xml');
}

const throwIfRelative = (url) => {
  // Removed test for \ temporary
  if (/["<>^`{|}]/i.test(url)) {
    throw Error({
      message: `URL "${url}" is not allowed to contain special characters " < > \\ ^ \` { | or }.`,
      character: true,
    });
  }

  // if (/ /i.test(url)) {
  // throw {message: `Spaces inside of URL not supported: ${url}`, space: true};
  // }
  if (!/^(?:[a-z][a-z0-9+.-]*:)/i.test(url)) {
    throw Error({ message: `Relative URL not supported: ${url}`, relative: true });
  }
  if (/ /i.test(url)) {
    if (exports.convertSpacesInURIs) {
      return url.replace(/ /g, '%20');
    }
    throw Error({ message: `Spaces inside of URL not supported: ${url}`, space: true });
  }
  return url;
};
/**
 *
 * Imports RDF/XML into a Graph
 *
 * @param {Node|String} xml this is the XML document or XML string from where the RDF will
 * be parsed.
 * @param {rdfjson.Graph|null} graph Where all tripples will be added, if null a new graph
 * will be created.
 * @returns {rdfjson.Graph} where all found tripples have been added.
 */
const rdfxml2graph = (xml, graph = null) => {
  let _xml = xml;
  if (_rdfjson_util__WEBPACK_IMPORTED_MODULE_3__["default"].isString(_xml)) {
    _xml = string2xml(_xml);
  }
  /**
   * @type {rdfjson.Graph}
   */
  const g = graph || new _Graph__WEBPACK_IMPORTED_MODULE_1__["default"]({});
  const store = new _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__["RDFFormula"]();
  store.add = (s, p, o) => {
    let subj;
    let pred;
    const obj = {};
    // Subject
    if (s instanceof _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__["RDFBlankNode"]) {
      subj = s.toString();
      g.registerBNode(subj);
    } else {
      s.uri = throwIfRelative(s.uri);
      subj = s.uri;
    }

    // Predicate
    if (p instanceof _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__["RDFBlankNode"]) {
      pred = p.toString();
      g.registerBNode(pred);
    } else {
      p.uri = throwIfRelative(p.uri);
      pred = p.uri;
    }

    // Object
    if (o instanceof _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__["RDFLiteral"]) {
      obj.type = 'literal';
      obj.value = o.value;
      if (o.lang) {
        obj.lang = o.lang;
      }
      if (o.datatype) {
        obj.datatype = o.datatype.uri;
      }
    } else if (o instanceof _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__["RDFSymbol"]) {
      o.uri = throwIfRelative(o.uri);
      obj.type = 'uri';
      obj.value = o.uri;
    } else if (o instanceof _rdfxml_terms__WEBPACK_IMPORTED_MODULE_5__["RDFBlankNode"]) {
      obj.value = o.toString();
      g.registerBNode(obj.value);
      obj.type = 'bnode';
    }
    g.create(subj, pred, obj, true);
  };
  const parser = new _rdfxml_Rdfparser__WEBPACK_IMPORTED_MODULE_4__["default"](store);
  parser.parse(_xml, '', '');
  return g;
};

const xmlEncode = url => encodeURI(decodeURI(url)).replace(/&/g, '&amp;');

const rdfjson2rdfxml = (graph) => {
  const g = graph instanceof _Graph__WEBPACK_IMPORTED_MODULE_1__["default"] ? graph._graph : graph || {};
  const nsUsed = [];
  const nsAdded = {};
  const nsify = function (prop) {
    const _o = _namespaces__WEBPACK_IMPORTED_MODULE_2__["default"].nsify(prop);
    if (!nsAdded[_o.abbrev]) {
      nsUsed.push(_o.abbrev);
      nsAdded[_o.abbrev] = _o.ns;
    }
    return _o.pretty;
  };

  const strs = [];
  Object.keys(g).forEach((s) => {
    if (s.substr(0, 2) === '_:') {
      strs.push(`${sp}<rdf:Description rdf:nodeID="_${s.substring(2)}">\n`);
    } else {
      strs.push(`${sp}<rdf:Description rdf:about="${xmlEncode(s)}">\n`);
    }
    const props = g[s];
    Object.keys(props).forEach((p) => {
      const nsp = nsify(p);
      props[p].forEach((o) => {
        let v;
        switch (o.type) {
          case 'literal':
            v = o.value.replace('&', '&amp;').replace('<', '&lt;');
            if (o.lang != null) {
              strs.push(`${sp2}<${nsp} xml:lang="${o.lang}">${v}</${nsp}>\n`);
            } else if (o.datatype != null) {
              strs.push(`${sp2}<${nsp} rdf:datatype="${o.datatype}">${v}</${nsp}>\n`);
            } else {
              strs.push(`${sp2}<${nsp}>${v}</${nsp}>\n`);
            }
            break;
          case 'uri':
            strs.push(`${sp2}<${nsp} rdf:resource="${xmlEncode(o.value)}"/>\n`);
            break;
          case 'bnode':
            if (o.value.substr(0, 2) === '_:') {
              strs.push(`${sp2}<${nsp} rdf:nodeID="_${o.value.substring(2)}"/>\n`);
            } else {
              strs.push(`${sp2}<${nsp} rdf:nodeID="${o.value}"/>\n`);
            }
            break;
          default:
        }
      });
    });
    strs.push(`${sp}</rdf:Description>\n`);
  });
  const initialStrs = ['<?xml version="1.0"?>\n<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"'];
  for (let j = 0; j < nsUsed.length; j++) {
    if (nsUsed[j] !== 'rdf') {
      initialStrs.push(`\n\txmlns:${nsUsed[j]}="${nsAdded[nsUsed[j]]}"`);
    }
  }
  initialStrs.push('>\n');
  strs.unshift(initialStrs.join(''));
  strs.push('</rdf:RDF>');
  return strs.join('');
};

/**
 * Detects RDF as a string in the RDF/XML, as an instance of Graph or as a object literal
 * corresponding to a RDF/JSON structure.
 * Limitation: Parse JSON strings into object literals if the JSON.parse is available in the
 * environment.
 *
 * @param {string|object} rdf in RDF/XML, RDF/JSON or a object literal corresponding to already
 * parsed RDF/JSON.
 * @returns {Object} a report with the attributes: graph, format and potentially an error.
 */
const detect = (rdf) => {
  const report = {};
  if (typeof rdf === 'string') {
    const taste = rdf.substr(0, 200);
    if (taste.toLowerCase().indexOf('<rdf:rdf') !== -1) {
      report.format = 'rdf/xml';
      try {
        report.graph = rdfxml2graph(rdf);
      } catch (e) {
        if (e.relative || e.space || e.character) {
          report.error = e.message;
          report.errorCode = 1;
        } else {
          report.error = 'Invalid rdf/xml';
          report.errorCode = 2;
        }
      }
    } else if (rdf.substring(0, 2) === '{"') {
      report.format = 'rdf/json';
      try {
        const jsonrdf = JSON.parse(undefined.rdfjson);
        report.graph = new _Graph__WEBPACK_IMPORTED_MODULE_1__["default"](jsonrdf);
      } catch (e) {
        report.error = 'Invalid json.';
        report.errorCode = 3;
      }
    } else {
      report.error = 'No RDF detected.';
      report.errorCode = 4;
    }
  } else if (rdf instanceof _Graph__WEBPACK_IMPORTED_MODULE_1__["default"]) {
    report.format = 'rdf/json';
    report.graph = rdf;
  } else if (typeof rdf === 'object') {
    report.format = 'rdf/json';
    report.graph = new _Graph__WEBPACK_IMPORTED_MODULE_1__["default"](rdf);
  } else {
    report.error = 'unknown format';
    report.errorCode = 5;
  }
  if (!report.error) {
    const r = report.graph.validate();
    if (!r.valid) {
      report.error = 'RDF/JSON is not valid.';
      report.errorCode = 6;
    }
  }
  return report;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  xml2string,
  string2xml,
  rdfxml2graph,
  rdfjson2rdfxml,
  detect,
});


/***/ }),

/***/ "./node_modules/rdfjson/src/formats/rdfjson/util.js":
/*!**********************************************************!*\
  !*** ./node_modules/rdfjson/src/formats/rdfjson/util.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// Four helper methods, from dojo.
const isObject = it => it !== undefined &&
  (it === null || typeof it === 'object' || Array.isArray(it) || typeof it === 'function');

const isString = it => (typeof it === 'string' || it instanceof String);

const isFunction = it => Object.prototype.toString.call(it) === '[object Function]';

const statementEquals = (s1, s2) =>
  s1.s === s2.s && s1.p === s2.p && objectEquals(s1.o, s2.o);

/**
 * Adds a statement to a graph object according to the rdf/json specification.
 * Duplicates of the same statement are not allowed in a graph,
 * hence they are not allowed to be added.
 *
 * The object in the statement are represented via an javascript object containing:
 * <ul><li>type - one of 'uri', 'literal' or 'bnode' (<b>required</b> and must be lowercase).</li>
 * <li>value - the lexical value of the object (<b>required</b>, full URIs should be used,
 * not namespaced using abbreviations)</li>
 * <li>lang - the language of a literal value (<b>optional</b>
 * but if supplied it must not be empty)</li>
 * <li>datatype - the datatype URI of the literal value (<b>optional</b>)</li>
 * The 'lang' and 'datatype' keys should only be used if the value of the 'type' key is "literal".
 *
 * @param {Object} graph according to the rdf/json specification.
 * @param {String} s a URI representing the subject in a statement.
 * @param {String} p a URI representing the predicate in a statement.
 * @param {Object} o an object representing either a resource or a literal,
 *  see format described above.
 * @return {Object} the javascript object corresponding to the statements object just added,
 *  note that it might be a clone of the object given in the parameter o
 * (for instance when the statement already exists in the graph).
 * @throws {String} an error message if the arguments are not valid.
 * @see The <a href="http://n2.talis.com/wiki/RDF_JSON_Specification">RDF JSON Specification</a>.
 */
const add = (graph, s, p, o) => {
  checkForWrongArgs([graph, s, p, o]);
  if (graph[s] === undefined) {
    graph[s] = {};
    graph[s][p] = [o];
    return o;
  }
  if (graph[s][p] === undefined) {
    graph[s][p] = [o];
    return o;
  }
  let i;
  const objs = graph[s][p];
  for (i = objs.length - 1; i >= 0; i--) {
    if (objectEquals(o, objs[i])) {
      return objs[i];
    }
  }
  objs.push(o);
  return o;
};

/**
 * Tries to remove the specified statement from the given graph.
 * If it is successful it returns the object of the statment removed.
 *
 * @param {Object} graph
 * @param {Object} s
 * @param {Object} p
 * @param {Object} o
 * @return {Object|undefined} the object of the statement removed,
 *  undefined if no matching statement could be removed.
 * @throws {String} an error message if the arguments are not valid.
 * @see exports.add for a longer treatment of the allowed arguments.
 */
const remove = (graph, s, p, o) => {
  checkForWrongArgs([graph, s, p, o]);
  if (graph[s] === undefined || graph[s][p] === undefined) {
    return undefined;
  }
  let i;
  const objs = graph[s][p];
  for (i = objs.length - 1; i >= 0; i--) {
    if (objectEquals(o, objs[i])) {
      const _o = objs[i];
      objs.splice(i, 1);
      cleanup(graph, s, p);
      return _o;
    }
  }
  return undefined;
};

/**
 * Checks if the graph contains the specified statement.
 *
 * @param {Object} graph
 * @param {String} s
 * @param {String} p
 * @param {Object} o
 * @return {Object|undefined} the object of the found statement if the graph contains the
 * specified statement, undefined otherwise.
 * @throws {String} an error message if the arguments are not valid.
 */
const contains = (graph, s, p, o) => {
  checkForWrongArgs([graph, s, p, o]);
  if (graph[s] === undefined || graph[s][p] === undefined) {
    return undefined;
  }
  let i;
  const objs = graph[s][p];
  for (i = objs.length - 1; i >= 0; i--) {
    if (objectEquals(o, objs[i])) {
      return objs[i];
    }
  }
  return undefined;
};

/**
 * Removes empty structures in the graph for the given subject and predicate.
 * It checks if there are subjects without outgoing properties or
 * if there are properties with no objects.
 *
 * Note that the need for this function is a consequence of the normalized character
 * of the RDF JSON format.
 *
 * @param {Object} graph
 * @param {Object} s
 * @param {Object} p
 */
const cleanup = (graph, s, p) => {
  if (graph[s][p].length === 0) {
    delete graph[s][p];
    if (Object.keys(graph[s]).length === 0) {
      delete graph[s];
    }
  }
};

/**
 * Checks the arguments for the add function are valid
 * (and all other functions that have the same signature).
 *
 * @param {Array} args an array of the arguments for the add function.
 * @throws {String} with a message if the arguments are not valid.
 * @see exports.add
 */
const checkForWrongArgs = (args) => {
  if (!isObject(args[0])) {
    throw new Error('Graph is not a object.');
  } else if (!isString(args[1])) {
    throw new Error('Subject is not a string.');
  } else if (!isString(args[2])) {
    throw new Error('Predicate is not a string.');
  } else if (!isObject(args[3])) {
    throw new Error('Object is not a object.');
  } else if (args[3].type === undefined) {
    throw new Error("Object has no type attribute, must be one of 'uri', 'literal', or" +
      " 'bnode'");
  } else if (args[3].value === undefined) {
    throw new Error('Object has no value attribute corresponding to the lexical value ' +
      'of the object.');
  }
  // TODO check that subject, predicate and object.datatype are uris.
  // TODO Also check that object.value is a URI if the type is uri.
};

/**
 * Compares two statement objects according to the RDF JSON Specification.
 * If both o1 and o2 are strings they are simply compared.
 * If one of o1 and o2 are a string and the other is an object the string is compared with the
 * value of the object ignoring any other attributes of the object.
 * If both o1 and o2 are null or undefined they are considered equal.
 *
 * @param {*} o1
 * @param {*} o2
 * @return {Boolean} true if they have the same type, lexical value, language, and datatype.
 */
const objectEquals = (o1, o2) => {
  if (o1 === o2 || (o1 == null && o1 === o2)) {
    return true;
  }
  // Note, using
  if (isString(o1)) {
    if (isString(o2)) {
      return o1 === o2;
    }
    return o1 === o2.value;
  } else if (isString(o2)) {
    return o1.value === o2;
  }
  return o1.type === o2.type && o1.value === o2.value && o1.lang === o2.lang &&
    o1.datatype === o2.datatype;
};

const findDirectOrRDFValue = (graph, subject, predicate) => {
  const arr = graph.find(subject, predicate);
  if (arr.length > 0) {
    if (arr[0].getType() !== 'bnode') {
      return arr[0].getValue();
    }
    return graph.findFirstValue(arr[0].getValue(), 'http://www.w3.org/1999/02/22-rdf-syntax-ns#value');
  }
  return undefined;
};

/* harmony default export */ __webpack_exports__["default"] = ({
  isObject,
  isString,
  isFunction,
  statementEquals,
  add,
  remove,
  contains,
  cleanup,
  checkForWrongArgs,
  objectEquals,
  findDirectOrRDFValue,
});


/***/ }),

/***/ "./node_modules/rdfjson/src/formats/rdfxml/Rdfparser.js":
/*!**************************************************************!*\
  !*** ./node_modules/rdfjson/src/formats/rdfxml/Rdfparser.js ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uri */ "./node_modules/rdfjson/src/formats/rdfxml/uri.js");


/**
 * @fileoverview
 * TABULATOR RDF PARSER
 *
 * Version 0.1
 *  Parser believed to be in full positive RDF/XML parsing compliance
 *  with the possible exception of handling deprecated RDF attributes
 *  appropriately. Parser is believed to comply fully with other W3C
 *  and industry standards where appropriate (DOM, ECMAScript, &c.)
 *
 *  Author: David Sheets <dsheets@mit.edu>
 *  SVN ID: $Id$
 *
 * W3C® SOFTWARE NOTICE AND LICENSE
 * http://www.w3.org/Consortium/Legal/2002/copyright-software-20021231
 * This work (and included software, documentation such as READMEs, or
 * other related items) is being provided by the copyright holders under
 * the following license. By obtaining, using and/or copying this work,
 * you (the licensee) agree that you have read, understood, and will
 * comply with the following terms and conditions.
 *
 * Permission to copy, modify, and distribute this software and its
 * documentation, with or without modification, for any purpose and
 * without fee or royalty is hereby granted, provided that you include
 * the following on ALL copies of the software and documentation or
 * portions thereof, including modifications:
 *
 * 1. The full text of this NOTICE in a location viewable to users of
 * the redistributed or derivative work.
 * 2. Any pre-existing intellectual property disclaimers, notices, or terms and
 * conditions. If none exist, the W3C Software Short Notice should be
 * included (hypertext is preferred, text is permitted) within the body
 * of any redistributed or derivative code.
 * 3. Notice of any changes or modifications to the files, including the
 * date changes were made. (We recommend you provide URIs to the location
 * from which the code is derived.)
 *
 * THIS SOFTWARE AND DOCUMENTATION IS PROVIDED "AS IS," AND COPYRIGHT
 * HOLDERS MAKE NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED,
 * INCLUDING BUT NOT LIMITED TO, WARRANTIES OF MERCHANTABILITY OR FITNESS
 * FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE OR
 * DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,
 * TRADEMARKS OR OTHER RIGHTS.
 *
 * COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL
 * OR CONSEQUENTIAL DAMAGES ARISING OUT OF ANY USE OF THE SOFTWARE OR
 * DOCUMENTATION.
 *
 * The name and trademarks of copyright holders may NOT be used in
 * advertising or publicity pertaining to the software without specific,
 * written prior permission. Title to copyright in this software and any
 * associated documentation will at all times remain with copyright
 * holders.
 */
/**
 * @class Class defining an RDFParser resource object tied to an RDFStore
 *
 * @author David Sheets <dsheets@mit.edu>
 * @version 0.1
 *
 * @constructor
 * @param store An RDFStore object
 */
var RDFParser;
RDFParser = function (store) {
  /** Standard namespaces that we know how to handle @final
   *  @member RDFParser
   */
  RDFParser['ns'] = {
    'RDF': "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    'RDFS': "http://www.w3.org/2000/01/rdf-schema#"
  };
  /** DOM Level 2 node type magic numbers @final
   *  @member RDFParser
   */
  RDFParser['nodeType'] = {
    'ELEMENT': 1, 'ATTRIBUTE': 2, 'TEXT': 3,
    'CDATA_SECTION': 4, 'ENTITY_REFERENCE': 5,
    'ENTITY': 6, 'PROCESSING_INSTRUCTION': 7,
    'COMMENT': 8, 'DOCUMENT': 9, 'DOCUMENT_TYPE': 10,
    'DOCUMENT_FRAGMENT': 11, 'NOTATION': 12
  };

  /**
   * Frame class for namespace and base URI lookups
   * Base lookups will always resolve because the parser knows
   * the default base.
   *
   * @private
   */
  this['frameFactory'] = function (parser, parent, element) {
    return {
      'NODE': 1,
      'ARC': 2,
      'parent': parent,
      'parser': parser,
      'store': parser['store'],
      'element': element,
      'lastChild': 0,
      'base': null,
      'lang': null,
      'node': null,
      'nodeType': null,
      'listIndex': 1,
      'rdfid': null,
      'datatype': null,
      'collection': false,

      /** Terminate the frame and notify the store that we're done */
      'terminateFrame': function () {
        if (this['collection']) {
          this['node']['close']()
        }
      },

      /** Add a symbol of a certain type to the this frame */
      'addSymbol': function (type, uri) {
        uri = Object(_uri__WEBPACK_IMPORTED_MODULE_0__["join"])(uri, this['base']);
        this['node'] = this['store']['sym'](uri);
        this['nodeType'] = type
      },

      /** Load any constructed triples into the store */
      'loadTriple': function () {
        if (this['parent']['parent']['collection']) {
          this['parent']['parent']['node']['append'](this['node'])
        }
        else {
          this['store']['add'](this['parent']['parent']['node'],
            this['parent']['node'],
            this['node'],
            this['parser']['why'])
        }
        if (this['parent']['rdfid'] != null) { // reify
          var triple = this['store']['sym'](
            Object(_uri__WEBPACK_IMPORTED_MODULE_0__["join"])("#" + this['parent']['rdfid'],
              this['base']));
          this['store']['add'](triple,
            this['store']['sym'](
              RDFParser['ns']['RDF']
              + "type"),
            this['store']['sym'](
              RDFParser['ns']['RDF']
              + "Statement"),
            this['parser']['why']);
          this['store']['add'](triple,
            this['store']['sym'](
              RDFParser['ns']['RDF']
              + "subject"),
            this['parent']['parent']['node'],
            this['parser']['why']);
          this['store']['add'](triple,
            this['store']['sym'](
              RDFParser['ns']['RDF']
              + "predicate"),
            this['parent']['node'],
            this['parser']['why']);
          this['store']['add'](triple,
            this['store']['sym'](
              RDFParser['ns']['RDF']
              + "object"),
            this['node'],
            this['parser']['why'])
        }
      },

      /** Check if it's OK to load a triple */
      'isTripleToLoad': function () {
        return (this['parent'] != null
          && this['parent']['parent'] != null
          && this['nodeType'] == this['NODE']
          && this['parent']['nodeType'] == this['ARC']
          && this['parent']['parent']['nodeType']
          == this['NODE'])
      },

      /** Add a symbolic node to this frame */
      'addNode': function (uri) {
        this['addSymbol'](this['NODE'], uri);
        if (this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      },

      /** Add a collection node to this frame */
      'addCollection': function () {
        this['nodeType'] = this['NODE'];
        this['node'] = this['store']['collection']();
        this['collection'] = true;
        if (this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      },

      /** Add a collection arc to this frame */
      'addCollectionArc': function () {
        this['nodeType'] = this['ARC']
      },

      /** Add a bnode to this frame */
      'addBNode': function (id) {
        if (id != null) {
          if (this['parser']['bnodes'][id] != null) {
            this['node'] = this['parser']['bnodes'][id]
          } else {
            this['node'] = this['parser']['bnodes'][id] = this['store']['bnode']()
          }
        } else {
          this['node'] = this['store']['bnode']()
        }

        this['nodeType'] = this['NODE'];
        if (this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      },

      /** Add an arc or property to this frame */
      'addArc': function (uri) {
        if (uri == RDFParser['ns']['RDF'] + "li") {
          uri = RDFParser['ns']['RDF'] + "_" + this['parent']['listIndex']++
        }
        this['addSymbol'](this['ARC'], uri)
      },

      /** Add a literal to this frame */
      'addLiteral': function (value) {
        if (this['parent']['datatype']) {
          this['node'] = this['store']['literal'](
            value, "", this['store']['sym'](
              this['parent']['datatype']))
        }
        else {
          this['node'] = this['store']['literal'](
            value, this['lang'])
        }
        this['nodeType'] = this['NODE'];
        if (this['isTripleToLoad']()) {
          this['loadTriple']()
        }
      }
    }
  };

  /** Our triple store reference @private */
  this['store'] = store;
  /** Our identified blank nodes @private */
  this['bnodes'] = {};
  /** A context for context-aware stores @private */
  this['why'] = null;
  /** Reification flag */
  this['reify'] = false;

  /**
   * Build our initial scope frame and parse the DOM into triples
   * @param document The DOM to parse
   * @param {String} base The base URL to use
   * @param {Object} why The context to which this resource belongs
   */
  this['parse'] = function (document, base, why) {
    var children = document['childNodes'], root;

    // clean up for the next run
    this['cleanParser']();

    // figure out the root element
    if (document['nodeType'] == RDFParser['nodeType']['DOCUMENT']) {
      for (var c = 0; c < children['length']; c++) {
        if (children[c]['nodeType']
          == RDFParser['nodeType']['ELEMENT']) {
          root = children[c];
          break
        }
      }
    }
    else if (document['nodeType'] == RDFParser['nodeType']['ELEMENT']) {
      root = document
    }
    else {
      throw new Error("RDFParser: can't find root in " + base
        + ". Halting. ");
    }

    this['why'] = why;

    // our topmost frame

    var f = this['frameFactory'](this);
    f['base'] = base;
    f['lang'] = '';

    this['parseDOM'](this['buildFrame'](f, root));
    return true
  };
  this['parseDOM'] = function (frame) {
    // a DOM utility function used in parsing
    var elementURI = function (el) {
      return el['namespaceURI'] + el['localName']
    };
    var dig = true; // if we'll dig down in the tree on the next iter

    while (frame['parent']) {
      var rdfid, bnid;
      var dom = frame['element'];
      var attrs = dom['attributes'];

      if (dom['nodeType']
        == RDFParser['nodeType']['TEXT']
        || dom['nodeType']
        == RDFParser['nodeType']['CDATA_SECTION']) {//we have a literal
        frame['addLiteral'](dom['nodeValue'])
      }
      else if (elementURI(dom)
        != RDFParser['ns']['RDF'] + "RDF") { // not root
        if (frame['parent'] && frame['parent']['collection']) {
          // we're a collection element
          frame['addCollectionArc']();
          frame = this['buildFrame'](frame, frame['element']);
          frame['parent']['element'] = null
        }
        if (!frame['parent'] || !frame['parent']['nodeType']
          || frame['parent']['nodeType'] == frame['ARC']) {
          // we need a node
          var about = dom['getAttributeNodeNS'](
            RDFParser['ns']['RDF'], "about");
          rdfid = dom['getAttributeNodeNS'](
            RDFParser['ns']['RDF'], "ID");
          if (about && rdfid) {
            throw new Error("RDFParser: " + dom['nodeName']
              + " has both rdf:id and rdf:about."
              + " Halting. Only one of these"
              + " properties may be specified on a"
              + " node.");
          }
          if (about == null && rdfid) {
            frame['addNode']("#" + rdfid['nodeValue']);
            dom['removeAttributeNode'](rdfid)
          }
          else if (about == null && rdfid == null) {
            bnid = dom['getAttributeNodeNS'](
              RDFParser['ns']['RDF'], "nodeID");
            if (bnid) {
              frame['addBNode'](bnid['nodeValue']);
              dom['removeAttributeNode'](bnid)
            } else {
              frame['addBNode']()
            }
          }
          else {
            frame['addNode'](about['nodeValue']);
            dom['removeAttributeNode'](about)
          }

          // Typed nodes
          var rdftype = dom['getAttributeNodeNS'](
            RDFParser['ns']['RDF'], "type");
          if (RDFParser['ns']['RDF'] + "Description"
            != elementURI(dom)) {
            rdftype = { 'nodeValue': elementURI(dom) }
          }
          if (rdftype != null) {
            this['store']['add'](frame['node'],
              this['store']['sym'](
                RDFParser['ns']['RDF'] + "type"),
              this['store']['sym'](
                Object(_uri__WEBPACK_IMPORTED_MODULE_0__["join"])(
                  rdftype['nodeValue'],
                  frame['base'])),
              this['why']);
            if (rdftype['nodeName']) {
              dom['removeAttributeNode'](rdftype)
            }
          }

          // Property Attributes
          for (var x = attrs['length'] - 1; x >= 0; x--) {
            this['store']['add'](frame['node'],
              this['store']['sym'](
                elementURI(attrs[x])),
              this['store']['literal'](
                attrs[x]['nodeValue'],
                frame['lang']),
              this['why'])
          }
        }
        else { // we should add an arc (or implicit bnode+arc)
          frame['addArc'](elementURI(dom));

          // save the arc's rdf:ID if it has one
          if (this['reify']) {
            rdfid = dom['getAttributeNodeNS'](
              RDFParser['ns']['RDF'], "ID");
            if (rdfid) {
              frame['rdfid'] = rdfid['nodeValue'];
              dom['removeAttributeNode'](rdfid)
            }
          }

          var parsetype = dom['getAttributeNodeNS'](
            RDFParser['ns']['RDF'], "parseType");
          var datatype = dom['getAttributeNodeNS'](
            RDFParser['ns']['RDF'], "datatype");
          if (datatype) {
            frame['datatype'] = datatype['nodeValue'];
            dom['removeAttributeNode'](datatype)
          }

          if (parsetype) {
            var nv = parsetype['nodeValue'];
            if (nv == "Literal") {
              frame['datatype']
                = RDFParser['ns']['RDF'] + "XMLLiteral";
              // (this.buildFrame(frame)).addLiteral(dom)
              // should work but doesn't
              frame = this['buildFrame'](frame);
              frame['addLiteral'](dom);
              dig = false
            }
            else if (nv == "Resource") {
              frame = this['buildFrame'](frame, frame['element']);
              frame['parent']['element'] = null;
              frame['addBNode']()
            }
            else if (nv == "Collection") {
              frame = this['buildFrame'](frame, frame['element']);
              frame['parent']['element'] = null;
              frame['addCollection']()
            }
            dom['removeAttributeNode'](parsetype)
          }

          if (attrs['length'] != 0) {
            var resource = dom['getAttributeNodeNS'](
              RDFParser['ns']['RDF'], "resource");
            bnid = dom['getAttributeNodeNS'](
              RDFParser['ns']['RDF'], "nodeID");

            frame = this['buildFrame'](frame);
            if (resource) {
              frame['addNode'](resource['nodeValue']);
              dom['removeAttributeNode'](resource)
            } else {
              if (bnid) {
                frame['addBNode'](bnid['nodeValue']);
                dom['removeAttributeNode'](bnid)
              } else {
                frame['addBNode']()
              }
            }

            for (x = attrs['length'] - 1; x >= 0; x--) {
              var f = this['buildFrame'](frame);
              f['addArc'](elementURI(attrs[x]));
              if (elementURI(attrs[x])
                == RDFParser['ns']['RDF'] + "type") {
                (this['buildFrame'](f))['addNode'](
                  attrs[x]['nodeValue'])
              } else {
                (this['buildFrame'](f))['addLiteral'](
                  attrs[x]['nodeValue'])
              }
            }
          }
          else if (dom['childNodes']['length'] == 0) {
            (this['buildFrame'](frame))['addLiteral']("")
          }
        }
      } // rdf:RDF

      // dig dug
      dom = frame['element'];
      while (frame['parent']) {
        var pframe = frame;
        while (dom == null) {
          frame = frame['parent'];
          dom = frame['element']
        }
        var ch = dom['childNodes'];
        var candidate = ch != null ? ch[frame['lastChild']] : null;
        if (candidate == null || !dig) {
          frame['terminateFrame']();
          if (!(frame = frame['parent'])) {
            break
          } // done
          dom = frame['element'];
          dig = true
        }
        else if ((candidate['nodeType']
            != RDFParser['nodeType']['ELEMENT']
            && candidate['nodeType']
            != RDFParser['nodeType']['TEXT']
            && candidate['nodeType']
            != RDFParser['nodeType']['CDATA_SECTION'])
          || ((candidate['nodeType']
            == RDFParser['nodeType']['TEXT']
            || candidate['nodeType']
            == RDFParser['nodeType']['CDATA_SECTION'])
            && dom['childNodes']['length'] != 1)) {
          frame['lastChild']++
        }
        else { // not a leaf
          frame['lastChild']++;
          frame = this['buildFrame'](pframe,
            dom['childNodes'][frame['lastChild'] - 1]);
          break
        }
      }
    } // while
  };

  /**
   * Cleans out state from a previous parse run
   * @private
   */
  this['cleanParser'] = function () {
    this['bnodes'] = {};
    this['why'] = null
  };

  /**
   * Builds scope frame
   * @private
   */
  this['buildFrame'] = function (parent, element) {
    var frame = this['frameFactory'](this, parent, element);
    if (parent) {
      frame['base'] = parent['base'];
      frame['lang'] = parent['lang']
    }
    if (element == null
      || element['nodeType'] == RDFParser['nodeType']['TEXT']
      || element['nodeType'] == RDFParser['nodeType']['CDATA_SECTION']) {
      return frame
    }

    var attrs = element['attributes'];

    var base = element['getAttributeNode']("xml:base");
    if (base != null) {
      frame['base'] = base['nodeValue'];
      element['removeAttribute']("xml:base")
    }
    var lang = element['getAttributeNode']("xml:lang");
    if (lang != null) {
      frame['lang'] = lang['nodeValue'];
      element['removeAttribute']("xml:lang")
    }

    // remove all extraneous xml and xmlns attributes
    for (var x = attrs['length'] - 1; x >= 0; x--) {
      if (attrs[x]['nodeName']['substr'](0, 3) == "xml") {
        element['removeAttributeNode'](attrs[x])
      }
    }
    return frame
  }
};
/* harmony default export */ __webpack_exports__["default"] = (RDFParser);


/***/ }),

/***/ "./node_modules/rdfjson/src/formats/rdfxml/terms.js":
/*!**********************************************************!*\
  !*** ./node_modules/rdfjson/src/formats/rdfxml/terms.js ***!
  \**********************************************************/
/*! exports provided: RDFSymbol, RDFFormula, RDFBlankNode, RDFLiteral */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RDFSymbol", function() { return RDFSymbol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RDFFormula", function() { return RDFFormula; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RDFBlankNode", function() { return RDFBlankNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RDFLiteral", function() { return RDFLiteral; });
/* harmony import */ var _uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./uri */ "./node_modules/rdfjson/src/formats/rdfxml/uri.js");

// These are the classes corresponding to the RDF and N3 data models
//
// Designed to look like rdflib and cwm designs.
//
// Issues: Should the names start with RDF to make them
//      unique as program-wide symbols?
//
// W3C open source licence 2005.
//

const RDFTracking = 0;
// Are we requiring reasons for statements?

//takes in an object and makes it an object if it's a literal
const makeTerm = (val) => {
  //  fyi("Making term from " + val)
  if (typeof val === 'object') {
    return val;
  }
  if (typeof val === 'string') {
    return new RDFLiteral(val);
  }
  if (typeof val === 'undefined') {
    return undefined;
  }
  alert(`Can't make term from ${val} of type ${typeof val}`); // @@ add numbers
};

//	Symbol
const RDFEmpty = function () {
  return this;
};

RDFEmpty.prototype.termType = 'empty';

RDFEmpty.prototype.toString = function () {
  return '';
};

RDFEmpty.prototype.toNT = function () {
  return ''
};

/**
 * @return {string}
 */
const RDFSymbol_toNT = function (x) {
  return ('<' + x.uri + '>');
};

const toNT = function () {
  return RDFSymbol_toNT(this);
};

const RDFSymbol = function (uri) {
  this.uri = uri;
  return this;
};

RDFSymbol.prototype.termType = 'symbol';

RDFSymbol.prototype.toString = toNT;

RDFSymbol.prototype.toNT = toNT;

//	Blank Node

let RDFNextId = 0;  // Gobal genid
const NTAnonymousNodePrefix = '_:n';

const RDFBlankNode = function () {
  this.id = RDFNextId++;
  return this;
};

RDFBlankNode.prototype.termType = 'bnode';

RDFBlankNode.prototype.toNT = function () {
  return NTAnonymousNodePrefix + this.id;
};
RDFBlankNode.prototype.toString = RDFBlankNode.prototype.toNT;

//	Literal

const RDFLiteral = function (value, /*String=*/ lang, /*String=*/datatype) {
  this.value = value;
  this.lang = lang;	  // string
  this.datatype = datatype;  // term
  return this;
};

RDFLiteral.prototype.termType = 'literal';

RDFLiteral.prototype.toNT = function () {
  const str = this.value;
  if (typeof str != 'string') {
    throw Error('Value of RDF literal is not string: ' + str);
  }
  str = str.replace(/\\/g, '\\\\');  // escape
  str = str.replace(/"/g, '\\"');
  str = '"' + str + '"';

  if (this.datatype) {
    //alert(this.datatype.termType+"   "+typeof this.datatype)
    str = str + '^^' + this.datatype;//.toNT()
  }
  if (this.lang) {
    str = str + '@' + this.lang;
  }
  return str;
};

RDFLiteral.prototype.toString = function () {
  return this.value;
};

const RDFCollection = function () {
  this.id = RDFNextId++;
  this.elements = [];
  this.closed = false;
};

RDFCollection.prototype.termType = 'collection';

RDFCollection.prototype.toNT = function () {
  return NTAnonymousNodePrefix + this.id;
};
RDFCollection.prototype.toString = RDFCollection.prototype.toNT;

RDFCollection.prototype.append = function (el) {
  this.elements.push(el);
};

RDFCollection.prototype.close = function () {
  this.closed = true;
};

//	Statement
//
//  This is a triple with an optional reason.
//
//   The reason can point to provenece or inference
//
/**
 * @return {string}
 */
const RDFStatement_toNT = function () {
  return (this.subject.toNT() + ' '
    + this.predicate.toNT() + ' '
    + this.object.toNT() + ' .');
};

const RDFStatement = function (subject, predicate, object, why) {
  this.subject = makeTerm(subject);
  this.predicate = makeTerm(predicate);
  this.object = makeTerm(object);
  if (typeof why != 'undefined') {
    this.why = why;
  } else if (RDFTracking) {
    console.log('WARNING: No reason on ' + subject + ' ' + predicate + ' ' + object);
  }
  return this;
};

RDFStatement.prototype.toNT = RDFStatement_toNT;
RDFStatement.prototype.toString = RDFStatement_toNT;

//	Formula
//
//	Set of statements.

const RDFFormula = function () {
  this.statements = [];
  this.constraints = [];
  this.initBindings = [];
  this.optional = [];
  return this;
};

/*function RDFQueryFormula() {
  this.statements = []
  this.constraints = []
  this.initBindings = []
  this.optional = []
  return this
}*/

/**
 * @return {string}
 */
const RDFFormula_toNT = function () {
  return '{\n' + this.statements.join('\n') + '}';
};

//RDFQueryFormula.prototype = new RDFFormula()
//RDFQueryFormula.termType = 'queryFormula'
RDFFormula.prototype.termType = 'formula';
RDFFormula.prototype.toNT = RDFFormula_toNT;
RDFFormula.prototype.toString = RDFFormula_toNT;

RDFFormula.prototype.add = function (subj, pred, obj, why) {
  this.statements.push(new RDFStatement(subj, pred, obj, why));
};

// Convenience methods on a formula allow the creation of new RDF terms:

RDFFormula.prototype.sym = function (uri, name) {
  if (name != null) {
    uri = this.namespaces[uri] + name;
  }
  return new RDFSymbol(uri);
};

RDFFormula.prototype.literal = function (val, lang, dt) {
  return new RDFLiteral(val.toString(), lang, dt);
};

RDFFormula.prototype.bnode = function () {
  return new RDFBlankNode();
};

RDFFormula.prototype.formula = function () {
  return new RDFFormula();
};

RDFFormula.prototype.collection = function () {
  return new RDFCollection();
};

/*RDFFormula.prototype.queryFormula = function() {
  return new RDFQueryFormula()
}*/

const RDFVariableBase = 'varid:'; // We deem variabe x to be the symbol varid:x

//An RDFVariable is a type of s/p/o that's not literal. All it holds is it's URI.
//It has type 'variable', and a function toNT that turns it into NTriple form
const RDFVariable = function (rel) {
  this.uri = Object(_uri__WEBPACK_IMPORTED_MODULE_0__["join"])(rel, RDFVariableBase);
  return this;
};

RDFVariable.prototype.termType = 'variable';
RDFVariable.prototype.toNT = function () {
  if (this.uri.slice(0, RDFVariableBase.length) == RDFVariableBase) {
    return `?${this.uri.slice(RDFVariableBase.length)}`;
  } // @@ poor man's refTo
  return `?${this.uri}`;
};

RDFVariable.prototype.toString = RDFVariable.prototype.toNT;
RDFVariable.prototype.classOrder = 7;

RDFFormula.prototype.variable = function (name) {
  return new RDFVariable(name);
};

RDFVariable.prototype.hashString = RDFVariable.prototype.toNT;

// Parse a single token
//
// The bnode bit should not be used on program-external values; designed
// for internal work such as storing a bnode id in an HTML attribute.
// Not coded for literals.

RDFFormula.prototype.fromNT = function (str) {
  const len = str.length;
  const ch = str.slice(0, 1);
  if (ch === '<') {
    return this.sym(str.slice(1, len - 1));
  }
  if (ch === '_') {
    const x = new RDFBlankNode();
    x.id = parseInt(str.slice(3));
    RDFNextId--;
    return x
  }
  alert(`Can't yet convert from NT: '${str}', ${str[0]}`);
};




/***/ }),

/***/ "./node_modules/rdfjson/src/formats/rdfxml/uri.js":
/*!********************************************************!*\
  !*** ./node_modules/rdfjson/src/formats/rdfxml/uri.js ***!
  \********************************************************/
/*! exports provided: join, protocol, docpart */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "join", function() { return join; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "protocol", function() { return protocol; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "docpart", function() { return docpart; });
//  Implementing URI-specific functions
//
//	See RFC 2386
//
// This is or was   http://www.w3.org/2005/10/ajaw/uri.js
// 2005 W3C open source licence
//
//
//  Take a URI given in relative or absolute form and a base
//  URI, and return an absolute URI
//
//  See also http://www.w3.org/2000/10/swap/uripath.py
//

const join = (given, base) => {
  // if (typeof fyi != 'undefined') fyi("   URI given="+given+" base="+base)
  var baseHash = base.indexOf('#');
  if (baseHash > 0) base = base.slice(0, baseHash);
  if (given.length == 0) return base; // before chopping its filename off
  if (given.indexOf('#') == 0) return base + given;
  var colon = given.indexOf(':');
  if (colon >= 0) return given;	// Absolute URI form overrides base URI
  var baseColon = base.indexOf(':');
  if (baseColon < 0) {
    console.log("Invalid base URL " + base);
    return given;
  }
  var baseScheme = base.slice(0, baseColon + 1);  // eg http:
  if (given.indexOf("//") == 0) {    // Starts with //
    return baseScheme + given;
  }
  var baseSingle;
  if (base.indexOf('//', baseColon) == baseColon + 1) {  // Any hostpart?
    baseSingle = base.indexOf("/", baseColon + 3);
    if (baseSingle < 0) {
      if (base.length - baseColon - 3 > 0) {
        return base + "/" + given;
      } else {
        return baseScheme + given;
      }
    }
  } else {
    baseSingle = base.indexOf("/", baseColon + 1);
    if (baseSingle < 0) {
      if (base.length - baseColon - 1 > 0) {
        return base + "/" + given;
      } else {
        return baseScheme + given;
      }
    }
  }
  if (given.indexOf('/') == 0) {	// starts with / but not //
    return base.slice(0, baseSingle) + given;
  }

  var path = base.slice(baseSingle);
  var lastSlash = path.lastIndexOf('/');
  if (lastSlash < 0) return baseScheme + given;
  if ((lastSlash >= 0) && (lastSlash < (path.length - 1))) {
    path = path.slice(0, lastSlash + 1); // Chop trailing filename from base
  }

  path = path + given;
  while (path.match(/[^\/]*\/\.\.\//)) {// must apply to result of prev
    path = path.replace(/[^\/]*\/\.\.\//, ''); // ECMAscript spec 7.8.5
  }
  path = path.replace(/\.\//g, ''); // spec vague on escaping
  return base.slice(0, baseSingle) + path;
};

/** returns URI without the frag **/
const docpart = (uri) => {
  var i = uri.indexOf("#");
  if (i < 0) return uri;
  return uri.slice(0, i);
};

/** return the protocol of a uri **/
const protocol = uri => uri.slice(0, uri.indexOf(':'))




/***/ }),

/***/ "./node_modules/rdfjson/src/namespaces.js":
/*!************************************************!*\
  !*** ./node_modules/rdfjson/src/namespaces.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
const nss = {
  ical: 'http://www.w3.org/2002/12/cal/ical#',
  vcard: 'http://www.w3.org/2006/vcard/ns#',
  dcterms: 'http://purl.org/dc/terms/',
  skos: 'http://www.w3.org/2004/02/skos/core#',
  rdfs: 'http://www.w3.org/2000/01/rdf-schema#',
  rdf: 'http://www.w3.org/1999/02/22-rdf-syntax-ns#',
  owl: 'http://www.w3.org/2002/07/owl#',
  vs: 'http://www.w3.org/2003/06/sw-vocab-status/ns#',
  foaf: 'http://xmlns.com/foaf/0.1/',
  wot: 'http://xmlns.com/wot/0.1/',
  dc: 'http://purl.org/dc/elements/1.1/',
  xsd: 'http://www.w3.org/2001/XMLSchema#',
  dcat: 'http://www.w3.org/ns/dcat#',
  org: 'http://www.w3.org/ns/org#',
  gn: 'http://www.geonames.org/ontology#',
  locn: 'http://www.w3.org/ns/locn#',
  schema: 'http://schema.org/',
  ex: 'http://example.com/',
  gsp: 'http://www.opengis.net/ont/geosparql#',
  odrs: 'http://schema.theodi.org/odrs#',
};
let nscounter = 0;
const _nsify = (ns, expanded, localname) => {
  if (!nss[ns]) {
    nss[ns] = expanded;
  }
  return {
    abbrev: ns,
    ns: expanded,
    localname,
    full: expanded + localname,
    pretty: `${ns}:${localname}`,
  };
};

/**
 * Returns an object that contain the following attributes:
 *
 * abbrev - the short namespace
 * ns - what the short namespace abbreviates
 * localname - the localname of the URI, given the current namespace
 * full - the original URI
 * pretty - the shortened version of the URI using the abbreviation, e.g. foaf:name
 *
 * @param uri
 * @return {{abbrev, ns, localname, full, pretty}}
 */
const nsify = (uri) => {
  const ens = Object.keys(nss).find(ns => uri.indexOf(nss[ns]) === 0);
  if (ens) {
    return _nsify(ens, nss[ens], uri.substring(nss[ens].length));
  }

  let slash = uri.lastIndexOf('/');
  const hash = uri.lastIndexOf('#');
  if (hash > slash) {
    slash = hash;
  }
  nscounter += 1;
  return _nsify(`ns${nscounter}`, uri.substring(0, slash + 1), uri.substring(slash + 1));
};

/**
 * Only abbreviates a URI if it can be matched to one of the already registered namespaces.
 *
 * @param {string} uri for example: http://xmlns.com/foaf/0.1/name
 * @return {string} in the form "foaf:name"
 */
const shortenKnown = (uri) => {
  const ens = Object.keys(nss).find(ns => uri.indexOf(nss[ns]) === 0);
  if (ens) {
    return _nsify(ens, nss[ens], uri.substring(nss[ens].length)).pretty;
  }
  return uri;
};

/**
 * Abbreviates all uris, if no matching namespace is found a suitable one is generated and
 * registered automatically.
 *
 * @param {string} uri for example: http://xmlns.com/foaf/0.1/name
 * @return {string} in the form "foaf:name" or "ns1:name" if foaf would not be registered already.
 */
const shorten = uri => nsify(uri).pretty;

/**
 * Expands an abbreviated URI from the list of registered namespaces.
 *
 * @param {string} nsuri a namespaced uri like "foaf:name"
 * @return {string} a full URI like "http://xmlns.com/foaf/0.1/name"
 */
const expand = (nsuri) => {
  const arr = nsuri.split(':');
  if (arr.length === 2 && nss.hasOwnProperty(arr[0])) {
    return nss[arr[0]] + arr[1];
  }
  return nsuri;
};

/**
 * Registers a namespace, both the abbreviation and its expansion.
 *
 * @param {string} ns the abbreviation, e.g. "foaf"
 * @param {string} full the expansion for the abbreviation, e.g. "http://xmlns.com/foaf/0.1/name"
 */
const add = (ns, full) => {
  if (typeof ns === 'string') {
    nss[ns] = full;
  } else if (typeof ns === 'object') {
    Object.keys(ns).forEach((nskey) => {
      nss[nskey] = ns[nskey];
    });
  }
};

/**
 * Provides access to the currently registered namespaces as an object with abbreviations as
 * keys and their expansions as the values.
 *
 * @return {object}
 */
const registry = () => nss;

/* harmony default export */ __webpack_exports__["default"] = ({
    nsify,
    shortenKnown,
    shorten,
    expand,
    add,
    registry,
});


/***/ }),

/***/ "./node_modules/rdfjson/src/print.js":
/*!*******************************************!*\
  !*** ./node_modules/rdfjson/src/print.js ***!
  \*******************************************/
/*! exports provided: pretty, statementList, statementTree, prettyTree, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pretty", function() { return pretty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "statementList", function() { return statementList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "statementTree", function() { return statementTree; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "prettyTree", function() { return prettyTree; });
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./namespaces */ "./node_modules/rdfjson/src/namespaces.js");


/**
 * @param {rdfjson.Graph} graph
 * @param {String} subject a URI for the subject to focus on
 */
const pretty = (graph, subject) => {
  const pretty = {};
  const stmts = graph.find(subject);
  for (let i = 0; i < stmts.length; i++) {
    const stmt = stmts[i];
    if (stmt.getType() !== 'bnode') {
      pretty[_namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].shorten(stmt.getPredicate())] = stmt.getValue();
    }
  }
  return pretty;
};

const statementTree = (graph, subject, visited) => {
  const _visited = visited || {};
  const stmts = graph ? graph.find(subject) : [];
  const arr = [];
  for (let i = 0; i < stmts.length; i++) {
    const stmt = stmts[i];
    if (stmt.getType() === 'literal') {
      arr.push({ stmt });
    } else {
      const row = { stmt };
      const obj = stmt.getValue();
      if (!_visited[obj]) {
        _visited[obj] = true;
        row.children = statementTree(graph, obj, _visited);
      }
    }
  }
  return arr;
};

const statementList = (graph, subject) => {
  const tree = statementTree(graph, subject);
  const arr = [];
  const f = (stmts, level) => {
    for (let i = 0; i < stmts.length; i++) {
      const stmt = stmts[i];
      stmt.indent = level;
      arr.push(stmt);
      if (stmt.children) {
        f(stmt.children, level + 1);
        delete stmt.children;
      }
    }
  };
  f(tree, 1);
  return arr;
};

const prettyTree = (graph, subject) => {
  const delegates = statementList(graph, subject);
  for (let i = 0; i < delegates.length; i++) {
    const delegate = delegates[i];
    const stmt = delegate.stmt;
    if (stmt.isSubjectBlank()) {
      delegate.s = stmt.getSubject();
    } else {
      delegate.s = _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].shorten(stmt.getSubject());
    }
    delegate.p = _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].shorten(stmt.getPredicate());
    const t = stmt.getType();
    if (t === 'uri') {
      delegate.o = _namespaces__WEBPACK_IMPORTED_MODULE_0__["default"].shorten(stmt.getValue());
      const lang = stmt.getLanguage();
      const dt = stmt.getDatatype();
      if (lang != null) {
        delegate.o += `@@${lang}`;
      } else if (dt != null) {
        delegate.o += `^^${dt}`;
      }
    } else if (t === 'literal') {
      delegate.o = `"${stmt.getValue()}"`;
    } else {
      delegate.o = `"${stmt.getValue()}"`;
    }
  }
  return delegates;
};



/* harmony default export */ __webpack_exports__["default"] = ({
  pretty,
  statementList,
  statementTree,
  prettyTree
});

/***/ }),

/***/ "./node_modules/rdfjson/src/utils.js":
/*!*******************************************!*\
  !*** ./node_modules/rdfjson/src/utils.js ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Graph */ "./node_modules/rdfjson/src/Graph.js");
/* harmony import */ var _namespaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namespaces */ "./node_modules/rdfjson/src/namespaces.js");
/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! md5 */ "./node_modules/md5/md5.js");
/* harmony import */ var md5__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(md5__WEBPACK_IMPORTED_MODULE_2__);




/**
 * Copies over a subset of statements from one metadata graph to another.
 * The statements copied are those with the provided uri in subject position, or
 * statements reachable via intermediate blank nodes from that uri.
 * Statements are not copied over if the predicate is listed in the ignore array,
 * unless the excludeAfterIgnore is specified in which case the triple is included
 * but no further triples reachable via the object.
 *
 * @param {rdfjson/Graph} inGraph graph which holds rdf data in graph format
 * @param {string} uri a starting point to find all statements to include
 * @param {object=} ignore is an object with predicates as attributes,
 * which are to be ignored (excluded)
 * @param {rdfjson/Graph=} outGraph optional graph which will hold copied statements,
 *  if no outGraph is provided a new will be created.
 * @return {rdfjson/Graph} same as the provided outGraph
 */
const extract = (inGraph, outGraph, uri, ignore, excludeAfterIgnore) => {
  const _outGraph = outGraph || new _Graph__WEBPACK_IMPORTED_MODULE_0__["default"]();
  const _ignore = ignore || {};
  inGraph.find(uri, null, null).forEach((stmt) => {
    if (!_ignore[stmt.getPredicate()]) {
      outGraph.add(stmt);
      if (stmt.getType() === 'bnode') {
        extract(inGraph, outGraph, stmt.getValue(), _ignore);
      }
    } else if (excludeAfterIgnore) {
      outGraph.add(stmt);
    }
  });
  return outGraph;
};

/**
 * Removes an entire subgraph from a given graph.
 * The subgraph is calculated by traversing triples in the forward direction
 * from a starting resource. A triple is included in the subgraph if it can be reached
 * via a path of triples from the starting resource that only passes triples that have
 * blank nodes in object position. The triples in the path may not include predicates
 * in the ignore list except the last triple in the path.
 *
 * @param {rdfjson/Graph} graph the graph to remove triples from
 * @param {string} uri the starting resource to calculate the subgraph from
 * @param {object} ignore an hash of predicates (with the boolean true as value)
 * to ignore when calculating the subgraph to remove, see explanation above.
 */
const remove = (graph, uri, ignore) => {
  const _ignore = ignore || {};
  graph.find(uri, null, null).forEach((stmt) => {
    graph.remove(stmt);
    if (!_ignore[stmt.getPredicate()]) {
      if (stmt.getType() === 'bnode') {
        remove(graph, stmt.getValue(), _ignore);
      }
    }
  });
};

/**
 * Creates a fingerprint of a graph by including all statements' subjects, predicates
 * and objects but excluding blank nodes wherever they occur. The result is sorted and a
 * md5-sum is calculated.
 *
 * Two isomorphic graphs will always have the same fingerprint, i.e. graphs that are similar
 * when disregarding names of blank nodes.
 *
 * Unfortunately, there are false positivies, i.e. two graphs may under certain circumstances
 * have the same fingerprint despite the fact that they are not isomorphic.
 * There are two situations when this can occur:
 *
 * Md5 collisions: Due to the way md5 works there are situations when two different
 * inputs can generate the same sum. However, this is very unlikely to happen for regular RDF
 * graphs.
 *
 * Algorithm deficiencies: If the graph has blank nodes that are connected to each other,
 * the fingerprint algorithm may fail.
 *
 * Briefly about the algorithm: Since blank nodes are often renamed upon serialization an
 * de-serialization these cannot be used in the fingerprinting algorithm. To overcome this
 * problem the algorithm gives each blank node an identifier via a deterministic process
 * that takes all incoming and outgoing triples into account. Clearly this approach will give
 * two blank nodes in two different graphs the same identifier if they have the same incoming
 * and outgoing triples. But, they may still correspond to different blank nodes
 * (in the isomorphic sense) if longer blank node traversal path are taken into account.
 *
 * Lets Look at two different graphs that will have the same fingerprint:
 * Graph 1: John indirectly knows Eric and Anna indirectly knows Linda
 * _:b1     foaf:name    'John'
 * _:b1     foaf:knows   _:b2
 * _:b2     foaf:knows   _:b3
 * _:b3     foaf:name    "Eric"
 * _:b4     foaf:name    'Anna'
 * _:b4     foaf:knows   _:b5
 * _:b5     foaf:knows   _:b6
 * _:b6     foaf:name    "Linda"
 *
 * Graph 2: John indirectly knows Linda and Anna indirectly knows Eric
 * _:b1     foaf:name    'John'
 * _:b1     foaf:knows   _:b2
 * _:b2     foaf:knows   _:b3
 * _:b3     foaf:name    "Linda"
 * _:b4     foaf:name    'Anna'
 * _:b4     foaf:knows   _:b5
 * _:b5     foaf:knows   _:b6
 * _:b6     foaf:name    "Eric"
 *
 * In practise this situation only occurs when you have longer paths of blank nodes without
 * additional distinguishing triples. However, from a modeling standpoint these kind of
 * expressions with long chains of nodes are seldom used and if they are used, there are
 * certainly distinguishing triples along the way.
 *
 * The conclusion is that checking if real world graphs are the same or not can be safely
 * determined with the help of this fingerprint method.
 *
 * @param {rdfjson/Graph} graph is the graph to fingerprint.
 * @param {array} excludeProperties a list of properties to exclude when calculating
 * the fingerprint.
 * @return {string} a md5 sum of the graph.
 */
const fingerprint = (graph, excludeProperties) => {
  const fpg = [];
  const exclude = new Set((excludeProperties || []).map(prop => _namespaces__WEBPACK_IMPORTED_MODULE_1__["default"].expand(prop)));
  const blankStmts = [];
  const blankIdx = {};

  const serializeObj = (stmt) => {
    let val = stmt.getValue();
    if (stmt.getLanguage()) {
      val += `@${stmt.getLanguage()}`;
    }
    if (stmt.getDatatype()) {
      val += `^^${stmt.getDatatype()}`;
    }
    return val;
  };
  const addToBlankRels = (bn, str) => {
    const idx = blankIdx[bn] || { rels: [] };
    blankIdx[bn] = idx;
    idx.rels.push(str);
  };

  graph.find().forEach((stmt) => {
    const s = stmt.getSubject();
    const p = stmt.getPredicate();
    if (exclude.has(p)) {
      return;
    }
    const oBlank = stmt.getType() === 'bnode';
    const sBlank = stmt.isSubjectBlank();
    if (sBlank || oBlank) {
      blankStmts.push(stmt);
      if (sBlank) {
        addToBlankRels(stmt.getSubject(), oBlank ? p : p + serializeObj(stmt));
      }
      if (stmt.getType() === 'bnode') {
        addToBlankRels(stmt.getValue(), sBlank ? p : s + p);
      }
      return;
    }

    fpg.push(s + p + serializeObj(stmt));
  });

  // Calculate a stable hash for each blank based on incoming and outgoing tripples.
  Object.values(blankIdx).forEach((blank) => {
    blank.rels.sort();
    blank.hash = md5__WEBPACK_IMPORTED_MODULE_2___default()(blank.rels.join(''));
  });

  // Add all statements with blanks in them
  blankStmts.forEach((stmt) => {
    const fps = [];
    fps.push(stmt.isSubjectBlank() ? blankIdx[stmt.getSubject()].hash : stmt.getSubject());
    fps.push(stmt.getPredicate());
    fps.push(stmt.getType() === 'bnode' ? blankIdx[stmt.getValue()].hash : serializeObj(stmt));
    fpg.push(fps.join(''));
  });

  fpg.sort();
  return md5__WEBPACK_IMPORTED_MODULE_2___default()(fpg.join(''));
};

/* harmony default export */ __webpack_exports__["default"] = ({
  extract,
  remove,
  fingerprint,
});


/***/ }),

/***/ "./node_modules/regenerator-runtime/runtime.js":
/*!*****************************************************!*\
  !*** ./node_modules/regenerator-runtime/runtime.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] =
    GeneratorFunction.displayName = "GeneratorFunction";

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      prototype[method] = function(arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList)
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  Gp[toStringTagSymbol] = "Generator";

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "./node_modules/superagent-jsonp/dist/superagent-jsonp.js":
/*!****************************************************************!*\
  !*** ./node_modules/superagent-jsonp/dist/superagent-jsonp.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var removeCallback = function removeCallback(_ref) {
  var script = _ref.script,
      callbackName = _ref.callbackName,
      timeout = _ref.timeout;

  if (script && script.parentNode) script.parentNode.removeChild(script);

  delete window[callbackName];

  clearTimeout(timeout); // clear timeout (for onerror event listener)
};

var jsonp = function jsonp(requestOrConfig) {
  var end = function end() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    return function handler(callback) {
      var _this = this;

      var callbackParam = config.callbackParam || 'callback';
      var callbackName = config.callbackName || 'superagentCallback' + (new Date().valueOf() + parseInt(Math.random() * 1000, 10));
      var timeoutLimit = config.timeout || 1000;

      var timeout = setTimeout(jsonp.errorWrapper.bind(this), timeoutLimit);

      this._jsonp = {
        callbackName: callbackName,
        callback: callback,
        timeout: timeout
      };

      window[callbackName] = jsonp.callbackWrapper.bind(this);

      this._query.push(encodeURIComponent(callbackParam) + '=' + encodeURIComponent(callbackName));
      var queryString = this._query.join('&');

      var s = document.createElement('script');
      {
        var separator = this.url.indexOf('?') > -1 ? '&' : '?';
        var url = this.url + separator + queryString;

        s.src = url;

        // Handle script load error #27
        s.onerror = function (e) {
          jsonp.errorWrapper.call(_this, e);
        };
      }

      document.head.appendChild(s);
      this._jsonp.script = s;

      return this;
    };
  };

  var reqFunc = function reqFunc(request) {
    // In case this is in nodejs, run without modifying request
    if (typeof window === 'undefined') return request;

    request.end = end.call(request, requestOrConfig);
    return request;
  };

  // if requestOrConfig is request
  if (typeof requestOrConfig.end === 'function') {
    return reqFunc(requestOrConfig);
  }

  return reqFunc;
};

jsonp.callbackWrapper = function callbackWrapper(body) {
  var err = null;
  var res = { body: body };

  removeCallback(this._jsonp);

  this._jsonp.callback.call(this, err, res);
};

jsonp.errorWrapper = function errorWrapper(error) {
  var err = new Error('404 Not found');
  if (error && error instanceof Event && error.type === 'error') {
    err = new Error('Connection issue');
  }

  removeCallback(this._jsonp);

  this._jsonp.callback.call(this, err, null);
};

// Prefer node/browserify style requires
if ( true && typeof module.exports !== 'undefined') {
  module.exports = jsonp;
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return { jsonp: jsonp };
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
} else {}

/***/ }),

/***/ "./node_modules/superagent/lib/agent-base.js":
/*!***************************************************!*\
  !*** ./node_modules/superagent/lib/agent-base.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;


/***/ }),

/***/ "./node_modules/superagent/lib/client.js":
/*!***********************************************!*\
  !*** ./node_modules/superagent/lib/client.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");
var RequestBase = __webpack_require__(/*! ./request-base */ "./node_modules/superagent/lib/request-base.js");
var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/superagent/lib/is-object.js");
var ResponseBase = __webpack_require__(/*! ./response-base */ "./node_modules/superagent/lib/response-base.js");
var Agent = __webpack_require__(/*! ./agent-base */ "./node_modules/superagent/lib/agent-base.js");

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};


/***/ }),

/***/ "./node_modules/superagent/lib/is-object.js":
/*!**************************************************!*\
  !*** ./node_modules/superagent/lib/is-object.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;


/***/ }),

/***/ "./node_modules/superagent/lib/request-base.js":
/*!*****************************************************!*\
  !*** ./node_modules/superagent/lib/request-base.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = __webpack_require__(/*! ./is-object */ "./node_modules/superagent/lib/is-object.js");

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};


/***/ }),

/***/ "./node_modules/superagent/lib/response-base.js":
/*!******************************************************!*\
  !*** ./node_modules/superagent/lib/response-base.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var utils = __webpack_require__(/*! ./utils */ "./node_modules/superagent/lib/utils.js");

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};


/***/ }),

/***/ "./node_modules/superagent/lib/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/superagent/lib/utils.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, changesOrigin){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/xmldom/dom-parser.js":
/*!*******************************************!*\
  !*** ./node_modules/xmldom/dom-parser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
	var XMLReader = __webpack_require__(/*! ./sax */ "./node_modules/xmldom/sax.js").XMLReader;
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(/*! ./dom */ "./node_modules/xmldom/dom.js").DOMImplementation;
	exports.XMLSerializer = __webpack_require__(/*! ./dom */ "./node_modules/xmldom/dom.js").XMLSerializer ;
	exports.DOMParser = DOMParser;
//}


/***/ }),

/***/ "./node_modules/xmldom/dom.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/dom.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "./node_modules/xmldom/sax.js":
/*!************************************!*\
  !*** ./node_modules/xmldom/sax.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		//console.error('#@@@@@@'+tagName)
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				//console.error(parseStack.length,parseStack)
				//console.error(config);
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					//}catch(e){console.error('@@@@@'+e)}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			errorHandler.error('element parse error: '+e)
			//errorHandler.error('element parse error: '+e);
			end = -1;
			//throw e;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;



/***/ }),

/***/ "./package.json":
/*!**********************!*\
  !*** ./package.json ***!
  \**********************/
/*! exports provided: name, version, main, module, dependencies, devDependencies, description, licenses, repository, homepage, scripts, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"entrystore-js\",\"version\":\"4.8.0-SNAPSHOT\",\"main\":\"dist/EntryStore.node.js\",\"module\":\"src/index.js\",\"dependencies\":{\"blueimp-md5\":\"^2.10.0\",\"core-js\":\"^3.1.4\",\"he\":\"^1.2.0\",\"lodash\":\"^4.17.10\",\"moment\":\"^2.22.2\",\"rdfjson\":\"https://bitbucket.org/metasolutions/rdfjson.git#develop\",\"regenerator-runtime\":\"^0.13.3\",\"superagent\":\"^3.8.3\",\"superagent-jsonp\":\"^0.2.1\",\"xmldom\":\"^0.1.27\"},\"devDependencies\":{\"@babel/cli\":\"^7.5.5\",\"@babel/core\":\"^7.5.5\",\"@babel/plugin-proposal-class-properties\":\"^7.5.5\",\"@babel/preset-env\":\"^7.5.5\",\"babel-loader\":\"^8.0.6\",\"clean-webpack-plugin\":\"^0.1.19\",\"eslint\":\"^5.6.0\",\"eslint-config-airbnb-base\":\"^13.1.0\",\"eslint-plugin-import\":\"^2.14.0\",\"jaguarjs-jsdoc\":\"0.0.1\",\"nodeunit\":\"^0.11.2\",\"print-licenses\":\"https://bitbucket.org/metasolutions/print-licenses#master\",\"webpack\":\"^4.39.1\",\"webpack-cli\":\"^3.2.1\",\"webpack-merge\":\"^4.1.4\"},\"description\":\"Store is a JS-library for working EntryStore.\",\"licenses\":[{\"type\":\"LGPL-3.0-only\",\"url\":\"https://www.gnu.org/licenses/lgpl-3.0.en.html\"}],\"repository\":\"https://bitbucket.org/metasolutions/entrystore.js.git\",\"homepage\":\"https://bitbucket.org/metasolutions/entrystore.js\",\"scripts\":{\"build\":\"webpack --config webpack.all.js --mode production\",\"build:dev\":\"webpack --config webpack.all.js --mode development\",\"test\":\"nodeunit ./tests/executeTests.js\",\"eslint\":\"eslint 'src/**/*.js'\",\"print-licenses\":\"print-licenses\"}}");

/***/ }),

/***/ "./src/Auth.js":
/*!*********************!*\
  !*** ./src/Auth.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * EntryStore is the main class that is used to connect to a running server-side
 * EntryStore repository.
 * @exports store/Auth
 */
var _default =
/*#__PURE__*/
function () {
  /**
   * @param {store/EntryStore} entrystore - a repository instance.
   */
  function _default(entrystore) {
    _classCallCheck(this, _default);

    this.entrystore = entrystore;
    this._listenerCounter = 0;
    /**
     * @type {Map<string, Function>}
     * @private
     */

    this._listenersIdx = new Map();
  }

  _createClass(_default, [{
    key: "messageListeners",
    value: function messageListeners(topic, obj) {
      this._listenersIdx.forEach(function (func) {
        func(topic, obj);
      });
    }
    /**
     * Adds an authentification listener, it will be notified of login and logout events.
     * @param {authListener} listener
     */

  }, {
    key: "addAuthListener",
    value: function addAuthListener(listener) {
      if (listener.__alid == null) {
        listener.__alid = "idx_".concat(this._listenerCounter);
        this._listenerCounter += 1;
      }

      this._listenersIdx.set(listener.__alid, listener);
    }
    /**
     * Removes an authentification listener.
     * @param {authListener} listener
     */

  }, {
    key: "removeAuthListener",
    value: function removeAuthListener(listener) {
      if (listener.__alid != null) {
        this._listenersIdx.delete(listener.__alid);
      }
    }
    /**
     * Yields information about who currently is authenticated against the EntryStore repository.
     * @returns {Promise.<store/EntryInfo>} - upon success an object containing attributes "user" being
     * the username, "id" of the user entry,
     * and "homecontext" being the entry-id of the home context is provided.
     * @see {@link store/EntryStore#auth auth}
     * @see {@link store/EntryStore#logout logout}
     */

  }, {
    key: "getUserInfo",
    value: function () {
      var _getUserInfo = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var forceLookup,
            _args = arguments;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                forceLookup = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;

                if (!(this.userInfo && !forceLookup)) {
                  _context.next = 3;
                  break;
                }

                return _context.abrupt("return", Promise.resolve(this.userInfo));

              case 3:
                if (this._uiDef) {
                  _context.next = 10;
                  break;
                }

                this._uiDef = this.entrystore.getREST().get("".concat(this.entrystore._baseURI, "auth/user"), null, true);
                this.entrystore.handleAsync(this._uiDef, 'getUserInfo');
                _context.next = 8;
                return this._uiDef;

              case 8:
                this.userInfo = _context.sent;
                delete this._uiDef;

              case 10:
                return _context.abrupt("return", this._uiDef);

              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getUserInfo() {
        return _getUserInfo.apply(this, arguments);
      }

      return getUserInfo;
    }()
    /**
     * @returns {Promise.<store/Entry>} on success the entry for the currently signed in user is provided.
     */

  }, {
    key: "getUserEntry",
    value: function () {
      var _getUserEntry = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2() {
        var forceLookup,
            userInfo,
            _args2 = arguments;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                forceLookup = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : false;

                if (!(this.userEntry && !forceLookup)) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return", Promise.resolve(this.userEntry));

              case 3:
                if (this._ueDef) {
                  _context2.next = 11;
                  break;
                }

                this._ueDef = this.getUserInfo(forceLookup);
                _context2.next = 7;
                return this._ueDef;

              case 7:
                userInfo = _context2.sent;
                _context2.next = 10;
                return this.entrystore.getEntry(this.entrystore.getEntryURI('_principals', userInfo.id), {
                  asyncContext: 'getUserEntry'
                });

              case 10:
                this.userEntry = _context2.sent;

              case 11:
                return _context2.abrupt("return", this.userEntry);

              case 12:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getUserEntry() {
        return _getUserEntry.apply(this, arguments);
      }

      return getUserEntry;
    }()
    /**
     * Authenticate using credentials containing a user, a password and an optional maxAge
     * given in seconds.
     *
     * @param user
     * @param password
     * @param maxAge
     * @returns {xhrPromise}
     */

  }, {
    key: "login",
    value: function () {
      var _login = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(user, password, maxAge) {
        var credentials, authPromise, auth, userInfo;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                if (!(this.userInfo && this.userInfo.user === user)) {
                  _context3.next = 2;
                  break;
                }

                return _context3.abrupt("return", this.getUserInfo());

              case 2:
                credentials = {
                  base: this.entrystore.getBaseURI(),
                  user: user,
                  password: password,
                  maxAge: maxAge
                };
                authPromise = this.entrystore.getREST().auth(credentials);
                this.entrystore.handleAsync(authPromise, 'login');
                _context3.next = 7;
                return authPromise;

              case 7:
                auth = _context3.sent;

                if (!(_typeof(auth) === 'object' && auth.user)) {
                  _context3.next = 10;
                  break;
                }

                return _context3.abrupt("return", auth);

              case 10:
                _context3.next = 12;
                return this.entrystore.getREST().get("".concat(this.entrystore._baseURI, "auth/user"), null, true);

              case 12:
                userInfo = _context3.sent;

                if (this._uiDef) {
                  this._uiDef.cancel();
                }

                if (this._ueDef) {
                  this._ueDef.cancel();
                }

                this.userInfo = userInfo;
                delete this.userEntry;
                this.entrystore.getCache().allNeedRefresh();
                this.messageListeners('login', userInfo);
                return _context3.abrupt("return", userInfo);

              case 20:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function login(_x, _x2, _x3) {
        return _login.apply(this, arguments);
      }

      return login;
    }()
    /**
     * Logout the currently authorized user.
     * @returns {Promise}
     */

  }, {
    key: "logout",
    value: function logout() {
      if (this.userInfo && this.userInfo.user === 'guest') {
        return this.getUserInfo();
      }

      var credentials = {
        base: this.entrystore.getBaseURI(),
        logout: true
      };
      var logoutPromise = this.entrystore.getREST().auth(credentials);
      this.entrystore.handleAsync(logoutPromise, 'logout');
      this.userInfo = {
        user: 'guest',
        id: '_guest'
      };
      delete this.userEntry;
      this.entrystore.getCache().allNeedRefresh();
      this.messageListeners('logout', this.userInfo);
      return this.userInfo;
    }
  }]);

  return _default;
}();
/**
 * @name userInfoPromise
 * @extends xhrPromise
 * @class
 */

/**
 * @name userInfoPromise#then
 * @param {userInfoCallback} onSuccess
 * @param {xhrFailureCallback} onError
 */

/**
 * @callback userInfoCallback
 * @param {userInfo} resource
 */

/**
 * @name userInfo
 * @namespace
 * @property {string}  user                   - the username
 * @property {string}  id                     - the entry id of the users entry
 * @property {string}  homecontext            - the entry id of the users home context.
 */

/**
 * @callback authListener
 * @param {string} topic - either login or logout.
 * @param {userInfo} userInfo - an object with the current user information
 */


exports.default = _default;

/***/ }),

/***/ "./src/Cache.js":
/*!**********************!*\
  !*** ./src/Cache.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Caches loaded entries and keeps track of which entries that need to be updated (refreshed).
 * The cache also provides a listener functionality that allows you to be notified of
 * when entries are updated.
 *
 * @exports store/Cache
 */
var Cache =
/*#__PURE__*/
function () {
  function Cache() {
    _classCallCheck(this, Cache);

    /**
     * @type {Map<string, Function>}
     * @private
     */
    this._listenersIdx = new Map();
    /**
     * @type {Map<string, store/Entry>}
     * @private
     */

    this._cacheIdx = new Map();
    /**
     * @type {Map<string, Set<store/Entry>>}
     * @private
     */

    this._cacheIdxResource = new Map();
    /**
     * @type {Map<string, object>}
     * @private
     */

    this._cacheCtrl = new Map();
    this._listenerCounter = 0;
  }
  /**
   * Add or update the entry to the cache.
   * All listeners will be notified unless silently is specified.
   *
   * @param {store/Entry} entry
   * @param {Boolean=} silently - listeners will be notified unless true is specified.
   */


  _createClass(Cache, [{
    key: "cache",
    value: function cache(entry, silently) {
      var entryURI = entry.getURI();

      var previouslyCached = this._cacheIdx.has(entryURI);

      this._cacheIdx.set(entryURI, entry);

      var entryRURI = entry.getResourceURI();
      var entriesSet = this._cacheIdxResource.has(entryRURI) ? this._cacheIdxResource.get(entryRURI) : new Set();

      if (!entriesSet.has(entry)) {
        entriesSet.add(entry);
      }

      this._cacheIdxResource.set(entryRURI, entriesSet);

      this._cacheCtrl.set(entryURI, {
        date: new Date().getTime()
      });

      if (previouslyCached && silently !== true) {
        this.messageListeners('refreshed', entry);
      }
    }
    /**
     * Removes a single entry from the cache.
     * @param {store/Entry} entry the entry to remove.
     */

  }, {
    key: "unCache",
    value: function unCache(entry) {
      var entryURI = entry.getURI();
      var entryRURI = entry.getResourceURI();

      this._cacheIdx.delete(entryURI);

      var entriesSet = this._cacheIdxResource.get(entryRURI);

      if (entriesSet.size > 0) {
        entriesSet.delete(entry);

        if (entriesSet.size === 0) {
          this._cacheIdxResource.delete(entryRURI);
        }
      }
    }
    /**
     * Marks an entry as in need of refresh from the store.
     * All listeners are notified of the entry now being in need of refreshing unless
     * silently is set to true.
     *
     * @param {store/Entry} entry
     * @param {Boolean=} silently
     */

  }, {
    key: "setRefreshNeeded",
    value: function setRefreshNeeded(entry, silently) {
      var entryURI = entry.getURI();

      var ctrl = this._cacheCtrl.get(entryURI);

      if (ctrl == null) {
        throw new Error("No cache control of existing entry: ".concat(entryURI));
      }

      ctrl.stale = true;

      if (silently !== true) {
        this.messageListeners('needRefresh', entry);
      }
    }
    /**
     * A convenience method for caching multiple entries.
     *
     * @param {store/Entry[]} entryArr
     * @param {Boolean=} silently
     * @see store/Cache#cache
     */

  }, {
    key: "cacheAll",
    value: function cacheAll(entryArr, silently) {
      var _this = this;

      entryArr.forEach(function (entry) {
        _this.cache(entry, silently);
      });
    }
    /**
     * Retrieve the entry from it's URI.
     *
     * @param {String} entryURI
     * @returns {store/Entry|undefined}
     */

  }, {
    key: "get",
    value: function get(entryURI) {
      return this._cacheIdx.get(entryURI);
    }
    /**
     * Retrieve all entries that have the specified uri as resource.
     * Note that since several entries (e.g. links) may have the same uri
     * as resource this method returns an array. However, in many situations
     * there will be zero or one entry per uri.
     *
     * @param {String} uri
     * @returns {Set<store/Entry>} always returns a set, may be empty though.
     */

  }, {
    key: "getByResourceURI",
    value: function getByResourceURI(uri) {
      return new Set(this._cacheIdxResource.get(uri));
    }
    /**
     * Tells whether the entry is in need of a refresh from the repository.
     *
     * @param {store/Entry} entry
     * @returns {boolean}
     */

  }, {
    key: "needRefresh",
    value: function needRefresh(entry) {
      var entryURI = entry.getURI();

      var ctrl = this._cacheCtrl.get(entryURI);

      if (ctrl == null) {
        throw Error("No cache control of existing entry: ".concat(entryURI));
      }

      return ctrl.stale === true;
    }
    /**
     * @param {Function} listener
     */

  }, {
    key: "addCacheUpdateListener",
    value: function addCacheUpdateListener(listener) {
      if (listener.__clid != null) {
        listener.__clid = "idx_".concat(this._listenerCounter);
        this._listenerCounter += 1;
      }

      this._listenersIdx.set(listener.__clid, listener);
    }
    /**
     * @param {Function} listener
     */

  }, {
    key: "removeCacheUpdateListener",
    value: function removeCacheUpdateListener(listener) {
      if (listener.__clid != null) {
        this._listenersIdx.delete(listener.__clid);
      }
    }
    /**
     * Agreed topics are:
     * allEntriesNeedRefresh - all entries are now in need of refresh,
     * typically happens after a change of user(sign in)
     * needRefresh - the specified entry need to be refreshed.
     * refreshed - the specified entry have been refreshed.
     *
     * @param {String} topic
     * @param {store/Entry=} affectedEntry
     */

  }, {
    key: "messageListeners",
    value: function messageListeners(topic, affectedEntry) {
      this._listenersIdx.forEach(function (func) {
        func(topic, affectedEntry);
      });
    }
    /**
     * Marks all entries as in need of refresh and consequently messages all listeners
     * with the allEntriesNeedRefresh topic.
     */

  }, {
    key: "allNeedRefresh",
    value: function allNeedRefresh() {
      var _this2 = this;

      this._cacheIdx.forEach(function (entry, uri) {
        // Do not messageListeners for every entry.
        _this2.setRefreshNeeded(_this2._cacheIdx[uri], true);
      });

      this.messageListeners('allEntriesNeedRefresh');
    }
    /**
     * Clears the cache from all cached entries.
     * Warning: all references to entries needs to be discarded as they will not be
     * kept in sync with changes.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._cacheIdx = new Map();
      this._cacheIdxResource = new Map();
      this._cacheCtrl = new Map();
    }
  }]);

  return Cache;
}();

exports.default = Cache;

/***/ }),

/***/ "./src/Context.js":
/*!************************!*\
  !*** ./src/Context.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph */ "./src/Graph.js"));

var _Pipeline = _interopRequireDefault(__webpack_require__(/*! ./Pipeline */ "./src/Pipeline.js"));

var _PrototypeEntry = _interopRequireDefault(__webpack_require__(/*! ./PrototypeEntry */ "./src/PrototypeEntry.js"));

var _Resource2 = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

var _String = _interopRequireDefault(__webpack_require__(/*! ./String */ "./src/String.js"));

var _types = _interopRequireDefault(__webpack_require__(/*! ./types */ "./src/types.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Methods for interacting with the EntryStore repository scoped to a specific context.
 *
 * @exports store/Context
 */
var Context =
/*#__PURE__*/
function (_Resource) {
  _inherits(Context, _Resource);

  function Context() {
    _classCallCheck(this, Context);

    return _possibleConstructorReturn(this, _getPrototypeOf(Context).apply(this, arguments));
  }

  _createClass(Context, [{
    key: "listEntries",

    /**
     * Retrieves a list of entries in the context.
     *
     * @param {Object} sort - same sort object as provided in the optionalLoadParams to
     * {@see store/EntryStore#getEntry getEntry} method.
     * @param {Object} limit - same limit as provided in the optionalLoadParams to
     * {@see store/EntryStore#getEntry getEntry} method.
     * @param {integer} page - unless limit is set to -1 (no pagination) we need to specify
     * which page to load, first page is 0.
     * @returns {Promise.<store/Entry[]>} upon success the promise returns an array of entries.
     * @see store/EntryStore#getListEntries
     */
    value: function listEntries(sort, limit, page) {
      return this.getEntryStore().getListEntries("".concat(this._resourceURI, "/entry/_all"), sort, limit, page);
    }
    /**
     * Convenience method, to retrieve an entry from this context.
     *
     * @param {string} entryId
     * @param {object} optionalLoadParams same parameter as in {@see store/EntryStore#getEntry}
     * @returns {Promise.<store/Entry>}
     * @see store/EntryStore#getEntry
     */

  }, {
    key: "getEntryById",
    value: function getEntryById(entryId) {
      var optionalLoadParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.getEntryStore().getEntry(this.getEntryURIbyId(entryId), optionalLoadParams);
    }
    /**
     * Expands the given entry id into a full URI.
     *
     * @param {string} entryId
     * @returns {string} the URI for an entry in this context with the given id.
     */

  }, {
    key: "getEntryURIbyId",
    value: function getEntryURIbyId(entryId) {
      return this.getEntryStore().getEntryURI(this.getId(), entryId);
    }
    /**
     * Factory method to create a PrototypeEntry that has the current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it
     * (returns a promise).
     *
     * @param {string=} id - id for the entry, fails after commit if an entry exists already with
     * this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newEntry",
    value: function newEntry(id) {
      return new _PrototypeEntry.default(this, id);
    }
    /**
     * Factory method to create a PrototypeEntry that corresponds to a local named resource that
     * has the current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it
     * (returns a promise).
     *
     * @param {string=} id - id for the entry, fails after commit if an entry exists already
     * with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newNamedEntry",
    value: function newNamedEntry(id) {
      return new _PrototypeEntry.default(this, id).setResourceType(_types.default.RT_NAMEDRESOURCE);
    }
    /**
     * Factory method to create a PrototypeEntry that corresponds to a link that has the
     * current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create
     * it (returns a promise).
     *
     * @param {string} link - the URI for the resource we are making a link to, mandatory.
     * @param {string=} id - id for the entry, fails after commit if an entry exists already
     * with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newLink",
    value: function newLink(link, id) {
      return new _PrototypeEntry.default(this, id).setResourceURI(link).setEntryType(_types.default.ET_LINK);
    }
    /**
     * Factory method to create a PrototypeEntry that is a linkref that has the current context
     * as container. Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to
     * actually create it (returns a promise).
     *
     * @param {string} link - is the URI for the resource we are making a link to, mandatory.
     * @param {string} metadataLink - is the URI for the metadata are referring to, mandatory.
     * @param {string=} id - id for the entry, fails after commit if an entry exists already
     * with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newLinkRef",
    value: function newLinkRef(link, metadataLink, id) {
      return new _PrototypeEntry.default(this, id).setResourceURI(link).setExternalMetadataURI(metadataLink).setEntryType(_types.default.ET_LINKREF);
    }
    /**
     * Factory method to create a PrototypeEntry that is a reference and has the current
     * context as container. Call {@link store/PrototypeEntry#commit commit} on the
     * PrototypeEntry to actually create it (returns a promise).
     * The only difference to the newLinkRef method is that the EntryType is Reference instead
     * of LinkReference which implies that there is no local metadata.
     *
     * @param {string} link - the URI for the resource we are making a link to, mandatory.
     * @param {string} metadataLink - the URI for the metadata are referring to, mandatory.
     * @param {string=} id for the entry, fails after commit if an entry exists already with
     * this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newRef",
    value: function newRef(link, metadataLink, id) {
      return new _PrototypeEntry.default(this, id).setResourceURI(link).setExternalMetadataURI(metadataLink).setEntryType(_types.default.ET_REF);
    }
    /**
     * Factory method to create a PrototypeEntry whose resource is a {@link store/List List)
     * and has the current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create
     * it (returns a promise).
     *
     * @param {string} id an optional id for the entry, fails on commit if an entry exists already
     * with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newList",
    value: function newList(id) {
      return new _PrototypeEntry.default(this, id).setGraphType(_types.default.GT_LIST);
    }
    /**
     * Factory method to create a PrototypeEntry whose resource is a {@link store/Graph Graph}
     * and has the current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it
     * (returns a promise).
     *
     * @param {rdfjson/Graph} graph - graph to store as a resource.
     * @param {string=} id - id for the entry, fails upon commit if an entry exists already
     * with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newGraph",
    value: function newGraph(graph, id) {
      var prototypeEntry = new _PrototypeEntry.default(this, id).setGraphType(_types.default.GT_GRAPH);
      var entryInfo = prototypeEntry.getEntryInfo();
      prototypeEntry._resource = new _Graph.default(entryInfo.getEntryURI(), entryInfo.getResourceURI(), this.getEntryStore(), graph || {});
      return prototypeEntry;
    }
    /**
     * Factory method to create a PrototypeEntry whose resource is a {@link store/String String}
     * that has the current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create
     * it (returns a promise).
     *
     * @param {string=} str an optional string for the String Resource.
     * @param {String} id an optional id for the entry, fails upon commit if an entry exists
     * already with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newString",
    value: function newString(str, id) {
      var prototypeEntry = new _PrototypeEntry.default(this, id).setGraphType(_types.default.GT_STRING);
      var entryInfo = prototypeEntry.getEntryInfo();
      prototypeEntry._resource = new _String.default(entryInfo.getEntryURI(), entryInfo.getResourceURI(), this.getEntryStore(), str);
      return prototypeEntry;
    }
    /**
     * Factory method to create a PrototypeEntry whose resource is a
     * {@link store/Pipeline pipeline} that has the current context as container.
     * Call {@link store/PrototypeEntry#commit commit} on the PrototypeEntry to actually create it
     * (returns a promise).
     *
     * @param {String} id an optional id for the entry, fails upon commit if an entry exists
     * already with this id.
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newPipeline",
    value: function newPipeline(id) {
      var prototypeEntry = new _PrototypeEntry.default(this, id).setGraphType(_types.default.GT_PIPELINE);
      var entryInfo = prototypeEntry.getEntryInfo();
      prototypeEntry._resource = new _Pipeline.default(entryInfo.getEntryURI(), entryInfo.getResourceURI(), this.getEntryStore(), {});
      return prototypeEntry;
    }
    /**
     * The name for this context.
     *
     * @returns {string}
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * Change of context name, succeeds if name is not in use already by another context.
     * @param {string} name
     * @returns {Promise}
     */

  }, {
    key: "setName",
    value: function setName(name) {
      var _this = this;

      var oldName = this._name;
      this._name = name;
      return this.getEntryStore().handleAsync(this.getEntryStore().getREST().put("".concat(this.getEntryURI(), "/name"), JSON.stringify({
        name: name
      })).then(function (data) {
        var entry = _this.getEntry(true);

        if (entry) {
          entry.getEntryInfo()._name = data;
        }

        return data;
      }, function (e) {
        _this._name = oldName;
        throw e;
      }), 'setContextName');
    }
    /**
     * Finds the user or group that has this context as homecontext if any.
     *
     * @returns {Promise.<store/Entry>} if succeeds if context a homecontext of some user or group.
     * @async
     */

  }, {
    key: "getHomeContextOf",
    value: function () {
      var _getHomeContextOf = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var contextEntry, es, groupResourceArr;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getEntry();

              case 2:
                contextEntry = _context.sent;
                es = contextEntry.getEntryStore();
                groupResourceArr = contextEntry.getReferrers('store:homeContext');

                if (!(groupResourceArr.length > 0)) {
                  _context.next = 7;
                  break;
                }

                return _context.abrupt("return", es.getEntry(es.getEntryURIFromURI(groupResourceArr[0])));

              case 7:
                throw new Error('No user or group that has this context as home context');

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getHomeContextOf() {
        return _getHomeContextOf.apply(this, arguments);
      }

      return getHomeContextOf;
    }()
    /**
     *
     * @param data
     * @private
     */

  }, {
    key: "_update",
    value: function _update(data) {
      this._name = data.alias || data.name; // TODO, change to only name after clean-up
    }
  }]);

  return Context;
}(_Resource2.default);

exports.default = Context;
;

/***/ }),

/***/ "./src/Entry.js":
/*!**********************!*\
  !*** ./src/Entry.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

var _types = _interopRequireDefault(__webpack_require__(/*! ./types */ "./src/types.js"));

var _EntryStore = _interopRequireDefault(__webpack_require__(/*! ./EntryStore */ "./src/EntryStore.js"));

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * Entries are at the center of this API. Entries holds together metadata, external metadata,
 * resources, access control, and provenance. Hence, entries appear in the majority of methods,
 * either directly or in callbacks via promises. Each entry has a simple identifier within a
 * context and a globally unique URI that can be used to load, store and index the entry.
 *
 * Many of the methods in this class are convenience methods that allows the developer to interact
 * with the information retrieved from the repository without digging through the RDF graphs.
 * For instance, all methods starting with _can_ or _is_ are convenience methods for working
 * with access control or the type information available in the associated
 * The same is true for the majority of the get methods,
 * only those that have corresponding set methods are really unique for this class.
 *
 * @link store/EntryInfo
 * @exports store/Entry
 */
var Entry =
/*#__PURE__*/
function () {
  /**
   * @param {store/Context} context container for this entry
   * @param {store/EntryInfo} entryInfo defines the basics of this entry
   */
  function Entry(context, entryInfo) {
    _classCallCheck(this, Entry);

    this._context = context;
    this._entryInfo = entryInfo;
    this._entryInfo._entry = this;
  }
  /**
   * @returns {store/EntryStore}
   */


  _createClass(Entry, [{
    key: "getEntryStore",
    value: function getEntryStore() {
      return this._context.getEntryStore();
    }
    /**
     * @returns {store/EntryInfo}
     */

  }, {
    key: "getEntryInfo",
    value: function getEntryInfo() {
      return this._entryInfo;
    }
    /**
     * Convenience method, same as calling entry.getEntryInfo().getEntryURI()
     * @return {string} the entry uri.
     * @see store/EntryInfo#getEntryURI
     */

  }, {
    key: "getURI",
    value: function getURI() {
      return this._entryInfo.getEntryURI();
    }
    /**
     * Convenience method, same as calling entry.getEntryInfo().getId()
     * @returns {string} the id of the entry
     * @see store/EntryInfo#getId
     */

  }, {
    key: "getId",
    value: function getId() {
      return this._entryInfo.getId();
    }
    /**
     * Convenience method, same as calling entry.getEntryInfo().getResourceURI()
     * @returns {string} a URI to the resource of this entry.
     */

  }, {
    key: "getResourceURI",
    value: function getResourceURI() {
      return this._entryInfo.getResourceURI();
    }
    /**
     * @returns {store/Context}
     */

  }, {
    key: "getContext",
    value: function getContext() {
      return this._context;
    }
    /**
     * Provides an RDF graph as an {@link rdfjson/Graph} instance.
     * @return {rdfjson/Graph} a RDF graph with metadata, typically containing statements about
     * the resourceURI. The returned graph may be empty but never null or undefined.
     */

  }, {
    key: "getMetadata",
    value: function getMetadata() {
      if (this._metadata == null) {
        this._metadata = new _rdfjson.Graph();
      }

      return this._metadata;
    }
    /**
     * Sets a new metadata graph for this entry without pushing it to the repository.
     * In many cases this method is not needed since you can get the metadata graph,
     * modify it and then commit the changes directly.
     *
     * However, in some cases you need to set a new metadata graph, e.g.
     * you want to overwrite the metadata with a new graph retrieved from another source or the
     * entry have been refreshed with new information and you want to commit the merged results.
     * In these cases you need to discard the current metadata graph with help of this method.
     *
     * @param {rdfjson/Graph} graph is an RDF graph with metadata, if it is not provided the current
     * metadata graph is saved (there is currently no check whether it has been modified or not).
     * @return store/Entry - to allow chaining with other methods, e.g. with commitMetadata.
     */

  }, {
    key: "setMetadata",
    value: function setMetadata(graph) {
      this._metadata = graph;
      return this;
    }
    /**
     * Will push the metadata for this entry to the repository.
     * If metadata has been set for an entry with EntryType 'reference'
     * the entry type will change to 'linkreference' upon a successful commit.
     * @params {boolean} [ignoreIfUnmodifiedSinceCheck=false] if explicitly set to true no check is done
     * if information is stale, also it will not automatically refresh with the latest date
     * @return {Promise.<store/Entry>} a promise that on success will contain the current updated entry.
     */

  }, {
    key: "commitMetadata",
    value: function commitMetadata() {
      var _this = this;

      var ignoreIfUnmodifiedSinceCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var p;
      var es = this.getEntryStore();

      if (this.isReference()) {
        p = Promise.reject("Entry \"".concat(this.getURI(), "\" is a reference and have no local metadata that can be saved."));
      } else if (!this.canWriteMetadata()) {
        p = Promise.reject("You do not have sufficient access rights to save metadata on entry \"".concat(this.getURI(), "\"."));
      } else if (this.needRefresh()) {
        p = Promise.reject("The entry \"".concat(this.getURI(), "\" need to be refreshed before its local metadata can be saved.\n") + 'This message indicates that the client is written poorly, this case should have been taken into account.');
      } else if (this._metadata == null) {
        p = Promise.reject("The entry \"".concat(this.getURI(), "\" should allow local metadata to be saved, but there is no local metadata.\nThis message is a bug in the storejs API."));
      } else {
        if (ignoreIfUnmodifiedSinceCheck) {
          p = es.getREST().put(this.getEntryInfo().getMetadataURI(), JSON.stringify(this._metadata.exportRDFJSON())).then(function () {
            return _this;
          });
        } else {
          var mod = this.getEntryInfo().getModificationDate();
          p = es.getREST().put(this.getEntryInfo().getMetadataURI(), JSON.stringify(this._metadata.exportRDFJSON()), mod).then(function () {
            _this.setRefreshNeeded(true);

            return _this.refresh().then(function () {
              return _this;
            }, function () {
              // Failed refreshing, but succeeded at saving metadata,
              // at least send out message that it needs to be refreshed.
              _this.getEntryStore().getCache().message('refreshed', _this);

              return _this;
            });
          });
        }
      }

      return es.handleAsync(p, 'commitMetadata');
    }
    /**
     * Same as entry.getMetadata().add(entry.getResourceURI(), predicate, o)
     * but instead of returning the created statement it returns the entry itself,
     * allowing chained method calls.
     *
     * @param {string} predicate the predicate
     * @param {object} object the object
     * @returns {store/Entry}
     */

  }, {
    key: "add",
    value: function add(predicate, object) {
      this.getMetadata().add(this.getResourceURI(), predicate, object);
      return this;
    }
    /**
     * Same as entry.getMetadata().addL(entry.getResourceURI(), predicate, literal, lang)
     * but instead of returning the created statement it returns the entry itself,
     * allowing chained method calls.
     *
     * @param {string} predicate the predicate
     * @param {string} literal the literal value
     * @param {string} language an optional language
     * @returns {store/Entry}
     */

  }, {
    key: "addL",
    value: function addL(predicate, literal, language) {
      this.getMetadata().addL(this.getResourceURI(), predicate, literal, language);
      return this;
    }
    /**
     * Same as entry.getMetadata().addD(entry.getResourceURI(), predicate, literal, lang)
     * but instead of returning the created statement it returns the entry itself,
     * allowing chained method calls.
     *
     * @param {string} predicate the predicate
     * @param {string} literal the literal value
     * @param {string} datatype the datatype (should be a string)
     * @returns {store/Entry}
     */

  }, {
    key: "addD",
    value: function addD(predicate, literal, datatype) {
      this.getMetadata().addD(this.getResourceURI(), predicate, literal, datatype);
      return this;
    }
    /**
     * Cached external metadata can only be provided for entries with entry type
     * reference or link reference.
     *
     * @return {rdfjson/Graph} - a RDF graph with cached external metadata, typically containing
     * statements about the resourceURI. The returned graph may be empty but never null
     * or undefined.
     */

  }, {
    key: "getCachedExternalMetadata",
    value: function getCachedExternalMetadata() {
      if (this._cachedExternalMetadata == null) {
        this._cachedExternalMetadata = new _rdfjson.Graph();
      }

      return this._cachedExternalMetadata;
    }
  }, {
    key: "getInferredMetadata",
    value: function getInferredMetadata() {
      return this._inferredMetadata;
    }
    /**
     * Sets a new cached external metadata graph for this entry without pushing
     * it to the repository.
     *
     * @param {rdfjson/Graph} graph is an RDF graph with metadata.
     * @return store/Entry - to allow chaining with other methods,
     * e.g. with commitCachedExternalMetadata.
     */

  }, {
    key: "setCachedExternalMetadata",
    value: function setCachedExternalMetadata(graph) {
      if (graph) {
        this._cachedExternalMetadata = graph;
      }

      return this;
    }
    /**
     * Pushes the current cached external metadata graph for this entry to the repository.
     *
     * @return {Promise.<store/Entry>} a promise that on success will contain the current updated entry.
     */

  }, {
    key: "commitCachedExternalMetadata",
    value: function commitCachedExternalMetadata() {
      var _this2 = this;

      var es = this.getEntryStore();
      var mod = this.getEntryInfo().getModificationDate();
      var promise = es.getREST().put(this.getEntryInfo().getCachedExternalMetadataURI(), JSON.stringify(this._cachedExternalMetadata.exportRDFJSON()), mod).then(function () {
        _this2.setRefreshNeeded(true);

        return _this2.refresh().then(function () {
          return _this2;
        }, function () {
          // Failed refreshing, but succeeded at saving metadata,
          // at least send out message that it needs to be refreshed.
          _this2.getEntryStore().getCache().message('refreshed', _this2);

          return _this2;
        });
      });
      return es.handleAsync(promise, 'commitCachedExternalMetadata');
    }
    /**
     * @todo remains to be supported in repository
     * @returns {rdfjson/Graph}
     */

  }, {
    key: "getExtractedMetadata",
    value: function getExtractedMetadata() {
      if (this._extractedMetadata == null) {
        this._extractedMetadata = new _rdfjson.Graph();
      }

      return this._extractedMetadata;
    }
    /**
     * Provides the resource for this entry if it exists in a promise,
     * e.g. if the graph-type is not none.
     * It is also possible to request the resource directly, i.e. get the resource rather
     * than a promise. This is achieved by specifying the "direct" parameter as true.
     * This always work for Lists, Groups, and Context resources.
     * For all other resources it will work if the resource, e.g. a Graph,
     * a String etc. is already loaded. If it is not loaded null will be returned.
     *
     * @returns {store/Resource | Promise.<store/Resource>}
     */

  }, {
    key: "getResource",
    value: function getResource() {
      var _this3 = this;

      var direct = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      if (direct) {
        return this._resource;
      }

      var es = this.getEntryStore();
      var promise;

      if (this._resource) {
        promise = Promise.resolve(this._resource);
      } else {
        var format = this.isString() ? 'text' : null;
        promise = es.getREST().get(this.getResourceURI(), format).then(function (data) {
          _factory.default.updateOrCreateResource(_this3, {
            resource: data
          }, true);

          return _this3._resource;
        });
      }

      return es.handleAsync(promise, 'getResource');
    }
    /**
     * @returns {rdfjson/Graph}
     */

  }, {
    key: "getReferrersGraph",
    value: function getReferrersGraph() {
      return this._relation;
    }
    /**
     * a list of URIs that has referred to this Entry using various properties.
     *
     * @param {string} prop
     * @returns {string[]}
     */

  }, {
    key: "getReferrers",
    value: function getReferrers(prop) {
      return this._relation.find(null, prop, null).map(function (stmt) {
        return stmt.getSubject();
      });
    }
    /**
     * a list of entry URIs corresponding to list entries where this entry is contained.
     * @returns {string[]}
     */

  }, {
    key: "getParentLists",
    value: function getParentLists() {
      var _this4 = this;

      var listResourceURIArr = this.getReferrers('http://entrystore.org/terms/hasListMember');
      return listResourceURIArr.map(function (resURI) {
        return _factory.default.getEntryURIFromURI(_this4.getEntryStore(), resURI);
      }, this);
    }
    /**
     * a list of entry URIs corresponding to groups where this user entry is member.
     * @returns {string[]}
     */

  }, {
    key: "getParentGroups",
    value: function getParentGroups() {
      var _this5 = this;

      var groupResourceURIArr = this.getReferrers('http://entrystore.org/terms/hasGroupMember');
      return groupResourceURIArr.map(function (resURI) {
        return _factory.default.getEntryURIFromURI(_this5.getEntryStore(), resURI);
      }, this);
    }
    /**
     * a list of comments (i.e. their URIs) of this entry.
     * @returns {string[]}
     */

  }, {
    key: "getComments",
    value: function getComments() {
      return this.getReferrers('http://ontologi.es/like#regarding');
    }
    /**
     * Is the resource of this entry of the GraphType list?
     * @returns {boolean}
     */

  }, {
    key: "isList",
    value: function isList() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_LIST;
    }
    /**
     * Is the resource of this entry of the Graphtype resultlist?
     * @returns {boolean}
     */

  }, {
    key: "isResultList",
    value: function isResultList() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_RESULTLIST;
    }
    /**
     * Is the resource of this entry of the GraphType context?
     * @returns {boolean}
     */

  }, {
    key: "isContext",
    value: function isContext() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_CONTEXT;
    }
    /**
     * Is the resource of this entry of the GraphType systemcontext?
     * @returns {boolean}
     */

  }, {
    key: "isSystemContext",
    value: function isSystemContext() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_SYSTEMCONTEXT;
    }
    /**
     * Is the resource of this entry of the GraphType user?
     * @returns {boolean}
     */

  }, {
    key: "isUser",
    value: function isUser() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_USER;
    }
    /**
     * Is the resource of this entry of the GraphType group?
     * @returns {boolean}
     */

  }, {
    key: "isGroup",
    value: function isGroup() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_GROUP;
    }
    /**
     * Is the resource of this entry of the GraphType graph?
     * @returns {boolean}
     */

  }, {
    key: "isGraph",
    value: function isGraph() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_GRAPH;
    }
    /**
     * Is the resource of this entry of the GraphType pipeline?
     * @returns {boolean}
     */

  }, {
    key: "isPipeline",
    value: function isPipeline() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_PIPELINE;
    }
    /**
     * Is the resource of this entry of the GraphType pipelineresult?
     * @returns {boolean}
     */

  }, {
    key: "isPipelineResult",
    value: function isPipelineResult() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_PIPELINERESULT;
    }
    /**
     * Is the resource of this entry of the GraphType string?
     * @returns {boolean}
     */

  }, {
    key: "isString",
    value: function isString() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_STRING;
    }
    /**
     * Is the resource of this entry of the GraphType none?
     * @returns {boolean}
     */

  }, {
    key: "isNone",
    value: function isNone() {
      return this.getEntryInfo().getGraphType() === _types.default.GT_NONE;
    }
    /**
     * Is this entry of the EntryType link?
     * @returns {boolean}
     */

  }, {
    key: "isLink",
    value: function isLink() {
      return this.getEntryInfo().getEntryType() === _types.default.ET_LINK;
    }
    /**
     * Is this entry of the EntryType reference?
     * @returns {boolean}
     */

  }, {
    key: "isReference",
    value: function isReference() {
      return this.getEntryInfo().getEntryType() === _types.default.ET_REF;
    }
    /**
     * Is this entry of the EntryType linkreference?
     * @returns {boolean}
     */

  }, {
    key: "isLinkReference",
    value: function isLinkReference() {
      return this.getEntryInfo().getEntryType() === _types.default.ET_LINKREF;
    }
    /**
     * Is the entry of the EntryType link, linkreference or reference?
     * That is, the resource can be controlled via {@link store/EntryInfo#setResourceURI}.
     *
     * @returns {boolean} true if entrytype is NOT local.
     */

  }, {
    key: "isExternal",
    value: function isExternal() {
      return this.getEntryInfo().getEntryType() !== _types.default.ET_LOCAL;
    }
    /**
     * Is the EntryType local, i.e. the resources URI is maintained
     * automatically by the repository for this entry.
     * Opposite to {@link store/Entry#isLinkLike}.
     *
     * @returns {boolean}
     */

  }, {
    key: "isLocal",
    value: function isLocal() {
      return this.getEntryInfo().getEntryType() === _types.default.ET_LOCAL;
    }
    /**
     * Is the entry a local link/linkreference/reference to another entry in the repository.
     * That is, true if the entry is a link, linkreference or reference AND the resource URI
     * belongs to another entry in the same repository.
     *
     * @returns {boolean}
     */

  }, {
    key: "isLinkToEntry",
    value: function isLinkToEntry() {
      var base = this.getEntryStore().getBaseURI();
      return this.isExternal() && this.getResourceURI().substr(0, base.length) === base;
    }
    /**
     * Is the entry is a link to another entry (as either a link, linkreference or reference) the
     * linked to entry is returned in a promise.
     *
     * @returns {Promise.<store/Entry>|undefined} undefined only if the entry does not link to another entry.
     */

  }, {
    key: "getLinkedEntry",
    value: function getLinkedEntry() {
      if (this.isLinkToEntry()) {
        // In case the link is to the resource URI rather than the entry URI, we extract
        // the entry id and context id and rebuild the entry URI.
        var es = this.getEntryStore();
        var resourceURI = this.getResourceURI();
        var entryId = es.getEntryId(resourceURI);
        var contextId = es.getContextId(resourceURI);
        var entryURI = es.getEntryURI(contextId, entryId);
        return es.handleAsync(this.getEntryStore().getEntry(entryURI), 'getLinkedEntry');
      }

      return undefined;
    }
    /**
     * Is the entry an information resource?
     * @returns {boolean}
     */

  }, {
    key: "isInformationResource",
    value: function isInformationResource() {
      return this.getEntryInfo().getResourceType() === _types.default.RT_INFORMATIONRESOURCE;
    }
    /**
     * Is the entry a named resource?
     * @returns {boolean}
     */

  }, {
    key: "isNamedResource",
    value: function isNamedResource() {
      return this.getEntryInfo().getResourceType() === _types.default.RT_NAMEDRESOURCE;
    }
    /**
     * Is the current user an owner of this entry?
     * @returns {boolean}
     */

  }, {
    key: "canAdministerEntry",
    value: function canAdministerEntry() {
      return this._rights.administer || false;
    }
    /**
     * Is the current user authorized to read the resource of this entry?
     * @returns {boolean}
     */

  }, {
    key: "canReadResource",
    value: function canReadResource() {
      return this._rights.administer || this._rights.readresource || this._rights.writeresource || false;
    }
    /**
     * Is the current user authorized to write the resource of this entry?
     * @returns {boolean}
     */

  }, {
    key: "canWriteResource",
    value: function canWriteResource() {
      return this._rights.administer || this._rights.writeresource || false;
    }
    /**
     * Is the current user authorized to read the metadata of this entry?
     * @returns {boolean}
     */

  }, {
    key: "canReadMetadata",
    value: function canReadMetadata() {
      return this._rights.administer || this._rights.readmetadata || this._rights.writemetadata || false;
    }
    /**
     * Is the current user authorized to write the metadata of this entry?
     * @returns {boolean}
     */

  }, {
    key: "canWriteMetadata",
    value: function canWriteMetadata() {
      return this._rights.administer || this._rights.writemetadata || false;
    }
    /**
     * Whether this entry is available publically or not.
     * To make sure this method returns a boolean make sure the contexts entry is loaded, e.g. via:
     * entry.getContext().getEntry().then(function() {
     *    if (entry.isPublic()) {...} //Or whatever you need to do with the isPublic method.
     * }
     *
     * @returns {boolean|undefined} undefined only if the entry has no ACL and the contexts entry
     * which specifies the default access is not cached, otherwise a boolean is returned.
     */

  }, {
    key: "isPublic",
    value: function isPublic() {
      var guestPrincipal = this.getEntryStore().getResourceURI('_principals', '_guest');
      var acl = this.getEntryInfo().getACL();

      if (acl.contextOverride) {
        return ['rwrite', 'rread', 'mwrite', 'mread'].some(function (key) {
          return acl[key].indexOf(guestPrincipal) !== -1;
        });
      }

      var ce = this.getContext().getEntry(true);

      if (ce == null) {
        return undefined;
      }

      acl = ce.getEntryInfo().getACL();
      return ['rwrite', 'rread'].some(function (key) {
        return acl[key].indexOf(guestPrincipal) !== -1;
      });
    }
    /**
     * Whether this entry is available to the specified user.
     * To make sure this method returns a boolean and not undefined,
     * make sure that the contexts entry is loaded, e.g. via:
     *
     * entry.getContext().getEntry().then(function() {
     *    //And then do you check, e.g.:
     *    entry.getEntryStore().getUserEntry().then(function(currentUserEntry) {
     *       if (entry.isPrivateTo(currentUserEntry) {...}
     *    })
     * }
     *
     * @returns {boolean|undefined} undefined if the contexts entry which
     * specifies the default access is not cached, otherwise a boolean is returned.
     */

  }, {
    key: "isPrivateTo",
    value: function isPrivateTo(userEntry) {
      var userPrincipal = userEntry.getResourceURI();
      var acl = this.getEntryInfo().getACL();
      var ce = this.getContext().getEntry(true);

      if (ce == null) {
        return undefined;
      }

      var cacl = ce.getEntryInfo().getACL();

      if (cacl.admin.length !== 1 || acl.admin[0] !== userPrincipal) {
        return false;
      }

      if (acl.contextOverride) {
        return acl.admin.length === 1 && acl.admin[0] === userPrincipal;
      }

      return true;
    }
    /**
     * Deletes this entry without any option to recover it.
     * @param {boolean} recursive if true and the entry is a list it will delete the entire tree of
     * lists and all entries that is only contained in the current list or any of its child lists.
     * @return {Promise} which on success indicates that the deletion has succeeded.
     */

  }, {
    key: "del",
    value: function del() {
      var _this6 = this;

      var recursive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var es = this.getEntryStore();

      var unCache = function unCache() {
        return es.getCache().unCache(_this6);
      };

      if (recursive === true) {
        return es.handleAsync(es.getREST().del("".concat(this.getURI(), "?recursive=true")).then(unCache), 'delEntry');
      }

      return es.handleAsync(es.getREST().del(this.getURI()).then(unCache), 'delEntry');
    }
    /**
     * That an entry needs to be refreshed typically means that it contains stale data
     * (with respect to what is available in the store).
     * The entry should be refresh before it is further used.
     *
     * @param {boolean=} silently the cache will send out a stale message (to all registered
     * listeners of the cache) for this entry if the value is false or undefined.
     * @see store.Entry#refresh.
     */

  }, {
    key: "setRefreshNeeded",
    value: function setRefreshNeeded() {
      var silently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      this.getEntryStore().getCache().setRefreshNeeded(this, silently);
    }
    /**
     * Tells whether an entry needs to be refreshed.
     *
     * @return {boolean} true if the entry need to be refreshed before used.
     * @see store/Entry#refresh.
     */

  }, {
    key: "needRefresh",
    value: function needRefresh() {
      return this.getEntryStore().getCache().needRefresh(this);
    }
    /**
     * Refreshes an entry if needed, that is, if it has been marked as invalid.
     * @param {boolean=} silently the cache will send out a refresh message for this entry
     * if a refresh was needed AND if the value of silently is false or undefined. If force is true
     * it will send out a refresh message anyhow.
     * @param {boolean=} [force=false] If true the entry will be refreshed independent if it was marked in need
     * of a refresh or not.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var _this7 = this;

      var silently = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var es = this.getEntryStore();
      var p;

      if (force === true || es.getCache().needRefresh(this)) {
        var entryURI = this.getURI();
        p = es.getREST().get(_factory.default.getEntryLoadURI(entryURI)).then(function (data) {
          _factory.default.update(_this7, data);

          es.getCache().cache(_this7, silently);
          return _this7;
        });
      } else {
        p = Promise.resolve(this);
      }

      return es.handleAsync(p, 'refresh');
    }
  }]);

  return Entry;
}();

exports.default = Entry;
;

/***/ }),

/***/ "./src/EntryInfo.js":
/*!**************************!*\
  !*** ./src/EntryInfo.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _moment = _interopRequireDefault(__webpack_require__(/*! moment */ "./node_modules/moment/moment.js"));

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

var _terms = _interopRequireDefault(__webpack_require__(/*! ./terms */ "./src/terms.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * EntryInfo is a class that contains all the administrative information of an entry.
 * @exports store/EntryInfo
 */
var EntryInfo =
/*#__PURE__*/
function () {
  /**
   * @param {String} entryURI must be provided unless the graph contains a statement with
   * the store:resource property which allows us to infer the entryURI.
   * @param {rdfjson/Graph} graph corresponds to a rdfjson.Graph class with the entryinfo as
   * statements
   * @param {store/EntryStore} entryStore
   */
  function EntryInfo(entryURI, graph, entryStore) {
    _classCallCheck(this, EntryInfo);

    this._entryURI = entryURI || graph.find(null, _terms.default.resource)[0].getSubject();
    this._graph = graph || new _rdfjson.Graph();
    this._entryStore = entryStore;
  }
  /**
   * @returns {store/Entry}
   */


  _createClass(EntryInfo, [{
    key: "getEntry",
    value: function getEntry() {
      return this._entry;
    }
    /**
     * @param {rdfjson/Graph} graph
     */

  }, {
    key: "setGraph",
    value: function setGraph(graph) {
      this._graph = graph;
    }
    /**
     * @return {rdfjson/Graph}
     */

  }, {
    key: "getGraph",
    value: function getGraph() {
      return this._graph;
    }
    /**
     * Pushes the entry information to the repository, e.g. posts to
     * basepath/store/{contextId}/entry/{entryId}
     * @params {boolean} ignoreIfUnmodifiedSinceCheck if explicitly set to true no check is done
     * if information is stale, also it will not automatically refresh with the latest date
     * @returns {Promise.<store/EntryInfo>}
     */

  }, {
    key: "commit",
    value: function commit() {
      var _this = this;

      var ignoreIfUnmodifiedSinceCheck = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var es = this._entry.getEntryStore();

      var mod;

      if (ignoreIfUnmodifiedSinceCheck === true) {
        mod = this.getModificationDate();
      }

      var p = es.getREST().put(this.getEntryURI(), JSON.stringify(this._graph.exportRDFJSON()), mod).then(function () {
        if (ignoreIfUnmodifiedSinceCheck !== true) {
          _this._entry.setRefreshNeeded(true);

          return _this._entry.refresh().then(function () {
            return _this;
          }, function () {
            // Failed refreshing, but succeeded at saving metadata,
            // at least send out message that it needs to be refreshed.
            es.getCache().message('refreshed', _this);
            return _this;
          });
        }

        return _this;
      });
      return es.handleAsync(p, 'commitEntryInfo');
    }
    /**
     * @returns {String}
     */

  }, {
    key: "getEntryURI",
    value: function getEntryURI() {
      return this._entryURI;
    }
    /**
     * @returns {String} the id of the entry
     */

  }, {
    key: "getId",
    value: function getId() {
      return _factory.default.getEntryId(this._entryURI);
    }
    /**
     * If the entry is a user, group or context there can be a name.
     * In general the name is accessed on the resource, but in certain
     * situations we do not have the resource yet(not loaded) but we still
     * have the name (from a search where the name is provided but not the resource),
     * in this case we can access this name here.
     *
     * @returns {String} a username, groupname or contextname of the entry
     */

  }, {
    key: "getName",
    value: function getName() {
      return this._name;
    }
    /**
     * If the entry is a user there can be a disabled state.
     * In general the disabled state is accessed on the resource, but in certain
     * situations we do not have the resource yet(not loaded) but we still
     * have the disabled state (from a search where the disabled state is provided
     * but not the resource), in this case we can access the disabled state here.
     *
     * @returns {boolean} a disabled state of a user
     */

  }, {
    key: "isDisabled",
    value: function isDisabled() {
      return this._disabled;
    }
    /**
     * @returns {String}
     */

  }, {
    key: "getMetadataURI",
    value: function getMetadataURI() {
      return _factory.default.getMetadataURIFromURI(this._entryStore, this._entryURI);
    }
    /**
     * @returns {String}
     */

  }, {
    key: "getExternalMetadataURI",
    value: function getExternalMetadataURI() {
      // TODO will only exist for LinkReferences and References.
      return this._graph.findFirstValue(this._entryURI, _terms.default.externalMetadata);
    }
    /**
     * @param {String} uri
     */

  }, {
    key: "setExternalMetadataURI",
    value: function setExternalMetadataURI(uri) {
      this._graph.findAndRemove(this._entryURI, _terms.default.externalMetadata);

      this._graph.create(this._entryURI, _terms.default.externalMetadata, {
        type: 'uri',
        value: uri
      });
    }
    /**
     * @returns {String}
     */

  }, {
    key: "getCachedExternalMetadataURI",
    value: function getCachedExternalMetadataURI() {
      return _factory.default.getCachedExternalMetadataURI(this._entryURI);
    }
    /**
     * @returns {String}
     */

  }, {
    key: "getResourceURI",
    value: function getResourceURI() {
      return this._graph.findFirstValue(this._entryURI, _terms.default.resource);
    }
    /**
     * @param {String} uri
     */

  }, {
    key: "setResourceURI",
    value: function setResourceURI(uri) {
      var oldResourceURI = this.getResourceURI();

      this._graph.findAndRemove(this._entryURI, _terms.default.resource);

      this._graph.create(this._entryURI, _terms.default.resource, {
        type: 'uri',
        value: uri
      });

      if (oldResourceURI) {
        var stmts = this._graph.find(oldResourceURI);

        for (var i = 0; i < stmts.length; i++) {
          stmts[i].setSubject(uri);
        }
      }
    }
    /**
     * @returns {String} one of the entryTypes
     * @see store/terms#entryType
     */

  }, {
    key: "getEntryType",
    value: function getEntryType() {
      var et = this._graph.findFirstValue(this._entryURI, _terms.default.rdf.type);

      return _terms.default.entryType[et || 'default'];
    }
  }, {
    key: "getResourceType",

    /**
     * the resource type of the entry, e.g. "Information", "Resolvable" etc.
     * The allowed values are available in store/types beginning with 'RT_'.
     * E.g. to check if the entry is an information resource:
     * if (ei.getResourceType() === types.RT_INFORMATIONRESOURCE) {...}
     *
     * @returns {String}
     */
    value: function getResourceType() {
      return this.constructor.getResourceTypeHelper(this, _terms.default.resourceType);
    }
    /**
     * the graph type of the entry, e.g. "User", "List", "String", etc.
     * The allowed values are available in store/types beginning with 'GT_'.
     * E.g. to check if the entry is a list:
     * if (ei.getGraphType() === types.GT_LIST) {...}
     *
     * @returns {String}
     */

  }, {
    key: "getGraphType",
    value: function getGraphType() {
      return this.constructor.getResourceTypeHelper(this, _terms.default.graphType);
    } // TODO: change to entryURI instead of resourceURI for principalURIs.

    /**
     * The acl object returned looks like:
     * {
     *   admin:  [principalURI1, principalURI2, ...],
     *   rread:  [principalURI3, ...],
     *   rwrite: [principalURI4, ...],
     *   mread:  [principalURI5, ...],
     *   mwrite: [principalURI6, ...]
     * }
     *
     * There will always be an array for each key, it might be empty though.
     * The principalURI* will always be an URI to the resource of a user or group entry.
     *
     * Please note that a non empty acl overrides any defaults from the surrounding context.
     *
     * @param {boolean} asIds - if true the principalURIs are shortened to entry identifiers.
     * @return {Object} an acl object.
     */

  }, {
    key: "getACL",
    value: function getACL() {
      var asIds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      var f = function f(stmt) {
        if (asIds) {
          return _factory.default.getEntryId(stmt.getValue());
        }

        return stmt.getValue();
      }; // Statement > object value.


      var ru = this.getResourceURI();
      var mu = this.getMetadataURI();
      var acl = {
        admin: this._graph.find(this._entryURI, _terms.default.acl.write).map(f),
        rread: this._graph.find(ru, _terms.default.acl.read).map(f),
        rwrite: this._graph.find(ru, _terms.default.acl.write).map(f),
        mread: this._graph.find(mu, _terms.default.acl.read).map(f),
        mwrite: this._graph.find(mu, _terms.default.acl.write).map(f)
      };
      acl.contextOverride = acl.admin.length !== 0 || acl.rread.length !== 0 || acl.rwrite.length !== 0 || acl.mread.length !== 0 || acl.mwrite.length !== 0;
      return acl;
    }
    /**
     * if the entry has an explicit ACL or if the containing contexts ACL is used.
     *
     * @returns {boolean}
     */

  }, {
    key: "hasACL",
    value: function hasACL() {
      return this.getACL().contextOverride;
    }
    /**
     * Replaces the current acl with the provided acl.
     * The acl object is the same as you get from the getACL call.
     * The first difference is that the acl object from this method is allowed to be empty
     * or leave out some keys that are not to be set.
     * The second difference is that it allows entryIds as values in the arrays,
     * not only full resource URIs, both have to refer to principals though.
     *
     * @param {Object} acl same kind of object you get from getACL.
     */

  }, {
    key: "setACL",
    value: function setACL(acl) {
      var g = this._graph;

      var f = function f(subj, pred, principals, base) {
        g.findAndRemove(subj, pred);
        (principals || []).forEach(function (principal) {
          if (principal.length < base.length || principal.indexOf(base) !== 0) {
            // principal is entry id.
            g.add(subj, pred, {
              type: 'uri',
              value: base + principal
            });
          } else {
            // principal is a full entry resource uri.
            g.add(subj, pred, {
              type: 'uri',
              value: principal
            });
          }
        });
      };

      var _acl = acl || {};

      var ru = this.getResourceURI();
      var mu = this.getMetadataURI();

      var base = _factory.default.getResourceBase(this._entry.getEntryStore(), '_principals');

      f(this._entryURI, _terms.default.acl.write, _acl.admin, base);
      f(ru, _terms.default.acl.read, _acl.rread, base);
      f(ru, _terms.default.acl.write, _acl.rwrite, base);
      f(mu, _terms.default.acl.read, _acl.mread, base);
      f(mu, _terms.default.acl.write, _acl.mwrite, base);
    }
    /**
     * Checks if there are any metadata revisions for this entry,
     * in practise this is always true if provenance is enabled for this entry.
     *
     * @return {boolean} true if there is at least one metadata revision.
     */

  }, {
    key: "hasMetadataRevisions",
    value: function hasMetadataRevisions() {
      // const mdURI = this.getMetadataURI();
      return this._graph.findFirstValue(null, 'owl:sameAs') != null;
    }
    /**
     * Extracts an array of metadata revisions from the graph.
     * Each revision is an object that contains:
     *   * time - when the change was made (Date)
     *   * by   - the user who performed the change (entryURI)
     *   * rev  - the revision number (string)
     *   * uri  - an URI to this revision (string)
     *
     * The uri of the revision can be used by the method getMetadataRevisionGraph
     * to get a hold of the actual new graph that caused the revision.
     *
     * @return {{time: Date, by: string, rev: string, uri: string}[]} a sorted array of revisions, latest revision first.
     */

  }, {
    key: "getMetadataRevisions",
    value: function getMetadataRevisions() {
      var revs = [];
      var mdURI = this.getMetadataURI();

      var stmts = this._graph.find(null, 'owl:sameAs', mdURI);

      if (stmts.length !== 1) {
        return revs;
      }

      var uri = stmts[0].getSubject();
      var es = this._entryStore;

      while (uri) {
        revs.push({
          uri: uri,
          rev: uri.substr(mdURI.length + 5),
          time: (0, _moment.default)(this._graph.findFirstValue(uri, 'prov:generatedAtTime')).toDate(),
          by: es.getEntryURIFromURI(this._graph.findFirstValue(uri, 'prov:wasAttributedTo'))
        });
        uri = this._graph.findFirstValue(uri, 'prov:wasRevisionOf');
      }

      revs.sort(function (r1, r2) {
        if (r1.time > r2.time) {
          return -1;
        } else if (r1.time < r2.time) {
          return 1;
        }

        return 0;
      });
      return revs;
    }
    /**
     * Retrieves the metadata graph of a certain revision from its graph.
     * @param revisionURI
     * @return {Promise.<rdfjson/Graph>}
     */

  }, {
    key: "getMetadataRevisionGraph",
    value: function () {
      var _getMetadataRevisionGraph = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(revisionURI) {
        var data;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                data = this._entryStore.getREST().get(revisionURI);
                return _context.abrupt("return", new _rdfjson.Graph(data));

              case 2:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function getMetadataRevisionGraph(_x) {
        return _getMetadataRevisionGraph.apply(this, arguments);
      }

      return getMetadataRevisionGraph;
    }()
    /**
     * @returns {string} the label of the resource of this entry,
     * typically set when uploading a file.
     */

  }, {
    key: "getLabel",
    value: function getLabel() {
      return this._graph.findFirstValue(this.getResourceURI(), 'http://www.w3.org/2000/01/rdf-schema#label');
    }
    /**
     * Sets a new label of the resource in the graph, call
     * {@link store/EntryInfo#commit commit} to push
     * the updated graph to the repository.
     *
     * @param {string} label - a new label for the resource.
     */

  }, {
    key: "setLabel",
    value: function setLabel(label) {
      this._graph.findAndRemove(this.getResourceURI(), 'http://www.w3.org/2000/01/rdf-schema#label');

      if (label != null && label !== '') {
        this._graph.add(this.getResourceURI(), 'http://www.w3.org/2000/01/rdf-schema#label', {
          type: 'literal',
          value: label
        });
      }
    }
    /**
     * @returns {string} the format of the resource of this entry.
     */

  }, {
    key: "getFormat",
    value: function getFormat() {
      return this._graph.findFirstValue(this.getResourceURI(), 'http://purl.org/dc/terms/format');
    }
    /**
     * Sets a new format of the resource in the graph, call {@link store/EntryInfo#commit commit}
     * to push the updated graph to the repository.
     *
     * @param {string} format - a format in the form application/json or text/plain.
     */

  }, {
    key: "setFormat",
    value: function setFormat(format) {
      this._graph.findAndRemove(this.getResourceURI(), 'http://purl.org/dc/terms/format');

      if (format != null && format !== '') {
        this._graph.addL(this.getResourceURI(), 'http://purl.org/dc/terms/format', format);
      }
    }
    /**
     * @returns {string} the status of this entry, always a URI.
     */

  }, {
    key: "getStatus",
    value: function getStatus() {
      return this._graph.findFirstValue(this.getEntryURI(), _terms.default.status.property);
    }
    /**
     * Sets a new status for this entry
     *
     * @param {string} status
     */

  }, {
    key: "setStatus",
    value: function setStatus(status) {
      this._graph.findAndRemove(this.getEntryURI(), _terms.default.status.property);

      if (status != null && status !== '' && status.indexOf('http') === 0) {
        this._graph.add(this.getEntryURI(), _terms.default.status.property, status);
      }
    }
    /**
     * @returns {Date} the date when the entry was created.
     */

  }, {
    key: "getCreationDate",
    value: function getCreationDate() {
      var d = this._graph.findFirstValue(this.getEntryURI(), 'http://purl.org/dc/terms/created');

      return (0, _moment.default)(d).toDate(); // Must always exist.
    }
    /**
     * @returns {Date} the date of last modification (according to the repository,
     * local changes are not reflected).
     */

  }, {
    key: "getModificationDate",
    value: function getModificationDate() {
      var d = this._graph.findFirstValue(this.getEntryURI(), 'http://purl.org/dc/terms/modified');

      if (d != null) {
        return (0, _moment.default)(d).toDate();
      }

      return this.getCreationDate();
    }
    /**
     * @returns {String} a URI to creator, the user Entry resource URI is used, e.g. "http://somerepo/store/_principals/resource/4", never null.
     */

  }, {
    key: "getCreator",
    value: function getCreator() {
      return this._graph.findFirstValue(this.getEntryURI(), 'http://purl.org/dc/terms/creator');
    }
    /**
     * @returns {number|undefined}
     */

  }, {
    key: "getSize",
    value: function getSize() {
      var extent = this._graph.findFirstValue(this.getResourceURI(), 'http://purl.org/dc/terms/extent');

      if (parseInt(extent, 10) === parseInt(extent, 10)) {
        return parseInt(extent, 10);
      }

      return undefined;
    }
    /**
     * @returns {Array} an array of URIs to the contributors using their Entry resource URIs,
     * e.g. ["http://somerepo/store/_principals/resource/4"], never null although the array might be empty.
     */

  }, {
    key: "getContributors",
    value: function getContributors() {
      return this._graph.find(this.getEntryURI(), 'http://purl.org/dc/terms/contributor').map(function (stmt) {
        return stmt.getValue();
      });
    }
  }], [{
    key: "getResourceTypeHelper",
    value: function getResourceTypeHelper(entry, vocab) {
      var stmts = entry._graph.find(entry.getResourceURI(), _terms.default.rdf.type);

      for (var i = 0; i < stmts.length; i++) {
        var t = vocab[stmts[i].getValue()];

        if (t != null) {
          return t;
        }
      }

      return vocab.default;
    }
  }]);

  return EntryInfo;
}();

exports.default = EntryInfo;
;

/***/ }),

/***/ "./src/EntryStore.js":
/*!***************************!*\
  !*** ./src/EntryStore.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Auth = _interopRequireDefault(__webpack_require__(/*! ./Auth */ "./src/Auth.js"));

var _Cache = _interopRequireDefault(__webpack_require__(/*! ./Cache */ "./src/Cache.js"));

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

var _PrototypeEntry = _interopRequireDefault(__webpack_require__(/*! ./PrototypeEntry */ "./src/PrototypeEntry.js"));

var _Resource = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

var _Rest = _interopRequireDefault(__webpack_require__(/*! ./Rest */ "./src/Rest.js"));

var _SolrQuery = _interopRequireDefault(__webpack_require__(/*! ./SolrQuery */ "./src/SolrQuery.js"));

var _types = _interopRequireDefault(__webpack_require__(/*! ./types */ "./src/types.js"));

var _User = _interopRequireDefault(__webpack_require__(/*! ./User */ "./src/User.js"));

var _utils = __webpack_require__(/*! ./utils */ "./src/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var he = __webpack_require__(/*! he */ "./node_modules/he/he.js"); // TODO @scazan: Remove when echoFile is changed by @Hannes

/**
 * EntryStore is the main class that is used to connect to a running server-side EntryStore
 * repository.
 * @exports store/EntryStore
 */


var EntryStore =
/*#__PURE__*/
function () {
  /**
   * @param {String=} baseURI - URL to the EntryStore repository we should communicate with,
   * may be left out and
   * guessed if run in a browser environment (appends "/store/" to the window.location.origin)
   * @param {Object=} credentials - same as provided in the {@link store/EntryStore#auth auth}
   * method.
   */
  function EntryStore(baseURI, credentials) {
    _classCallCheck(this, EntryStore);

    if ((0, _utils.isBrowser)() && baseURI == null) {
      this._baseURI = "".concat(window.location.origin, "/store/");
    } else {
      this._baseURI = baseURI;

      if (this._baseURI[this._baseURI.length - 1] !== '/') {
        this._baseURI = "".concat(this._baseURI, "/");
      }
    }

    this._cache = new _Cache.default();
    this._auth = new _Auth.default(this);

    if (credentials) {
      this.auth(credentials);
    }

    this._contexts = {};
    this._rest = new _Rest.default();
  }
  /**
   * Provides a listener that will be called for every asynchronous call being made.
   * The handler is invoked with the promise from the asynchronous call
   * and a callType parameter indicating which asynchronous call that has been made.
   *
   * The callType parameter can take the following values:
   * - getEntry        - an entry is retrieved (EntryStore.getEntry)
   * - createEntry     - an entry is created   (EntryStore.createEntry)
   * - createGroupAndContext - a group and context pair is created
   * (EntryStore.createGroupAndContext)
   * - loadViaProxy    - data is requested via repository proxy (EntryStore.loadViaProxy)
   * - commitMetadata  - changes to metadata is pushed (Entry.commitMetadata)
   * - commitCachedExternalMetadata - changes to cached external metadata is pushed
   * (Entry.commitCachedExternalMetadata)
   * - getResource     - the entry's resource has been requested (Entry.getResource)
   * - getLinkedEntry  - a linked entry is requested (Entry.getLinkedEntry)
   * - delEntry        - an entry is deleted (Entry.del)
   * - refresh         - an entry is refreshed (Entry.refresh)
   * - setContextName  - the name of a context is changed (Context.setName)
   * - getUserInfo     - the user information is requested (auth.getUserInfo)
   * - getUserEntry    - the user entry is requested (auth.getUserEntry)
   * - login           - logging in (auth.login)
   * - logout          - logging out (auth.logout)
   * - commitEntryInfo - pushing changes in entry information (EntryInfo.commit)
   * - getFile         - the contents of a file resource is requested (File.get*)
   * - putFile         - the contents of a file is pushed (File.put*)
   * - commitGraph     - a graph resource is pushed (Graph.commit)
   * - commitString    - a string resource is pushed (String.commit)
   * - setGroupName    - a new name of a group is pushed (Group.setName)
   * - setUserName     - a new name of a user is pushed (User.setName)
   * - setUserDisabled - a new disabled state of a user is pushed (User.setDisabled)
   * - setUserLanguage - a new preferred language of the user is pushed (User.setLanguage)
   * - setUserPassword - a new password for the user is pushed (User.setPassword)
   * - setUserHomeContext - a new home context for the user is pushed (User.setHomeContext)
   * - setUserCustomProperties - new custom properties for the user (User.setCustomProperties)
   * - loadListEntries - members of a list are requested (List.getEntries)
   * - setList         - the list members are changed via a list
   * - addToList       - See List.addEntry
   * - removeFromList  - See List.removeEntry
   * .removeEntry)
   * - search          - a search is being performed (SearchList.getEntries)
   * - execute         - a pipeline is executed (Pipeline.execute)
   *
   * @param {Promise.<string>} listener
   */


  _createClass(EntryStore, [{
    key: "addAsyncListener",
    value: function addAsyncListener(listener) {
      if (this.asyncListeners) {
        this.asyncListeners.push(listener);
      } else {
        this.asyncListeners = [listener];
      }
    }
    /**
     * Removes a previously added listener for asynchronous calls.
     * @param {string} listener
     */

  }, {
    key: "removeAsyncListener",
    value: function removeAsyncListener(listener) {
      if (this.asyncListeners) {
        this.asyncListeners.splice(this.asyncListeners.indexOf(listener), 1);
      }
    }
    /**
     *
     * @param {Promise} promise
     * @param {string} context
     * @return {Promise}
     */

  }, {
    key: "handleAsync",
    value: function handleAsync(promise, context) {
      if (this.asyncListeners) {
        for (var i = 0; i < this.asyncListeners.length; i++) {
          this.asyncListeners[i](promise, context);
        }
      }

      return promise;
    }
    /**
     * @returns {store/Auth} where functionality related to authorization are located,
     * including a listener infrastructure.
     */

  }, {
    key: "getAuth",
    value: function getAuth() {
      return this._auth;
    }
    /**
     * Yields information about who currently is authenticated against the EntryStore repository.
     * @returns {Promise.<store/EntryInfo>} - upon success an object containing attributes "user" being
     * the username, "id" of the user entry, and "homecontext" being the entry-id of the
     * home context is provided.
     * @see {@link store/EntryStore#auth auth}
     * @see {@link store/EntryStore#logout logout}
     * @deprecated use corresponding method on auth object instead.
     */

  }, {
    key: "getUserInfo",
    value: function getUserInfo() {
      return this._auth.getUserInfo();
    }
    /**
     * @returns {Promise.<store/Entry>} on success the entry for the currently signed in user is provided.
     * @deprecated use corresponding method on auth object instead.
     */

  }, {
    key: "getUserEntry",
    value: function getUserEntry() {
      return this._auth.getUserEntry();
    }
    /**
     * Authenticate using credentials containing a user, a password and an optional maxAge given
     * in seconds.
     *
     * @param {{user, password, maxAge}} credentials as a parameter object
     * @deprecated use corresponding method on auth object instead.
     */

  }, {
    key: "auth",
    value: function auth(credentials) {
      if (credentials == null) {
        return this._auth.logout();
      }

      return this._auth.login(credentials.user, credentials.password, credentials.maxAge);
    }
    /**
     * Logout the currently authorized user.
     * @returns {Promise}
     * @deprecated use corresponding method on auth object instead.
     */

  }, {
    key: "logout",
    value: function logout() {
      return this._auth.logout();
    }
    /**
     * Fetches an entry given an entryURI. If the entry is already loaded and available in the
     * cache it will be returned directly, otherwise it will be loaded from the repository.
     * If the entry is already loaded but marked as in need of a refresh it will be refreshed
     * first.
     *
     * The optional load parameters are provided in a single parameter object with six possible
     * attributes. Below we outline these attributes, the first two (forceLoad and direct) applies
     * to all kind of entries while the following three (limit, offset and sort) only applies if
     * the entry is a list:
     *
     * forceLoad - ignores if the entry is already in cache and fetches from the repository
     * loadResource - makes sure that entry.getResource(true) will not return null
     *     (does not work in combination with direct).
     * direct - returns the entry from the cache directly rather than returning a promise,
     *    if the entry is not in the cache an undefined value will be returned.
     * limit - only a limited number of children are loaded, -1 means no limit, 0, undefined
     *    or if the attribute is not provided means that the default limit of 20 is used.
     * offset - only children from offest and forward is returned, must be positive.
     * sort - information on how to sort the children:
     *     * if sort is not provided at all or an empty object is provided the members of the
     *       list will not be sorted, instead the list's natural order will be used
     *     * if sort is given as null the defaults will be used ({sortBy: "title", prio: "List"}).
     *     * if sort is given as a non emtpy object the following attributes are considered:
     *       ** sortBy - the attribute instructs which metadata field to sort the children by,
     *          i.e., title, created, modified, or size.
     *       ** lang - if sort is title and the title is provided in several languages a
     *          prioritized language can be given.
     *       ** prio - allows specific graphtypes to be prioritized
     *          (e.g. show up in the top of the list).
     *       ** descending - if true the children are shown in descending order.
     *
     *
     * **Note** - in the case where the entry is a list it is possible to change the limit,
     * offset and sort later by calling the corresponding methods on the {@link store/List}
     * resource, e.g. {@link store/List#setSort}. However, setting the values already in this
     * method call has as a consequence that one less request to the repository is made as you
     * will get members (in the right amount and order) in the same request as you get metadata
     * and other information.
     *
     * A request of a list entry can look like:
     *
     *     var euri = entrystore.getEntryURI("1", "1");
     *     entrystore.getEntry(euri, {
     *          forceLoad: true,
     *          limit: 10,
     *          offset: 20,
     *          sort: {
     *             sortBy: "modified",
     *             prio: types.GT_LIST
     *          }
     *      });
     *
     * The optional params here says that we force a load from the repository, that we want the
     * results to be paginated with a limit of 10 entries per page and that we want page 3.
     * We also indicate that we want the list to be sorted by latest modification date and that
     * if there are member entries that are lists they should be sorted to the top.
     *
     * @param {string} entryURI - the entryURI for the entry to retrieve.
     * @param {{forceLoad, direct, loadResource, limit, offset, sort, asyncContext}} optionalLoadParams - parameters for how to load an entry.
     * @return {Promise.<store/Entry> | store/Entry | undefined} - by default a promise is returned,
     * if the direct parameter is specified the entry is returned directly or undefined if the
     * entry is not in cache.
     * @see {@link store/EntryStore#getEntryURI getEntryURI} for help to construct entry URIs.
     * @see {@link store/Context#getEntryById} for loading entries relative to a context.
     */

  }, {
    key: "getEntry",
    value: function getEntry(entryURI) {
      var optionalLoadParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var forceLoad = optionalLoadParams ? optionalLoadParams.forceLoad === true : false;

      var e = this._cache.get(entryURI);

      var asyncContext = 'getEntry';

      if (optionalLoadParams != null) {
        if (optionalLoadParams.asyncContext) {
          asyncContext = optionalLoadParams.asyncContext;
        }

        if (optionalLoadParams.direct === true) {
          return e;
        }
      }

      var checkResourceLoaded = function checkResourceLoaded(entry) {
        if (optionalLoadParams != null && optionalLoadParams.loadResource && entry.getResource() == null) {
          return entry.getResource().then(function () {
            return entry;
          });
        }

        return entry;
      };

      if (e && !forceLoad) {
        if ((e.isList() || e.isGroup()) && optionalLoadParams != null) {
          var list = e.getResource(true); // Direct access works for lists and groups.

          list.setLimit(optionalLoadParams.limit);
          list.setSort(optionalLoadParams.sort);
        } // Will only refresh if needed, a promise is returned in any case


        return this.handleAsync(e.refresh().then(checkResourceLoaded), asyncContext);
      }

      var self = this;

      var entryLoadURI = _factory.default.getEntryLoadURI(entryURI, optionalLoadParams);

      return this.handleAsync(this._rest.get(entryLoadURI).then(function (data) {
        // The entry, will always be there.
        var entry = _factory.default.updateOrCreate(entryURI, data, self);

        return checkResourceLoaded(entry);
      }, function (err) {
        throw new Error("Failed fetching entry. ".concat(err));
      }), asyncContext);
    }
    /**
     * Retrieves entries from a list. One way to see it is that this is a convenience method
     * that retrieves a list entry, its member entries and returns those in an array.
     *
     * @param {string} entryURI - URI of the list entry to load entries from.
     * @param {Object} sort - same sort object as provided in the optionalLoadParams to
     * {@see store/EntryStore#getEntry getEntry} method.
     * @param {Object} limit - same limit as provided in the optionalLoadParams to
     * {@see store/EntryStore#getEntry getEntry} method.
     * @param {integer} page - unless limit is set to -1 (no pagination) we need to specify which
     * page to load, first page is 0.
     * @returns {Promise.<store/Entry[]>} upon success the promise returns an array of entries.
     */

  }, {
    key: "getListEntries",
    value: function getListEntries(entryURI, sort, limit, page) {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var op = {};

        if (sort != null) {
          op.sort = sort;
        }

        if (limit % 1 === 0) {
          op.limit = limit;
        }

        if (page % 1 === 0) {
          if (limit % 1 === 0) {
            op.offset = limit * page;
          } else {
            op.offset = _factory.default.getDefaultLimit() * page;
          }
        }

        _this.getEntryStore().getEntry(entryURI, op).then(function (entry) {
          var list = entry.getResource(true);
          list.getEntries(page).then(resolve, reject);
        }, reject);
      });
    }
    /**
     * Retrieves a Context instance via its id. Note that this method returns directly without
     * checking with the EntryStore repository that the context exists. Hence successive
     * operations via this context instance may fail if the context does not exist in the
     * EntryStore
     * repository.
     *
     * Note that in EntryStore everything is connected to entries. Hence a context is nothing else
     * than a special kind of resource maintained by an entry. This entry provides metadata about
     * the context as well as the default ownership and access control that applies to all entries
     * inside of this context.
     *
     * To get a hold of the contexts own entry use the {@link store/Resource#getEntry}
     * method on the context (inherited from the generic {@link store/Resource} class.
     *
     * Advanced: Entrys corresponding to contexts are stored in the special _contexts
     * context which, since it is a context, contains its own entry.
     *
     * @param {string} contextId - identifier for the context (not necessarily the same as the
     * alias/name for the context)
     * @return {store/Context}
     */

  }, {
    key: "getContextById",
    value: function getContextById(contextId) {
      return _factory.default.getContext(this, "".concat(this._baseURI, "_contexts/entry/").concat(contextId));
    }
    /**
     * Retrieves a Context instance via its entry's URI.
     *
     * @param {String} contextEntryURI - URI to the context's entry, e.g. base/_contexts/entry/1.
     * @returns {store/Context}
     * @see {@link store/EntryStore#getContextById getContextById}
     */

  }, {
    key: "getContext",
    value: function getContext(contextEntryURI) {
      return _factory.default.getContext(this, contextEntryURI);
    }
    /**
     * Retrieves a paginated list of all contexts in the EntryStore repository.
     * @return {store/List} - the list contains entries which have contexts as resources.
     */

  }, {
    key: "getContextList",
    value: function getContextList() {
      return this.newSolrQuery().graphType(_types.default.GT_CONTEXT).list();
    }
    /**
     * Retrieves a paginated list of all users and groups in the EntryStore repository
     * @return {store/List} the list contains entries that have principals as resources.
     * @todo May include folders and other entries as well...
     */

  }, {
    key: "getPrincipalList",
    value: function getPrincipalList() {
      return this.newSolrQuery().graphType([_types.default.GT_USER, _types.default.GT_GROUP]).list();
    }
    /**
     * Creates a new entry according to information in the provided {@link store/PrototypeEntry}.
     * The information specifies the type of entry, which context it should reside in,
     * initial metadata etc. This method is seldom called explicitly, instead it is called
     * indirectly via the {@link store/PrototypeEntry#commit} method. E.g.:
     *
     *     context.newEntry().commit().then(function(newlyCreatedEntry) {...}
     *
     * @param {store/PrototypeEntry} prototypeEntry - information about the entry to create.
     * @return {Promise}
     * @see store/PrototypeEntry#commit
     * @see store/EntryStore#newContext
     * @see store/EntryStore#newUser
     * @see store/EntryStore#newGroup
     * @see store/Context#newEntry
     * @see store/Context#newLink
     * @see store/Context#newLinkRef
     * @see store/Context#newRef
     * @see store/Context#newList
     * @see store/Context#newGraph
     * @see store/Context#newString
     */

  }, {
    key: "createEntry",
    value: function createEntry(prototypeEntry) {
      var _this2 = this;

      var postURI = _factory.default.getEntryCreateURI(prototypeEntry, prototypeEntry.getParentList());

      var postParams = _factory.default.getEntryCreatePostData(prototypeEntry);

      return this.handleAsync(this._rest.create(postURI, postParams).then(function (euri) {
        // var euri = factory.getURIFromCreated(data, prototypeEntry.getContext());
        var plist = prototypeEntry.getParentList();

        if (plist != null) {
          var res = plist.getResource(true);

          if (res != null && res.needRefresh) {
            plist.getResource(true).needRefresh();
          }
        }

        return _this2.getEntry(euri);
      }), 'createEntry');
    }
    /**
     * Provides a PrototypeEntry for creating a new context.
     * @param {string=} contextName - optional name for the context, can be changed later,
     * must be unique in the _principals context
     * @param {string=} id - optional requested identifier (entryId) for the context,
     * cannot be changed later, must be unique in the _principals context
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newContext",
    value: function newContext(contextName, id) {
      var _contexts = _factory.default.getContext(this, "".concat(this._baseURI, "_contexts/entry/_contexts"));

      var prototypeEntry = new _PrototypeEntry.default(_contexts, id).setGraphType(_types.default.GT_CONTEXT);

      if (contextName != null) {
        var ei = prototypeEntry.getEntryInfo();
        var resource = new _Resource.default(ei.getEntryURI(), ei.getResourceURI(), this);

        resource._update({
          name: contextName
        });

        prototypeEntry._resource = resource;
      }

      return prototypeEntry;
    }
    /**
     *
     * @param name
     * @return {Promise}
     */

  }, {
    key: "createGroupAndContext",
    value: function createGroupAndContext(name) {
      var _this3 = this;

      var uri = "".concat(this._baseURI, "_principals/groups");

      if (name != null) {
        uri += "?name=".concat(encodeURIComponent(name));
      }

      return this.handleAsync(this._rest.create(uri).then(function (location) {
        return _this3.getEntry(location);
      }), 'createGroupAndContext');
    }
    /**
     * Provides a PrototypeEntry for creating a new user.
     * @param {string=} username - the name the user will use to authenticate himself
     * @param {string=} password - the password the user will use to authenticate himself
     * @param {string=} homeContext - a specific context the user will consider his own home
     * @param {string=} id - requested identifier for the user
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newUser",
    value: function newUser(username, password, homeContext, id) {
      var _principals = _factory.default.getContext(this, "".concat(this._baseURI, "_contexts/entry/_principals"));

      var prototypeEntry = new _PrototypeEntry.default(_principals, id).setGraphType(_types.default.GT_USER);
      var entryInfo = prototypeEntry.getEntryInfo();
      var data = {};

      if (username != null) {
        data.name = username;
      }

      if (password != null) {
        data.password = password;
      }

      if (homeContext != null) {
        data.homecontext = homeContext;
      }

      prototypeEntry._resource = new _User.default(entryInfo.getEntryURI(), entryInfo.getResourceURI(), this, data);
      return prototypeEntry;
    }
    /**
     * @param {string=} groupName - optional name for the group, can be changed later,
     * must be unique in the _principals context
     * @param {string=} id - optional requested identifier (entryId) for the group,
     * cannot be changed later, must be unique in the _principals context
     * @returns {store/PrototypeEntry}
     */

  }, {
    key: "newGroup",
    value: function newGroup(groupName, id) {
      var _principals = _factory.default.getContext(this, "".concat(this._baseURI, "_contexts/entry/_principals"));

      var prototypeEntry = new _PrototypeEntry.default(_principals, id).setGraphType(_types.default.GT_GROUP);

      if (groupName != null) {
        var ei = prototypeEntry.getEntryInfo();
        var resource = new _Resource.default(ei.getEntryURI(), ei.getResourceURI(), this);

        resource._update({
          name: groupName
        });

        prototypeEntry._resource = resource;
      }

      return prototypeEntry;
    }
    /**
     * Move an entry from one list to another.
     *
     * @param {store/Entry} entry - entry to move
     * @param {store/Entry} fromList - source list where the entry is currently residing.
     * @param {store/Entry} toList - destination list where the entry is supposed to end up.
     * @returns {Promise}
     */

  }, {
    key: "moveEntry",
    value: function moveEntry(entry, fromList, toList) {
      var uri = _factory.default.getMoveURI(entry, fromList, toList, this._baseURI);

      return this.handleAsync(this.getREST().post(uri, ''), 'moveEntry');
    }
    /**
     * Loads data via the EntryStore repository's own proxy.
     *
     * @param {string} uri indicates the resource to load.
     * @param {string} formatHint indicates that you want data back in the format specified
     * (e.g. by specifiying a suitable accept header).
     * @returns {Promise}
     */

  }, {
    key: "loadViaProxy",
    value: function loadViaProxy(uri, formatHint) {
      var url = _factory.default.getProxyURI(this._baseURI, uri);

      return this.handleAsync(this.getREST().get(url, formatHint, true), 'loadViaProxy');
    }
    /**
     * Pushes a file to the server and gets the result back immediately.
     * Since browser environments cannot access the local filesystem, the only way to get the
     * contents of a file is to "upload" it and get the contents back from the server.
     * EntryStore provides the "echo" resource to provide this workaround.
     *
     * In a browser environment a file is represented via an input element which references
     * the file to be uploaded via its value attribute. E.g.:
     *
     *       <input type="file" name="uploadFile"/>
     *
     * During the uploading process the input tag will be moved temporarily in the DOM tree,
     * it will be restored to its original position afterwards (both upon success and failure).
     *
     * @param {node} data - input element corresponding to the file to upload (echo).
     * @returns {xhrPromise}
     */

  }, {
    key: "echoFile",
    value: function echoFile(data) {
      // noinspection AmdModulesDependencies
      if (!(data instanceof Node)) {
        throw new Error('Argument needs to be an input element.');
      }

      if (data.name == null || data.name === '') {
        throw new Error('Failure, cannot upload resource from input element unless a name' + ' attribute is provided.');
      } // TODO EntryStore should return the actual response without HTML wrapping


      return this.handleAsync(this.getREST().putFile("".concat(this.getBaseURI(), "echo"), data, 'text').then(function (rawData) {
        var response = rawData.text;

        if (response) {
          var idx = response.indexOf('\n'); // this checks if

          var status = parseInt(response.substr(0, idx).split(':')[1], 10);

          if (status !== 200) {
            var err = new Error("HTTP status code: ".concat(status));
            err.status = status;
            throw err;
          }

          var textAreaValue = response.substr(idx + 1).replace('</textarea>', ''); // TODO remove when EntryStore is fixed

          return he.decode(textAreaValue);
        }

        return response; // empty
      }), 'echoFile');
    }
    /**
     * Performing searches against an EntryStore repository is achieved by creating a
     * {@link store/SearchList} which is similar to a regular {@link store/List}.
     * From this list it is possible to get paginated results in form of matching entries.
     * For example:
     *
     *     var personType = "http://xmlns.com/foaf/0.1/Person";
     *     var searchList = entrystore.newSolrQuery().rdfType(personType).list();
     *     searchList.setLimit(20).getEntries().then(function(results) {...});
     *
     * @returns {store/SolrQuery}
     */

  }, {
    key: "newSolrQuery",
    value: function newSolrQuery() {
      return new _SolrQuery.default(this);
    }
    /**
     * @deprecated use {@link #newSolrQuery} instead.
     */

  }, {
    key: "createSearchList",
    value: function createSearchList(query) {
      return _factory.default.createSearchList(this, query);
    }
    /**
     * Constructs an metadata URI from the id for the context and the specific entry.
     * @param {string} contextId - an identifier for the context the entry belongs to
     * @param {string} entryId - an identifier for the entry
     * @returns {String} - an entry URI
     */

  }, {
    key: "getMetadataURI",
    value: function getMetadataURI(contextId, entryId) {
      return _factory.default.getMetadataURI(this, contextId, entryId);
    }
    /**
     * Constructs an entry URI from the id for the context and the specific entry.
     * @param {string} contextId - an identifier for the context the entry belongs to
     * @param {string} entryId - an identifier for the entry
     * @returns {String} - an entry URI
     */

  }, {
    key: "getEntryURI",
    value: function getEntryURI(contextId, entryId) {
      return _factory.default.getEntryURI(this, contextId, entryId);
    }
    /**
     * Constructs an entry URI from a normal repository URI, e.g. any URI from which is possible
     * to deduce a contextId and an entryId. Equivalent to calling:
     * es.getEntryURI(es.getContextId(uri), es.getEntryId(uri))
     *
     * @param {string} uri - a URI for the entry, can be a entryURI (obviously), resourceURI
     * (if local), metadataURI, or relationsURI.
     * @returns {String} - an entry URI
     */

  }, {
    key: "getEntryURIFromURI",
    value: function getEntryURIFromURI(uri) {
      return _factory.default.getEntryURIFromURI(this, uri);
    }
    /**
     * Constructs an entry resource URI (local URI, not a link obviously) from the id for the
     * context and the specific entry.
     *
     * @param {string} contextId - an identifier for the context the resource belongs to
     * @param {string} entryId - an identifier for the entry the resource belongs to
     * @returns {String} a resource URI
     */

  }, {
    key: "getResourceURI",
    value: function getResourceURI(contextId, entryId) {
      return _factory.default.getResourceURI(this, contextId, entryId);
    }
    /**
     * The base URI of the EntryStore repository we have connected to.
     *
     * @returns {String}
     */

  }, {
    key: "getBaseURI",
    value: function getBaseURI() {
      return this._baseURI;
    }
    /**
     * The entry id of this entry, resource or metadata uri.
     *
     * @param {string} uri
     * @returns {string}
     */

  }, {
    key: "getEntryId",
    value: function getEntryId(uri) {
      return _factory.default.getEntryId(uri, this.getBaseURI());
    }
    /**
     * The context id of this entry, resource or metadata uri.
     *
     * @param {string} uri
     * @returns {string}
     */

  }, {
    key: "getContextId",
    value: function getContextId(uri) {
      return _factory.default.getContextId(uri, this.getBaseURI());
    }
    /**
     *  To get status resource
     *
     * @returns {Promise}
     */

  }, {
    key: "getStatus",
    value: function getStatus() {
      var uri = "".concat(this._baseURI, "management/status?extended");
      return this.handleAsync(this.getREST().get(uri));
    }
    /**
     * The cache where all entries are cached after loading.
     *
     * @returns {store/Cache}
     */

  }, {
    key: "getCache",
    value: function getCache() {
      return this._cache;
    }
    /**
     * The loading mechanism are performed via REST calls, this REST module can be
     * used for doing manual lookups outside of the scope of this API.
     *
     * @returns {store/Rest}
     */

  }, {
    key: "getREST",
    value: function getREST() {
      return this._rest;
    } //= =============Non-public methods==============

    /**
     * @returns {Object}
     */

  }, {
    key: "getCachedContextsIdx",
    value: function getCachedContextsIdx() {
      return this._contexts;
    }
    /**
     * Provides information about version of EntryStore repository, the javascript API,
     * status of services etc.
     * @todo Needs support from EntryStore REST API
     * @todo Document promise
     */

  }], [{
    key: "info",
    value: function info() {
      var packageJSON = __webpack_require__(/*! ../package.json */ "./package.json");

      return {
        version: packageJSON.version
      };
    }
  }]);

  return EntryStore;
}();

exports.default = EntryStore;
;

/***/ }),

/***/ "./src/EntryStoreUtil.js":
/*!*******************************!*\
  !*** ./src/EntryStoreUtil.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * EntryStoreUtil provides utility functionality for working with entries.
 * @exports store/EntryStoreUtil
 */
var EntryStoreUtil =
/*#__PURE__*/
function () {
  /**
   * @param {store/EntryStore} entrystore
   */
  function EntryStoreUtil(entrystore) {
    _classCallCheck(this, EntryStoreUtil);

    this._entrystore = entrystore;
    this._preloadIdx = new Map();
  }
  /**
   * @returns {store/EntryStore}
   */


  _createClass(EntryStoreUtil, [{
    key: "getEntryStore",
    value: function getEntryStore() {
      return this._entrystore;
    }
    /**
     * Preload entries of a specific type.
     * Not strictly needed, used for optimization reasons.
     * Up to a maximum of 100 entries are preloaded.
     *
     * @param {string} ofType
     * @param {store/Context} context if provided limits the preload to a specific context.
     * @returns {store/Entry}
     */

  }, {
    key: "preloadEntries",
    value: function preloadEntries(ofType, context) {
      var preloadForType = this._preloadIdx.get(ofType);

      var promise;

      if (preloadForType) {
        if (context) {
          promise = preloadForType[context.getEntryURI()];

          if (promise) {
            return promise;
          }
        } else if (preloadForType.noContext) {
          return preloadForType.noContext;
        }
      } else {
        preloadForType = {};

        this._preloadIdx.set(ofType, preloadForType);
      }

      var searchObj = this._entrystore.newSolrQuery().resourceType(ofType).limit(100);

      if (context) {
        searchObj.context(context);
      }

      var list = searchObj.list();
      promise = list.getEntries(0);

      if (context) {
        preloadForType[context.getEntryURI()] = promise;
      } else {
        preloadForType.noContext = promise;
      }

      return promise;
    }
  }, {
    key: "clearPreloadEntriesDuplicateCheck",
    value: function clearPreloadEntriesDuplicateCheck(ofType, inContext) {
      if (ofType) {
        var preloadForType = this._preloadIdx.get(ofType);

        if (preloadForType && inContext) {
          delete preloadForType[inContext.getEntryURI()];
        } else {
          this._preloadIdx.delete(ofType);
        }
      } else {
        this._preloadIdx = new Map();
      }
    }
    /**
     * Retrieves an entry for a resource URI, note that if there are several entries that all
     * have the same resource URI it is unclear which of these entries that are returned.
     * Hence, only use this function if you expect there to be a single entry per resource URI.
     *
     * @param {string} resourceURI is the URI for the resource.
     * @param {store/Context=} context only look for entries in this context, may be left out.
     * @param {string} asyncCallType the callType used when making the search.
     * @returns {Promise.<store/Entry>}
     * @async
     * @throws
     */

  }, {
    key: "getEntryByResourceURI",
    value: function () {
      var _getEntryByResourceURI = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(resourceURI, context, asyncCallType) {
        var cache, entriesSet, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, entry, query, entryArr;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                cache = this._entrystore.getCache();
                entriesSet = cache.getByResourceURI(resourceURI);

                if (!context) {
                  _context.next = 29;
                  break;
                }

                _iteratorNormalCompletion = true;
                _didIteratorError = false;
                _iteratorError = undefined;
                _context.prev = 6;
                _iterator = entriesSet[Symbol.iterator]();

              case 8:
                if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
                  _context.next = 15;
                  break;
                }

                entry = _step.value;

                if (!(entry.getContext().getId() === context.getId())) {
                  _context.next = 12;
                  break;
                }

                return _context.abrupt("return", Promise.resolve(entry));

              case 12:
                _iteratorNormalCompletion = true;
                _context.next = 8;
                break;

              case 15:
                _context.next = 21;
                break;

              case 17:
                _context.prev = 17;
                _context.t0 = _context["catch"](6);
                _didIteratorError = true;
                _iteratorError = _context.t0;

              case 21:
                _context.prev = 21;
                _context.prev = 22;

                if (!_iteratorNormalCompletion && _iterator.return != null) {
                  _iterator.return();
                }

              case 24:
                _context.prev = 24;

                if (!_didIteratorError) {
                  _context.next = 27;
                  break;
                }

                throw _iteratorError;

              case 27:
                return _context.finish(24);

              case 28:
                return _context.finish(21);

              case 29:
                query = this._entrystore.newSolrQuery().resource(resourceURI).limit(1);

                if (context) {
                  query.context(context);
                }

                _context.next = 33;
                return query.list(asyncCallType).getEntries(0);

              case 33:
                entryArr = _context.sent;

                if (!(entryArr.length > 0)) {
                  _context.next = 36;
                  break;
                }

                return _context.abrupt("return", entryArr[0]);

              case 36:
                throw new Error("No entries for resource with URI: ".concat(resourceURI));

              case 37:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 17, 21, 29], [22,, 24, 28]]);
      }));

      function getEntryByResourceURI(_x, _x2, _x3) {
        return _getEntryByResourceURI.apply(this, arguments);
      }

      return getEntryByResourceURI;
    }()
    /**
     * @param {string} resourceURI is the URI for the resource.
     * @returns {store/Entry}
     */

  }, {
    key: "getEntryListByResourceURI",
    value: function getEntryListByResourceURI(resourceURI) {
      return this._entrystore.newSolrQuery().resource(resourceURI).list();
    }
    /**
     * Attempting to find a unique entry for a specific type,
     * if multiple entries exists with the same type the returned promise fails.
     * You may restrict to a specific context.
     *
     * @param {string} typeURI is the rdf:type URI for the entry to match.
     * @param {store/Context} context restrict to finding the entry in this context
     * @param {string} asyncCallType the callType used when making the search.
     * @returns {Promise.<store/Entry>}
     * @async
     * @throws
     */

  }, {
    key: "getEntryByType",
    value: function () {
      var _getEntryByType = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(typeURI, context, asyncCallType) {
        var query, entryArr;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                query = this._entrystore.newSolrQuery().rdfType(typeURI).limit(2);

                if (context) {
                  query.context(context);
                }

                _context2.next = 4;
                return query.list(asyncCallType).getEntries(0);

              case 4:
                entryArr = _context2.sent;

                if (!(entryArr.length === 1)) {
                  _context2.next = 7;
                  break;
                }

                return _context2.abrupt("return", entryArr[0]);

              case 7:
                throw new Error('Wrong number of entries in context / repository');

              case 8:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function getEntryByType(_x4, _x5, _x6) {
        return _getEntryByType.apply(this, arguments);
      }

      return getEntryByType;
    }()
    /**
     * Attempting to find one entry for a specific graph type,
     * if multiple entries exists with the same type the returned promise fails.
     * You may restrict to a specific context.
     *
     * @param {string} graphType is the graph type for the entry to match, e.g. use
     * {@see store/types#GT_USER}.
     * @param {store/Context} context restrict to finding the entry in this context
     * @param {string} asyncCallType the callType used when making the search.
     * @returns {Promise.<store/Entry>}
     * @async
     * @throws
     */

  }, {
    key: "getEntryByGraphType",
    value: function () {
      var _getEntryByGraphType = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(graphType, context, asyncCallType) {
        var query, entryArr;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                query = this._entrystore.newSolrQuery().graphType(graphType).limit(2);

                if (context) {
                  query.context(context);
                }

                _context3.next = 4;
                return query.list(asyncCallType).getEntries(0);

              case 4:
                entryArr = _context3.sent;

                if (!(entryArr.length > 0)) {
                  _context3.next = 7;
                  break;
                }

                return _context3.abrupt("return", entryArr[0]);

              case 7:
                throw new Error("No entries in ".concat(context ? 'context' : 'repository', " context with graphType ").concat(graphType));

              case 8:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function getEntryByGraphType(_x7, _x8, _x9) {
        return _getEntryByGraphType.apply(this, arguments);
      }

      return getEntryByGraphType;
    }()
    /**
     * Removes all entries matched by a search in a serial manner,
     * also empties the cache from loaded entries so it should not overflow
     * if the searchlist is big.
     *
     * The removal is accomplished by first iterating through the searchlist and collecting
     * uris to all entries that should be removed. After that the entries are removed.
     *
     * @param {store/SearchList} list
     * @returns {Promise}
     */

  }, {
    key: "removeAll",
    value: function () {
      var _removeAll = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee5(list) {
        var uris, es, cache, rest, deleteNext, result;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                uris = [];
                es = this._entrystore;
                cache = es.getCache();
                rest = es.getREST();

                deleteNext =
                /*#__PURE__*/
                function () {
                  var _ref = _asyncToGenerator(
                  /*#__PURE__*/
                  regeneratorRuntime.mark(function _callee4() {
                    var uri;
                    return regeneratorRuntime.wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            if (!(uris.length > 0)) {
                              _context4.next = 11;
                              break;
                            }

                            uri = uris.pop();
                            _context4.prev = 2;
                            _context4.next = 5;
                            return rest.del(uri);

                          case 5:
                            _context4.next = 10;
                            break;

                          case 7:
                            _context4.prev = 7;
                            _context4.t0 = _context4["catch"](2);
                            console.log("Could not remove entry with uri: ".concat(uri, " continuing anyway."));

                          case 10:
                            deleteNext();

                          case 11:
                            return _context4.abrupt("return", undefined);

                          case 12:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4, null, [[2, 7]]);
                  }));

                  return function deleteNext() {
                    return _ref.apply(this, arguments);
                  };
                }();

                _context5.next = 7;
                return list.forEach(function (entry) {
                  uris.push(entry.getURI());
                  cache.unCache(entry); // @todo @valentino perhaps they are removed from cache too early. Move to deleteNext?
                });

              case 7:
                result = _context5.sent;
                deleteNext(result);

              case 9:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, this);
      }));

      function removeAll(_x10) {
        return _removeAll.apply(this, arguments);
      }

      return removeAll;
    }()
  }]);

  return EntryStoreUtil;
}();

exports.default = EntryStoreUtil;

/***/ }),

/***/ "./src/File.js":
/*!*********************!*\
  !*** ./src/File.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _xmldom = _interopRequireDefault(__webpack_require__(/*! xmldom */ "./node_modules/xmldom/dom-parser.js"));

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

var _Resource2 = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

var _utils = __webpack_require__(/*! ./utils */ "./src/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * File resources are resources located in the Entrystore repository that have a graph type of
 * none, e.g. none of the special cases for which there are special treatment in EntryStore.
 *
 * @exports store/File
 */
var FileResource =
/*#__PURE__*/
function (_Resource) {
  _inherits(FileResource, _Resource);

  function FileResource() {
    _classCallCheck(this, FileResource);

    return _possibleConstructorReturn(this, _getPrototypeOf(FileResource).apply(this, arguments));
  }

  _createClass(FileResource, [{
    key: "putFile",

    /**
     * Pushes a file to the server for this resource.
     * In a browser environment a file is represented via an input tag which references
     * the file to be uploaded via its value attribute. E.g.:
     *
     *       <input type="file" name="uploadFile"/>
     *
     * During the uploading process the input tag will be moved temporarily in the DOM tree,
     * it will be restored to its original position afterwards (both upon success and failure).
     *
     * In a nodejs environments the file is leveraged as a stream, i.e.:
     * res.putFile(fs.createReadStream('file.txt'));
     *
     * @param {node|fileHandle} data - input tag or file handle that corresponds to a file.
     * @param {string} format - indicates the mimetype of the data
     * @todo fix-if-modified-since
     * @returns {Promise}
     */
    value: function putFile(data, format) {
      var _this = this;

      var url; // noinspection AmdModulesDependencies

      if ((0, _utils.isBrowser)() && data instanceof Node) {
        if (data.name == null || data.name === '') {
          throw new Error('Failure, cannot upload resource from input element unless a name' + ' attribute is provided.');
        }

        url = _factory.default.getPutFileURI(this.getResourceURI());
      } else {
        url = this.getResourceURI();
      }

      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().putFile(url, data, format).then(function (res) {
        _this.getEntry(true).setRefreshNeeded();

        return res;
      }), 'putFile');
    }
    /**
     * Pushes data to the server for this resource.
     *
     * @param {string} data - to be stored as a file.
     * @param {string} format - the format of the data as a mimetype.
     * @returns {Promise}
     */

  }, {
    key: "put",
    value: function put(data) {
      var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'application/json';
      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().put(this.getResourceURI(), data, null, format), 'putFile');
    }
    /**
     * Pushes text content to the server for this resource.
     *
     * @param {string} text - to be stored as a file, format will be set to text/plain.
     * @returns {Promise}
     */

  }, {
    key: "putText",
    value: function putText(text) {
      return this.put(text, 'text/plain');
    }
    /**
     * Pushes JSON content to the server for this resource.
     *
     * @param {Object} obj - to be stored as a json object, format will be set to application/json.
     * @returns {Promise}
     */

  }, {
    key: "putJSON",
    value: function putJSON(obj) {
      return this.put(JSON.stringify(obj));
    }
    /**
     * Pushes xml content to the server for this resource.
     *
     * @param {string|Document} xml - to be stored as a xml object, format will be set to
     * application/json.
     * @returns {Promise}
     * @todo not finished or tested
     */

  }, {
    key: "putXML",
    value: function putXML(xml) {
      var _xml = xml;
      var XMLSerializer = (0, _utils.isBrowser)() ? window.XMLSerializer : _xmldom.default.XMLSerializer;

      if (!(0, _utils.isBrowser)() || _xml instanceof Document) {
        try {
          // Gecko- and Webkit-based browsers (Firefox, Chrome), Opera.
          _xml = new XMLSerializer().serializeToString(_xml);
        } catch (e) {
          try {
            // Internet Explorer.
            _xml = _xml.xml;
          } catch (ee) {
            throw new Error('Xmlserializer not supported');
          }
        }
      } else if (typeof _xml !== "string") {
        throw new Error('Unsupported format of parameter xml to method putAsXML');
      }

      return this.put(_xml, 'text/xml');
    }
    /**
     * @returns {xhrPromise} which format the resource is returned in the promise (string, json or
     * xml) depends on what is specified in the mimetype. Xml is only returned in a browser
     * environment, if not in a browser a string is returned.
     */

  }, {
    key: "get",
    value: function get() {
      var format = this.getEntry(true).getEntryInfo().getFormat();
      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().get(this.getResourceURI(), format), 'getFile');
    }
    /**
     * @returns {Promise} ignores what is specified in the mimetype and returns the resource
     * as a string in the promise.
     */

  }, {
    key: "getText",
    value: function getText() {
      var es = this.getEntryStore();
      return es.handleAsync(this.getEntryStore().getREST().get(this.getResourceURI(), 'text/plain', true), 'getFile');
    }
    /**
     * @returns {Promise} ignores what is specified in the mimetype and returns the resource
     * as a javascript object in the promise.
     */

  }, {
    key: "getJSON",
    value: function getJSON() {
      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().get(this.getResourceURI(), 'application/json'), 'getFile');
    }
    /**
     * @returns {Promise} ignores what is specified in the mimetype and returns the resource
     * in the promise as a XML Document or a string (depending on if you are in browser or not).
     */

  }, {
    key: "getXML",
    value: function getXML() {
      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().get(this.getResourceURI(), 'text/xml'), 'getFile');
    }
  }]);

  return FileResource;
}(_Resource2.default);

exports.default = FileResource;

/***/ }),

/***/ "./src/Graph.js":
/*!**********************!*\
  !*** ./src/Graph.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

var _Resource2 = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Graph is a resource for handling RDF graphs relying on the {@link rdfjson/Graph} API.
 *
 * @exports store/Graph
 */
var GraphResource =
/*#__PURE__*/
function (_Resource) {
  _inherits(GraphResource, _Resource);

  /**
   * @param {string} entryURI - URI to an entry where this resource is contained.
   * @param {string} resourceURI - URI to the resource.
   * @param {store/EntryStore} entryStore - the API's repository instance.
   * @param {rdfjson/Graph | Object} data - is an RDF graph of some sort
   */
  function GraphResource(entryURI, resourceURI, entryStore, data) {
    var _this;

    _classCallCheck(this, GraphResource);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(GraphResource).call(this, entryURI, resourceURI, entryStore)); // Call the super constructor.

    _this._graph = data && data._graph ? data : new _rdfjson.Graph(data);
    return _this;
  }
  /**
   * Get the rdf Graph. The returned graph is not a copy, subsequent getGraph calls will return
   * the same instance as long as the entry has not been refreshed or a new instance set via
   * {@link store/Graph#setGraph setGraph}.
   *
   * @returns {rdfjson/Graph} will never be null or undefined, although the graph may be empty.
   */


  _createClass(GraphResource, [{
    key: "getGraph",
    value: function getGraph() {
      return this._graph;
    }
    /**
     * Set the rdf Graph. To update the graph in the repository call the
     * {@link store/EntryStore#commit commit}.
     *
     * @param {rdfjson/Graph} graph - the new graph, if null or undefined a new empty graph will
     * be set.
     * @returns {store/Graph} - to allow chaining with commit.
     */

  }, {
    key: "setGraph",
    value: function setGraph(graph) {
      this._graph = graph || new _rdfjson.Graph();
      return this;
    }
    /**
     * Pushes the current graph back to repository.
     *
     * @todo fix ifModifiedSince.
     * @param {rdfjson/Graph} graph
     * @returns {Promise}
     */

  }, {
    key: "commit",
    value: function commit() {
      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify(this._graph.exportRDFJSON())), 'commitGraph');
    }
    /**
     * Provides a JSON representation of the graph as rdf/json.
     *
     * @returns {Object}
     */

  }, {
    key: "getSource",
    value: function getSource() {
      return this._graph.exportRDFJSON();
    }
    /**
     *
     * @param data
     * @private
     */

  }, {
    key: "_update",
    value: function _update(data) {
      this._graph = new _rdfjson.Graph(data);
    }
  }]);

  return GraphResource;
}(_Resource2.default);

exports.default = GraphResource;

/***/ }),

/***/ "./src/Group.js":
/*!**********************!*\
  !*** ./src/Group.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _List2 = _interopRequireDefault(__webpack_require__(/*! ./List */ "./src/List.js"));

var _terms = _interopRequireDefault(__webpack_require__(/*! ./terms */ "./src/terms.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Group is a subclass of the List resource and contains a list of users.
 * The group resource URI can be referred to from access control lists.
 *
 * @exports store/Group
 */
var Group =
/*#__PURE__*/
function (_List) {
  _inherits(Group, _List);

  function Group() {
    _classCallCheck(this, Group);

    return _possibleConstructorReturn(this, _getPrototypeOf(Group).apply(this, arguments));
  }

  _createClass(Group, [{
    key: "getName",

    /**
     * Get the name of the group, this is a a unique name (username) in the current
     * repository's _principals context.
     * @returns {string}
     */
    value: function getName() {
      return this._name;
    }
    /**
     * Set a new name of the group, it will not succeed if it is already in use, for instance by
     * another user or group.
     * @param {string} name
     * @returns {Promise}
     */

  }, {
    key: "setName",
    value: function setName(name) {
      var _this = this;

      var oldName = this._name;
      this._name = name;
      return this._entryStore.handleAsync(this._entryStore.getREST().put("".concat(this.getEntryURI(), "/name"), JSON.stringify({
        name: name
      })).then(function (data) {
        var entry = _this.getEntry(true);

        if (entry) {
          entry.getEntryInfo()._name = data;
        }

        return data;
      }, function (e) {
        _this._name = oldName;
        throw e;
      }), 'setGroupName');
    }
    /**
     * Get the home context for this user.
     *
     * @returns {string} - a context id (not the full resource URI).
     */

  }, {
    key: "getHomeContext",
    value: function getHomeContext() {
      var es = this.getEntryStore();
      var entry = this.getEntry(true);
      var contextResourceURI = entry.getEntryInfo().getGraph().findFirstValue(entry.getResourceURI(), _terms.default.homeContext);

      if (contextResourceURI != null) {
        return es.getEntryId(contextResourceURI);
      }

      return undefined;
    }
    /**
     * Set a new home context for this group.
     * Note that the home context is stored in the entryinformation, hence, all other changes made
     * to the entryinformation will be saved unless the doNotPushToRepository flag is set to true.
     *
     * @param {string} contextId - a context id (not the full resource URI).
     * @param {boolean} doNotPushToRepository if true the changes will be made in the
     * entryinformation but it will not be pushed to the respository. To do this you need to get
     * a hold of the entryinformation and call commit.
     * @returns {Promise.<store/EntryInfo>|undefined}
     */

  }, {
    key: "setHomeContext",
    value: function setHomeContext(contextId, doNotPushToRepository) {
      var es = this.getEntryStore();
      var newContextURI = es.getResourceURI('_contexts', contextId);
      var entry = this.getEntry(true);
      var graph = entry.getEntryInfo().getGraph();
      graph.findAndRemove(entry.getResourceURI(), _terms.default.homeContext);
      graph.add(entry.getResourceURI(), _terms.default.homeContext, {
        type: 'uri',
        value: newContextURI
      });

      if (doNotPushToRepository !== true) {
        return entry.getEntryInfo().commit();
      }

      return undefined;
    }
    /**
     *
     * Data contains allUnsorted array, size, and children.
     * @param data
     * @param children
     * @private
     */

  }, {
    key: "_update",
    value: function _update(data, children) {
      _get(_getPrototypeOf(Group.prototype), "_update", this).call(this, data, children);

      this._name = data.name;
    }
  }]);

  return Group;
}(_List2.default);

exports.default = Group;

/***/ }),

/***/ "./src/List.js":
/*!*********************!*\
  !*** ./src/List.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Resource2 = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * List is a container for other entries in the same context.
 * A single entry may appear in multiple lists (multiple parent lists) unless if it is
 * a list itself. To avoid circular references list entries are only allowed to appear
 * in one parent list.
 *
 * @exports store/List
 */
var List =
/*#__PURE__*/
function (_Resource) {
  _inherits(List, _Resource);

  /**
   * @param {string} entryURI - URI to an entry where this resource is contained.
   * @param {string} resourceURI - URI to the resource.
   * @param {store/EntryStore} entryStore - the API's repository instance.
   */
  function List(entryURI, resourceURI, entryStore) {
    var _this;

    _classCallCheck(this, List);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(List).call(this, entryURI, resourceURI, entryStore));
    _this._cache = entryStore.getCache();
    /**
     * Array of entry URIs
     * @type {Array.<string>}
     * @private
     */

    _this._sortedChildren = [];
    return _this;
  }
  /**
   * Set the max amount of entries to include in each page during pagination.
   *
   * @param {integer} limit
   * @returns {store/List} allows chaining of set-operations.
   */


  _createClass(List, [{
    key: "setLimit",
    value: function setLimit(limit) {
      this._limit = limit;
      return this;
    }
    /**
     * Get the max amount of entries to include in each page during pagination.
     *
     * @returns {integer}
     */

  }, {
    key: "getLimit",
    value: function getLimit() {
      return this._limit || _factory.default.getDefaultLimit();
    }
    /**
     * Sets the sort order when loading entries contained in this list.
     *
     * @param {Object} sortParams - same object structure as the sort parameter in
     * optionalLoadParameters in {@link store/EntryStore#getEntry} method.
     * @returns {store/List} allows chaining of set-operations.
     */

  }, {
    key: "setSort",
    value: function setSort(sortParams) {
      this._clearSortedEntries();

      this._sortParams = sortParams;
      return this;
    }
    /**
     * Retrieves an array of entries contained in this list according to the current page and
     * pagination settings.
     * @param {number} page - the page to request an array of entries for,
     * first page is numbered 0.
     * @returns {Promise.<store/Entry[]>} the promise will return an entry-array.
     */

  }, {
    key: "getEntries",
    value: function getEntries() {
      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

      var results = this._getEntries(page);

      if (results != null) {
        return Promise.resolve(results);
      }

      return this._forceLoadEntries(page);
    }
    /**
     * Executes a callback on each list members in the order provided by the list.
     * If the provided function return false for one entry the iteration is stopped and
     * the function is not called for consecutive entries.
     *
     * @param {Function} func
     * @return {Promise} called with two parameters, the first a boolean saying if all entries
     * where passed, the second an index telling how many entries iterated over.
     */

  }, {
    key: "forEach",
    value: function forEach(func) {
      var page = 0;
      var idx = 0;
      var g;
      var h;
      var limit = this.getLimit();
      var self = this;

      var f = function f(entries) {
        var entriesLength = entries.length;

        g = function g(res) {
          if (res === false) {
            return Promise.resolve(false);
          }

          return h();
        };

        h = function h() {
          if (entries.length === 0) {
            return Promise.resolve(true);
          }

          var res = func(entries.pop(), idx);
          idx += 1;

          if (typeof res !== 'undefined' && typeof res.then === 'function') {
            return res.then(g);
          }

          return g(res);
        };

        return h().then(function (cont) {
          if (cont !== false && entriesLength === limit) {
            page += 1;
            return self.getEntries(page).then(f);
          }

          return Promise.resolve(idx);
        });
      };

      return this.getEntries(0).then(f);
    }
    /**
     * Adds an entry to this list, on success the List entry will be returned (updated with
     * latest modification date). The added entry will be marked as in need of a
     * refresh due to stale inv-rel cache. However,since List entry is loaded it may be refreshed
     * already when method is resolved, it depends if it is in the first page of the list.
     *
     * @param {store/Entry} entry - entry to add to the list.
     * @returns {Promise.<store/Entry>}
     */

  }, {
    key: "addEntry",
    value: function () {
      var _addEntry = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(entry) {
        var entries;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                _context.next = 2;
                return this.getAllEntryIds();

              case 2:
                entries = _context.sent;
                entries.push(entry.getId());
                _context.next = 6;
                return this.setAllEntryIds(entries, 'addToList');

              case 6:
                entry.setRefreshNeeded();
                return _context.abrupt("return", this.getEntry());

              case 8:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function addEntry(_x) {
        return _addEntry.apply(this, arguments);
      }

      return addEntry;
    }()
    /**
     * Removes an entry from this list, on success the List entry will be returned (updated with
     * latest modification date). The removed entry will not be updated but marked as in need
     * of a refresh due to stale inv-rel cache. However,since List entry is loaded it may be
     * refreshed already when method is resolved, it depends if it is in the first page of the list.
     *
     * @param {store/Entry} entry - entry to be removed from the list.
     * @returns {Promise}
     */

  }, {
    key: "removeEntry",
    value: function () {
      var _removeEntry = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(entry) {
        var entries;
        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                _context2.next = 2;
                return this.getAllEntryIds();

              case 2:
                entries = _context2.sent;
                entries.splice(entries.indexOf(entry.getId()), 1);
                _context2.next = 6;
                return this.setAllEntryIds(entries, 'removeFromList');

              case 6:
                entry.setRefreshNeeded();

              case 7:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function removeEntry(_x2) {
        return _removeEntry.apply(this, arguments);
      }

      return removeEntry;
    }()
    /**
     * Will unset things since the cache is stale...
     */

  }, {
    key: "needRefresh",
    value: function needRefresh() {
      delete this._unsortedChildren;
      this._sortedChildren = [];
      delete this._size;
    }
    /**
     * Get a list of entry ids contained in this list.
     *
     * @returns {Promise.<Array.<string>>} the promise will deliver an array of children entries in this
     * list as ids
     * (strings, not full URIs).
     */

  }, {
    key: "getAllEntryIds",
    value: function getAllEntryIds() {
      var _this2 = this;

      if (this._unsortedChildren != null) {
        return Promise.resolve(this._unsortedChildren);
      }

      return this.getEntries().then(function () {
        return _this2._unsortedChildren;
      });
    }
    /**
     * Set a list of entry ids to be contained in this list.
     *
     * @param {string[]} entries - array of entry ids (as strings, not full URIs).
     * @param {string} callType
     * @returns {Promise.<store/Entry>}
     */

  }, {
    key: "setAllEntryIds",
    value: function setAllEntryIds(entries, callType) {
      var _this3 = this;

      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify(entries)).then(function () {
        _this3.needRefresh();

        return _this3._entryStore.getEntry(_this3.getEntryURI()).then(function (oentry) {
          oentry.setRefreshNeeded();
          return oentry;
        });
      }), callType || 'setList');
    }
    /**
     * Get size of list.
     *
     * @returns {number} the amount of entries in the list, -1 if unknown.
     */

  }, {
    key: "getSize",
    value: function getSize() {
      return typeof this._size === 'number' ? this._size : -1;
    } //= ========Helper methods===============

  }, {
    key: "_clearSortedEntries",
    value: function _clearSortedEntries() {
      this._sortedChildren = [];
    }
    /**
     *
     * @param page
     * @param careAboutFresh
     * @return {null|Array}
     * @private
     */

  }, {
    key: "_getEntries",
    value: function _getEntries() {
      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var careAboutFresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (this._size == null) {
        return null;
      }

      var limit = this.getLimit();
      var offset = page * limit;
      var needRefresh = false;
      var results = [];
      var entryURI;

      for (var i = offset; i < offset + limit && i < this._size; i++) {
        entryURI = this._sortedChildren[i];

        if (entryURI) {
          var e = this._entryStore.getCache().get(entryURI);

          if (careAboutFresh === false || e != null && !e.needRefresh()) {
            results.push(e);
          } else {
            needRefresh = true;
            break;
          }
        } else {
          needRefresh = true;
          break;
        }
      }

      if (needRefresh) {
        return null;
      }

      return results;
    }
    /**
     *
     * @param page
     * @return {*|Promise<Array | never>}
     * @private
     */

  }, {
    key: "_forceLoadEntries",
    value: function _forceLoadEntries() {
      var _this4 = this;

      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var limit = this.getLimit();
      var offset = page * limit;
      return this._entryStore.getEntry(this._entryURI, {
        forceLoad: true,
        offset: offset,
        limit: limit,
        sort: this._sort,
        asyncContext: 'loadListEntries'
      }).then(function () {
        return _this4._getEntries(page, false);
      });
    }
    /**
     * Data contains allUnsorted array, size, and children.
     *
     * @param data
     * @param children
     * @private
     */

  }, {
    key: "_update",
    value: function _update(data, children) {
      var offset = data.offset || 0;

      for (var i = 0; i < children.length; i++) {
        this._sortedChildren[offset + i] = children[i].getURI();
      }

      this._size = data.size || children.length;
      this._unsortedChildren = data.allUnsorted || children.map(function (entry) {
        return entry.getId();
      });
    }
  }]);

  return List;
}(_Resource2.default);

exports.default = List;
;

/***/ }),

/***/ "./src/Pipeline.js":
/*!*************************!*\
  !*** ./src/Pipeline.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph */ "./src/Graph.js"));

var _terms = _interopRequireDefault(__webpack_require__(/*! ./terms */ "./src/terms.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * Pipeline is a Graph that contains an ordered list of transforms, each transform is of a
 * specific type and takes a set of arguments.
 *
 * @exports store/Pipeline
 */
var Pipeline =
/*#__PURE__*/
function (_GraphResource) {
  _inherits(Pipeline, _GraphResource);

  function Pipeline() {
    _classCallCheck(this, Pipeline);

    return _possibleConstructorReturn(this, _getPrototypeOf(Pipeline).apply(this, arguments));
  }

  _createClass(Pipeline, [{
    key: "getDestination",

    /**
     * The destination where the result (in the form of a single RDF graph) should
     * end up (within the specified entry's graph resource).
     * If empty string, a new entry will be created to store the results.
     * If undefined, the result will not go to a single destination, see getDetectDestination
     * instead. Some transform types does not respect the destination, e.g. currently ROWSTORE
     * which always creates a new entry containing the results.
     *
     * @returns {String|undefined} an entry URI where the result should go, empty string for new
     * entries for every execution or undefined if no destination has been specified.
     */
    value: function getDestination() {
      return this._graph.findFirstValue(null, _terms.default.pipeline.transformDestination);
    }
    /**
     * @see store/Pipeline#getDestination
     * @param {String} entryOrEntryURI entry URI, empty string for new entries every time,
     * use undefined to remove destination setting altogether.
     */

  }, {
    key: "setDestination",
    value: function setDestination(entryOrEntryURI) {
      this._graph.findAndRemove(null, _terms.default.pipeline.transformDestination);

      var uri = _typeof(entryOrEntryURI) === 'object' && entryOrEntryURI.getURI ? entryOrEntryURI.getURI() : entryOrEntryURI;

      this._graph.add(this._resourceURI, _terms.default.pipeline.transformDestination, uri);
    }
    /**
     * Detect destination means that the result of the last transform (a graph) should be attempted
     * to be split into multiple entries according to markings in the graph.
     *
     * I.e. it detects and adds a set of entries from the graph via the anonymous closure
     * algorithm starting from blank nodes resources
     * with either one of the two following properties that both indicate which entryId to use:<ul>
     * <li>http://entrystore.org/terms/mergeResourceId or the</li>
     * <li>http://entrystore.org/terms/referenceResourceId</li>
     * </ul>
     * The mergeResourceId indicates that the corresponding entry should be merged or created if it
     * does not exist.
     * The referenceResourceId only indicates that another entry (via its resource id) should be
     * referenced from
     * the graph (which might be inside an entry indicated by mergeResourceId).
     *
     *
     * @returns {boolean} true if destination should be detected.
     */

  }, {
    key: "getDetectDestination",
    value: function getDetectDestination() {
      var val = this._graph.findFirstValue(null, _terms.default.pipeline.transformDetectDestination);

      if (typeof val !== 'undefined') {
        return val.toLowerCase().indexOf('true') === 0;
      }

      return false;
    }
    /**
     *
     * @see store/Pipeline#getDetectDestination
     * @param {boolean} detect if true detection of entry references in the graph is attempted.
     */

  }, {
    key: "setDetectDestination",
    value: function setDetectDestination(detect) {
      this._graph.findAndRemove(null, _terms.default.pipeline.transformDetectDestination);

      if (detect === true) {
        this._graph.add(this._resourceURI, _terms.default.pipeline.transformDetectDestination, {
          type: 'literal',
          value: 'true',
          datatype: _terms.default.xsd.boolean
        });
      }
    }
    /**
     * @returns {String[]} of transform ids, typically blank node ids, hence, they are not
     * preserved between saves / loads so take care.
     */

  }, {
    key: "getTransforms",
    value: function getTransforms() {
      var stmts = this._graph.find(null, _terms.default.pipeline.transform);

      var arr = stmts.map(function (stmt) {
        return stmt.getValue();
      });
      var self = this;
      arr.sort(function (tr1, tr2) {
        var pr1 = self.getPriority(tr1);
        var pr2 = self.getPriority(tr2);
        return pr1 - pr2;
      });
      return arr;
    }
    /**
     * Finds a transform with the given type and returns its id.
     *
     * @param transformType the transform type to look for
     * @returns {string|undefined} transform id, undefined if no transform was found for the given type
     */

  }, {
    key: "getTransformForType",
    value: function getTransformForType(transformType) {
      var _this = this;

      var transformId;
      var trIds = this.getTransforms();
      trIds.forEach(function (trId) {
        // get transform type and check for fetch and get url
        if (_this.getTransformType(trId) === transformType) {
          transformId = trId;
        }
      }, this);
      return transformId;
    }
    /**
     * Adds a new transform.
     *
     * @param {String} type one of the [getTransforms]{@link store/Pipeline#getTransforms}.
     * @param {Object} args a hash of key value pairs for this transform.
     * @returns {String} the newly transforms id (for this session, may change after save / load
     * so take care).
     */

  }, {
    key: "addTransform",
    value: function addTransform(type, args) {
      var transforms = this.getTransforms();
      var priority = transforms.length > 0 ? this.getPriority(transforms[transforms.length - 1]) : 0;

      var stmt = this._graph.add(this._resourceURI, _terms.default.pipeline.transform);

      var id = stmt.getValue();
      this.setTransformType(id, type);
      this.setPriority(id, priority + 1);
      this.setTransformArguments(id, args);
      return id;
    }
    /**
     * Removes a transform.
     *
     * @param {String} transformId the blank node of a specific transform as retrieved by
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @see store/Pipeline#getTransforms
     */

  }, {
    key: "removeTransform",
    value: function removeTransform(transformId) {
      this.setTransformArguments(transformId, {});

      this._graph.findAndRemove(transformId);

      this._graph.findAndRemove(null, null, {
        type: 'bnode',
        value: transformId
      });
    }
    /**
     * Changes the order of the transforms by changing their priority properties.
     *
     * @param {Array} transforms
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @see store/Pipeline#getTransforms
     */

  }, {
    key: "setOrderOfTransforms",
    value: function setOrderOfTransforms(transforms) {
      for (var i = 0; i < transforms.length; i++) {
        this._graph.findAndRemove(transforms[i], _terms.default.pipeline.transformPriority);

        this._graph.add(transforms[i], _terms.default.pipeline.transformPriority, {
          type: 'literal',
          value: "".concat(i),
          datatype: _terms.default.xsd.integer
        });
      }
    }
    /**
     * @param {String} transformId the blank node of a specific transform as retrieved by
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @returns {number} the priority as a float.
     */

  }, {
    key: "getPriority",
    value: function getPriority(transformId) {
      var prio = this._graph.findFirstValue(transformId, _terms.default.pipeline.transformPriority);

      if (typeof prio === 'string') {
        prio = parseFloat(prio);

        if (!isNaN(prio)) {
          return prio;
        }
      }

      return 0;
    }
    /**
     * It is recommended to use setOrderOfTransforms instead.
     * @param {String} transformId the blank node of a specific transform as retrieved by
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @param {number} prio the priority as a float.
     * @see store/Pipeline#setOrderOfTransforms
     */

  }, {
    key: "setPriority",
    value: function setPriority(transformId, prio) {
      this._graph.findAndRemove(transformId, _terms.default.pipeline.transformPriority);

      this._graph.add(transformId, _terms.default.pipeline.transformPriority, {
        type: 'literal',
        value: "".concat(prio),
        datatype: _terms.default.xsd.integer
      });
    }
    /**
     * @param {String} transformId the blank node of a specific transform as retrieved by
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @returns {String} one of the values specified in {@link store/Pipeline#transformTypes}.
     */

  }, {
    key: "getTransformType",
    value: function getTransformType(transformId) {
      return this._graph.findFirstValue(transformId, _terms.default.pipeline.transformType);
    }
    /**
     *
     * @param {String} transformId the blank node of a specific transform as retrieved by
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @param {String} transformType one of the options in {@link store/Pipeline#transformTypes}.
     */

  }, {
    key: "setTransformType",
    value: function setTransformType(transformId, transformType) {
      this._graph.findAndRemove(transformId, _terms.default.pipeline.transformType);

      this._graph.addL(transformId, _terms.default.pipeline.transformType, transformType);
    }
    /**
     * @param {String} transformId the blank node of a specific transform as retrieved
     * by [getTransforms]{@link store/Pipeline#getTransforms}.  If no id is provided
     * arguments from all transforms will be returned in a single merged object.
     * @returns {Object|undefined} the arguments for a transform (or all transforms) as an object
     * hash with property value pairs.
     */

  }, {
    key: "getTransformArguments",
    value: function getTransformArguments(transformId) {
      var _this2 = this;

      var args;

      var stmts = this._graph.find(transformId, _terms.default.pipeline.transformArgument);

      stmts.forEach(function (stmt) {
        var key = _this2._graph.findFirstValue(stmt.getValue(), _terms.default.pipeline.transformArgumentKey);

        var value = _this2._graph.findFirstValue(stmt.getValue(), _terms.default.pipeline.transformArgumentValue);

        args = args || {};
        args[key] = value;
      }, this);
      return args;
    }
    /**
     * @param {String} transformId the blank node of a specific transform as retrieved
     * by [getTransforms]{@link store/Pipeline#getTransforms}.
     * @returns {Array} of arguments' keys
     */

  }, {
    key: "getTransformArgumentsKeys",
    value: function getTransformArgumentsKeys() {
      var _this3 = this;

      var transformId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var args = [];

      if (transformId) {
        var stmts = this._graph.find(transformId, _terms.default.pipeline.transformArgument);

        stmts.forEach(function (stmt) {
          var keys = _this3._graph.find(stmt.getValue(), _terms.default.pipeline.transformArgumentKey);

          args.push(keys.map(function (key) {
            return key.getValue();
          }));
        }, this);
      }

      return args;
    }
    /**
     * Replaces the current arguments with those provided.
     * @param {String} transformId the blank node of a specific transform as retrieved by
     * [getTransforms]{@link store/Pipeline#getTransforms}.
     * @param {Object} args the arguments for the transform as an object hash with property value pairs.
     */

  }, {
    key: "setTransformArguments",
    value: function setTransformArguments(transformId, args) {
      var _this4 = this;

      var stmts = this._graph.find(transformId, _terms.default.pipeline.transformArgument);

      stmts.forEach(function (stmt) {
        _this4._graph.findAndRemove(stmt.getValue(), _terms.default.pipeline.transformArgumentKey);

        _this4._graph.findAndRemove(stmt.getValue(), _terms.default.pipeline.transformArgumentValue);

        _this4._graph.remove(stmt);
      }, this);
      Object.keys(args).forEach(function (key) {
        var newArg = _this4._graph.add(transformId, _terms.default.pipeline.transformArgument);

        _this4._graph.addL(newArg.getValue(), _terms.default.pipeline.transformArgumentKey, key);

        _this4._graph.addL(newArg.getValue(), _terms.default.pipeline.transformArgumentValue, args[key]);
      });
    }
    /**
     * Retrieves a transform argument value for a specific transform type and property (key).
     * @param {string} transformType
     * @param {string} property
     * @returns {*|undefined}
     */

  }, {
    key: "getTransformProperty",
    value: function getTransformProperty(transformType, property) {
      var tid = this.getTransformForType(transformType);

      if (tid) {
        var obj = this.getTransformArguments(tid);

        if (obj && property in obj) {
          return obj[property];
        }
      }

      return undefined;
    }
    /**
     * Sets or updates an individual property (key-value pair in arguments) of a transform.
     * The transform is identified either explicitly by an id or via a transformType (assumed
     * unique).
     * @param {string} transformIdOrType corresponds to the transform to change the property for
     * @param {string} key
     * @param {string} value
     */

  }, {
    key: "setTransformProperty",
    value: function setTransformProperty(transformIdOrType, key, value) {
      var obj = this.getTransformArguments(transformIdOrType);

      if (obj != null) {
        obj[key] = value;
        this.setTransformArguments(transformIdOrType, obj);
      } else {
        var tid = this.getTransformForType(transformIdOrType);
        obj = this.getTransformArguments(tid);

        if (obj != null) {
          obj[key] = value;
          this.setTransformArguments(tid, obj);
        }
      }
    }
    /**
     * Executes the pipeline with the given source entry as input, if not provided the pipeline
     * will be used as sourceentry.
     *
     * @param {store/Entry} sourceEntry an optional entry containing some data that is to be
     * transformed, e.g. can be a CSV file.
     * @param {object} params additional parameters used in the execution of the pipeline, e.g.
     * action (with value create, replace or append) and datasetURL pointing to the existing
     * dataset in rowstore.
     * @returns {entryURIArrayPromise} an array of entry URIs that where created/modified by
     * this execution.
     */

  }, {
    key: "execute",
    value: function execute(sourceEntry, params) {
      var executeURI;
      var es = this.getEntryStore();

      var _params = params || {};

      _params.pipeline = this.getEntryURI();

      if (sourceEntry == null) {
        executeURI = "".concat(es.getBaseURI() + es.getContextId(this.getEntryURI()), "/execute");
      } else {
        _params.source = sourceEntry.getURI();
        executeURI = "".concat(sourceEntry.getContext().getResourceURI(), "/execute");
      }

      return es.handleAsync(es.getREST().post(executeURI, JSON.stringify(_params)), 'execute').then(function (response) {
        return response.body.result;
      }, function (err) {
        throw err;
      });
    }
  }]);

  return Pipeline;
}(_Graph.default);
/**
 * Available transforms (types).
 *
 * @type {{TABULAR: string, ROWSTORE: string}}
 */


exports.default = Pipeline;
Pipeline.prototype.transformTypes = {
  TABULAR: 'tabular',
  ROWSTORE: 'rowstore',
  EMPTY: 'empty',
  FETCH: 'fetch',
  VALIDATE: 'validate',
  MERGE: 'merge'
};

/***/ }),

/***/ "./src/PrototypeEntry.js":
/*!*******************************!*\
  !*** ./src/PrototypeEntry.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Entry2 = _interopRequireDefault(__webpack_require__(/*! ./Entry */ "./src/Entry.js"));

var _EntryInfo = _interopRequireDefault(__webpack_require__(/*! ./EntryInfo */ "./src/EntryInfo.js"));

var _terms = _interopRequireDefault(__webpack_require__(/*! ./terms */ "./src/terms.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * A PrototypeEntry is used to create new entries by collecting information about the initial
 * state of the entry to send along to the repository upon creation.
 *
 * All access and utility methods from Entry is just inherited. Some methods have been moved over
 * from EntryInformation to allow easier method chaining. Finally some information cannot be
 * changed in an entry, e.g. the entry, graph and resource types, but are crucial before creation.
 * Hence, some methods have been introduced to cover for this need.
 *
 * @exports store/PrototypeEntry
 */
var PrototypeEntry =
/*#__PURE__*/
function (_Entry) {
  _inherits(PrototypeEntry, _Entry);

  /**
   * @param {store/Context} context where this prototypeEntry belongs.
   * @param {string} id - entry identifier, if not unique in the context the subsequent commit
   * will fail.
   */
  function PrototypeEntry(context, id) {
    var _this;

    _classCallCheck(this, PrototypeEntry);

    var _id = id || '_newId';

    var cru = context.getResourceURI();
    var entryInfo = new _EntryInfo.default("".concat(cru, "/entry/").concat(_id), null, context.getEntryStore());

    if (context.getId() === '_contexts') {
      entryInfo._resourceURI = context.getEntryStore().getBaseURI() + _id;
    } else {
      entryInfo._resourceURI = "".concat(cru, "/resource/").concat(_id);
    }

    var oldSetResourceURI = entryInfo.setResourceURI;

    entryInfo.setResourceURI = function (uri) {
      this._resourceURI = uri;
      oldSetResourceURI.call(this, uri);
    };

    entryInfo.getResourceURI = function () {
      return this._resourceURI;
    };

    _this = _possibleConstructorReturn(this, _getPrototypeOf(PrototypeEntry).call(this, context, entryInfo)); // Call the super constructor.

    if (id != null) {
      _this.specificId = _id;
    }

    return _this;
  }
  /**
   * Direct access method for the resource instance for prorotypeEntries.
   * @returns {store/Resource}
   */


  _createClass(PrototypeEntry, [{
    key: "getResource",
    value: function getResource() {
      return this._resource;
    }
    /**
     * Exposes the {@link store/EntryInfo#setACL setACL} method from {@link store/EntryInfo}
     * on PrototypeEntry
     * and makes it chainable.
     *
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setACL",
    value: function setACL() {
      _EntryInfo.default.prototype.setACL.apply(this._entryInfo, arguments);

      return this;
    }
    /**
     * Exposes the {@link store/EntryInfo#setResourceURI setResourceURI} method from
     * {@link store/EntryInfo} on this class
     * and makes it chainable.
     *
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setResourceURI",
    value: function setResourceURI() {
      var _this$_entryInfo;

      (_this$_entryInfo = this._entryInfo).setResourceURI.apply(_this$_entryInfo, arguments);

      return this;
    }
    /**
     * Exposes the {@link store/EntryInfo#setExternalMetadataURI setExternalMetadataURI} method
     * from {@link store/EntryInfo} on this class
     * and makes it chainable.
     *
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setExternalMetadataURI",
    value: function setExternalMetadataURI() {
      _EntryInfo.default.prototype.setExternalMetadataURI.apply(this._entryInfo, arguments);

      return this;
    }
    /**
     * Makes it possible to change the EntryType (which is not allowed on existing entries).
     *
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setEntryType",
    value: function setEntryType(et) {
      var uri = _terms.default.invEntryType[et];

      if (uri) {
        this._entryInfo.getGraph().create(this._entryInfo.getEntryURI(), _terms.default.rdf.type, {
          type: 'uri',
          value: uri
        });
      }

      return this;
    }
    /**
     * Makes it possible to change the GraphType (which is not allowed on existing entries).
     *
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setGraphType",
    value: function setGraphType(gt) {
      this._gt = gt;
      var uri = _terms.default.invGraphType[gt];

      if (uri) {
        this._entryInfo.getGraph().create(this._entryInfo.getResourceURI(), _terms.default.rdf.type, {
          type: 'uri',
          value: uri
        });
      }

      return this;
    }
    /**
     * Makes it possible to change the ResourceType (which is not allowed on existing entries).
     *
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setResourceType",
    value: function setResourceType(rt) {
      var uri = _terms.default.invResourceType[rt];

      if (uri) {
        this._entryInfo.getGraph().create(this._entryInfo.getResourceURI(), _terms.default.rdf.type, {
          type: 'uri',
          value: uri
        });
      }

      return this;
    }
    /**
     * When creating new entries a single parent list can be specified, hence we need a way to set
     * it in PrototypeEntry.
     *
     * @param {store/Entry} parentListEntry
     * @returns {store/PrototypeEntry} - to allow the method call to be chained.
     */

  }, {
    key: "setParentList",
    value: function setParentList(parentListEntry) {
      this.parentListEntry = parentListEntry;
      return this;
    }
    /**
     * Get the parent list (as an entry) for this PrototypeEntry.
     * @returns {store/Entry}
     */

  }, {
    key: "getParentList",
    value: function getParentList() {
      return this.parentListEntry;
    }
    /**
     * Get the suggested entry id for this PrototypeEntry
     * @returns {string}
     */

  }, {
    key: "getSpecificId",
    value: function getSpecificId() {
      return this.specificId;
    }
    /**
     * Allowed as a way to save metadata for an
     * entry that is assumed to exist with a given entry id.
     * @override
     */

  }, {
    key: "commitMetadata",
    value: function commitMetadata() {
      if (!this.specificId) {
        throw new Error('The entryId must have been specified for allowing metadata to be saved.');
      }

      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().put(this.getEntryInfo().getMetadataURI(), JSON.stringify(this.getMetadata().exportRDFJSON())), 'commitMetadata');
    }
    /**
     * Allowed as a way to save cached external metadata for an entry that is assumed to
     * exist with a given entry id.
     * @override
     */

  }, {
    key: "commitCachedExternalMetadata",
    value: function commitCachedExternalMetadata() {
      if (!this.specificId) {
        throw new Error('The entryId must have been specified for allowing cached external metadata to be saved.');
      }

      var es = this.getEntryStore();
      return es.handleAsync(es.getREST().put(this.getEntryInfo().getCachedExternalMetadataURI(), JSON.stringify(this._cachedExternalMetadata.exportRDFJSON())), 'commitCachedExternalMetadata');
    }
    /**
     * @deprecated use {@link store/PrototypeEntry#commit commit} instead.
     * @returns {Promise.<store/Entry>}
     */

  }, {
    key: "create",
    value: function create() {
      return this._context.getEntryStore().createEntry(this);
    }
    /**
     * Create a new entry according to the information specified in the prototype entry.
     *
     * @returns {Promise.<store/Entry>}
     * @see store/EntryStore#createEntry
     */

  }, {
    key: "commit",
    value: function commit() {
      return this._context.getEntryStore().createEntry(this);
    }
  }]);

  return PrototypeEntry;
}(_Entry2.default);

exports.default = PrototypeEntry;
;

/***/ }),

/***/ "./src/Resource.js":
/*!*************************!*\
  !*** ./src/Resource.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

/**
 * This is the base class for resources contained by entries, do not use directly,
 * instead use a subclass.
 *
 * @exports store/Resource
 * @see subclass {@link store/Context}
 * @see subclass {@link store/List}
 * @see subclass {@link store/Graph}
 * @see subclass {@link store/String}
 * @see subclass {@link store/File}
 * @see subclass {@link store/User}
 * @see subclass {@link store/Group}
 */
var Resource =
/*#__PURE__*/
function () {
  /**
   * @param {string} entryURI - URI to an entry where this resource is contained.
   * @param {string} resourceURI - URI to the resource.
   * @param {store/EntryStore} entryStore - the API's repository instance.
   */
  function Resource(entryURI, resourceURI, entryStore) {
    _classCallCheck(this, Resource);

    this._entryURI = entryURI;
    this._resourceURI = resourceURI;
    this._entryStore = entryStore;
  }
  /**
   * Retrieves the API's repository instance
   *
   * @returns {store/EntryStore}
   */


  _createClass(Resource, [{
    key: "getEntryStore",
    value: function getEntryStore() {
      return this._entryStore;
    }
    /**
     * Retrieves the entry that contains this resource. Asking for the entry directly
     * (direct=true, rather than getting
     * it asynchronously via a promise) should work for all resources except context resources.
     *
     * > _**Advanced explanation:**
     * > Context resources are often created opportunistically by the API without also
     * > loading the context entry along with it, e.g. when loading entries during a search
     * > operation. The reason why the context entries are not loaded along with the context
     * > resource is that such an approach, depending on the use-case, may lead to dramatic
     * > increases in the amount of requests to the repository._
     *
     * @return {Promise.<store/Entry>|store/Entry} if direct=true an Entry is returned (or undefined if not
     * in cache, only happens sometimes for Contexts) otherwise a promise is returned that on
     * success provides the entry for this resource.
     */

  }, {
    key: "getEntry",
    value: function getEntry() {
      var direct = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this._entryStore.getEntry(this._entryURI, {
        direct: direct
      });
    }
    /**
     * The resources own URI.
     *
     * @returns {string}
     */

  }, {
    key: "getResourceURI",
    value: function getResourceURI() {
      return this._resourceURI;
    }
    /**
     * The URI to the entry containing this resource.
     *
     * @returns {string}
     */

  }, {
    key: "getEntryURI",
    value: function getEntryURI() {
      return this._entryURI;
    }
    /**
     * The id for the entry containing this resource.
     *
     * @returns {string}
     */

  }, {
    key: "getId",
    value: function getId() {
      return _factory.default.getEntryId(this._entryURI);
    }
  }, {
    key: "_update",
    value: function _update(data) {
      this._data = data;
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this._data;
    }
  }]);

  return Resource;
}();

exports.default = Resource;

/***/ }),

/***/ "./src/Rest.js":
/*!*********************!*\
  !*** ./src/Rest.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _blueimpMd = _interopRequireDefault(__webpack_require__(/*! blueimp-md5 */ "./node_modules/blueimp-md5/js/md5.js"));

var _superagent = _interopRequireDefault(__webpack_require__(/*! superagent */ "./node_modules/superagent/lib/client.js"));

var _xmldom = _interopRequireDefault(__webpack_require__(/*! xmldom */ "./node_modules/xmldom/dom-parser.js"));

var _utils = __webpack_require__(/*! ./utils */ "./src/utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var jsonp = __webpack_require__(/*! superagent-jsonp */ "./node_modules/superagent-jsonp/dist/superagent-jsonp.js");
/**
 * Check if requests will be to the same domain, i.e. no CORS.
 * Must be used in a browser environment.
 *
 * @param url
 * @returns {boolean}
 */


var sameOrigin = function sameOrigin(url) {
  var a1 = document.createElement('a');
  var a2 = document.createElement('a');
  a1.href = url;
  a2.href = window.location.href;
  return a1.hostname === a2.hostname && a1.port === a2.port && a1.protocol === a2.protocol && a2.protocol !== 'file:';
};
/**
 * @return {number}
 */


var getPreventCacheNumber = function getPreventCacheNumber() {
  return parseInt((Math.random() * 10000).toString(), 10);
};
/**
 * This class encapsulates functionality for communicating with the repository via Ajax calls.
 * Authentication is done via cookies and accept headers are in general set to
 * application/json behind the scenes.
 *
 * @exports store/Rest
 */


var Rest =
/*#__PURE__*/
function () {
  function Rest() {
    _classCallCheck(this, Rest);

    this.timeout = 30000; // 30 seconds

    this.headers = {
      Accept: 'application/json',
      'Content-Type': 'application/json; charset=UTF-8',
      'X-Requested-With': null
    };
    var rest = this;

    if ((0, _utils.isBrowser)()) {
      /**
       *
       * @param uri
       * @param {Object} data
       * @param format
       * @return {undefined|*}
       */
      rest.putFile = function (uri, data) {
        var format = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'application/json';

        if (!data.value) {
          return undefined;
        }

        var stubForm = new FormData();
        var files = data.files;
        Array.from(files).forEach(function (file, idx) {
          // is the item a File?
          if (file instanceof File) {
            stubForm.append(idx.toString(), file);
          }
        });
        return _superagent.default.post(uri).query({
          preventCache: getPreventCacheNumber()
        }).accept(format).withCredentials().send(stubForm);
      };
    }
  }
  /**
   * @param {object} credentials should contain attributes "user", "password", and "maxAge".
   * MaxAge is the amount of seconds the authorization should be valid.
   * @return {Promise} A thenable object
   * @async
   */


  _createClass(Rest, [{
    key: "auth",
    value: function () {
      var _auth = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee(credentials) {
        var _this = this;

        var user, password, maxAge, logout, base, data, queryStringData, response, cookies, logoutRequestResult;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                user = credentials.user, password = credentials.password, maxAge = credentials.maxAge, logout = credentials.logout, base = credentials.base;
                delete this.headers.cookie;

                if (!(logout !== true)) {
                  _context.next = 12;
                  break;
                }

                data = {
                  auth_username: encodeURIComponent(user),
                  auth_password: encodeURIComponent(password),
                  // in seconds, 86400 is default and corresponds to a day.
                  auth_maxage: maxAge != null ? maxAge : 604800
                };

                if (!(0, _utils.isBrowser)()) {
                  _context.next = 6;
                  break;
                }

                return _context.abrupt("return", this.post("".concat(base, "auth/cookie"), data, null, 'application/x-www-form-urlencoded'));

              case 6:
                queryStringData = Object.entries(data).reduce(function (accum, prop) {
                  return "".concat(accum).concat(prop.join('='), "&");
                }, '');
                _context.next = 9;
                return this.post("".concat(base, "auth/cookie"), queryStringData, null, 'application/x-www-form-urlencoded');

              case 9:
                response = _context.sent;
                cookies = response.headers['set-cookie'];
                cookies.some(function (c) {
                  if (c.substring(0, 11) === 'auth_token=') {
                    _this.headers.cookie = [c];
                    return true;
                  }

                  return false;
                });

              case 12:
                logoutRequestResult = _superagent.default.get("".concat(base, "auth/logout")).query({
                  preventCache: getPreventCacheNumber()
                }).accept('application/json').withCredentials().timeout({
                  response: this.timeout
                });
                Object.entries(this.headers).map(function (keyVal) {
                  return logoutRequestResult.set(keyVal[0], keyVal[1]);
                });
                return _context.abrupt("return", logoutRequestResult);

              case 15:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this);
      }));

      function auth(_x) {
        return _auth.apply(this, arguments);
      }

      return auth;
    }()
    /**
     * Fetches data from the provided URI.
     * If a cross-domain call is made and we are in a browser environment a jsonp call is made.
     *
     * @param {string} uri - URI to a resource to fetch.
     * @param {string|null} format - the format to request as a mimetype.
     * @param {boolean} nonJSONP - stop JSONP handling (default false)
     * @return {Promise} A thenable object
     * @async
     * @throws
     */

  }, {
    key: "get",
    value: function () {
      var _get = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee2(uri) {
        var format,
            nonJSONP,
            locHeaders,
            _uri,
            handleAs,
            GETRequest,
            response,
            _args2 = arguments;

        return regeneratorRuntime.wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                format = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : null;
                nonJSONP = _args2.length > 2 && _args2[2] !== undefined ? _args2[2] : false;
                locHeaders = Object.assign({}, this.headers);
                delete locHeaders['Content-Type'];
                _uri = uri;
                handleAs = 'json';

                if (!(format != null)) {
                  _context2.next = 15;
                  break;
                }

                locHeaders.Accept = format;
                _context2.t0 = format;
                _context2.next = _context2.t0 === 'application/json' ? 11 : _context2.t0 === 'application/xml' ? 12 : _context2.t0 === 'text/xml' ? 12 : 14;
                break;

              case 11:
                return _context2.abrupt("break", 15);

              case 12:
                handleAs = 'xml';
                return _context2.abrupt("break", 15);

              case 14:
                // All other situations, including text/plain.
                handleAs = 'text';

              case 15:
                if (!((0, _utils.isBrowser)() && !sameOrigin(_uri) && !nonJSONP)) {
                  _context2.next = 17;
                  break;
                }

                return _context2.abrupt("return", new Promise(function (resolve, reject) {
                  var queryParameter = new RegExp('[?&]format=');

                  if (!queryParameter.test(_uri)) {
                    _uri += "".concat(_uri.includes('?') ? '&' : '?', "format=application/json");
                  }

                  _superagent.default.get(_uri).use(jsonp({
                    timeout: 1000000,
                    // @scazan: superagent-jsonp's random number generator is weak, so we create our own
                    callbackName: "cb".concat((0, _blueimpMd.default)(_uri).slice(0, 7)).concat(getPreventCacheNumber())
                  })) // Need this timeout to prevent a superagentCallback*** not defined issue with superagent-jsonp: https://github.com/lamp/superagent-jsonp/issues/31
                  .then(function (data) {
                    resolve(data.body);
                  }, reject);
                }));

              case 17:
                GETRequest = _superagent.default.get(_uri).accept(handleAs).timeout({
                  response: this.timeout
                }).query({
                  preventCache: getPreventCacheNumber()
                }).withCredentials();

                if (handleAs === 'xml') {
                  GETRequest.parse['application/xml'] = function (res, callback) {
                    var DOMParser = (0, _utils.isBrowser)() ? window.DOMParser : _xmldom.default.DOMParser;
                    var parser = new DOMParser();

                    if ((0, _utils.isBrowser)()) {
                      return parser.parseFromString(res, 'application/xml');
                    } // @todo @valentino check if here it should be an else and callback outside that
                    // Node handles the return as a callback


                    res.text = parser.parseFromString(res.text, 'application/xml');
                    callback(null, res);
                    return res.text;
                  };
                }

                Object.entries(locHeaders).map(function (keyVal) {
                  return GETRequest.set(keyVal[0], keyVal[1]);
                });
                _context2.next = 22;
                return GETRequest;

              case 22:
                response = _context2.sent;

                if (!(response.statusCode === 200)) {
                  _context2.next = 27;
                  break;
                }

                if (!(handleAs === 'text' || format === 'text/xml')) {
                  _context2.next = 26;
                  break;
                }

                return _context2.abrupt("return", response.text);

              case 26:
                return _context2.abrupt("return", response.body);

              case 27:
                throw new Error("Resource could not be loaded: ".concat(response.text));

              case 28:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2, this);
      }));

      function get(_x2) {
        return _get.apply(this, arguments);
      }

      return get;
    }()
    /**
     * Posts data to the provided URI.
     *
     * @param {String} uri - an URI to post to.
     * @param {String|Object} data - the data to post. If an object the data is sent as form data.
     * @param {Date=} modDate a date to use for the HTTP if-unmodified-since header.
     * @param {string=} format - indicates the content-type of the data, default is
     * application/json, except if the data is an object in which case the default is
     * multipart/form-data.
     * @return {Promise} A thenable object
     */

  }, {
    key: "post",
    value: function post(uri, data, modDate, format) {
      var locHeaders = Object.assign({}, this.headers);

      if (modDate) {
        locHeaders['If-Unmodified-Since'] = modDate.toUTCString();
      } // multipart/form-data


      if (format) {
        locHeaders['Content-Type'] = format;
      }

      var POSTRequest = _superagent.default.post(uri).query({
        'request.preventCache': getPreventCacheNumber()
      });

      if (data) {
        POSTRequest.send(data) // serialize the object into a format that the backend is used to (no JSON strings)
        .serialize(function (obj) {
          return Object.entries(obj).map(function (keyVal) {
            return "".concat(keyVal[0], "=").concat(keyVal[1], "&");
          }).join('');
        });
      }

      POSTRequest.withCredentials().timeout({
        response: this.timeout
      });
      Object.entries(locHeaders).map(function (keyVal) {
        return POSTRequest.set(keyVal[0], keyVal[1]);
      });
      return POSTRequest;
    }
    /**
     * Posts data to a factory resource with the intent to create a new resource.
     * That is, it posts data and expects a Location header back with information on the created
     * resource.
     *
     * @param {string} uri - factory resource, may include parameters.
     * @param {string|Object} data - the data that is to be posted as a string,
     * if an object is provided it will be serialized as json.
     * @returns {Promise.<String>}
     */

  }, {
    key: "create",
    value: function () {
      var _create = _asyncToGenerator(
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee3(uri, data) {
        var response, location, idx;
        return regeneratorRuntime.wrap(function _callee3$(_context3) {
          while (1) {
            switch (_context3.prev = _context3.next) {
              case 0:
                _context3.next = 2;
                return this.post(uri, data);

              case 2:
                response = _context3.sent;
                // let location = response.getHeader('Location');
                location = response.headers.location; // In some weird cases, like when making requests from file:///
                // we do not have access to headers.

                if (!location && response.body) {
                  idx = uri.indexOf('?');

                  if (idx !== -1) {
                    location = uri.substr(0, uri.indexOf('?'));
                  } else {
                    location = uri;
                  }

                  location += "/entry/".concat(JSON.parse(response.body).entryId);
                }

                return _context3.abrupt("return", location);

              case 6:
              case "end":
                return _context3.stop();
            }
          }
        }, _callee3, this);
      }));

      function create(_x3, _x4) {
        return _create.apply(this, arguments);
      }

      return create;
    }()
    /**
     * Replaces a resource with a new representation.
     *
     * @param {string} uri the address to put to.
     * @param {string|Object} data - the data to put. If an object the data is sent as form data.
     * @param {Date=} modDate a date to use for the HTTP if-unmodified-since header.
     * @param {string=} format - indicates the content-type of the data, default is
     * application/json, except if the data is an object in which case the default is
     * multipart/form-data.
     * @return {Promise} A thenable object
     */

  }, {
    key: "put",
    value: function put(uri, data, modDate, format) {
      var locHeaders = Object.assign({}, this.headers);

      if (modDate) {
        locHeaders['If-Unmodified-Since'] = modDate.toUTCString();
      }

      if (format) {
        locHeaders['Content-Type'] = format;
      } else if (_typeof(data) === 'object') {
        locHeaders['Content-Type'] = 'application/json'; // @todo perhaps not needed, this is default
      }

      var putRequest = _superagent.default.put(uri).query({
        preventCache: getPreventCacheNumber()
      }).send(data).withCredentials().timeout({
        response: this.timeout
      });

      Object.entries(locHeaders).map(function (keyVal) {
        return putRequest.set(keyVal[0], keyVal[1]);
      });
      return putRequest;
    }
    /**
     * Deletes a resource.
     *
     * @param {String} uri of the resource that is to be deleted.
     * @param {Date=} modDate a date to use for the HTTP if-unmodified-since header.
     * @return {Promise} A thenable object
     */

  }, {
    key: "del",
    value: function del(uri, modDate) {
      var locHeaders = Object.assign({}, this.headers);
      delete locHeaders['Content-Type'];

      if (modDate) {
        locHeaders['If-Unmodified-Since'] = modDate.toUTCString();
      }

      var deleteRequest = _superagent.default.del(uri).query({
        preventCache: getPreventCacheNumber()
      }).withCredentials().timeout({
        response: this.timeout
      });

      Object.entries(locHeaders).map(function (keyVal) {
        return deleteRequest.set(keyVal[0], keyVal[1]);
      });
      return deleteRequest;
    }
    /**
     * Post a file to a URI.
     * In a browser environment a file is represented via an input tag which references
     * the file to be uploaded via its value attribute.
     * In node environments the file is represented as a stream constructed via
     * fs.createReadStream('file.txt').
     *
     * > _**Under the hood** the tag is moved into a form in an invisible iframe
     * which then is submitted. If there is a response it is provided in a textarea which
     * can be looked into since we are on the same domain._
     *
     * @param {string} uri the URI to which we will put the file.
     * @param {data} data - input tag or stream that may for instance correspond to a file
     * in a nodejs setting.
     * @param {string} format the format to handle the response as, either text, xml, html or json
     * (json is default).
     * @return {Promise} A thenable object
     */

  }, {
    key: "putFile",
    value: function putFile(uri, data, format) {
      return this.post(uri, data, null, format);
    }
  }]);

  return Rest;
}();

exports.default = Rest;

/***/ }),

/***/ "./src/SearchList.js":
/*!***************************!*\
  !*** ./src/SearchList.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EntryStore = _interopRequireDefault(__webpack_require__(/*! ./EntryStore */ "./src/EntryStore.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

// import List from './List';

/**
 * @exports store/SearchList
 */
var SearchList =
/*#__PURE__*/
function () {
  /**
   * @param {store/EntryStore} entryStore
   * @param {Object} query
   * @param {string} callType parameter provided to asyncListeners on query execution,
   * assumed to be 'search' if left out
   */
  function SearchList(entryStore, query, callType) {
    _classCallCheck(this, SearchList);

    this._entryStore = entryStore;
    this._query = query;
    this._callType = callType || 'search';
    this._sortedChildren = [];
  }
  /**
   * the query instance, e.g. an instance of store/SolrQuery, associated with this SearchList.
   * @returns {Object}
   */


  _createClass(SearchList, [{
    key: "getQuery",
    value: function getQuery() {
      return this._query;
    }
  }, {
    key: "setLimit",
    value: function setLimit(limit) {
      this._query.limit(limit);
    }
  }, {
    key: "getLimit",
    value: function getLimit() {
      return this._query.getLimit() || factory.getDefaultLimit();
    }
    /**
     * Array of facets, each facet is an object which contains the following fields:
     *
     *  name       - the solr search field this facet corresponds to
     *  valueCount - the number of values this facet matches
     *  values     - an array of values matching this facet, with name and count each.
     *
     * In addition, when asking for facets for arbitrary predicates there is two additional fields:
     *
     *  predicate - the full URI of the predicate this facet corresponds to
     *  type - the type of the facet values, currently only literal, uri and integer are supported
     *
     * Note that you can ask for facets for solr fields like "tags", in this case the above two
     * fields will be not be present as the "tags" solr field corresponds to a mix of different
     * predicates and possibly different types.
     *
     * Here is an example of a facet for dcat:keyword:
     * {
     *   name:  "metadata.predicate.literal_s.a6424133",
     *   predicate: "http://www.w3.org/ns/dcat#keyword",
     *   type: "literal",
     *   valueCount: 3,
     *   values: [
     *      {name: "elektrictet", count: 1},
     *      {name: "finans", count: 1},
     *      {name: "skatt", count: 1}
     *   ]
     * }
     *
     * @return {Array} never null or undefined, may be an array of length 0 though.
     */

  }, {
    key: "getFacets",
    value: function getFacets() {
      return this.facets;
    }
  }, {
    key: "setFacets",
    value: function setFacets(facetFields) {
      if (!Array.isArray(facetFields) || facetFields.length === 0) {
        this.facets = [];
      } else {
        this.facets = facetFields;
        var f2p = this._query.facet2predicate;
        facetFields.forEach(function (ff) {
          if (f2p && f2p[ff.name]) {
            ff.predicate = f2p[ff.name];
          }

          if (ff.name.startsWith('metadata.predicate')) {
            ff.type = ff.name.split('.')[2];
          } else if (ff.name.startsWith('related.metadata.predicate')) {
            ff.type = ff.name.split('.')[3];
          }
        });
      }
    }
    /**
     *
     * @param {number} [page=0]
     * @return {Promise}
     * @private
     */

  }, {
    key: "_forceLoadEntries",
    value: function _forceLoadEntries() {
      var _this = this;

      var page = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var offset = page * this.getLimit();

      this._query.offset(offset);

      return this._entryStore.handleAsync(this._entryStore.getREST().get(this._query.getQuery(this._entryStore)).then(function (data) {
        _this.setFacets(data.facetFields);

        return es.getFactory().extractSearchResults(data, _this, _this._entryStore);
      }), this._callType);
    }
  }]);

  return SearchList;
}();
/**
 * Get size of list.
 *
 * @returns {number} the amount of entries in the list, -1 if unknown.
 */
// SearchList.prototype.getSize = List.prototype.getSize;

/**
 * Retrieves an array of entries contained in this list according to the current page and
 * pagination settings.
 *
 * @param {integer} page - the page to request an array of entries for, first page is numbered 0.
 * @returns {Promise.<Array.<Entry>>} the promise will return an entry-array.
 * @method
 */
// SearchList.prototype.getEntries = List.prototype.getEntries;

/**
 * Executes a callback on each list members in the order provided by the solr-search.
 * If the provided function return false for one entry the iteration is stopped and
 * the function is not called for consecutive matched entries.
 *
 * @param {Function} func
 */
// SearchList.prototype.forEach = List.prototype.forEach;
// SearchList.prototype._getEntries = List.prototype._getEntries;
// SearchList.prototype._update = List.prototype._update;
// export default SearchList;


exports.default = SearchList;

/***/ }),

/***/ "./src/SolrQuery.js":
/*!**************************!*\
  !*** ./src/SolrQuery.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _blueimpMd = _interopRequireDefault(__webpack_require__(/*! blueimp-md5 */ "./node_modules/blueimp-md5/js/md5.js"));

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

var _Context = _interopRequireDefault(__webpack_require__(/*! ./Context */ "./src/Context.js"));

var _EntryStore = _interopRequireDefault(__webpack_require__(/*! ./EntryStore */ "./src/EntryStore.js"));

var _SearchList = _interopRequireDefault(__webpack_require__(/*! ./SearchList */ "./src/SearchList.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var encodeStr = function encodeStr(str) {
  return encodeURIComponent(str.replace(/:/g, '\\:').replace(/\(/g, '\\(').replace(/\)/g, '\\)'));
};

var shorten = function shorten(predicate) {
  return (0, _blueimpMd.default)(_rdfjson.namespaces.expand(predicate)).substr(0, 8);
};

var ngramLimit = 15;

var isNgram = function isNgram(key) {
  return key.indexOf('title') === 0 || key.indexOf('tag.literal') === 0 || key.indexOf('metadata.predicate.literal') === 0 && key.indexOf('metadata.predicate.literal_') !== 0 || key.indexOf('related.metadata.predicate.literal') === 0 && key.indexOf('related.metadata.predicate.literal_') !== 0;
};

var isExactMatch = function isExactMatch(key) {
  return key.indexOf('predicate.literal_s') > 0 || key.indexOf('predicate.literal') === -1;
};
/**
 * Empty spaces in search term should be interpreted as AND instead of the default OR.
 * In addition, fields indexed as text_ngram will have to be shortened to the ngram max limit
 * as they will not match otherwise.
 *
 * @param key
 * @param term
 * @param isFacet
 * @return {*}
 */


var solrFriendly = function solrFriendly(key, term, isFacet) {
  var and = term.trim().replace(/\s\s+/g, ' ');

  if (isNgram(key) && isFacet !== true) {
    and = and.split(' ').map(function (t) {
      return t.length < ngramLimit ? encodeStr(t) : encodeStr(t.substr(0, ngramLimit));
    });
  } else if (isExactMatch(key)) {
    if (and.indexOf(' ') === -1) {
      and = [encodeStr(and)];
    } else {
      and = ["\"".concat(encodeStr(and), "\"")];
    }
  } else {
    and = and.split(' ').map(function (t) {
      return encodeStr(t);
    });
  }

  return and.length === 1 ? and[0] : "(".concat(and.join('+AND+'), ")");
};
/**
 *
 * @param struct
 * @param isAnd
 * @return {string}
 */


var buildQuery = function buildQuery(struct, isAnd) {
  var terms = [];
  Object.keys(struct).forEach(function (key) {
    var val = struct[key];
    val = Array.isArray(val) ? val.map(function (v) {
      return _rdfjson.namespaces.expand(v);
    }) : _rdfjson.namespaces.expand(val);

    switch (key) {
      case 'or':
        terms.push(buildQuery(val, false));
        break;

      case 'and':
        terms.push(buildQuery(val, true));
        break;

      default:
        if (typeof val === 'string') {
          terms.push("".concat(key, ":").concat(solrFriendly(key, val)));
        } else if (Array.isArray(val)) {
          var or = [];
          val.forEach(function (o) {
            or.push("".concat(key, ":").concat(solrFriendly(key, o)));
          });

          if (or.length > 1) {
            terms.push("(".concat(or.join('+OR+'), ")"));
          } else {
            terms.push("".concat(or.join('+OR+')));
          }
        } else if (_typeof(val) === 'object') {// TODO
        }

    }
  });

  if (terms.length > 1) {
    return "(".concat(terms.join(isAnd ? '+AND+' : '+OR+'), ")");
  }

  return terms.join("".concat(isAnd ? '+AND+' : '+OR+'));
};
/**
 * The SolrQuery class provides a way to create a query by chaining method calls according to
 * the builder pattern. For example:
 *
 *     const sq = es.newSolrQuery().title("some title").type("http://example.com/Person")
 *
 * The example yields a search for entries that have a title that contains "some title"
 * and a rdf:type of "http://example.com/Person" expressed in the metadata.
 * To execute the query you can either ask for a {@link store/SearchList} and then call
 * getEntries (or forEach):
 *
 *     const sl = sq.list();
 *     sl.getEntries().then((entryArr) => {// Do something })
 *
 * Or you use the abbreviated version where you just call getEntries directly (or forEach)
 * on the SolrQuery:
 *
 *     sq.getEntries()
 *
 * The majority of the methods work the same way, that is they take two values, a value and a
 * possible negation flag. The value can be an array corresponding to a disjunction and if the
 * flag is set true the search string will be constructed to search for the negation of the
 * provided value. For example, if a graph type in the form of an array containing List and User
 * is provided together with a negation boolean set to true, the query will search for anything
 * but lists and users:
 *
 *     sq.graphType([types.GT_LIST, types.GT_USER], true)
 *
 * Supported methods on the solr object correspond in large to the available solr fields
 * documented at, some method names are different to avoid dots:
 * {@link https://code.google.com/p/entrystore/wiki/KnowledgeBaseSearch}
 *
 * There is also a special method ({@link store/SolrQuery#getQuery getQuery}) for getting the
 * query as a string that is used by EntryStore API behind the scenes, you can safely ignore
 * this method.
 *
 * @exports store/SolrQuery
 */


var SolrQuery =
/*#__PURE__*/
function () {
  /**
   * @param {store/EntryStore} entrystore
   */
  function SolrQuery(entrystore) {
    _classCallCheck(this, SolrQuery);

    this._entrystore = entrystore;
    this.properties = [];
    this.relatedProperties = [];
    /**
     *
     * @type {Map<string, *>}
     */

    this.params = new Map();
    /**
     *
     * @type {Map<string, any>}
     */

    this.modifiers = new Map();
    /**
     *
     * @type {Set<Object>}
     * @private
     */

    this._and = new Set();
    /**
     *
     * @type {Set<Object>}
     * @private
     */

    this._or = new Set();
    this.facetpredicates = {};
    this.relatedFacetpredicates = {};
  }
  /**
   * @private
   */


  _createClass(SolrQuery, [{
    key: "_q",
    value: function _q(key, val) {
      var modifier = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      this.params.set(key, val);

      if (modifier === null) {
        this.modifiers.set(key, modifier);
      }

      return this;
    }
    /**
     * Matches all titles in all languages, multivalued, cannot be sorted on.
     * Includes dc:title, dcterms:title, skos:prefLabel, skos:altLabel, skos:hiddenLabel,
     * rdfs:label, foaf:name.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "title",
    value: function title(val, modifier) {
      return this._q('title', val, modifier);
    }
    /**
     * Matches all descriptions in all languages, multivalued, cannot be sorted on.
     * Includes dc:description, dcterms:description, rdfs:comment
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "description",
    value: function description(val, modifier) {
      return this._q('description', val, modifier);
    }
    /**
     * Matches all tags literals in all languages, multivalued, cannot be sorted on.
     * Includes dc:subject, dcterms:subject, dcat:keyword and lom:keyword
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "tagLiteral",
    value: function tagLiteral(val, modifier) {
      return this._q('tag.literal', val, modifier);
    }
    /**
     * Matches all tag URIs, multivalued, cannot be sorted on.
     * Includes dc:subject, dcterms:subject
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "tagURI",
    value: function tagURI(val, modifier) {
      return this._q('tag.uri', val, modifier);
    }
    /**
     * Matches the language (as a literal) of the resource, single value, can be used for sorting?
     * Includes dc:language, dcterms:language
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "lang",
    value: function lang(val, modifier) {
      return this._q('lang', val, modifier);
    }
    /**
     * Matches title, description and tags, multivalue, cannot be sorted on.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "all",
    value: function all(val, modifier) {
      return this._q('all', val, modifier);
    }
    /**
     * Matches all URIs in subject position in the metadata, except the resourceURI.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "subject",
    value: function subject(val, modifier) {
      return this._q('metadata.subject', val, modifier);
    }
    /**
     * Matches all URIs in predicate position in the metadata.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "predicate",
    value: function predicate(val, modifier) {
      return this._q('metadata.predicate', val, modifier);
    }
    /**
     * Matches all literals in object position in the metadata.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "objectLiteral",
    value: function objectLiteral(val, modifier) {
      return this._q('metadata.object.literal', val, modifier);
    }
    /**
     * Matches all URIs in object position in the metadata.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "objectUri",
    value: function objectUri(val, modifier) {
      return this._q('metadata.object.uri', val, modifier);
    }
    /**
     * Matches the resourceURI of the entry.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "resource",
    value: function resource(val) {
      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._q('resource', val, modifier);
    }
    /**
     * Matches the entryURI of the entry.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "uri",
    value: function uri(val, modifier) {
      return this._q('uri', val, modifier);
    }
    /**
     * Matches all types of the resourceURI, i.e.
     * all URIs pointed to via rdf:type from the resourceURI.
     *
     * @param {string|array} rdfType
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "rdfType",
    value: function rdfType(_rdfType) {
      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (Array.isArray(_rdfType)) {
        return this._q('rdfType', _rdfType.map(function (t) {
          return _rdfjson.namespaces.expand(t);
        }), modifier);
      }

      return this._q('rdfType', _rdfjson.namespaces.expand(_rdfType), modifier);
    }
    /**
     * Matches all creators (in the entry information graph) expressed via their resourceURIs.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "creator",
    value: function creator(val, modifier) {
      return this._q('creator', val, modifier);
    }
    /**
     * Matches all contributors (in the entry information graph) expressed via their resourceURIs.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "contributors",
    value: function contributors(val, modifier) {
      return this._q('contributors', val, modifier);
    }
    /**
     * Matches only entries that are part of the given lists, identified via their resourceURIs.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "lists",
    value: function lists(val, modifier) {
      return this._q('lists', val, modifier);
    }
    /**
     * Matches entries that are created at the specific date, most useful for sorting.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "created",
    value: function created(val, modifier) {
      return this._q('created', val, modifier);
    }
    /**
     * Matches entries that are modified at the specific date, most useful for sorting.
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "modified",
    value: function modified(val, modifier) {
      return this._q('modified', val, modifier);
    }
    /**
     * Matches entries with the given entry type, use the values in {@link store/types}, e.g.
     * sq.entryType(types.ET_LINK).
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "entryType",
    value: function entryType(val, modifier) {
      return this._q('entryType', val, modifier);
    }
    /**
     * Matches entries with the given graph type, use the values in {@link store/types}, e.g.
     * sq.entryType(types.GT_USER).
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "graphType",
    value: function graphType(val) {
      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this._q('graphType', val, modifier);
    }
    /**
     * Matches entries with the given resource type, use the values in {@link store/types}, e.g.
     * sq.entryType(types.RT_INFORMATIONRESOURCE).
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "resourceType",
    value: function resourceType(val, modifier) {
      return this._q('resourceType', val, modifier);
    }
    /**
     * Matches only public entries. Warning, individual entrys public flag is inherited from
     * surrounding context and if the context ACL is updated the entrys are not reindexed
     * automatically. Hence, this flag may be incorrect.
     *
     * @param {true|false} isPublic
     * @return {store/SolrQuery}
     */

  }, {
    key: "publicRead",
    value: function publicRead() {
      var isPublic = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return this._q('public', isPublic === true ? 'true' : 'false');
    }
    /**
     * Matches only entries with explicitly ACL stating user(s) has admin rights
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "admin",
    value: function admin(val, modifier) {
      return this._q('acl.admin', val, modifier);
    }
    /**
     * Matches only entries with explicitly ACL stating user(s) has metadata read rights
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "metadataRead",
    value: function metadataRead(val, modifier) {
      return this._q('acl.metadata.r', val, modifier);
    }
    /**
     * Matches only entries with explicitly ACL stating user(s) has metadata write (and read) rights
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "metadataWrite",
    value: function metadataWrite(val, modifier) {
      return this._q('acl.metadata.rw', val, modifier);
    }
    /**
     * Matches only entries with explicitly ACL stating user(s) has resource read rights
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "resourceRead",
    value: function resourceRead(val, modifier) {
      return this._q('acl.resource.r', val, modifier);
    }
    /**
     * Matches only entries with explicitly ACL stating user(s) has resource write (and read) rights
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "resourceWrite",
    value: function resourceWrite(val, modifier) {
      return this._q('acl.resource.rw', val, modifier);
    }
    /**
     * Matches entries with with specific status (expressed in entry information graph)
     *
     * @param {string|array} val
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "status",
    value: function status(val, modifier) {
      return this._q('status', val, modifier);
    }
    /**
     * Matches only entries within specified context(s)
     *
     * @param {string|store/Context} context either a contextId, the resourceURI for a
     +     * context, a store/Context instance or an array containing any of those. In case of a
     +     * string, either directly or within the array and it starts with 'http' it is assumed it is
     +     * the resourceURI of the context, otherwise the context is assumed to be a contextId.
     * @param {true|false|string} modifier
     * @return {store/SolrQuery}
     */

  }, {
    key: "context",
    value: function context(_context) {
      var _this = this;

      var modifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      var f = function f(c) {
        if (c && c.getResourceURI) {
          return c.getResourceURI();
        } else if (typeof c === 'string' && c !== '') {
          if (c.indexOf('http') === 0) {
            return c;
          }

          return _this._entrystore.getContextById(c).getResourceURI();
        }

        return null;
      };

      if (Array.isArray(_context)) {
        var resourceURIArr = _context.map(f).filter(function (v) {
          return v !== null;
        });

        if (resourceURIArr.length > 0) {
          this._q('context', resourceURIArr, modifier);
        }
      } else {
        var resourceURI = f(_context);

        if (resourceURI !== null) {
          return this._q('context', resourceURI, modifier);
        }
      }

      return this;
    }
    /**
     * Provide a query in the form of an object structure where the toplevel attributes
     * are disjunctive (OR:ed together). The following example will query for things that
     * are typed as vedgetables AND have the word 'tomato' in either the title OR description:
     * query.rdfType('ex:Vedgetable).or({
     *   title: 'tomato',
     *   description: 'tomato'
     * });
     *
     * Note, the name of the method ('or') does not refers to how the object structure is
     * combined with the rest of the query, only how the inner parts of the object structure
     * is combined. To change the toplevel behaviour of the query from an and to an or,
     * use the disjunctive method.
     *
     * @param {Object} structure
     * @return {store/SolrQuery}
     */

  }, {
    key: "or",
    value: function or(structure) {
      this._or.add(structure);

      return this;
    }
    /**
     * Provide a query in the form of an object structure where the toplevel attributes
     * are conjunctive (AND:ed together). The following example will query for things that
     * are typed as vedgetables OR typed as fruit AND has a title that contains the word 'orange':
     * query.disjunctive().rdfType('ex:Vedgetable).and({
     *   rdfType: 'ex:Fruit',
     *   title: 'Orange',
     * });
     *
     * Note, the name of the method ('and') does not refers to how the object structure is
     * combined with the rest of the query, only how the inner parts of the object structure
     * is combined. In this example we have change the toplevel behaviour of the query to
     * become disjunctive (being OR:ed together), this is to make the query more representative
     * since there is no need for the grouping of the object structure otherwise.
     *
     * @param {Object} structure
     * @return {store/SolrQuery}
     */

  }, {
    key: "and",
    value: function and(structure) {
      this._and.add(structure);

      return this;
    }
    /**
     * @deprecated
     */
    //eslint-disable-next-line

  }, {
    key: "title_lang",
    value: function title_lang(title, language) {}
    /**
     * If a title has a language set, a dynamic field is created with the pattern "title.en",
     * without multi value support. This is used in the context of sorting.
     * @param title {String} the title to search for
     * @param language {String} the language of the title for instance "en".
     * @return {store/SolrQuery}
     */

  }, {
    key: "titleWithLanguage",
    value: function titleWithLanguage(title, language) {
      this._title_lang = {
        value: title,
        language: language
      };
      return this;
    }
    /**
     * Matches specific property value combinations.
     *
     * @param {string} predicate
     * @param {string|array} object
     * @param {true|false|string} modifier
     * @param {text|string} [indexType=ngram] 'ngram' corresponds to partial string
     * matching, string corresponds to exact string matching and text corresponds to word matching.
     * @param {boolean} [related=false] will search in related properties if true, default is false
     * @return {store/SolrQuery}
     */

  }, {
    key: "literalProperty",
    value: function literalProperty(predicate, object, modifier) {
      var indexType = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 'ngram';
      var related = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var key = shorten(predicate);
      var nodetype;

      switch (indexType) {
        case 'text':
          nodetype = 'literal_t';
          break;

        case 'string':
          nodetype = 'literal_s';
          break;

        case 'ngram':
        default:
          nodetype = 'literal';
      }

      (related ? this.relatedProperties : this.properties).push({
        md5: key,
        pred: predicate,
        object: object,
        modifier: modifier,
        nodetype: nodetype
      });
      return this;
    }
    /**
     * Matches specific property value combinations when the value is an integer.
     * Note that the integer values are single value per property and can be used for sorting.
     *
     * @param {string} predicate
     * @param {string|array} object
     * @param {true|false|string} modifier
     * @param {boolean} related - will search in related properties if true, default is false
     * @return {store/SolrQuery}
     */

  }, {
    key: "integerProperty",
    value: function integerProperty(predicate, object, modifier) {
      var related = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var key = shorten(predicate);
      (related ? this.relatedProperties : this.properties).push({
        md5: key,
        pred: predicate,
        object: object,
        modifier: modifier,
        nodetype: 'integer'
      });
      return this;
    }
    /**
     * Matches specific property value combinations when the value is an integer.
     * Note that the integer values are single value per property and can be used for sorting.
     *
     * @param {string} predicate
     * @param {string|array} object
     * @param {true|false|string} modifier
     * @param {boolean} related - will search in related properties if true, default is false
     * @return {store/SolrQuery}
     */

  }, {
    key: "uriProperty",
    value: function uriProperty(predicate, object, modifier) {
      var related = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var key = shorten(predicate);
      (related ? this.relatedProperties : this.properties).push({
        md5: key,
        pred: predicate,
        object: Array.isArray(object) ? object.map(function (o) {
          return _rdfjson.namespaces.expand(o);
        }) : _rdfjson.namespaces.expand(object),
        modifier: modifier,
        nodetype: 'uri'
      });
      return this;
    }
    /**
     * Sets the pagination limit.
     *
     * @param {string|number} limit
     * @return {store/SolrQuery}
     */

  }, {
    key: "limit",
    value: function limit(_limit) {
      this._limit = _limit;
      return this;
    }
    /**
     * Gets the pagination limit if it set.
     *
     * @return {string|number}
     */

  }, {
    key: "getLimit",
    value: function getLimit() {
      return this._limit;
    }
    /**
     * The parameter "sort" can be used for Solr-style sorting, e.g. "sort=title+asc,modified+desc".
     * The default sorting value is to sort after the score (relevancy) and the modification date.
     * All string and non-multi value fields can be used for sorting, this basically excludes title,
     * description and keywords,
     * but allows sorting after e.g. title.en.
     * If no sort is explicitly given the default sort string used is "score+asc".
     * @param sort {String} a list of fields together with '+asc' or '+desc', first field has the
     * highest priority when sorting.
     * @return {store/SolrQuery}
     */

  }, {
    key: "sort",
    value: function sort(_sort) {
      this._sort = _sort;
      return this;
    }
    /**
     * Set an explicit offset.
     *
     * @param {string|number} offset
     * @return {store/SolrQuery}
     */

  }, {
    key: "offset",
    value: function offset(_offset) {
      this._offset = _offset;
      return this;
    }
    /**
     * @private
     * @param {string} facet
     * @param {string} predicate
     * @param {boolean} [related=false]
     * @return {store/SolrQuery}
     */

  }, {
    key: "facet",
    value: function facet(_facet, predicate) {
      var related = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      this.facets = this.facets || [];

      if (predicate) {
        this.facet2predicate = this.facet2predicate || {};
        this.facet2predicate[_facet] = _rdfjson.namespaces.expand(predicate);

        if (related) {
          this.relatedFacetpredicates[predicate] = true;
        } else {
          this.facetpredicates[predicate] = true;
        }
      }

      this.facets.push(_facet);
      return this;
    }
    /**
     * Request to include literal facets for the given predicate
     * @param {string} predicate
     * @param {boolean} [related=false] whether the facet is on the related predicates, default is false
     * @return {store/SolrQuery}
     */

  }, {
    key: "literalFacet",
    value: function literalFacet(predicate) {
      var related = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.facet("".concat(related ? 'related.' : '', "metadata.predicate.literal_s.").concat(shorten(predicate)), predicate, related);
      return this;
    }
    /**
     * Request to include URI facets for the given predicate
     * @param {string} predicate
     * @param {boolean} [related=false] whether the facet is on the related predicates, default is false
     * @return {store/SolrQuery}
     */

  }, {
    key: "uriFacet",
    value: function uriFacet(predicate) {
      var related = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.facet("".concat(related ? 'related.' : '', "metadata.predicate.uri.").concat(shorten(predicate)), predicate, related);
      return this;
    }
    /**
     * Request to include integer facets for the given predicate
     * @param {string} predicate
     * @param {boolean} [related=false] whether the facet is on the related predicates, default is false
     * @return {store/SolrQuery}
     */

  }, {
    key: "integerFacet",
    value: function integerFacet(predicate) {
      var related = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      this.facet("".concat(related ? 'related.' : '', "metadata.predicate.integer.").concat(shorten(predicate)), predicate, related);
      return this;
    }
    /**
     * Tell the query construction to make the fields added via the property methods
     * (uriProperty, literalProperty and integerProperty) to be disjunctive rather than
     * conjunctive. For example:
     *
     *     es.newSolrQuery().disjunctiveProperties().literalProperty("dcterms:title", "banana")
     *          .uriProperty("dcterms:subject", "ex:Banana");
     *
     * Will search for entries that have either a "banana" in the title or a relation to
     * ex:Banana via dcterms:subject. The default, without disjunctiveProperties being called
     * is to create a conjunction, i.e. AND them together.
     *
     * @return {store/SolrQuery}
     */

  }, {
    key: "disjunctiveProperties",
    value: function disjunctiveProperties() {
      this.disjunctiveProperties = true;
      return this;
    }
    /**
     * Tell the query construction to make top level fields disjunctive rather than
     * conjunctive. For example
     *
     *     es.newSolrQuery().disjunctive().title("banana").description("tomato")
     *
     * Will search for entries that have either a "banana" in the title or "tomato" in the
     * description rather than entries that have both which is the default.
     *
     * @return {store/SolrQuery}
     */

  }, {
    key: "disjunctive",
    value: function disjunctive() {
      this.disjunctive = true;
      return this;
    }
    /**
     * Construct a SearchList fro this SolrQuery.
     *
     * @param asyncCallType
     * @returns {store/SearchList}
     */

  }, {
    key: "list",
    value: function list(asyncCallType) {
      return new _SearchList.default(this._entrystore, this, asyncCallType);
    }
    /**
     * Produces the actual query to the EntryStore API.
     * @return {string}
     * @protected
     */

  }, {
    key: "getQuery",
    value: function getQuery() {
      var _this2 = this;

      var and = [];

      if (this._title_lang != null) {
        and.push("title.".concat(this._title_lang.lang, ":").concat(solrFriendly(this._title_lang.lang, this._title_lang.value)));
      }

      this.params.forEach(function (v, key) {
        var modifier = _this2.modifiers.get(key);

        if (typeof v === 'string' && v !== '') {
          if (modifier === true || modifier === 'not') {
            and.push("NOT(".concat(key, ":").concat(solrFriendly(key, v), ")"));
          } else {
            and.push("".concat(key, ":").concat(solrFriendly(key, v)));
          }
        } else if (Array.isArray(v) && v.length > 0) {
          var or = [];
          v.forEach(function (ov) {
            if (typeof ov === 'string') {
              or.push("".concat(key, ":").concat(solrFriendly(key, ov)));
            }
          });

          if (modifier === true || modifier === 'not') {
            and.push("NOT(".concat(or.join('+OR+'), ")"));
          } else if (modifier === 'and') {
            and.push("(".concat(or.join('+AND+'), ")"));
          } else {
            and.push("(".concat(or.join('+OR+'), ")"));
          }
        }
      });

      if (this.relatedProperties.length > 0) {
        var or = [];
        this.relatedProperties.forEach(function (prop) {
          var obj = prop.object;
          var key = "related.metadata.predicate.".concat(prop.nodetype, ".").concat(prop.md5);

          if (typeof obj === 'string') {
            or.push("".concat(key, ":").concat(solrFriendly(key, obj, _this2.relatedFacetpredicates[prop.pred])));
          } else if (Array.isArray(obj) && obj.length > 0) {
            obj.forEach(function (o) {
              or.push("".concat(key, ":").concat(solrFriendly(key, o, _this2.relatedFacetpredicates[prop.pred])));
            });
          }
        });
        and.push("(".concat(or.join('+OR+'), ")"));
      }

      if (this.disjunctiveProperties || this.disjunctive) {
        var _or = [];
        this.properties.forEach(function (prop) {
          var obj = prop.object;
          var key = "metadata.predicate.".concat(prop.nodetype, ".").concat(prop.md5);

          if (typeof obj === 'string') {
            _or.push("".concat(key, ":").concat(solrFriendly(key, obj, _this2.facetpredicates[prop.pred])));
          } else if (Array.isArray(obj) && obj.length > 0) {
            obj.forEach(function (o) {
              _or.push("".concat(key, ":").concat(solrFriendly(key, o, _this2.facetpredicates[prop.pred])));
            });
          }
        });

        if (_or.length > 0) {
          and.push("(".concat(_or.join('+OR+'), ")"));
        }
      } else {
        this.properties.forEach(function (prop) {
          var obj = prop.object;
          var key = "metadata.predicate.".concat(prop.nodetype, ".").concat(prop.md5);

          if (typeof obj === 'string') {
            if (prop.modifier === true || prop.modifier === 'not') {
              and.push("NOT(".concat(key, ":").concat(solrFriendly(key, obj, _this2.facetpredicates[prop.pred]), ")"));
            } else {
              and.push("".concat(key, ":").concat(solrFriendly(key, obj, _this2.facetpredicates[prop.pred])));
            }
          } else if (Array.isArray(obj) && obj.length > 0) {
            var _or2 = [];
            obj.forEach(function (o) {
              _or2.push("".concat(key, ":").concat(solrFriendly(key, o, _this2.facetpredicates[prop.pred])));
            }, _this2);

            if (prop.modifier === true || prop.modifier === 'not') {
              and.push("NOT(".concat(_or2.join('+OR+'), ")"));
            } else if (prop.modifier === 'and') {
              and.push("(".concat(_or2.join('+AND+'), ")"));
            } else {
              and.push("(".concat(_or2.join('+OR+'), ")"));
            }
          }
        }, this);
      }

      this._and.forEach(function (struct) {
        and.push(buildQuery(struct, true));
      });

      this._or.forEach(function (struct) {
        and.push(buildQuery(struct, false));
      });

      var trail = '';

      if (this._limit != null) {
        trail = "&limit=".concat(this._limit);
      }

      if (this._offset) {
        trail = "".concat(trail, "&offset=").concat(this._offset);
      }

      if (this._sort) {
        trail = "".concat(trail, "&sort=").concat(this._sort || 'score+asc');
      }

      if (this.facets) {
        trail += "&facetFields=".concat(this.facets.join(','));
      }

      return "".concat(this._entrystore.getBaseURI(), "search?type=solr&query=").concat(and.join(this.disjunctive ? '+OR' : '+AND+')).concat(trail);
    }
    /**
     * @param page
     * @returns {Promise.<Array.<Entry>>} the promise will return an entry-array.
     * @see {store/List.getEntries}
     */

  }, {
    key: "getEntries",
    value: function getEntries(page) {
      return this.list().getEntries(page);
    }
    /**
     * @param func
     * @return {promise}
     * @see {store/List.forEach}
     */

  }, {
    key: "forEach",
    value: function forEach(func) {
      return this.list().forEach(func);
    }
  }]);

  return SolrQuery;
}();

exports.default = SolrQuery;

/***/ }),

/***/ "./src/String.js":
/*!***********************!*\
  !*** ./src/String.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Resource2 = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * String is a resource for handling simple strings of data.
 *
 * @exports store/String
 */
var StringResource =
/*#__PURE__*/
function (_Resource) {
  _inherits(StringResource, _Resource);

  /**
   * @param {string} entryURI - URI to an entry where this resource is contained.
   * @param {string} resourceURI - URI to the resource.
   * @param {store/EntryStore} entryStore - the API's repository instance.
   * @param {string} data - the actual string, may the empty string, but not null or undefined.
   */
  function StringResource(entryURI, resourceURI, entryStore, data) {
    var _this;

    _classCallCheck(this, StringResource);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(StringResource).call(this, entryURI, resourceURI, entryStore)); // Call the super constructor.

    _this._data = data;
    return _this;
  }
  /**
   * @returns {string} may be an empty string, never null or undefined.
   */


  _createClass(StringResource, [{
    key: "getString",
    value: function getString() {
      return this._data;
    }
    /**
     * Set a new string, does not save it to the repository, use commit for that. E.g.
     *
     *     stringresource.setString("New value").commit().then(function() {...});
     *
     * @param {string} string - the new string
     * @returns {store/StringResource} allows chaining with commit.
     * @see store/String#commit
     */

  }, {
    key: "setString",
    value: function setString(string) {
      this._data = string || '';
      return this;
    }
    /**
     * Pushes the string back to the repository.
     *
     * @returns {Promise}
     * @see store/String#setString
     */

  }, {
    key: "commit",
    value: function commit() {
      return this._entryStore.handleAsync(es.getREST().put(this._resourceURI, this._data), 'commitString');
    }
  }, {
    key: "getSource",
    value: function getSource() {
      return this._data;
    }
  }]);

  return StringResource;
}(_Resource2.default);

exports.default = StringResource;

/***/ }),

/***/ "./src/User.js":
/*!*********************!*\
  !*** ./src/User.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Resource2 = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

/**
 * User instances are resources corresponding to users that can be authenticated to access
 * the EntryStore repository. The user resource URI can be referred to from access control lists.
 *
 * @exports store/User
 */
var User =
/*#__PURE__*/
function (_Resource) {
  _inherits(User, _Resource);

  /**
   * @param {string} entryURI - URI to an entry where this resource is contained.
   * @param {string} resourceURI - URI to the resource.
   * @param {store/EntryStore} entryStore - the API's repository instance.
   * @param {Object} data - information about the user, e.g. object with name and homecontext.
   */
  function User(entryURI, resourceURI, entryStore, data) {
    var _this;

    _classCallCheck(this, User);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(User).call(this, entryURI, resourceURI, entryStore));
    _this._data = data;
    return _this;
  }
  /**
   * Get the name of the user, this is a a unique name (username) in the current repository's
   * _principals context.
   * @returns {string}
   */


  _createClass(User, [{
    key: "getName",
    value: function getName() {
      return this._data.name;
    }
    /**
     * Set a new name (username), it will not succeed if it is already in use, for instance by
     * another user or group.
     * @param {string} name
     * @returns {Promise}
     */

  }, {
    key: "setName",
    value: function setName(name) {
      var _this2 = this;

      var oldName = this._data.name;
      this._data.name = name;
      return this._entryStore.handleAsync(es.getREST().put(this._resourceURI, JSON.stringify({
        name: name
      })).then(function (data) {
        var entry = _this2.getEntry(true);

        if (entry) {
          entry.getEntryInfo()._name = name;
        }

        return data;
      }, function (e) {
        _this2._data.name = oldName;
        throw e;
      }), 'setUserName');
    }
    /**
     * Get the preferred language of the user.
     * @returns {string}
     */

  }, {
    key: "getLanguage",
    value: function getLanguage() {
      return this._data.language;
    }
    /**
     * Sets the preferred language of a user.
     * @param {string} language
     * @returns {Promise}
     */

  }, {
    key: "setLanguage",
    value: function setLanguage(language) {
      var _this3 = this;

      var oldLang = this._data.language;
      this._data.language = language;
      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify({
        language: language
      })).then(function (data) {
        return data;
      }, function (e) {
        _this3._data.language = oldLang;
        throw e;
      }), 'setUserLanguage');
    }
    /**
     * Set a new password for the user.
     *
     * @param {string} password - a new password, should be at least 8 characters long.
     * @returns {Promise}
     */

  }, {
    key: "setPassword",
    value: function setPassword(password) {
      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify({
        password: password
      })), 'setUserPassword');
    }
    /**
     * Check if the user is disabled. Disabled users cannot sign in, although they still exist
     * for lookup, e.g. when presenting creators and contributors.
     * @returns {boolean}
     */

  }, {
    key: "isDisabled",
    value: function isDisabled() {
      return this._data.disabled === true;
    }
    /**
     * Set the user to be disabled or not.
     * @param {boolean} disabled
     * @returns {Promise}
     */

  }, {
    key: "setDisabled",
    value: function setDisabled(disabled) {
      var _this4 = this;

      if (disabled === this.isDisabled()) {
        return Promise.resolve(true);
      }

      var oldDisabled = this._data.disabled === true;
      this._data.disabled = disabled;
      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify({
        disabled: disabled
      })).then(function (data) {
        var entry = _this4.getEntry(true);

        if (entry) {
          entry.getEntryInfo()._disabled = disabled;
        }

        return data;
      }, function (e) {
        _this4._data.disabled = oldDisabled;
        throw e;
      }), 'setUserDisabled');
    }
    /**
     * Get the home context for this user.
     *
     * @returns {string} - a context id (not the full resource URI).
     */

  }, {
    key: "getHomeContext",
    value: function getHomeContext() {
      return this._data.homecontext;
    }
    /**
     * Set a new home context for this user.
     *
     * @param {string} contextId - a context id (not the full resource URI).
     * @returns {Promise}
     */

  }, {
    key: "setHomeContext",
    value: function setHomeContext(contextId) {
      var _this5 = this;

      var oldHomeContext = this._data.homecontext;
      this._data.homecontext = contextId;
      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify({
        homecontext: contextId
      })).then(function (data) {
        return data;
      }, function (e) {
        _this5._data.homecontext = oldHomeContext;
        throw e;
      }), 'setUserHomeContext');
    }
    /**
     * Get custom properties.
     *
     * @returns {object} - key value pairs of custom properties.
     */

  }, {
    key: "getCustomProperties",
    value: function getCustomProperties() {
      return this._data.customProperties || {};
    }
    /**
     * Set a new home context for this user.
     *
     * @param {object} customProperties
     * @returns {Promise}
     */

  }, {
    key: "setCustomProperties",
    value: function setCustomProperties(customProperties) {
      var _this6 = this;

      var oldCustomProperties = this._data.customProperties;
      this._data.customProperties = customProperties;
      return this._entryStore.handleAsync(this._entryStore.getREST().put(this._resourceURI, JSON.stringify({
        customProperties: customProperties
      })).then(function (data) {
        return data;
      }, function (e) {
        _this6._data.customProperties = oldCustomProperties;
        throw e;
      }), 'setUserCustomProperties');
    }
    /**
     *
     * @return {Object}
     */

  }, {
    key: "getSource",
    value: function getSource() {
      return this._data;
    }
  }]);

  return User;
}(_Resource2.default);

exports.default = User;

/***/ }),

/***/ "./src/factory.js":
/*!************************!*\
  !*** ./src/factory.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

var _Context = _interopRequireDefault(__webpack_require__(/*! ./Context */ "./src/Context.js"));

var _Entry = _interopRequireDefault(__webpack_require__(/*! ./Entry */ "./src/Entry.js"));

var _EntryInfo = _interopRequireDefault(__webpack_require__(/*! ./EntryInfo */ "./src/EntryInfo.js"));

var _File = _interopRequireDefault(__webpack_require__(/*! ./File */ "./src/File.js"));

var _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph */ "./src/Graph.js"));

var _Group = _interopRequireDefault(__webpack_require__(/*! ./Group */ "./src/Group.js"));

var _List = _interopRequireDefault(__webpack_require__(/*! ./List */ "./src/List.js"));

var _Pipeline = _interopRequireDefault(__webpack_require__(/*! ./Pipeline */ "./src/Pipeline.js"));

var _SearchList = _interopRequireDefault(__webpack_require__(/*! ./SearchList */ "./src/SearchList.js"));

var _String = _interopRequireDefault(__webpack_require__(/*! ./String */ "./src/String.js"));

var _types = _interopRequireDefault(__webpack_require__(/*! ./types */ "./src/types.js"));

var _User = _interopRequireDefault(__webpack_require__(/*! ./User */ "./src/User.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This module contains utility methods that encapsulates EntryStores REST layer from the rest
 * of the code. It is intended to be used internally by the EntryStore.js API,
 * not by application developers.
 *
 * Hence, **you should avoid using factory methods directly in application code as there are
 * most probably other ways to achieve the same thing. Most likely by using method in
 * {@link store/EntryStore}!**
 *
 * The utility methods are currently not visible as they are not documented yet.
 * (The methods cannot be marked as private as they need to be used throughout the API.)
 *
 * @exports store/factory
 * @namespace
 */
var sortObj = {
  sortBy: 'title',
  prio: 'List'
};
var defaultLimit = 50;

var getContextForEntry = function getContextForEntry(entryURI, entryStore) {
  var baseURI = entryStore.getBaseURI();
  var contextId = entryURI.substr(baseURI.length, entryURI.indexOf('/', baseURI.length) - baseURI.length);
  var contexts = entryStore.getCachedContextsIdx();
  var context = contexts[contextId];

  if (!context) {
    context = new _Context.default("".concat(baseURI, "_contexts/entry/").concat(contextId), baseURI + contextId, entryStore);
    contexts[contextId] = context;
  }

  return context;
};

var transformRights = function transformRights(rights) {
  var o = {};
  var r = rights || [];

  for (var n = 0; n < r.length; n++) {
    o[r[n]] = true;
  }

  return o;
};

var fixNameAndDisabled = function fixNameAndDisabled(resObj, data) {
  var resource = data.resource; // Special case of searches and similar when name is provided but not full resource.

  if (resObj != null) {
    if (resource && typeof resource.name === 'string') {
      if (resObj instanceof _User.default) {
        resObj._data = resObj._data || {};
        resObj._data.name = resource.name;
      } else {
        // Context and Group
        resObj._name = resource.name;
      }
    }

    if (resObj instanceof _User.default) {
      resObj._data = resObj._data || {};

      if (resource && typeof resource.disabled === 'boolean') {
        resObj._data.disabled = resource.disabled;
      }
    }
  }
};

var _updateOrCreateResource = function _updateOrCreateResource(entry, data, force) {
  var _data = data || {};

  var resource = entry.getResource(true);
  var uri = entry.getURI();
  var ruri = entry.getResourceURI();
  var cruri = entry.getContext().getResourceURI();
  var es = entry.getEntryStore();
  var ei = entry.getEntryInfo();

  if (!resource && ei.getEntryType() === _types.default.ET_LOCAL && ei.getResourceType() === _types.default.RT_INFORMATIONRESOURCE) {
    switch (entry.getEntryInfo().getGraphType()) {
      case _types.default.GT_CONTEXT:
        // Synchronous resource, asynchronous methods.
        // Dummy URL to find the right context.
        resource = getContextForEntry("".concat(es.getBaseURI() + entry.getId(), "/"), entry.getEntryStore());

        resource._update(_data);

        break;

      case _types.default.GT_LIST: // Synchronous resource, asynchronous methods.

      case _types.default.GT_GROUP:
        // Synchronous resource, asynchronous methods.
        if (entry.isGroup()) {
          resource = new _Group.default(uri, ruri, es);
        } else {
          resource = new _List.default(uri, ruri, es);
        }

        if (_data.resource && _data.resource.children) {
          resource._update(_data.resource, _data.resource.children.map(function (child) {
            return updateOrCreate("".concat(cruri, "/entry/").concat(child.entryId), child, es);
          }));
        }

        break;

      case _types.default.GT_USER:
        // Asynchronous resource, synchronous getters.
        if (force || _data.resource != null) {
          resource = new _User.default(uri, ruri, es, _data.resource || {});
        }

        break;

      case _types.default.GT_STRING:
        if (force || _data.resource != null) {
          resource = new _String.default(uri, ruri, es, _data.resource || '');
        }

        break;

      case _types.default.GT_GRAPH:
        // Sync or Async?
        if (force || _data.resource != null) {
          resource = new _Graph.default(uri, ruri, es, _data.resource || {});
        }

        break;

      case _types.default.GT_PIPELINE:
        // Sync or Async?
        if (force || _data.resource != null) {
          resource = new _Pipeline.default(uri, ruri, es, _data.resource || {});
        }

        break;

      case _types.default.GT_PIPELINERESULT: // If local, Pipelineresult resource is a file.

      case _types.default.GT_NONE:
        // Uploaded file.
        resource = new _File.default(uri, ruri, es);
        break;

      default:
    }

    entry._resource = resource;
    fixNameAndDisabled(resource, _data);
    return;
  }

  if (resource == null || _data.resource == null) {
    fixNameAndDisabled(resource, _data);
    return;
  }

  if (resource._update) {
    if (entry.isList() || entry.isGroup()) {
      if (_data.resource && _data.resource.children) {
        resource._update(_data.resource, _data.resource.children.map(function (child) {
          return updateOrCreate("".concat(cruri, "/entry/").concat(child.entryId), child, entry.getEntryStore());
        }));
      }
    } else {
      resource._update(_data.resource);
    }
  }
};

var _updateEntry = function _updateEntry(entry, data) {
  entry._metadata = data.metadata ? new _rdfjson.Graph(data.metadata) : null;
  entry._cachedExternalMetadata = data['cached-external-metadata'] ? new _rdfjson.Graph(data['cached-external-metadata']) : null;
  entry._inferredMetadata = data.inferred ? new _rdfjson.Graph(data.inferred) : null;
  entry._extractedMetadata = data['extracted-metadata'] ? new _rdfjson.Graph(data['extracted-metadata']) : null;
  entry._relation = data.relations ? new _rdfjson.Graph(data.relations) : new _rdfjson.Graph();
  entry._rights = transformRights(data.rights); // Sometimes we get the name that is really part of the resource without getting the full
  // resource, in this case we store this in the entryinfo.

  if (data.name || data.resource && data.resource.name) {
    var ei = entry.getEntryInfo(); // ei._alias = data.alias;

    ei._name = data.name || data.resource.name;
  } // Sometimes we get the disabled state that is really part of the resource
  // without getting the full resource, in this case we store this in the entryinfo.


  if (data.disabled || data.resource && data.resource.disabled) {
    var _ei = entry.getEntryInfo();

    _ei._disabled = data.disabled || data.resource.disabled;
  }

  return entry;
};
/**
 *
 * @param entryStore
 * @param contextEntryURI
 * @return {store/Context}
 */


var getContext = function getContext(entryStore, contextEntryURI) {
  var baseURI = entryStore.getBaseURI();
  var contextsBaseURI = "".concat(baseURI, "_contexts/entry/");
  var contextId = contextEntryURI.substr(contextsBaseURI.length);
  var contexts = entryStore.getCachedContextsIdx();
  var context = contexts[contextId];

  if (!context) {
    context = new _Context.default(contextEntryURI, baseURI + contextId, entryStore);
    contexts[contextId] = context;
  }

  return context;
};
/**
 *
 * @param entryStore
 * @param entryURI
 * @return {List}
 */


var getList = function getList(entryStore, entryURI) {
  var cache = entryStore.getCache();
  var entry = cache.get(entryURI);

  if (!entry) {
    // If no entry is in cache, create an empty entry
    // Assuming there is an info object... TODO check so not info_stub remains in rest layer.
    var entryInfo = new _EntryInfo.default(entryURI, new _rdfjson.Graph(), entryStore);
    var context = getContextForEntry(entryURI, entryStore);
    entry = new _Entry.default(context, entryInfo);
    var resourceURI = entryURI.replace('/entry/', '/resource/');
    entry._resource = new _List.default(entryURI, resourceURI, entryStore);
    cache.cache(entry, true); // Add to cache silently

    entry.setRefreshNeeded(true); // Make sure it needs to be updated before accessed
  } // Returning only the list which has no reference to the entry isolates the entry from
  // being accessed before refreshed.


  return entry._resource;
};
/**
 *
 * @param entryURI
 * @param data
 * @param entryStore
 * @return {Entry}
 */


var updateOrCreate = function updateOrCreate(entryURI, data, entryStore) {
  var cache = entryStore.getCache();
  var entry = cache.get(entryURI);

  if (entry) {
    entry.getEntryInfo().setGraph(new _rdfjson.Graph(data.info));
  } else {
    // Assuming there is an info object... TODO check so not info_stub remains in rest layer.
    var entryInfo = new _EntryInfo.default(entryURI, new _rdfjson.Graph(data.info), entryStore);
    var context = getContextForEntry(entryURI, entryStore);
    entry = new _Entry.default(context, entryInfo);
  }

  _updateEntry(entry, data);

  _updateOrCreateResource(entry, data);

  cache.cache(entry); // Add to or refresh the cache.

  return entry;
};
/**
 *
 * @type {_updateOrCreateResource}
 */


var updateOrCreateResource = _updateOrCreateResource;
/**
 *
 * @param {Entry} entry
 * @param {Object} data
 */

var update = function update(entry, data) {
  entry.getEntryInfo().setGraph(new _rdfjson.Graph(data.info));

  _updateOrCreateResource(entry, data);

  _updateEntry(entry, data);

  entry.getEntryStore().getCache().cache(entry); // Add to or refresh the cache.
};
/**
 *
 * @param entryStore
 * @param query
 * @return {SearchList}
 */


var createSearchList = function createSearchList(entryStore, query) {
  return new _SearchList.default(entryStore, query);
};
/**
 *
 * @param data
 * @param list
 * @param entryStore
 * @return {Array.<Entry>}
 */


var extractSearchResults = function extractSearchResults(data, list, entryStore) {
  // Update or create all entries received
  // TODO change rest api so offset is inside of resource.
  data.resource.offset = data.resource.offset || data.offset; // TODO change rest api so size is inside of resource.

  data.resource.size = data.resource.size || data.results;
  var baseURI = entryStore.getBaseURI();
  var entries = data.resource.children.map(function (child) {
    return updateOrCreate("".concat(baseURI + child.contextId, "/entry/").concat(child.entryId), child, entryStore);
  });

  list._update(data.resource, entries);

  return entries;
};
/**
 *
 * @param entryURI
 * @return {string}
 */


var getCachedExternalMetadataURI = function getCachedExternalMetadataURI(entryURI) {
  return entryURI.replace('/entry/', '/cached-external-metadata/');
};
/**
 * @deprecated in favor of {@link store/factory#getEntryId}
 */


var getId = function getId(uri) {
  return uri.substr(uri.lastIndexOf('/') + 1);
};
/**
 *
 * @param uri
 * @param base
 * @return {string|undefined}
 */


var getEntryId = function getEntryId(uri, base) {
  var _uri = uri;

  if (base) {
    _uri = _uri.substr(base.length - 1); // include the / before.
  }

  var res = _uri.match(/\/([^/]+)\/(entry|resource|metadata|relation)\/([^?/]+)(\?.*)?$/);

  if (res) {
    return res[3];
  } else if (_uri.lastIndexOf('/') === 0) {
    return _uri.substr(1);
  } else if (!base) {
    return _uri.substr(_uri.lastIndexOf('/') + 1);
  }

  return undefined;
};
/**
 *
 * @param uri
 * @param base
 * @return {string|undefined}
 */


var getContextId = function getContextId(uri, base) {
  var _uri = uri;

  if (base) {
    _uri = _uri.substr(base.length - 1); // include the / before.
  }

  var res = _uri.match(/\/([^/]+)\/(entry|resource|metadata|relation)\/([^?/]+)(\?.*)?$/);

  if (res) {
    return res[1];
  } else if (_uri.indexOf('/') === -1 || !base) {
    return '_contexts';
  }

  return undefined;
};
/**
 *
 * @param entryStore
 * @param uri
 * @return {string}
 */


var getEntryURIFromURI = function getEntryURIFromURI(entryStore, uri) {
  var base = entryStore.getBaseURI();
  return "".concat(base + getContextId(uri, base), "/entry/").concat(getEntryId(uri, base));
};
/**
 *
 * @param entryStore
 * @param contextId
 * @param entryId
 * @return {string}
 */


var getEntryURI = function getEntryURI(entryStore, contextId, entryId) {
  return "".concat(entryStore.getBaseURI()).concat(contextId, "/entry/").concat(entryId);
};
/**
 *
 * @param entryStore
 * @param uri
 * @return {string}
 */


var getMetadataURIFromURI = function getMetadataURIFromURI(entryStore, uri) {
  var base = entryStore.getBaseURI();
  return "".concat(base + getContextId(uri, base), "/metadata/").concat(getEntryId(uri, base));
};
/**
 *
 * @param entryStore
 * @param contextId
 * @param entryId
 * @return {string}
 */


var getMetadataURI = function getMetadataURI(entryStore, contextId, entryId) {
  return "".concat(entryStore.getBaseURI()).concat(contextId, "/entry/").concat(entryId);
};
/**
 *
 * @param entryStore
 * @param contextId
 * @return {string}
 */


var getResourceBase = function getResourceBase(entryStore, contextId) {
  return "".concat(entryStore.getBaseURI() + contextId, "/resource/");
};
/**
 *
 * @param entryStore
 * @param contextId
 * @param entryId
 * @return {string}
 */


var getResourceURI = function getResourceURI(entryStore, contextId, entryId) {
  if (contextId === '_contexts') {
    return entryStore.getBaseURI() + entryId;
  }

  return "".concat(entryStore.getBaseURI() + contextId, "/resource/").concat(entryId);
};
/**
 *
 * @param data
 * @param context
 * @return {string}
 */


var getURIFromCreated = function getURIFromCreated(data, context) {
  return "".concat(context.getResourceURI(), "/entry/").concat(data.entryId);
};
/**
 *
 * @param entryURI
 * @param params
 * @return {string}
 */


var getEntryLoadURI = function getEntryLoadURI(entryURI, params) {
  var _params = params || {};

  var strL = '';

  if (_params.limit > 0 || _params.limit === -1) {
    strL = "&limit=".concat(_params.limit);
  } else {
    strL = "&limit=".concat(defaultLimit);
  }

  var strO = _params.offset == null || _params.offset === 0 ? '' : "&offset=".concat(_params.offset);
  var sort = _params.sort == null ? sortObj : _params.sort;
  var strSort = '';
  var strDesc = '';
  var strPrio = '';

  if (sort != null) {
    strSort = sort.sortBy == null ? '' : "&sort=".concat(sort.sortBy);
    strDesc = sort.descending === true ? '&order=desc' : '';
    strPrio = sort.prio == null ? '' : "&prio=".concat(sort.prio); // TODO lang remains.
  }

  return "".concat(entryURI, "?includeAll").concat(strL).concat(strO).concat(strSort).concat(strDesc).concat(strPrio);
};
/**
 *
 * @param prototypeEntry
 * @param parentListEntry
 * @return {string}
 */


var getEntryCreateURI = function getEntryCreateURI(prototypeEntry, parentListEntry) {
  var uri = "".concat(prototypeEntry.getContext().getResourceURI(), "?");

  if (prototypeEntry) {
    var ei = prototypeEntry.getEntryInfo();

    if (prototypeEntry.getSpecificId() != null) {
      uri = "".concat(uri, "id=").concat(prototypeEntry.getSpecificId(), "&");
    }

    if (prototypeEntry.isLink()) {
      uri = "".concat(uri, "resource=").concat(encodeURIComponent(prototypeEntry.getResourceURI()), "&");
    }

    if (prototypeEntry.isReference() || prototypeEntry.isLinkReference()) {
      // external metadata
      uri = "".concat(uri, "resource=").concat(encodeURIComponent(prototypeEntry.getResourceURI()), "&");
      uri = "".concat(uri, "cached-external-metadata=").concat(encodeURIComponent(ei.getExternalMetadataURI()), "&");
    }

    if (ei.getEntryType() !== _types.default.ET_LOCAL) {
      // local, link, linkreference, reference
      uri = "".concat(uri, "entrytype=").concat(ei.getEntryType().toLowerCase(), "&");
    } // informationresource, namedresource


    if (ei.getResourceType() !== _types.default.RT_INFORMATIONRESOURCE) {
      // TODO Bug in REST layer, should be resourcetype, is now informationresource innstead
      uri = "".concat(uri, "informationresource=false&");
    }

    if (ei.getGraphType() !== _types.default.GT_NONE) {
      uri = "".concat(uri, "graphtype=").concat(ei.getGraphType().toLowerCase(), "&");
    }
  }

  if (parentListEntry) {
    uri = "".concat(uri, "list=").concat(parentListEntry.getResourceURI(), "&");
  }

  return uri.slice(0, -1);
};
/**
 *
 * @param prototypeEntry
 * @return {string}
 */


var getEntryCreatePostData = function getEntryCreatePostData(prototypeEntry) {
  var postData = {};
  var empty = true;
  var md = prototypeEntry.getMetadata();

  if (md != null && !md.isEmpty()) {
    postData.metadata = md.exportRDFJSON();
    empty = false;
  }

  var re = prototypeEntry.getResource(true);

  if (re != null && re.getSource != null) {
    postData.resource = re.getSource();
    empty = false;
  }

  var ei = prototypeEntry.getEntryInfo().getGraph();

  if (ei != null && !ei.isEmpty()) {
    postData.info = ei.exportRDFJSON();
    empty = false;
  }

  var cachedExternalMetadata = prototypeEntry.getCachedExternalMetadata();

  if (cachedExternalMetadata != null && !cachedExternalMetadata.isEmpty()) {
    postData['cached-external-metadata'] = cachedExternalMetadata.exportRDFJSON();
    empty = false;
  }

  return empty ? '' : JSON.stringify(postData);
};
/**
 *
 * @param entry
 * @param fromListEntry
 * @param toListEntry
 * @param baseURI
 * @return {string}
 */


var getMoveURI = function getMoveURI(entry, fromListEntry, toListEntry, baseURI) {
  var entryURI = entry.getURI().substr(baseURI.length); // Only send something like 3/entry/2

  var furi = fromListEntry.getResourceURI().substr(baseURI.length);
  return "".concat(toListEntry.getResourceURI(), "?moveEntry=").concat(entryURI, "&fromList=").concat(furi);
};
/**
 *
 * @param baseURI
 * @param uri
 * @param formatHint
 * @return {string}
 */


var getProxyURI = function getProxyURI(baseURI, uri, formatHint) {
  var url = "".concat(baseURI, "proxy?url=").concat(encodeURIComponent(uri));

  if (formatHint != null) {
    url += "&fromFormat=".concat(formatHint);
  }

  return url;
};
/**
 *
 * @param uri
 * @return {string}
 */


var getPutFileURI = function getPutFileURI(uri) {
  return "".concat(uri + (uri.indexOf('?') < 0 ? '?' : '&'), "method=put&textarea=true");
};
/**
 * @param sortObject
 */


var setSort = function setSort(sortObject) {
  sortObj = sortObject;
};
/**
 * @return {{sortBy: string, prio: string}}
 */


var getSort = function getSort() {
  return sortObj;
};
/**
 *
 * @return {number}
 */


var getDefaultLimit = function getDefaultLimit() {
  return defaultLimit;
};
/**
 *
 * @param limit
 */


var setDefaultLimit = function setDefaultLimit(limit) {
  defaultLimit = limit;
};

var _default = {
  getContext: getContext,
  getList: getList,
  updateOrCreate: updateOrCreate,
  updateOrCreateResource: updateOrCreateResource,
  update: update,
  createSearchList: createSearchList,
  extractSearchResults: extractSearchResults,
  getCachedExternalMetadataURI: getCachedExternalMetadataURI,
  getId: getId,
  getEntryId: getEntryId,
  getContextId: getContextId,
  getEntryURIFromURI: getEntryURIFromURI,
  getEntryURI: getEntryURI,
  getMetadataURIFromURI: getMetadataURIFromURI,
  getMetadataURI: getMetadataURI,
  getResourceBase: getResourceBase,
  getResourceURI: getResourceURI,
  getURIFromCreated: getURIFromCreated,
  getEntryLoadURI: getEntryLoadURI,
  getEntryCreateURI: getEntryCreateURI,
  getEntryCreatePostData: getEntryCreatePostData,
  getMoveURI: getMoveURI,
  getProxyURI: getProxyURI,
  getPutFileURI: getPutFileURI,
  setSort: setSort,
  getSort: getSort,
  getDefaultLimit: getDefaultLimit,
  setDefaultLimit: setDefaultLimit
};
exports.default = _default;

/***/ }),

/***/ "./src/html.js":
/*!*********************!*\
  !*** ./src/html.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

/**
 * A module that contain utility methods for generating html for entries.
 *
 * @exports store/html
 * @namespace
 */
var html = {}; // The above construction seem to be needed because of jsdoc3 issues with not detecting the
// exports variable.

/**
 * Generates a table with columns subject, predicate, and object.
 * @param {store/Entry} entry to expose metadata for
 * @returns {string} rendered html as a string
 */

html.metadataTable = function (entry) {
  var delegates = _rdfjson.print.prettyTree(entry.getMetadata(), entry.getResourceURI());

  var arr = [];

  for (var i = 0; i < delegates.length; i++) {
    var d = delegates[i];
    var st = d.stmt;
    arr.push("".concat('<tr>' + "<td class='rdf_subject'>").concat(st.isSubjectBlank() ? d.s : "<a href='".concat(st.getSubject(), "'>").concat(d.s, "</a>"), "</td>") + "<td class='rdf_predicate'><a href='".concat(st.getPredicate(), "'>").concat(d.p, "</a></td>") + "<td class='rdf_object'>".concat(st.getType() === 'uri' ? "<a href='".concat(st.getValue(), "'>").concat(d.o, "</a>") : d.o, "</td></tr>"));
  }

  return arr.join('\n');
};

var _ind = {};

var indenter = function indenter(indent) {
  if (!_ind[indent]) {
    var str = '';

    for (var i = 1; i < indent; i++) {
      str += "<span class='rdf_indent'></span>";
    }

    _ind[indent] = str;
  }

  return _ind[indent];
};
/**
 * Prints one level of triples from a subject where URIs are namespaced.
 *
 * @param {rdfjson/Graph} graph the graph containing the metadata
 * @param {string} subject URI to a resource to start from
 * @returns {string} string with the triples rendered as HTML.
 */


html.metadataIndent = function (graph, subject) {
  var delegates = _rdfjson.print.prettyTree(graph, subject);

  var arr = [];

  for (var i = 0; i < delegates.length; i++) {
    var d = delegates[i];
    var st = d.stmt;
    arr.push("<div class='rdf_statement'>".concat(indenter(d.indent), "<span class='rdf_subject'>").concat(st.isSubjectBlank() ? d.s : "<a href='".concat(st.getSubject(), "'>").concat(d.s, "</a>"), "</span>") + "<span class='rdf_predicate'><a href='".concat(st.getPredicate(), "'>").concat(d.p, "</a></span>") + "<span class='rdf_object'>".concat(st.getType() === 'uri' ? "<a href='".concat(st.getValue(), "'>").concat(d.o, "</a>") : d.o, "</span></div>"));
  }

  return arr.join('\n');
};
/**
 * Prints the three types of the entry, i.e. entry, resource and graphtype.
 * @param {store/EntryInfo} entryInfo
 * @returns {string}
 */


html.entryInfo = function (entryInfo) {
  return "<span class='info entrytype'><label>EntryType:</label> ".concat(entryInfo.getEntryType(), "</span>") + "<span class='info resourceType'><label>ResourceType:</label> ".concat(entryInfo.getResourceType(), "</span>") + "<span class='info graphType'><label>GraphType:</label> ".concat(entryInfo.getGraphType(), "</span>");
};
/**
 * Prints information about the entry, including entryinfo, metadata, cached external metadata
 * as well as which context the entry belongs to.
 *
 * @param {store/Entry} entry
 * @returns {string} information about the entry as a HTML string.
 */


html.print = function (entry) {
  var strs = ["".concat("<div class='entry'>" + "<h3>Context: <a class='contextURI' href='").concat(entry.getContext().getEntryURI(), "'>").concat(entry.getContext().getId(), "</a> <span></span> ") + "Entry: <a class='entryURI' href='".concat(entry.getURI(), "'>").concat(entry.getId(), "</a></h3>") + '<div>' + "<div class='entryInfo'>".concat(html.entryInfo(entry.getEntryInfo()), "</div>")];
  var md = entry.getMetadata();

  if (md && !md.isEmpty()) {
    strs.push("<h4>Local metadata:</h4><div class='metadata'>".concat(html.metadataIndent(md, entry.getResourceURI()), "</div>"));
  }

  var emd = entry.getCachedExternalMetadata();

  if (emd && !emd.isEmpty()) {
    strs.push("<h4>Cached external metadata:</h4><div class='metadata'>".concat(html.metadataIndent(emd, entry.getResourceURI()), "</div>"));
  }

  strs.push('</div></div>');
  return strs.join('');
};

var _default = html;
exports.default = _default;

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "factory", {
  enumerable: true,
  get: function get() {
    return _factory.default;
  }
});
Object.defineProperty(exports, "html", {
  enumerable: true,
  get: function get() {
    return _html.default;
  }
});
Object.defineProperty(exports, "promiseUtil", {
  enumerable: true,
  get: function get() {
    return _promiseUtil.default;
  }
});
Object.defineProperty(exports, "rest", {
  enumerable: true,
  get: function get() {
    return _Rest.default;
  }
});
Object.defineProperty(exports, "solr", {
  enumerable: true,
  get: function get() {
    return _SolrQuery.default;
  }
});
Object.defineProperty(exports, "types", {
  enumerable: true,
  get: function get() {
    return _types.default;
  }
});
Object.defineProperty(exports, "Auth", {
  enumerable: true,
  get: function get() {
    return _Auth.default;
  }
});
Object.defineProperty(exports, "Cache", {
  enumerable: true,
  get: function get() {
    return _Cache.default;
  }
});
Object.defineProperty(exports, "Context", {
  enumerable: true,
  get: function get() {
    return _Context.default;
  }
});
Object.defineProperty(exports, "Entry", {
  enumerable: true,
  get: function get() {
    return _Entry.default;
  }
});
Object.defineProperty(exports, "EntryInfo", {
  enumerable: true,
  get: function get() {
    return _EntryInfo.default;
  }
});
Object.defineProperty(exports, "EntryStore", {
  enumerable: true,
  get: function get() {
    return _EntryStore.default;
  }
});
Object.defineProperty(exports, "EntryStoreUtil", {
  enumerable: true,
  get: function get() {
    return _EntryStoreUtil.default;
  }
});
Object.defineProperty(exports, "File", {
  enumerable: true,
  get: function get() {
    return _File.default;
  }
});
Object.defineProperty(exports, "Graph", {
  enumerable: true,
  get: function get() {
    return _Graph.default;
  }
});
Object.defineProperty(exports, "Group", {
  enumerable: true,
  get: function get() {
    return _Group.default;
  }
});
Object.defineProperty(exports, "List", {
  enumerable: true,
  get: function get() {
    return _List.default;
  }
});
Object.defineProperty(exports, "Pipeline", {
  enumerable: true,
  get: function get() {
    return _Pipeline.default;
  }
});
Object.defineProperty(exports, "PrototypeEntry", {
  enumerable: true,
  get: function get() {
    return _PrototypeEntry.default;
  }
});
Object.defineProperty(exports, "Resource", {
  enumerable: true,
  get: function get() {
    return _Resource.default;
  }
});
Object.defineProperty(exports, "SearchList", {
  enumerable: true,
  get: function get() {
    return _SearchList.default;
  }
});
Object.defineProperty(exports, "String", {
  enumerable: true,
  get: function get() {
    return _String.default;
  }
});
Object.defineProperty(exports, "User", {
  enumerable: true,
  get: function get() {
    return _User.default;
  }
});
Object.defineProperty(exports, "terms", {
  enumerable: true,
  get: function get() {
    return _terms.default;
  }
});
Object.defineProperty(exports, "utils", {
  enumerable: true,
  get: function get() {
    return _utils.default;
  }
});
Object.defineProperty(exports, "namespaces", {
  enumerable: true,
  get: function get() {
    return _rdfjson.namespaces;
  }
});

__webpack_require__(/*! core-js/stable */ "./node_modules/core-js/stable/index.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "./node_modules/regenerator-runtime/runtime.js");

var _factory = _interopRequireDefault(__webpack_require__(/*! ./factory */ "./src/factory.js"));

var _html = _interopRequireDefault(__webpack_require__(/*! ./html */ "./src/html.js"));

var _promiseUtil = _interopRequireDefault(__webpack_require__(/*! ./promiseUtil */ "./src/promiseUtil.js"));

var _Rest = _interopRequireDefault(__webpack_require__(/*! ./Rest */ "./src/Rest.js"));

var _SolrQuery = _interopRequireDefault(__webpack_require__(/*! ./SolrQuery */ "./src/SolrQuery.js"));

var _types = _interopRequireDefault(__webpack_require__(/*! ./types */ "./src/types.js"));

var _Auth = _interopRequireDefault(__webpack_require__(/*! ./Auth */ "./src/Auth.js"));

var _Cache = _interopRequireDefault(__webpack_require__(/*! ./Cache */ "./src/Cache.js"));

var _Context = _interopRequireDefault(__webpack_require__(/*! ./Context */ "./src/Context.js"));

var _Entry = _interopRequireDefault(__webpack_require__(/*! ./Entry */ "./src/Entry.js"));

var _EntryInfo = _interopRequireDefault(__webpack_require__(/*! ./EntryInfo */ "./src/EntryInfo.js"));

var _EntryStore = _interopRequireDefault(__webpack_require__(/*! ./EntryStore */ "./src/EntryStore.js"));

var _EntryStoreUtil = _interopRequireDefault(__webpack_require__(/*! ./EntryStoreUtil */ "./src/EntryStoreUtil.js"));

var _File = _interopRequireDefault(__webpack_require__(/*! ./File */ "./src/File.js"));

var _Graph = _interopRequireDefault(__webpack_require__(/*! ./Graph */ "./src/Graph.js"));

var _Group = _interopRequireDefault(__webpack_require__(/*! ./Group */ "./src/Group.js"));

var _List = _interopRequireDefault(__webpack_require__(/*! ./List */ "./src/List.js"));

var _Pipeline = _interopRequireDefault(__webpack_require__(/*! ./Pipeline */ "./src/Pipeline.js"));

var _PrototypeEntry = _interopRequireDefault(__webpack_require__(/*! ./PrototypeEntry */ "./src/PrototypeEntry.js"));

var _Resource = _interopRequireDefault(__webpack_require__(/*! ./Resource */ "./src/Resource.js"));

var _SearchList = _interopRequireDefault(__webpack_require__(/*! ./SearchList */ "./src/SearchList.js"));

var _String = _interopRequireDefault(__webpack_require__(/*! ./String */ "./src/String.js"));

var _User = _interopRequireDefault(__webpack_require__(/*! ./User */ "./src/User.js"));

var _terms = _interopRequireDefault(__webpack_require__(/*! ./terms */ "./src/terms.js"));

var _utils = _interopRequireDefault(__webpack_require__(/*! ./utils */ "./src/utils.js"));

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/***/ }),

/***/ "./src/promiseUtil.js":
/*!****************************!*\
  !*** ./src/promiseUtil.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * This module contains utility methods for promises.
 *
 * @exports store/promiseUtil
 * @namespace
 */
var promiseUtil = {};
/**
 * Asynchronous forEach relying on promises that works in serial rather than parallell.
 * It invokes a function on each item only after the promise from the previous item
 * in the array has succeeded.
 * If one of the promises fails the forEach promise fails altogheter.
 * The result is provided in an array if the items is an array.
 * In the case where the items is an object the same object is returned
 * but with the values replaced with the result of the promise.
 * (The function is applied to the value of each key in the items object.)
 *
 * @param {array|object} items
 * @param {function} func a function that is applied to each item and must return a promise
 * @returns {Promise}
 */

promiseUtil.forEach = function (items, func) {
  return new Promise(function (resolve, reject) {
    var arr;

    var _cursor;

    var onFailure = function onFailure(err) {
      reject(err);
    };

    if (Array.isArray(items)) {
      var results = [];
      arr = items.slice();

      _cursor = function cursor(result) {
        results.push(result);

        if (arr.length > 0) {
          return promiseUtil.toPromise(func(arr.shift())).then(_cursor, onFailure);
        }

        resolve(results);
        return undefined;
      };

      if (arr.length === 0) {
        resolve(results);
      } else {
        promiseUtil.toPromise(func(arr.shift())).then(_cursor, onFailure);
      }
    } else if (_typeof(items) === 'object') {
      arr = Object.keys(items);
      var itemKey;

      var onSuccess = function onSuccess(result) {
        items[itemKey] = result;

        _cursor();
      };

      _cursor = function _cursor() {
        if (arr.length > 0) {
          itemKey = arr.shift();
          promiseUtil.toPromise(func(items[itemKey])).then(onSuccess, onFailure);
        } else {
          resolve(items);
        }
      };

      _cursor();
    }
  });
};
/**
 * Makes sure a value is a promise, if needed wraps it as a promise.
 * If the value the false boolean it is interpreted as a reject.
 *
 * @param {any|Promise} value the value to wrap in a promise, if it already is a promise it is returned.
 * @return {Promise}
 */


promiseUtil.toPromise = function (value) {
  if (_typeof(value) === 'object' && value !== null && typeof value.then === 'function') {
    return value;
  }

  if (value === false) {
    return Promise.reject(value);
  }

  return Promise.resolve(value);
};
/**
 * Use setTimeout with promise. This is useful when you want to do things like
 * Promise.all(
 *  promise1,
 *  promiseUtil.delay(1000),
 * ]);
 * @param millisecs
 * @returns {Promise<any>}
 */


promiseUtil.delay = function (millisecs) {
  return new Promise(function (resolve) {
    return setTimeout(resolve, millisecs);
  });
};

var _default = promiseUtil;
exports.default = _default;

/***/ }),

/***/ "./src/terms.js":
/*!**********************!*\
  !*** ./src/terms.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _rdfjson = __webpack_require__(/*! rdfjson */ "./node_modules/rdfjson/main.js");

var _types = _interopRequireDefault(__webpack_require__(/*! ./types */ "./src/types.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var inv = function inv(obj) {
  var iobj = {};
  Object.keys(obj).forEach(function (key) {
    iobj[obj[key]] = key;
  });
  return iobj;
}; // Namespaces


var ns = 'http://entrystore.org/terms/';
var rdfns = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';
var xsdns = 'http://www.w3.org/2001/XMLSchema#';

_rdfjson.namespaces.add('prov', 'http://www.w3.org/ns/prov#');

_rdfjson.namespaces.add('store', ns);

_rdfjson.namespaces.add('storepr', 'http://entrystore.org/terms/pipelineresult#');

var terms = {
  homeContext: "".concat(ns, "homeContext"),
  resource: "".concat(ns, "resource"),
  metadata: "".concat(ns, "metadata"),
  externalMetadata: "".concat(ns, "externalMetadata"),
  reasoningFacts: "".concat(ns, "reasoningFacts"),
  status: {
    property: "".concat(ns, "status"),
    InProgress: "".concat(ns, "InProgress"),
    Pending: "".concat(ns, "Pending"),
    Succeeded: "".concat(ns, "Success"),
    Failed: "".concat(ns, "Failed")
  },
  rdf: {
    type: "".concat(rdfns, "type")
  },
  pipeline: {
    pipeline: "".concat(ns, "pipeline"),
    pipelineData: "".concat(ns, "pipelineData"),
    transform: "".concat(ns, "transform"),
    transformPriority: "".concat(ns, "transformPriority"),
    transformType: "".concat(ns, "transformType"),
    transformArgument: "".concat(ns, "transformArgument"),
    transformArgumentKey: "".concat(ns, "transformArgumentKey"),
    transformArgumentValue: "".concat(ns, "transformArgumentValue"),
    transformDestination: "".concat(ns, "transformDestination"),
    transformDetectDestination: "".concat(ns, "transformDetectDestination")
  },
  acl: {
    read: "".concat(ns, "read"),
    write: "".concat(ns, "write")
  },
  xsd: {
    integer: "".concat(xsdns, "integer"),
    float: "".concat(xsdns, "float"),
    boolean: "".concat(xsdns, "boolean")
  }
}; // EntryType

var et = {};
et["".concat(ns, "Local")] = _types.default.ET_LOCAL;
et["".concat(ns, "Link")] = _types.default.ET_LINK;
et["".concat(ns, "LinkReference")] = _types.default.ET_LINKREF;
et["".concat(ns, "Reference")] = _types.default.ET_REF;
et.default = _types.default.ET_LOCAL; // The default option

terms.entryType = et;
terms.invEntryType = inv(et); // GraphType

var gt = {};
gt["".concat(ns, "None")] = _types.default.GT_NONE;
gt["".concat(ns, "Context")] = _types.default.GT_CONTEXT;
gt["".concat(ns, "SystemContext")] = _types.default.GT_SYSTEMCONTEXT;
gt["".concat(ns, "User")] = _types.default.GT_USER;
gt["".concat(ns, "Group")] = _types.default.GT_GROUP;
gt["".concat(ns, "List")] = _types.default.GT_LIST;
gt["".concat(ns, "ResultList")] = _types.default.GT_RESULTLIST;
gt["".concat(ns, "Graph")] = _types.default.GT_GRAPH;
gt["".concat(ns, "Pipeline")] = _types.default.GT_PIPELINE;
gt["".concat(ns, "PipelineResult")] = _types.default.GT_PIPELINERESULT;
gt["".concat(ns, "String")] = _types.default.GT_STRING;
gt.default = _types.default.GT_NONE; // The default option

terms.graphType = gt;
terms.invGraphType = inv(gt); // ResourceType

var rt = {};
rt["".concat(ns, "InformationResource")] = _types.default.RT_INFORMATIONRESOURCE;
rt["".concat(ns, "ResolvableInformationResource")] = _types.default.RT_RESOLVABLEINFORMATIONRESOURCE;
rt["".concat(ns, "NamedResource")] = _types.default.RT_NAMEDRESOURCE;
rt["".concat(ns, "Unknown")] = _types.default.RT_UNKNOWN;
rt.default = _types.default.RT_INFORMATIONRESOURCE; // The default option

terms.resourceType = rt;
terms.invResourceType = inv(rt);
var _default = terms;
exports.default = _default;

/***/ }),

/***/ "./src/types.js":
/*!**********************!*\
  !*** ./src/types.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**
   * Types is a module containing the three different types: GraphType, EntryType and
   * ResourceType shortened GT, ET and RT.
   *
   * @exports {store/types}
   */
var types = {
  /**
   * Local entrytype implies that the resource is maintained in the repository.
   * It can be an uploaded file, a list, a group, a user etc. The nature of the resource
   * is determined by the graphtype.
   *
   * @const
   * @see store/Entry#isLocal
   */
  ET_LOCAL: 'Local',

  /**
   * Link EntryType implies that the resource is not maintained in the repository, rather the
   * entry only provides a link to the resource.
   * The metadata is still maintained in the repository though.
   *
   * @const
   * @see store/Entry#isLink
   */
  ET_LINK: 'Link',

  /**
   * Similar to link, only the metadata is also external to the repository.
   * In many cases it is possible to access a locally cached version of the external
   * metadata though.
   * @see store/Entry#getCachedExternalMetadata
   * @see store/Entry#isReference
   */
  ET_REF: 'Reference',

  /**
   * Similar to link and reference, only there is both local metadata and external metadata.
   * @see store/Entry#isLinkReference
   */
  ET_LINKREF: 'Linkreference',

  /**
   * No graph type specified means that no knowledge of the resources character is known.
   * Hence, no special treatment of the resource is expected.
   * This is common when handling regular files, web resources or abstract entities.
   * @see store/Entry#isNone
   */
  GT_NONE: 'None',

  /**
   * The resource is a context, i.e. a container for other entries.
   *
   * @see store/Entry#isContext
   * @see store/Context
   */
  GT_CONTEXT: 'Context',

  /**
   * The resource is one of the special context of this repository, e.g. _contexts or _principals.
   * @see store/Entry#isSystemContext
   */
  GT_SYSTEMCONTEXT: 'Systemcontext',

  /**
   * The resource is a user.
   *
   * @see store/Entry#isUser
   * @see store/User
   */
  GT_USER: 'User',

  /**
   * The resource is a group.
   *
   * @see store/Entry#isGroup
   * @see store/Group
   */
  GT_GROUP: 'Group',

  /**
   * The resource is a list.
   *
   * @see store/Entry#isList
   * @see store/List
   */
  GT_LIST: 'List',

  /**
   * @todo remains to be supported in this API
   * @see store/Entry#isResultList
   */
  GT_RESULTLIST: 'Resultlist',

  /**
   * The resource is a RDF graph.
   * @see store/Entry#isGraph
   * @see store/Graph
   */
  GT_GRAPH: 'Graph',

  /**
   * The resource is a string.
   * @see store/Entry#isString
   * @see store/String
   */
  GT_STRING: 'String',

  /**
   * The resource is a pipeline, e.g. an entry that can somehow be executed on the server side.
   * @see store/Entry#isPipeline
   * @see store/Pipeline
   */
  GT_PIPELINE: 'Pipeline',

  /**
   * The resource is a pipelineresult, e.g. the result of the execution of a pipeline
   * on the server side.
   * @see store/Entry#isPipelineResult
   * @see store/Pipeline
   */
  GT_PIPELINERESULT: 'PipelineResult',

  /**
   * The resource is available as a digital representation of some sort.
   * Opposite to resources that have no representation, referred to as
   * {@link store/types.NAMEDRESOURCE named}.
   */
  RT_INFORMATIONRESOURCE: 'Information',

  /**
   * The resource is resolvable to another address.
   * @todo the API has little support for this type currently.
   */
  RT_RESOLVABLEINFORMATIONRESOURCE: 'Resolvable',

  /**
   * The resource is not available digitally, i.e. it has now digital representation that
   * can be transferred over a network.
   */
  RT_NAMEDRESOURCE: 'Named',

  /**
   * It is unknown if the resource has a representation or not, typically this is the case when
   * large amounts of resources are harvested from another system and it is not feasible to try
   * to load them to check weather they have a digital representation or not. At least the check
   * cannot be done initially and therefore the type is set to unknown.
   */
  RT_UNKNOWN: 'Unknown'
};
var _default = types;
exports.default = _default;

/***/ }),

/***/ "./src/utils.js":
/*!**********************!*\
  !*** ./src/utils.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isIE = exports.isNode = exports.isBrowser = exports.utils = void 0;
var utils = {};
exports.utils = utils;

utils.getRelatedToEntryURIs = function (fromEntry) {
  var es = fromEntry.getEntryStore();
  var base = fromEntry.getEntryStore().getBaseURI();
  var relatedEntryURIs = [];
  fromEntry.getMetadata().find().forEach(function (stmt) {
    if (stmt.getType() === 'uri') {
      var obj = stmt.getValue();

      if (obj.indexOf(base) === 0) {
        var uri = es.getEntryURI(es.getContextId(obj), es.getEntryId(obj));
        relatedEntryURIs.push(uri);
      }
    }
  });
  return relatedEntryURIs;
};

utils.getRelatedToEntries = function (fromEntry) {
  var es = fromEntry.getEntryStore();
  return Promise.all(utils.getRelatedToEntryURIs(fromEntry).map(function (uri) {
    return es.getEntry(uri);
  }));
};

utils.remove = function (entry) {
  var es = entry.getEntryStore();
  var cache = es.getCache();
  var refStmts = entry.getReferrersGraph().find();
  var entryPromises = refStmts.map(function (stmt) {
    var subj = stmt.getSubject();
    var euri = es.getEntryURI(es.getContextId(subj), es.getEntryId(subj));
    return es.getEntry(euri);
  });
  return entry.del().then(function () {
    return Promise.all(entryPromises).then(function (arr) {
      var promises = refStmts.map(function (stmt, idx) {
        var md = arr[idx].getMetadata();
        md.remove(stmt);
        return arr[idx].commitMetadata();
      });
      var uris = utils.getRelatedToEntryURIs(entry);
      uris.forEach(function (uri) {
        var e = cache.get(uri);

        if (e != null) {
          e.setRefreshNeeded();
          promises.push(e.refresh());
        }
      });
      return Promise.all(promises);
    });
  });
};

utils.addRelation = function (fromEntry, property, toEntry) {
  fromEntry.getMetadata().add(fromEntry.getResourceURI(), property, toEntry.getResourceURI());
  return fromEntry.commitMetadata().then(function () {
    toEntry.setRefreshNeeded();
    return toEntry.refresh();
  });
};

utils.removeRelation = function (fromEntry, property, toEntry) {
  fromEntry.getMetadata().remove(fromEntry.getResourceURI(), property, {
    type: 'uri',
    value: toEntry.getResourceURI()
  });
  return fromEntry.commitMetadata().then(function () {
    toEntry.setRefreshNeeded();
    return toEntry.refresh();
  });
}; // Relies on there not being a window.document in Node
// Based off of: https://github.com/flexdinesh/browser-or-node/blob/master/src/index.js


var isBrowser = function isBrowser() {
  return typeof window !== 'undefined' && typeof window.document !== 'undefined';
};

exports.isBrowser = isBrowser;
utils.isBrowser = isBrowser;

var isNode = function isNode() {
  return  true && typeof module.exports !== 'undefined';
};

exports.isNode = isNode;
utils.isNode = isNode;

var isIE = function isIE() {
  return window && window.navigator.userAgent.match(/MSIE/) !== null;
};

exports.isIE = isIE;
utils.isIE = isIE;
var _default = utils;
exports.default = _default;

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9FbnRyeVN0b3JlL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvYmx1ZWltcC1tZDUvanMvbWQ1LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY2hhcmVuYy9jaGFyZW5jLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2VzL2luZGV4LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYS1mdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hbi1pbnN0YW5jZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FuLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1idWZmZXIuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZpbGwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWZyb20uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LWxhc3QtaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9hcnJheS1tZXRob2QtaGFzLXNwZWNpZXMtc3VwcG9ydC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXJlZHVjZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvYmluZC1jb250ZXh0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jbGFzc29mLXJhdy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NsYXNzb2YuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb2xsZWN0aW9uLXN0cm9uZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24td2Vhay5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvbGxlY3Rpb24uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3B5LWNvbnN0cnVjdG9yLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2NyZWF0ZS1odG1sLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLWl0ZXJhdG9yLWNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kYXRlLXRvLWlzby1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kYXRlLXRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Rlc2NyaXB0b3JzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9kb20taXRlcmFibGVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZW51bS1idWcta2V5cy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2V4cG9ydC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZhaWxzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZsYXR0ZW4taW50by1hcnJheS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZvcmNlZC1vYmplY3QtcHJvdG90eXBlLWFjY2Vzc29ycy1tZXRob2RzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZm9yY2VkLXN0cmluZy1odG1sLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2ZvcmNlZC1zdHJpbmctdHJpbS1tZXRob2QuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mcmVlemluZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtYnVpbHQtaW4uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9nZXQtaXRlcmF0b3ItbWV0aG9kLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvZ2xvYmFsLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGFzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaGlkZGVuLWtleXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9oaWRlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaG9zdC1yZXBvcnQtZXJyb3JzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaHRtbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2llOC1kb20tZGVmaW5lLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LWl0ZXJhdG9yLW1ldGhvZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLWFycmF5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtZm9yY2VkLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXMtaW50ZWdlci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL2lzLXB1cmUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pcy1yZWdleHAuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9pdGVyYXRvcnMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYXRoLWV4cG0xLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC1mcm91bmQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9tYXRoLWxvZzFwLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWF0aC1zaWduLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbWljcm90YXNrLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL25hdGl2ZS11cmwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbm90LWEtcmVnZXhwLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvbnVtYmVyLWlzLWZpbml0ZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtY3JlYXRlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy1leHRlcm5hbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3Qta2V5cy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL29iamVjdC1wcm9wZXJ0eS1pcy1lbnVtZXJhYmxlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tYXJyYXkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9vYmplY3QtdG8tc3RyaW5nLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvb3duLWtleXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhcnNlLWludC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3BhdGguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9wZXJmb3JtLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcHVueWNvZGUtdG8tYXNjaWkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS1hbGwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWRlZmluZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZWdleHAtZmxhZ3MuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zYW1lLXZhbHVlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LWdsb2JhbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NldC1zcGVjaWVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zaGFyZWQta2V5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2hhcmVkLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctbXVsdGlieXRlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvc3RyaW5nLXBhZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy9zdHJpbmctdHJpbS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3Rhc2suanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdG8taW5kZXguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3RvLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1sZW5ndGguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vYmplY3QuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1vZmZzZXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3R5cGVkLWFycmF5LWZyb20uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy90eXBlZC1hcnJheXMtY29uc3RydWN0b3JzLXJlcXVpcmVzLXdyYXBwZXJzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdWlkLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvdXNlci1hZ2VudC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlYmtpdC1zdHJpbmctcGFkLWJ1Zy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9pbnRlcm5hbHMvd2hpdGVzcGFjZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL2ludGVybmFscy93cmFwcGVkLXdlbGwta25vd24tc3ltYm9sLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5jb25zdHJ1Y3Rvci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuaXMtdmlldy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuc2xpY2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuY29uY2F0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmNvcHktd2l0aGluLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmV2ZXJ5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbGwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmlsdGVyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZpbmQtaW5kZXguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuZmluZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0LW1hcC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5mbGF0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZvci1lYWNoLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LmZyb20uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXMtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5vZi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc29tZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5hcnJheS5zb3J0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnNwZWNpZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuc3BsaWNlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXQtbWFwLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0YS12aWV3LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmRhdGUubm93LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLmRhdGUudG8taXNvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5kYXRlLnRvLWpzb24uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1wcmltaXRpdmUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZGF0ZS50by1zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24uYmluZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5mdW5jdGlvbi5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5qc29uLnRvLXN0cmluZy10YWcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWFwLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguYWNvc2guanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5hc2luaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmF0YW5oLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguY2JydC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmNsejMyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguY29zaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmV4cG0xLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguZnJvdW5kLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguaHlwb3QuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5pbXVsLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGgubG9nMTAuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5sb2cxcC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLmxvZzIuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC5zaWduLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGguc2luaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5tYXRoLnRhbmguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubWF0aC50by1zdHJpbmctdGFnLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm1hdGgudHJ1bmMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5lcHNpbG9uLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5pcy1maW5pdGUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmlzLWludGVnZXIuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMubnVtYmVyLmlzLW5hbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIuaXMtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5tYXgtc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5taW4tc2FmZS1pbnRlZ2VyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci5wYXJzZS1mbG9hdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIucGFyc2UtaW50LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm51bWJlci50by1maXhlZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5udW1iZXIudG8tcHJlY2lzaW9uLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmNyZWF0ZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLWdldHRlci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmRlZmluZS1wcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXNldHRlci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZW50cmllcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZnJlZXplLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5mcm9tLWVudHJpZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuaXMtZXh0ZW5zaWJsZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QuaXMtZnJvemVuLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5pcy1zZWFsZWQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LmlzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5rZXlzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5sb29rdXAtZ2V0dGVyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5sb29rdXAtc2V0dGVyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnNlYWwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMub2JqZWN0LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5vYmplY3QudmFsdWVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWZsb2F0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnBhcnNlLWludC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5wcm9taXNlLmZpbmFsbHkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucHJvbWlzZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmFwcGx5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuY29uc3RydWN0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuZGVmaW5lLXByb3BlcnR5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuZGVsZXRlLXByb3BlcnR5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZmxlY3QuZ2V0LXByb3RvdHlwZS1vZi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmdldC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0Lmhhcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LmlzLWV4dGVuc2libGUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5vd24ta2V5cy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LnByZXZlbnQtZXh0ZW5zaW9ucy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWZsZWN0LnNldC1wcm90b3R5cGUtb2YuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVmbGVjdC5zZXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnJlZ2V4cC5mbGFncy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnNldC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuYW5jaG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5iaWcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmJsaW5rLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5ib2xkLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5jb2RlLXBvaW50LWF0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmZpeGVkLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5mb250Y29sb3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmZvbnRzaXplLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5mcm9tLWNvZGUtcG9pbnQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGFsaWNzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubGluay5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2gtYWxsLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucGFkLWVuZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucGFkLXN0YXJ0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5yYXcuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGVhdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc2VhcmNoLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zbWFsbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zdHJpa2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN1Yi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuc3VwLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy50cmltLWVuZC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS1zdGFydC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuYXN5bmMtaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmRlc2NyaXB0aW9uLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5oYXMtaW5zdGFuY2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLmlzLWNvbmNhdC1zcHJlYWRhYmxlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnN5bWJvbC5pdGVyYXRvci5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLm1hdGNoLWFsbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wubWF0Y2guanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLnJlcGxhY2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLnNlYXJjaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuc3BlY2llcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wuc3BsaXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMuc3ltYm9sLnRvLXByaW1pdGl2ZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wudG8tc3RyaW5nLXRhZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy5zeW1ib2wudW5zY29wYWJsZXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuY29weS13aXRoaW4uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZXZlcnkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maWx0ZXIuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5maW5kLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0MzItYXJyYXkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQ2NC1hcnJheS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mcm9tLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluY2x1ZGVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmluZGV4LW9mLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDE2LWFycmF5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDMyLWFycmF5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDgtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuam9pbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5sYXN0LWluZGV4LW9mLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm1hcC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5vZi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmVkdWNlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJldmVyc2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2V0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNsaWNlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnNvbWUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29ydC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zdWJhcnJheS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS50by1sb2NhbGUtc3RyaW5nLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLXN0cmluZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MTYtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWFycmF5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnVpbnQ4LWNsYW1wZWQtYXJyYXkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1tYXAuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvZXMud2Vhay1zZXQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5mb3ItZWFjaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIuZG9tLWNvbGxlY3Rpb25zLml0ZXJhdG9yLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi5pbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jb3JlLWpzL21vZHVsZXMvd2ViLnF1ZXVlLW1pY3JvdGFzay5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudGltZXJzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwtc2VhcmNoLXBhcmFtcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvbW9kdWxlcy93ZWIudXJsLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy9tb2R1bGVzL3dlYi51cmwudG8tanNvbi5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2NvcmUtanMvc3RhYmxlL2luZGV4LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvY29yZS1qcy93ZWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9jcnlwdC9jcnlwdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL2hlL2hlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvbWQ1L21kNS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL21vbWVudC9tb21lbnQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9yZGZqc29uL21haW4uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9yZGZqc29uL3NyYy9HcmFwaC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3JkZmpzb24vc3JjL1N0YXRlbWVudC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3JkZmpzb24vc3JjL2Zvcm1hdHMvY29udmVydGVycy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3JkZmpzb24vc3JjL2Zvcm1hdHMvcmRmanNvbi91dGlsLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvcmRmanNvbi9zcmMvZm9ybWF0cy9yZGZ4bWwvUmRmcGFyc2VyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvcmRmanNvbi9zcmMvZm9ybWF0cy9yZGZ4bWwvdGVybXMuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9yZGZqc29uL3NyYy9mb3JtYXRzL3JkZnhtbC91cmkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9yZGZqc29uL3NyYy9uYW1lc3BhY2VzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvcmRmanNvbi9zcmMvcHJpbnQuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9yZGZqc29uL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3JlZ2VuZXJhdG9yLXJ1bnRpbWUvcnVudGltZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQtanNvbnAvZGlzdC9zdXBlcmFnZW50LWpzb25wLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMvc3VwZXJhZ2VudC9saWIvYWdlbnQtYmFzZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL2lzLW9iamVjdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3JlcXVlc3QtYmFzZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3N1cGVyYWdlbnQvbGliL3Jlc3BvbnNlLWJhc2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL25vZGVfbW9kdWxlcy9zdXBlcmFnZW50L2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLyh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3htbGRvbS9kb20tcGFyc2VyLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9ub2RlX21vZHVsZXMveG1sZG9tL2RvbS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vbm9kZV9tb2R1bGVzL3htbGRvbS9zYXguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9BdXRoLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvQ2FjaGUuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9Db250ZXh0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvRW50cnkuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9FbnRyeUluZm8uanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9FbnRyeVN0b3JlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvRW50cnlTdG9yZVV0aWwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9GaWxlLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvR3JhcGguanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9Hcm91cC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL0xpc3QuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9QaXBlbGluZS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL1Byb3RvdHlwZUVudHJ5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvUmVzb3VyY2UuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9SZXN0LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvU2VhcmNoTGlzdC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL1NvbHJRdWVyeS5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL1N0cmluZy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL1VzZXIuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy9mYWN0b3J5LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvaHRtbC5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL2luZGV4LmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvcHJvbWlzZVV0aWwuanMiLCJ3ZWJwYWNrOi8vRW50cnlTdG9yZS8uL3NyYy90ZXJtcy5qcyIsIndlYnBhY2s6Ly9FbnRyeVN0b3JlLy4vc3JjL3R5cGVzLmpzIiwid2VicGFjazovL0VudHJ5U3RvcmUvLi9zcmMvdXRpbHMuanMiXSwibmFtZXMiOlsiZW50cnlzdG9yZSIsIl9saXN0ZW5lckNvdW50ZXIiLCJfbGlzdGVuZXJzSWR4IiwiTWFwIiwidG9waWMiLCJvYmoiLCJmb3JFYWNoIiwiZnVuYyIsImxpc3RlbmVyIiwiX19hbGlkIiwic2V0IiwiZGVsZXRlIiwiZm9yY2VMb29rdXAiLCJ1c2VySW5mbyIsIlByb21pc2UiLCJyZXNvbHZlIiwiX3VpRGVmIiwiZ2V0UkVTVCIsImdldCIsIl9iYXNlVVJJIiwiaGFuZGxlQXN5bmMiLCJ1c2VyRW50cnkiLCJfdWVEZWYiLCJnZXRVc2VySW5mbyIsImdldEVudHJ5IiwiZ2V0RW50cnlVUkkiLCJpZCIsImFzeW5jQ29udGV4dCIsInVzZXIiLCJwYXNzd29yZCIsIm1heEFnZSIsImNyZWRlbnRpYWxzIiwiYmFzZSIsImdldEJhc2VVUkkiLCJhdXRoUHJvbWlzZSIsImF1dGgiLCJjYW5jZWwiLCJnZXRDYWNoZSIsImFsbE5lZWRSZWZyZXNoIiwibWVzc2FnZUxpc3RlbmVycyIsImxvZ291dCIsImxvZ291dFByb21pc2UiLCJDYWNoZSIsIl9jYWNoZUlkeCIsIl9jYWNoZUlkeFJlc291cmNlIiwiX2NhY2hlQ3RybCIsImVudHJ5Iiwic2lsZW50bHkiLCJlbnRyeVVSSSIsImdldFVSSSIsInByZXZpb3VzbHlDYWNoZWQiLCJoYXMiLCJlbnRyeVJVUkkiLCJnZXRSZXNvdXJjZVVSSSIsImVudHJpZXNTZXQiLCJTZXQiLCJhZGQiLCJkYXRlIiwiRGF0ZSIsImdldFRpbWUiLCJzaXplIiwiY3RybCIsIkVycm9yIiwic3RhbGUiLCJlbnRyeUFyciIsImNhY2hlIiwidXJpIiwiX19jbGlkIiwiYWZmZWN0ZWRFbnRyeSIsInNldFJlZnJlc2hOZWVkZWQiLCJDb250ZXh0Iiwic29ydCIsImxpbWl0IiwicGFnZSIsImdldEVudHJ5U3RvcmUiLCJnZXRMaXN0RW50cmllcyIsIl9yZXNvdXJjZVVSSSIsImVudHJ5SWQiLCJvcHRpb25hbExvYWRQYXJhbXMiLCJnZXRFbnRyeVVSSWJ5SWQiLCJnZXRJZCIsIlByb3RvdHlwZUVudHJ5Iiwic2V0UmVzb3VyY2VUeXBlIiwidHlwZXMiLCJSVF9OQU1FRFJFU09VUkNFIiwibGluayIsInNldFJlc291cmNlVVJJIiwic2V0RW50cnlUeXBlIiwiRVRfTElOSyIsIm1ldGFkYXRhTGluayIsInNldEV4dGVybmFsTWV0YWRhdGFVUkkiLCJFVF9MSU5LUkVGIiwiRVRfUkVGIiwic2V0R3JhcGhUeXBlIiwiR1RfTElTVCIsImdyYXBoIiwicHJvdG90eXBlRW50cnkiLCJHVF9HUkFQSCIsImVudHJ5SW5mbyIsImdldEVudHJ5SW5mbyIsIl9yZXNvdXJjZSIsIkdyYXBoUmVzb3VyY2UiLCJzdHIiLCJHVF9TVFJJTkciLCJTdHJpbmdSZXNvdXJjZSIsIkdUX1BJUEVMSU5FIiwiUGlwZWxpbmUiLCJfbmFtZSIsIm5hbWUiLCJvbGROYW1lIiwicHV0IiwiSlNPTiIsInN0cmluZ2lmeSIsInRoZW4iLCJkYXRhIiwiZSIsImNvbnRleHRFbnRyeSIsImVzIiwiZ3JvdXBSZXNvdXJjZUFyciIsImdldFJlZmVycmVycyIsImxlbmd0aCIsImdldEVudHJ5VVJJRnJvbVVSSSIsImFsaWFzIiwiUmVzb3VyY2UiLCJFbnRyeSIsImNvbnRleHQiLCJfY29udGV4dCIsIl9lbnRyeUluZm8iLCJfZW50cnkiLCJfbWV0YWRhdGEiLCJHcmFwaCIsImlnbm9yZUlmVW5tb2RpZmllZFNpbmNlQ2hlY2siLCJwIiwiaXNSZWZlcmVuY2UiLCJyZWplY3QiLCJjYW5Xcml0ZU1ldGFkYXRhIiwibmVlZFJlZnJlc2giLCJnZXRNZXRhZGF0YVVSSSIsImV4cG9ydFJERkpTT04iLCJtb2QiLCJnZXRNb2RpZmljYXRpb25EYXRlIiwicmVmcmVzaCIsIm1lc3NhZ2UiLCJwcmVkaWNhdGUiLCJvYmplY3QiLCJnZXRNZXRhZGF0YSIsImxpdGVyYWwiLCJsYW5ndWFnZSIsImFkZEwiLCJkYXRhdHlwZSIsImFkZEQiLCJfY2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSIsIl9pbmZlcnJlZE1ldGFkYXRhIiwicHJvbWlzZSIsImdldENhY2hlZEV4dGVybmFsTWV0YWRhdGFVUkkiLCJfZXh0cmFjdGVkTWV0YWRhdGEiLCJkaXJlY3QiLCJmb3JtYXQiLCJpc1N0cmluZyIsImZhY3RvcnkiLCJ1cGRhdGVPckNyZWF0ZVJlc291cmNlIiwicmVzb3VyY2UiLCJfcmVsYXRpb24iLCJwcm9wIiwiZmluZCIsIm1hcCIsInN0bXQiLCJnZXRTdWJqZWN0IiwibGlzdFJlc291cmNlVVJJQXJyIiwicmVzVVJJIiwiZ3JvdXBSZXNvdXJjZVVSSUFyciIsImdldEdyYXBoVHlwZSIsIkdUX1JFU1VMVExJU1QiLCJHVF9DT05URVhUIiwiR1RfU1lTVEVNQ09OVEVYVCIsIkdUX1VTRVIiLCJHVF9HUk9VUCIsIkdUX1BJUEVMSU5FUkVTVUxUIiwiR1RfTk9ORSIsImdldEVudHJ5VHlwZSIsIkVUX0xPQ0FMIiwiaXNFeHRlcm5hbCIsInN1YnN0ciIsImlzTGlua1RvRW50cnkiLCJyZXNvdXJjZVVSSSIsImdldEVudHJ5SWQiLCJjb250ZXh0SWQiLCJnZXRDb250ZXh0SWQiLCJ1bmRlZmluZWQiLCJnZXRSZXNvdXJjZVR5cGUiLCJSVF9JTkZPUk1BVElPTlJFU09VUkNFIiwiX3JpZ2h0cyIsImFkbWluaXN0ZXIiLCJyZWFkcmVzb3VyY2UiLCJ3cml0ZXJlc291cmNlIiwicmVhZG1ldGFkYXRhIiwid3JpdGVtZXRhZGF0YSIsImd1ZXN0UHJpbmNpcGFsIiwiYWNsIiwiZ2V0QUNMIiwiY29udGV4dE92ZXJyaWRlIiwic29tZSIsImtleSIsImluZGV4T2YiLCJjZSIsImdldENvbnRleHQiLCJ1c2VyUHJpbmNpcGFsIiwiY2FjbCIsImFkbWluIiwicmVjdXJzaXZlIiwidW5DYWNoZSIsImRlbCIsImZvcmNlIiwiZ2V0RW50cnlMb2FkVVJJIiwidXBkYXRlIiwiRW50cnlJbmZvIiwiZW50cnlTdG9yZSIsIl9lbnRyeVVSSSIsInRlcm1zIiwiX2dyYXBoIiwiX2VudHJ5U3RvcmUiLCJfZGlzYWJsZWQiLCJnZXRNZXRhZGF0YVVSSUZyb21VUkkiLCJmaW5kRmlyc3RWYWx1ZSIsImV4dGVybmFsTWV0YWRhdGEiLCJmaW5kQW5kUmVtb3ZlIiwiY3JlYXRlIiwidHlwZSIsInZhbHVlIiwib2xkUmVzb3VyY2VVUkkiLCJzdG10cyIsImkiLCJzZXRTdWJqZWN0IiwiZXQiLCJyZGYiLCJlbnRyeVR5cGUiLCJjb25zdHJ1Y3RvciIsImdldFJlc291cmNlVHlwZUhlbHBlciIsInJlc291cmNlVHlwZSIsImdyYXBoVHlwZSIsImFzSWRzIiwiZiIsImdldFZhbHVlIiwicnUiLCJtdSIsIndyaXRlIiwicnJlYWQiLCJyZWFkIiwicndyaXRlIiwibXJlYWQiLCJtd3JpdGUiLCJnIiwic3ViaiIsInByZWQiLCJwcmluY2lwYWxzIiwicHJpbmNpcGFsIiwiX2FjbCIsImdldFJlc291cmNlQmFzZSIsInJldnMiLCJtZFVSSSIsInB1c2giLCJyZXYiLCJ0aW1lIiwidG9EYXRlIiwiYnkiLCJyMSIsInIyIiwicmV2aXNpb25VUkkiLCJsYWJlbCIsInN0YXR1cyIsInByb3BlcnR5IiwiZCIsImdldENyZWF0aW9uRGF0ZSIsImV4dGVudCIsInBhcnNlSW50Iiwidm9jYWIiLCJ0IiwiZGVmYXVsdCIsImhlIiwicmVxdWlyZSIsIkVudHJ5U3RvcmUiLCJiYXNlVVJJIiwid2luZG93IiwibG9jYXRpb24iLCJvcmlnaW4iLCJfY2FjaGUiLCJfYXV0aCIsIkF1dGgiLCJfY29udGV4dHMiLCJfcmVzdCIsIlJlc3QiLCJhc3luY0xpc3RlbmVycyIsInNwbGljZSIsImdldFVzZXJFbnRyeSIsImxvZ2luIiwiZm9yY2VMb2FkIiwiY2hlY2tSZXNvdXJjZUxvYWRlZCIsImxvYWRSZXNvdXJjZSIsImdldFJlc291cmNlIiwiaXNMaXN0IiwiaXNHcm91cCIsImxpc3QiLCJzZXRMaW1pdCIsInNldFNvcnQiLCJzZWxmIiwiZW50cnlMb2FkVVJJIiwidXBkYXRlT3JDcmVhdGUiLCJlcnIiLCJvcCIsIm9mZnNldCIsImdldERlZmF1bHRMaW1pdCIsImdldEVudHJpZXMiLCJjb250ZXh0RW50cnlVUkkiLCJuZXdTb2xyUXVlcnkiLCJwb3N0VVJJIiwiZ2V0RW50cnlDcmVhdGVVUkkiLCJnZXRQYXJlbnRMaXN0IiwicG9zdFBhcmFtcyIsImdldEVudHJ5Q3JlYXRlUG9zdERhdGEiLCJldXJpIiwicGxpc3QiLCJyZXMiLCJjb250ZXh0TmFtZSIsImVpIiwiX3VwZGF0ZSIsImVuY29kZVVSSUNvbXBvbmVudCIsInVzZXJuYW1lIiwiaG9tZUNvbnRleHQiLCJfcHJpbmNpcGFscyIsImhvbWVjb250ZXh0IiwiVXNlciIsImdyb3VwTmFtZSIsImZyb21MaXN0IiwidG9MaXN0IiwiZ2V0TW92ZVVSSSIsInBvc3QiLCJmb3JtYXRIaW50IiwidXJsIiwiZ2V0UHJveHlVUkkiLCJOb2RlIiwicHV0RmlsZSIsInJhd0RhdGEiLCJyZXNwb25zZSIsInRleHQiLCJpZHgiLCJzcGxpdCIsInRleHRBcmVhVmFsdWUiLCJyZXBsYWNlIiwiZGVjb2RlIiwiU29sclF1ZXJ5IiwicXVlcnkiLCJjcmVhdGVTZWFyY2hMaXN0IiwicGFja2FnZUpTT04iLCJ2ZXJzaW9uIiwiRW50cnlTdG9yZVV0aWwiLCJfZW50cnlzdG9yZSIsIl9wcmVsb2FkSWR4Iiwib2ZUeXBlIiwicHJlbG9hZEZvclR5cGUiLCJub0NvbnRleHQiLCJzZWFyY2hPYmoiLCJpbkNvbnRleHQiLCJhc3luY0NhbGxUeXBlIiwiZ2V0QnlSZXNvdXJjZVVSSSIsInR5cGVVUkkiLCJyZGZUeXBlIiwidXJpcyIsInJlc3QiLCJkZWxldGVOZXh0IiwicG9wIiwiY29uc29sZSIsImxvZyIsInJlc3VsdCIsIkZpbGVSZXNvdXJjZSIsImdldFB1dEZpbGVVUkkiLCJ4bWwiLCJfeG1sIiwiWE1MU2VyaWFsaXplciIsInhtbGRvbSIsIkRvY3VtZW50Iiwic2VyaWFsaXplVG9TdHJpbmciLCJlZSIsImdldEZvcm1hdCIsIkdyb3VwIiwiY29udGV4dFJlc291cmNlVVJJIiwiZ2V0R3JhcGgiLCJkb05vdFB1c2hUb1JlcG9zaXRvcnkiLCJuZXdDb250ZXh0VVJJIiwiY29tbWl0IiwiY2hpbGRyZW4iLCJMaXN0IiwiX3NvcnRlZENoaWxkcmVuIiwiX2xpbWl0Iiwic29ydFBhcmFtcyIsIl9jbGVhclNvcnRlZEVudHJpZXMiLCJfc29ydFBhcmFtcyIsInJlc3VsdHMiLCJfZ2V0RW50cmllcyIsIl9mb3JjZUxvYWRFbnRyaWVzIiwiaCIsImdldExpbWl0IiwiZW50cmllcyIsImVudHJpZXNMZW5ndGgiLCJjb250IiwiZ2V0QWxsRW50cnlJZHMiLCJzZXRBbGxFbnRyeUlkcyIsIl91bnNvcnRlZENoaWxkcmVuIiwiX3NpemUiLCJjYWxsVHlwZSIsIm9lbnRyeSIsImNhcmVBYm91dEZyZXNoIiwiX3NvcnQiLCJhbGxVbnNvcnRlZCIsInBpcGVsaW5lIiwidHJhbnNmb3JtRGVzdGluYXRpb24iLCJlbnRyeU9yRW50cnlVUkkiLCJ2YWwiLCJ0cmFuc2Zvcm1EZXRlY3REZXN0aW5hdGlvbiIsInRvTG93ZXJDYXNlIiwiZGV0ZWN0IiwieHNkIiwiYm9vbGVhbiIsInRyYW5zZm9ybSIsImFyciIsInRyMSIsInRyMiIsInByMSIsImdldFByaW9yaXR5IiwicHIyIiwidHJhbnNmb3JtVHlwZSIsInRyYW5zZm9ybUlkIiwidHJJZHMiLCJnZXRUcmFuc2Zvcm1zIiwidHJJZCIsImdldFRyYW5zZm9ybVR5cGUiLCJhcmdzIiwidHJhbnNmb3JtcyIsInByaW9yaXR5Iiwic2V0VHJhbnNmb3JtVHlwZSIsInNldFByaW9yaXR5Iiwic2V0VHJhbnNmb3JtQXJndW1lbnRzIiwidHJhbnNmb3JtUHJpb3JpdHkiLCJpbnRlZ2VyIiwicHJpbyIsInBhcnNlRmxvYXQiLCJpc05hTiIsInRyYW5zZm9ybUFyZ3VtZW50IiwidHJhbnNmb3JtQXJndW1lbnRLZXkiLCJ0cmFuc2Zvcm1Bcmd1bWVudFZhbHVlIiwia2V5cyIsInJlbW92ZSIsIk9iamVjdCIsIm5ld0FyZyIsInRpZCIsImdldFRyYW5zZm9ybUZvclR5cGUiLCJnZXRUcmFuc2Zvcm1Bcmd1bWVudHMiLCJ0cmFuc2Zvcm1JZE9yVHlwZSIsInNvdXJjZUVudHJ5IiwicGFyYW1zIiwiZXhlY3V0ZVVSSSIsIl9wYXJhbXMiLCJzb3VyY2UiLCJib2R5IiwicHJvdG90eXBlIiwidHJhbnNmb3JtVHlwZXMiLCJUQUJVTEFSIiwiUk9XU1RPUkUiLCJFTVBUWSIsIkZFVENIIiwiVkFMSURBVEUiLCJNRVJHRSIsIl9pZCIsImNydSIsIm9sZFNldFJlc291cmNlVVJJIiwiY2FsbCIsInNwZWNpZmljSWQiLCJzZXRBQ0wiLCJhcHBseSIsImFyZ3VtZW50cyIsImludkVudHJ5VHlwZSIsImd0IiwiX2d0IiwiaW52R3JhcGhUeXBlIiwicnQiLCJpbnZSZXNvdXJjZVR5cGUiLCJwYXJlbnRMaXN0RW50cnkiLCJjcmVhdGVFbnRyeSIsIl9kYXRhIiwianNvbnAiLCJzYW1lT3JpZ2luIiwiYTEiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJhMiIsImhyZWYiLCJob3N0bmFtZSIsInBvcnQiLCJwcm90b2NvbCIsImdldFByZXZlbnRDYWNoZU51bWJlciIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsInRpbWVvdXQiLCJoZWFkZXJzIiwiQWNjZXB0Iiwic3R1YkZvcm0iLCJGb3JtRGF0YSIsImZpbGVzIiwiQXJyYXkiLCJmcm9tIiwiZmlsZSIsIkZpbGUiLCJhcHBlbmQiLCJzdXBlcmFnZW50IiwicHJldmVudENhY2hlIiwiYWNjZXB0Iiwid2l0aENyZWRlbnRpYWxzIiwic2VuZCIsImNvb2tpZSIsImF1dGhfdXNlcm5hbWUiLCJhdXRoX3Bhc3N3b3JkIiwiYXV0aF9tYXhhZ2UiLCJxdWVyeVN0cmluZ0RhdGEiLCJyZWR1Y2UiLCJhY2N1bSIsImpvaW4iLCJjb29raWVzIiwiYyIsInN1YnN0cmluZyIsImxvZ291dFJlcXVlc3RSZXN1bHQiLCJrZXlWYWwiLCJub25KU09OUCIsImxvY0hlYWRlcnMiLCJhc3NpZ24iLCJfdXJpIiwiaGFuZGxlQXMiLCJxdWVyeVBhcmFtZXRlciIsIlJlZ0V4cCIsInRlc3QiLCJpbmNsdWRlcyIsInVzZSIsImNhbGxiYWNrTmFtZSIsInNsaWNlIiwiR0VUUmVxdWVzdCIsInBhcnNlIiwiY2FsbGJhY2siLCJET01QYXJzZXIiLCJwYXJzZXIiLCJwYXJzZUZyb21TdHJpbmciLCJzdGF0dXNDb2RlIiwibW9kRGF0ZSIsInRvVVRDU3RyaW5nIiwiUE9TVFJlcXVlc3QiLCJzZXJpYWxpemUiLCJwdXRSZXF1ZXN0IiwiZGVsZXRlUmVxdWVzdCIsIlNlYXJjaExpc3QiLCJfcXVlcnkiLCJfY2FsbFR5cGUiLCJmYWNldHMiLCJmYWNldEZpZWxkcyIsImlzQXJyYXkiLCJmMnAiLCJmYWNldDJwcmVkaWNhdGUiLCJmZiIsInN0YXJ0c1dpdGgiLCJnZXRRdWVyeSIsInNldEZhY2V0cyIsImdldEZhY3RvcnkiLCJleHRyYWN0U2VhcmNoUmVzdWx0cyIsImVuY29kZVN0ciIsInNob3J0ZW4iLCJuYW1lc3BhY2VzIiwiZXhwYW5kIiwibmdyYW1MaW1pdCIsImlzTmdyYW0iLCJpc0V4YWN0TWF0Y2giLCJzb2xyRnJpZW5kbHkiLCJ0ZXJtIiwiaXNGYWNldCIsImFuZCIsInRyaW0iLCJidWlsZFF1ZXJ5Iiwic3RydWN0IiwiaXNBbmQiLCJ2Iiwib3IiLCJvIiwicHJvcGVydGllcyIsInJlbGF0ZWRQcm9wZXJ0aWVzIiwibW9kaWZpZXJzIiwiX2FuZCIsIl9vciIsImZhY2V0cHJlZGljYXRlcyIsInJlbGF0ZWRGYWNldHByZWRpY2F0ZXMiLCJtb2RpZmllciIsIl9xIiwiaXNQdWJsaWMiLCJnZXRDb250ZXh0QnlJZCIsInJlc291cmNlVVJJQXJyIiwiZmlsdGVyIiwic3RydWN0dXJlIiwidGl0bGUiLCJfdGl0bGVfbGFuZyIsImluZGV4VHlwZSIsInJlbGF0ZWQiLCJub2RldHlwZSIsIm1kNSIsIl9vZmZzZXQiLCJmYWNldCIsImRpc2p1bmN0aXZlUHJvcGVydGllcyIsImRpc2p1bmN0aXZlIiwibGFuZyIsIm92IiwidHJhaWwiLCJzdHJpbmciLCJvbGRMYW5nIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwib2xkRGlzYWJsZWQiLCJvbGRIb21lQ29udGV4dCIsImN1c3RvbVByb3BlcnRpZXMiLCJvbGRDdXN0b21Qcm9wZXJ0aWVzIiwic29ydE9iaiIsInNvcnRCeSIsImRlZmF1bHRMaW1pdCIsImdldENvbnRleHRGb3JFbnRyeSIsImNvbnRleHRzIiwiZ2V0Q2FjaGVkQ29udGV4dHNJZHgiLCJ0cmFuc2Zvcm1SaWdodHMiLCJyaWdodHMiLCJyIiwibiIsImZpeE5hbWVBbmREaXNhYmxlZCIsInJlc09iaiIsIl91cGRhdGVPckNyZWF0ZVJlc291cmNlIiwicnVyaSIsImNydXJpIiwiY2hpbGQiLCJfdXBkYXRlRW50cnkiLCJtZXRhZGF0YSIsImluZmVycmVkIiwicmVsYXRpb25zIiwiY29udGV4dHNCYXNlVVJJIiwiZ2V0TGlzdCIsInNldEdyYXBoIiwiaW5mbyIsImxhc3RJbmRleE9mIiwibWF0Y2giLCJnZXRVUklGcm9tQ3JlYXRlZCIsInN0ckwiLCJzdHJPIiwic3RyU29ydCIsInN0ckRlc2MiLCJzdHJQcmlvIiwiZGVzY2VuZGluZyIsImdldFNwZWNpZmljSWQiLCJpc0xpbmsiLCJpc0xpbmtSZWZlcmVuY2UiLCJnZXRFeHRlcm5hbE1ldGFkYXRhVVJJIiwicG9zdERhdGEiLCJlbXB0eSIsIm1kIiwiaXNFbXB0eSIsInJlIiwiZ2V0U291cmNlIiwiY2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSIsImdldENhY2hlZEV4dGVybmFsTWV0YWRhdGEiLCJmcm9tTGlzdEVudHJ5IiwidG9MaXN0RW50cnkiLCJmdXJpIiwic29ydE9iamVjdCIsImdldFNvcnQiLCJzZXREZWZhdWx0TGltaXQiLCJodG1sIiwibWV0YWRhdGFUYWJsZSIsImRlbGVnYXRlcyIsInByaW50IiwicHJldHR5VHJlZSIsInN0IiwiaXNTdWJqZWN0QmxhbmsiLCJzIiwiZ2V0UHJlZGljYXRlIiwiZ2V0VHlwZSIsIl9pbmQiLCJpbmRlbnRlciIsImluZGVudCIsIm1ldGFkYXRhSW5kZW50Iiwic3ViamVjdCIsInN0cnMiLCJlbWQiLCJwcm9taXNlVXRpbCIsIml0ZW1zIiwiY3Vyc29yIiwib25GYWlsdXJlIiwidG9Qcm9taXNlIiwic2hpZnQiLCJpdGVtS2V5Iiwib25TdWNjZXNzIiwiZGVsYXkiLCJtaWxsaXNlY3MiLCJzZXRUaW1lb3V0IiwiaW52IiwiaW9iaiIsIm5zIiwicmRmbnMiLCJ4c2RucyIsInJlYXNvbmluZ0ZhY3RzIiwiSW5Qcm9ncmVzcyIsIlBlbmRpbmciLCJTdWNjZWVkZWQiLCJGYWlsZWQiLCJwaXBlbGluZURhdGEiLCJmbG9hdCIsIlJUX1JFU09MVkFCTEVJTkZPUk1BVElPTlJFU09VUkNFIiwiUlRfVU5LTk9XTiIsInV0aWxzIiwiZ2V0UmVsYXRlZFRvRW50cnlVUklzIiwiZnJvbUVudHJ5IiwicmVsYXRlZEVudHJ5VVJJcyIsImdldFJlbGF0ZWRUb0VudHJpZXMiLCJhbGwiLCJyZWZTdG10cyIsImdldFJlZmVycmVyc0dyYXBoIiwiZW50cnlQcm9taXNlcyIsInByb21pc2VzIiwiY29tbWl0TWV0YWRhdGEiLCJhZGRSZWxhdGlvbiIsInRvRW50cnkiLCJyZW1vdmVSZWxhdGlvbiIsImlzQnJvd3NlciIsImlzTm9kZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc0lFIiwibmF2aWdhdG9yIiwidXNlckFnZW50Il0sIm1hcHBpbmdzIjoiOztRQUFBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBOzs7UUFHQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0EsMENBQTBDLGdDQUFnQztRQUMxRTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLHdEQUF3RCxrQkFBa0I7UUFDMUU7UUFDQSxpREFBaUQsY0FBYztRQUMvRDs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EseUNBQXlDLGlDQUFpQztRQUMxRSxnSEFBZ0gsbUJBQW1CLEVBQUU7UUFDckk7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwyQkFBMkIsMEJBQTBCLEVBQUU7UUFDdkQsaUNBQWlDLGVBQWU7UUFDaEQ7UUFDQTtRQUNBOztRQUVBO1FBQ0Esc0RBQXNELCtEQUErRDs7UUFFckg7UUFDQTs7O1FBR0E7UUFDQTs7Ozs7Ozs7Ozs7O0FDbEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxDQUFDO0FBQ0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYztBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBbUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVB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QyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDM0MsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDOUMsbUJBQU8sQ0FBQyw2R0FBd0M7QUFDaEQsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDM0MsbUJBQU8sQ0FBQyxpSUFBa0Q7QUFDMUQsbUJBQU8sQ0FBQyxtSUFBbUQ7QUFDM0QsbUJBQU8sQ0FBQyx1SEFBNkM7QUFDckQsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQywrR0FBeUM7QUFDakQsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDN0MsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDaEMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDM0MsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDOUMsbUJBQU8sQ0FBQyxpSEFBMEM7QUFDbEQsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDOUMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDOUMsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDM0MsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyxpRkFBMEI7QUFDbEMsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDaEMsbUJBQU8sQ0FBQyxxRkFBNEI7QUFDcEMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQywyRUFBdUI7QUFDL0IsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQyxtRUFBbUI7QUFDM0IsbUJBQU8sQ0FBQyxtRUFBbUI7QUFDM0IsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDaEMsbUJBQU8sQ0FBQyw2RUFBd0I7QUFDaEMsbUJBQU8sQ0FBQyw2R0FBd0M7QUFDaEQsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQywrRUFBeUI7QUFDakMsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDOUMsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQywySEFBK0M7QUFDdkQsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQyw2R0FBd0M7QUFDaEQsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQyw2R0FBd0M7QUFDaEQsbUJBQU8sQ0FBQywrR0FBeUM7QUFDakQsbUJBQU8sQ0FBQywrR0FBeUM7QUFDakQsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyx5RkFBOEI7QUFDdEMsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyx5R0FBc0M7QUFDOUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQywrR0FBeUM7QUFDakQsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQyxpR0FBa0M7QUFDMUMsbUJBQU8sQ0FBQyw2R0FBd0M7QUFDaEQsbUJBQU8sQ0FBQyxtR0FBbUM7QUFDM0MsbUJBQU8sQ0FBQywyRkFBK0I7QUFDdkMsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFDeEMsbUJBQU8sQ0FBQyxxR0FBb0M7QUFDNUMsbUJBQU8sQ0FBQyxxSEFBNEM7QUFDcEQsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDN0MsbUJBQU8sQ0FBQyx1RkFBNkI7QUFDckMsbUJBQU8sQ0FBQywrRkFBaUM7QUFDekMsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQywyR0FBdUM7QUFDL0MsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyxtSUFBbUQ7QUFDM0QsbUJBQU8sQ0FBQyw2R0FBd0M7QUFDaEQsbUJBQU8sQ0FBQyxtRkFBMkI7QUFDbkMsbUJBQU8sQ0FBQyx1R0FBcUM7QUFDN0MsbUJBQU8sQ0FBQyw2RkFBZ0M7QUFD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O0FBQ0Qsb0NBQW9DO0FBQ3BDLG9CQUFvQixRQUFRO0FBQzVCLENBQUM7QUFDRCx3Q0FBd0M7QUFDeEMsb0JBQW9CO0FBQ3BCLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2QkFBNkI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHVCQUF1QjtBQUM1QztBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxL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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QixPQUFPO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsT0FBTztBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixPQUFPO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtSUFBa0M7QUFDbEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsK0JBQStCO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLEVBQUUsSUFBSSxFQUFFO0FBQ25ELHdDQUF3QyxFQUFFLElBQUksRUFBRTs7QUFFaEQ7O0FBRUE7QUFDQSxpQ0FBaUMsRUFBRTtBQUNuQywyQkFBMkIsRUFBRTtBQUM3Qiw2QkFBNkIsRUFBRTtBQUMvQiwyQkFBMkIsRUFBRTtBQUM3Qix5QkFBeUIsRUFBRSxJQUFJLEVBQUU7QUFDakMsd0JBQXdCLEVBQUU7QUFDMUIsK0JBQStCLEdBQUc7QUFDbEMseUJBQXlCLEVBQUU7QUFDM0I7QUFDQSwyQkFBMkIsRUFBRSxJQUFJLEVBQUU7QUFDbkMsMEJBQTBCLEVBQUUsSUFBSSxFQUFFO0FBQ2xDLHdCQUF3QixFQUFFO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw0Q0FBNEMsT0FBTztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBOEQsSUFBSSwwREFBMEQsSUFBSSxxRUFBcUUsRUFBRTs7QUFFdk07QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsbUJBQW1CLG1CQUFtQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixzQkFBc0I7QUFDekM7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsZ0JBQWdCO0FBQ2xEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsb0JBQW9CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUM7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZCQUE2QjtBQUN0QztBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQSw2REFBNkQ7QUFDN0QseURBQXlEO0FBQ3pELCtEQUErRDtBQUMvRCx3REFBd0QsT0FBTztBQUMvRCx3REFBd0QsT0FBTztBQUMvRCx1REFBdUQsT0FBTztBQUM5RCxtRUFBbUUsT0FBTztBQUMxRSxxRUFBcUUsT0FBTztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxxQkFBcUI7QUFDeEQsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscUJBQXFCO0FBQ3hELFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsbUJBQW1CO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHFCQUFxQixtQkFBbUI7QUFDeEM7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQW1CLE9BQU87QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9DQUFvQyxJQUFJO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7O0FBRUw7OztBQUdBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7QUN6L0lEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQXVEO0FBQ1E7QUFDbEI7QUFDUTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtREFBRTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxP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SDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRTtBQUNiLFdBQVcsRUFBRTtBQUNiLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7OztBQ3ZORDtBQUFBO0FBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkLEtBQUs7QUFDTCxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsV0FBVztBQUNuRDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsU0FBUztBQUNUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQ0FBb0MsY0FBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUI7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QUFZOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsZUFBZTtBQUMxQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsTUFBTTtBQUNqQixXQUFXLFNBQVM7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBLEVBQUU7QUFDRiwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMkJBQTJCO0FBQzNCLDRCQUE0QjtBQUM1QiwrQkFBK0I7QUFDL0I7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsU0FBUztBQUNUO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFD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TUFBTSxJQUFJQSxNQUFNLENBQUNxYyxTQUFQLENBQWlCQyxTQUFqQixDQUEyQnhGLEtBQTNCLENBQWlDLE1BQWpDLE1BQTZDLElBQTdEO0FBQUEsQ0FBYjs7O0FBQ0FvRSxLQUFLLENBQUNrQixJQUFOLEdBQWFBLElBQWI7ZUFRZWxCLEsiLCJmaWxlIjoiRW50cnlTdG9yZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LmpzXCIpO1xuIiwiLypcbiAqIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5cbi8qIGdsb2JhbCBkZWZpbmUgKi9cblxuOyhmdW5jdGlvbiAoJCkge1xuICAndXNlIHN0cmljdCdcblxuICAvKlxuICAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAgKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICAqL1xuICBmdW5jdGlvbiBzYWZlQWRkICh4LCB5KSB7XG4gICAgdmFyIGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKVxuICAgIHZhciBtc3cgPSAoeCA+PiAxNikgKyAoeSA+PiAxNikgKyAobHN3ID4+IDE2KVxuICAgIHJldHVybiAobXN3IDw8IDE2KSB8IChsc3cgJiAweGZmZmYpXG4gIH1cblxuICAvKlxuICAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAgKi9cbiAgZnVuY3Rpb24gYml0Um90YXRlTGVmdCAobnVtLCBjbnQpIHtcbiAgICByZXR1cm4gKG51bSA8PCBjbnQpIHwgKG51bSA+Pj4gKDMyIC0gY250KSlcbiAgfVxuXG4gIC8qXG4gICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAgKi9cbiAgZnVuY3Rpb24gbWQ1Y21uIChxLCBhLCBiLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIHNhZmVBZGQoYml0Um90YXRlTGVmdChzYWZlQWRkKHNhZmVBZGQoYSwgcSksIHNhZmVBZGQoeCwgdCkpLCBzKSwgYilcbiAgfVxuICBmdW5jdGlvbiBtZDVmZiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBtZDVjbW4oKGIgJiBjKSB8ICh+YiAmIGQpLCBhLCBiLCB4LCBzLCB0KVxuICB9XG4gIGZ1bmN0aW9uIG1kNWdnIChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gICAgcmV0dXJuIG1kNWNtbigoYiAmIGQpIHwgKGMgJiB+ZCksIGEsIGIsIHgsIHMsIHQpXG4gIH1cbiAgZnVuY3Rpb24gbWQ1aGggKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdClcbiAgfVxuICBmdW5jdGlvbiBtZDVpaSAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICAgIHJldHVybiBtZDVjbW4oYyBeIChiIHwgfmQpLCBhLCBiLCB4LCBzLCB0KVxuICB9XG5cbiAgLypcbiAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICAqL1xuICBmdW5jdGlvbiBiaW5sTUQ1ICh4LCBsZW4pIHtcbiAgICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICAgIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgKGxlbiAlIDMyKVxuICAgIHhbKChsZW4gKyA2NCkgPj4+IDkgPDwgNCkgKyAxNF0gPSBsZW5cblxuICAgIHZhciBpXG4gICAgdmFyIG9sZGFcbiAgICB2YXIgb2xkYlxuICAgIHZhciBvbGRjXG4gICAgdmFyIG9sZGRcbiAgICB2YXIgYSA9IDE3MzI1ODQxOTNcbiAgICB2YXIgYiA9IC0yNzE3MzM4NzlcbiAgICB2YXIgYyA9IC0xNzMyNTg0MTk0XG4gICAgdmFyIGQgPSAyNzE3MzM4NzhcblxuICAgIGZvciAoaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgb2xkYSA9IGFcbiAgICAgIG9sZGIgPSBiXG4gICAgICBvbGRjID0gY1xuICAgICAgb2xkZCA9IGRcblxuICAgICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpXG4gICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMV0sIDEyLCAtMzg5NTY0NTg2KVxuICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KVxuICAgICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApXG4gICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgNF0sIDcsIC0xNzY0MTg4OTcpXG4gICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KVxuICAgICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpXG4gICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgN10sIDIyLCAtNDU3MDU5ODMpXG4gICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpXG4gICAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNylcbiAgICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxMF0sIDE3LCAtNDIwNjMpXG4gICAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpXG4gICAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKVxuICAgICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDEzXSwgMTIsIC00MDM0MTEwMSlcbiAgICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MClcbiAgICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KVxuXG4gICAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApXG4gICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgNl0sIDksIC0xMDY5NTAxNjMyKVxuICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMylcbiAgICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMilcbiAgICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNSwgLTcwMTU1ODY5MSlcbiAgICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKVxuICAgICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpXG4gICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgNF0sIDIwLCAtNDA1NTM3ODQ4KVxuICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpXG4gICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MClcbiAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTQsIC0xODczNjM5NjEpXG4gICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKVxuICAgICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpXG4gICAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMl0sIDksIC01MTQwMzc4NClcbiAgICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpXG4gICAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpXG5cbiAgICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OClcbiAgICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA4XSwgMTEsIC0yMDIyNTc0NDYzKVxuICAgICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpXG4gICAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KVxuICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDFdLCA0LCAtMTUzMDk5MjA2MClcbiAgICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpXG4gICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKVxuICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDEwXSwgMjMsIC0xMDk0NzMwNjQwKVxuICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KVxuICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKVxuICAgICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNiwgLTcyMjUyMTk3OSlcbiAgICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KVxuICAgICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KVxuICAgICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDEyXSwgMTEsIC00MjE4MTU4MzUpXG4gICAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKVxuICAgICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSlcblxuICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpXG4gICAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgN10sIDEwLCAxMTI2ODkxNDE1KVxuICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KVxuICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KVxuICAgICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDEyXSwgNiwgMTcwMDQ4NTU3MSlcbiAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KVxuICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKVxuICAgICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDFdLCAyMSwgLTIwNTQ5MjI3OTkpXG4gICAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpXG4gICAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KVxuICAgICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNSwgLTE1NjAxOTgzODApXG4gICAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSlcbiAgICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MClcbiAgICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxMV0sIDEwLCAtMTEyMDIxMDM3OSlcbiAgICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSlcbiAgICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpXG5cbiAgICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpXG4gICAgICBiID0gc2FmZUFkZChiLCBvbGRiKVxuICAgICAgYyA9IHNhZmVBZGQoYywgb2xkYylcbiAgICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpXG4gICAgfVxuICAgIHJldHVybiBbYSwgYiwgYywgZF1cbiAgfVxuXG4gIC8qXG4gICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGEgc3RyaW5nXG4gICovXG4gIGZ1bmN0aW9uIGJpbmwycnN0ciAoaW5wdXQpIHtcbiAgICB2YXIgaVxuICAgIHZhciBvdXRwdXQgPSAnJ1xuICAgIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICAgIG91dHB1dCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChpbnB1dFtpID4+IDVdID4+PiAoaSAlIDMyKSkgJiAweGZmKVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0XG4gIH1cblxuICAvKlxuICAqIENvbnZlcnQgYSByYXcgc3RyaW5nIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgKiBDaGFyYWN0ZXJzID4yNTUgaGF2ZSB0aGVpciBoaWdoLWJ5dGUgc2lsZW50bHkgaWdub3JlZC5cbiAgKi9cbiAgZnVuY3Rpb24gcnN0cjJiaW5sIChpbnB1dCkge1xuICAgIHZhciBpXG4gICAgdmFyIG91dHB1dCA9IFtdXG4gICAgb3V0cHV0WyhpbnB1dC5sZW5ndGggPj4gMikgLSAxXSA9IHVuZGVmaW5lZFxuICAgIGZvciAoaSA9IDA7IGkgPCBvdXRwdXQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG91dHB1dFtpXSA9IDBcbiAgICB9XG4gICAgdmFyIGxlbmd0aDggPSBpbnB1dC5sZW5ndGggKiA4XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0LmNoYXJDb2RlQXQoaSAvIDgpICYgMHhmZikgPDwgKGkgJSAzMilcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFxuICB9XG5cbiAgLypcbiAgKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhIHJhdyBzdHJpbmdcbiAgKi9cbiAgZnVuY3Rpb24gcnN0ck1ENSAocykge1xuICAgIHJldHVybiBiaW5sMnJzdHIoYmlubE1ENShyc3RyMmJpbmwocyksIHMubGVuZ3RoICogOCkpXG4gIH1cblxuICAvKlxuICAqIENhbGN1bGF0ZSB0aGUgSE1BQy1NRDUsIG9mIGEga2V5IGFuZCBzb21lIGRhdGEgKHJhdyBzdHJpbmdzKVxuICAqL1xuICBmdW5jdGlvbiByc3RySE1BQ01ENSAoa2V5LCBkYXRhKSB7XG4gICAgdmFyIGlcbiAgICB2YXIgYmtleSA9IHJzdHIyYmlubChrZXkpXG4gICAgdmFyIGlwYWQgPSBbXVxuICAgIHZhciBvcGFkID0gW11cbiAgICB2YXIgaGFzaFxuICAgIGlwYWRbMTVdID0gb3BhZFsxNV0gPSB1bmRlZmluZWRcbiAgICBpZiAoYmtleS5sZW5ndGggPiAxNikge1xuICAgICAgYmtleSA9IGJpbmxNRDUoYmtleSwga2V5Lmxlbmd0aCAqIDgpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCAxNjsgaSArPSAxKSB7XG4gICAgICBpcGFkW2ldID0gYmtleVtpXSBeIDB4MzYzNjM2MzZcbiAgICAgIG9wYWRbaV0gPSBia2V5W2ldIF4gMHg1YzVjNWM1Y1xuICAgIH1cbiAgICBoYXNoID0gYmlubE1ENShpcGFkLmNvbmNhdChyc3RyMmJpbmwoZGF0YSkpLCA1MTIgKyBkYXRhLmxlbmd0aCAqIDgpXG4gICAgcmV0dXJuIGJpbmwycnN0cihiaW5sTUQ1KG9wYWQuY29uY2F0KGhhc2gpLCA1MTIgKyAxMjgpKVxuICB9XG5cbiAgLypcbiAgKiBDb252ZXJ0IGEgcmF3IHN0cmluZyB0byBhIGhleCBzdHJpbmdcbiAgKi9cbiAgZnVuY3Rpb24gcnN0cjJoZXggKGlucHV0KSB7XG4gICAgdmFyIGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICAgIHZhciBvdXRwdXQgPSAnJ1xuICAgIHZhciB4XG4gICAgdmFyIGlcbiAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHggPSBpbnB1dC5jaGFyQ29kZUF0KGkpXG4gICAgICBvdXRwdXQgKz0gaGV4VGFiLmNoYXJBdCgoeCA+Pj4gNCkgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpXG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRcbiAgfVxuXG4gIC8qXG4gICogRW5jb2RlIGEgc3RyaW5nIGFzIHV0Zi04XG4gICovXG4gIGZ1bmN0aW9uIHN0cjJyc3RyVVRGOCAoaW5wdXQpIHtcbiAgICByZXR1cm4gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGlucHV0KSlcbiAgfVxuXG4gIC8qXG4gICogVGFrZSBzdHJpbmcgYXJndW1lbnRzIGFuZCByZXR1cm4gZWl0aGVyIHJhdyBvciBoZXggZW5jb2RlZCBzdHJpbmdzXG4gICovXG4gIGZ1bmN0aW9uIHJhd01ENSAocykge1xuICAgIHJldHVybiByc3RyTUQ1KHN0cjJyc3RyVVRGOChzKSlcbiAgfVxuICBmdW5jdGlvbiBoZXhNRDUgKHMpIHtcbiAgICByZXR1cm4gcnN0cjJoZXgocmF3TUQ1KHMpKVxuICB9XG4gIGZ1bmN0aW9uIHJhd0hNQUNNRDUgKGssIGQpIHtcbiAgICByZXR1cm4gcnN0ckhNQUNNRDUoc3RyMnJzdHJVVEY4KGspLCBzdHIycnN0clVURjgoZCkpXG4gIH1cbiAgZnVuY3Rpb24gaGV4SE1BQ01ENSAoaywgZCkge1xuICAgIHJldHVybiByc3RyMmhleChyYXdITUFDTUQ1KGssIGQpKVxuICB9XG5cbiAgZnVuY3Rpb24gbWQ1IChzdHJpbmcsIGtleSwgcmF3KSB7XG4gICAgaWYgKCFrZXkpIHtcbiAgICAgIGlmICghcmF3KSB7XG4gICAgICAgIHJldHVybiBoZXhNRDUoc3RyaW5nKVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJhd01ENShzdHJpbmcpXG4gICAgfVxuICAgIGlmICghcmF3KSB7XG4gICAgICByZXR1cm4gaGV4SE1BQ01ENShrZXksIHN0cmluZylcbiAgICB9XG4gICAgcmV0dXJuIHJhd0hNQUNNRDUoa2V5LCBzdHJpbmcpXG4gIH1cblxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBtZDVcbiAgICB9KVxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZDVcbiAgfSBlbHNlIHtcbiAgICAkLm1kNSA9IG1kNVxuICB9XG59KSh0aGlzKVxuIiwidmFyIGNoYXJlbmMgPSB7XG4gIC8vIFVURi04IGVuY29kaW5nXG4gIHV0Zjg6IHtcbiAgICAvLyBDb252ZXJ0IGEgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIHN0cmluZ1RvQnl0ZXM6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgcmV0dXJuIGNoYXJlbmMuYmluLnN0cmluZ1RvQnl0ZXModW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHN0cikpKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJ5dGUgYXJyYXkgdG8gYSBzdHJpbmdcbiAgICBieXRlc1RvU3RyaW5nOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoY2hhcmVuYy5iaW4uYnl0ZXNUb1N0cmluZyhieXRlcykpKTtcbiAgICB9XG4gIH0sXG5cbiAgLy8gQmluYXJ5IGVuY29kaW5nXG4gIGJpbjoge1xuICAgIC8vIENvbnZlcnQgYSBzdHJpbmcgdG8gYSBieXRlIGFycmF5XG4gICAgc3RyaW5nVG9CeXRlczogZnVuY3Rpb24oc3RyKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKylcbiAgICAgICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIHN0cmluZ1xuICAgIGJ5dGVzVG9TdHJpbmc6IGZ1bmN0aW9uKGJ5dGVzKSB7XG4gICAgICBmb3IgKHZhciBzdHIgPSBbXSwgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKylcbiAgICAgICAgc3RyLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSkpO1xuICAgICAgcmV0dXJuIHN0ci5qb2luKCcnKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gY2hhcmVuYztcbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpXHJcbiAgICAsIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcblxyXG4gIGlmIChjYWxsYmFja3MpIHtcclxuICAgIGNhbGxiYWNrcyA9IGNhbGxiYWNrcy5zbGljZSgwKTtcclxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcclxuICAgICAgY2FsbGJhY2tzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmV0dXJuIGFycmF5IG9mIGNhbGxiYWNrcyBmb3IgYGV2ZW50YC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0FycmF5fVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgcmV0dXJuIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gfHwgW107XHJcbn07XHJcblxyXG4vKipcclxuICogQ2hlY2sgaWYgdGhpcyBlbWl0dGVyIGhhcyBgZXZlbnRgIGhhbmRsZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7Qm9vbGVhbn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5oYXNMaXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgcmV0dXJuICEhIHRoaXMubGlzdGVuZXJzKGV2ZW50KS5sZW5ndGg7XHJcbn07XHJcbiIsInJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5hc3luYy1pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wuZGVzY3JpcHRpb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLmhhcy1pbnN0YW5jZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wuaXMtY29uY2F0LXNwcmVhZGFibGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLml0ZXJhdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5tYXRjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zeW1ib2wubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5yZXBsYWNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC5zZWFyY2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLnNwZWNpZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLnNwbGl0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN5bWJvbC50by1wcmltaXRpdmUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLnRvLXN0cmluZy10YWcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3ltYm9sLnVuc2NvcGFibGVzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5hc3NpZ24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LmNyZWF0ZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZGVmaW5lLXByb3BlcnR5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtcHJvcGVydGllcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZW50cmllcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZnJlZXplJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5mcm9tLWVudHJpZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LmdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9ycycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuZ2V0LXByb3RvdHlwZS1vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuaXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LmlzLWV4dGVuc2libGUnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LmlzLWZyb3plbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QuaXMtc2VhbGVkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5rZXlzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5wcmV2ZW50LWV4dGVuc2lvbnMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LnNlYWwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LnNldC1wcm90b3R5cGUtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMub2JqZWN0LnZhbHVlcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5vYmplY3QudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5kZWZpbmUtc2V0dGVyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5sb29rdXAtZ2V0dGVyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm9iamVjdC5sb29rdXAtc2V0dGVyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmZ1bmN0aW9uLmJpbmQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuZnVuY3Rpb24ubmFtZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5mdW5jdGlvbi5oYXMtaW5zdGFuY2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuZnJvbScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pcy1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5jb25jYXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuY29weS13aXRoaW4nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuZXZlcnknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuZmlsbCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5maWx0ZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuZmluZCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5maW5kLWluZGV4Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5LmZsYXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuZmxhdC1tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaW5jbHVkZXMnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuam9pbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5sYXN0LWluZGV4LW9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5Lm1hcCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5yZWR1Y2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkucmVkdWNlLXJpZ2h0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5LnNwbGljZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5zcGVjaWVzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5LnVuc2NvcGFibGVzLmZsYXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkudW5zY29wYWJsZXMuZmxhdC1tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLmZyb20tY29kZS1wb2ludCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcucmF3Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5jb2RlLXBvaW50LWF0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5lbmRzLXdpdGgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5tYXRjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2gtYWxsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5wYWQtZW5kJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5wYWQtc3RhcnQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLnJlcGVhdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcucmVwbGFjZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuc2VhcmNoJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuc3RhcnRzLXdpdGgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0tc3RhcnQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLnRyaW0tZW5kJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuYW5jaG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5iaWcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLmJsaW5rJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5ib2xkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5maXhlZCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuZm9udGNvbG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5mb250c2l6ZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRhbGljcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcubGluaycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuc21hbGwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc3RyaW5nLnN0cmlrZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuc3ViJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnN0cmluZy5zdXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVnZXhwLmNvbnN0cnVjdG9yJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZ2V4cC5leGVjJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZ2V4cC5mbGFncycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5yZWdleHAudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnBhcnNlLWludCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wYXJzZS1mbG9hdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5udW1iZXIuY29uc3RydWN0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubnVtYmVyLmVwc2lsb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubnVtYmVyLmlzLWZpbml0ZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5udW1iZXIuaXMtaW50ZWdlcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5udW1iZXIuaXMtbmFuJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm51bWJlci5pcy1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubnVtYmVyLm1heC1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubnVtYmVyLm1pbi1zYWZlLWludGVnZXInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubnVtYmVyLnBhcnNlLWZsb2F0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm51bWJlci5wYXJzZS1pbnQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubnVtYmVyLnRvLWZpeGVkJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm51bWJlci50by1wcmVjaXNpb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5hY29zaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXRoLmFzaW5oJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm1hdGguYXRhbmgnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5jYnJ0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm1hdGguY2x6MzInKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5jb3NoJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm1hdGguZXhwbTEnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5mcm91bmQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5oeXBvdCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXRoLmltdWwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5sb2cxMCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXRoLmxvZzFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm1hdGgubG9nMicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXRoLnNpZ24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC5zaW5oJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLm1hdGgudGFuaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXRoLnRvLXN0cmluZy10YWcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMubWF0aC50cnVuYycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5kYXRlLm5vdycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5kYXRlLnRvLWpzb24nKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuZGF0ZS50by1pc28tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmRhdGUudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmRhdGUudG8tcHJpbWl0aXZlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmpzb24udG8tc3RyaW5nLXRhZycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5wcm9taXNlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnByb21pc2UuZmluYWxseScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5tYXAnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLndlYWstbWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLndlYWstc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLmFycmF5LWJ1ZmZlci5jb25zdHJ1Y3RvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuaXMtdmlldycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS1idWZmZXIuc2xpY2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuZGF0YS12aWV3Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDgtY2xhbXBlZC1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbnQxNi1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS51aW50MTYtYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuaW50MzItYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudWludDMyLWFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZsb2F0MzItYXJyYXknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmxvYXQ2NC1hcnJheScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mcm9tJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lm9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmNvcHktd2l0aGluJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmV2ZXJ5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbGwnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmlsdGVyJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LmZpbmQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuZmluZC1pbmRleCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5mb3ItZWFjaCcpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmNsdWRlcycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pbmRleC1vZicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5qb2luJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5Lmxhc3QtaW5kZXgtb2YnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkubWFwJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnJlZHVjZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5yZWR1Y2UtcmlnaHQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkucmV2ZXJzZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc2xpY2UnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkuc29tZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy50eXBlZC1hcnJheS5zb3J0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnN1YmFycmF5Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnR5cGVkLWFycmF5LnRvLWxvY2FsZS1zdHJpbmcnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMudHlwZWQtYXJyYXkudG8tc3RyaW5nJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZmxlY3QuYXBwbHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVmbGVjdC5jb25zdHJ1Y3QnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVmbGVjdC5kZWZpbmUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVmbGVjdC5kZWxldGUtcHJvcGVydHknKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVmbGVjdC5nZXQnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVmbGVjdC5nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMucmVmbGVjdC5nZXQtcHJvdG90eXBlLW9mJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZmxlY3QuaGFzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZmxlY3QuaXMtZXh0ZW5zaWJsZScpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5yZWZsZWN0Lm93bi1rZXlzJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZmxlY3QucHJldmVudC1leHRlbnNpb25zJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZmxlY3Quc2V0Jyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL2VzLnJlZmxlY3Quc2V0LXByb3RvdHlwZS1vZicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAodHlwZW9mIGl0ICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoU3RyaW5nKGl0KSArICcgaXMgbm90IGEgZnVuY3Rpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSAmJiBpdCAhPT0gbnVsbCkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArIFN0cmluZyhpdCkgKyAnIGFzIGEgcHJvdG90eXBlJyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsInZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xuXG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIEFycmF5LnByb3RvdHlwZVtAQHVuc2NvcGFibGVzXVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmlmIChBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU10gPT0gdW5kZWZpbmVkKSB7XG4gIGhpZGUoQXJyYXlQcm90b3R5cGUsIFVOU0NPUEFCTEVTLCBjcmVhdGUobnVsbCkpO1xufVxuXG4vLyBhZGQgYSBrZXkgdG8gQXJyYXkucHJvdG90eXBlW0BAdW5zY29wYWJsZXNdXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdW2tleV0gPSB0cnVlO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcblxuLy8gYEFkdmFuY2VTdHJpbmdJbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hZHZhbmNlc3RyaW5naW5kZXhcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFMsIGluZGV4LCB1bmljb2RlKSB7XG4gIHJldHVybiBpbmRleCArICh1bmljb2RlID8gY2hhckF0KFMsIGluZGV4KS5sZW5ndGggOiAxKTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQ29uc3RydWN0b3IsIG5hbWUpIHtcbiAgaWYgKCEoaXQgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCAnICsgKG5hbWUgPyBuYW1lICsgJyAnIDogJycpICsgJ2ludm9jYXRpb24nKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoIWlzT2JqZWN0KGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gIH0gcmV0dXJuIGl0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBnZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xuXG52YXIgRGF0YVZpZXcgPSBnbG9iYWwuRGF0YVZpZXc7XG52YXIgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldyAmJiBEYXRhVmlldy5wcm90b3R5cGU7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5ICYmIFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5ICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheSk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgaXNQcm90b3R5cGVPZiA9IE9iamVjdFByb3RvdHlwZS5pc1Byb3RvdHlwZU9mO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSB1aWQoJ1RZUEVEX0FSUkFZX1RBRycpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSAhIShnbG9iYWwuQXJyYXlCdWZmZXIgJiYgRGF0YVZpZXcpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBOQVRJVkVfQVJSQVlfQlVGRkVSICYmICEhc2V0UHJvdG90eXBlT2Y7XG52YXIgVFlQRURfQVJSQVlfVEFHX1JFUUlSRUQgPSBmYWxzZTtcbnZhciBOQU1FO1xuXG52YXIgVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QgPSB7XG4gIEludDhBcnJheTogMSxcbiAgVWludDhBcnJheTogMSxcbiAgVWludDhDbGFtcGVkQXJyYXk6IDEsXG4gIEludDE2QXJyYXk6IDIsXG4gIFVpbnQxNkFycmF5OiAyLFxuICBJbnQzMkFycmF5OiA0LFxuICBVaW50MzJBcnJheTogNCxcbiAgRmxvYXQzMkFycmF5OiA0LFxuICBGbG9hdDY0QXJyYXk6IDhcbn07XG5cbnZhciBpc1ZpZXcgPSBmdW5jdGlvbiBpc1ZpZXcoaXQpIHtcbiAgdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gIHJldHVybiBrbGFzcyA9PT0gJ0RhdGFWaWV3JyB8fCBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG5cbnZhciBpc1R5cGVkQXJyYXkgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGNsYXNzb2YoaXQpKTtcbn07XG5cbnZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXNUeXBlZEFycmF5KGl0KSkgcmV0dXJuIGl0O1xuICB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheScpO1xufTtcblxudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBmdW5jdGlvbiAoQykge1xuICBpZiAoc2V0UHJvdG90eXBlT2YpIHtcbiAgICBpZiAoaXNQcm90b3R5cGVPZi5jYWxsKFR5cGVkQXJyYXksIEMpKSByZXR1cm4gQztcbiAgfSBlbHNlIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSBpZiAoaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBOQU1FKSkge1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBnbG9iYWxbQVJSQVldO1xuICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgKEMgPT09IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciB8fCBpc1Byb3RvdHlwZU9mLmNhbGwoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBDKSkpIHtcbiAgICAgIHJldHVybiBDO1xuICAgIH1cbiAgfSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcblxudmFyIGV4cG9ydFByb3RvID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCkge1xuICBpZiAoIURFU0NSSVBUT1JTKSByZXR1cm47XG4gIGlmIChmb3JjZWQpIGZvciAodmFyIEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXMoVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSwgS0VZKSkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXTtcbiAgICB9XG4gIH1cbiAgaWYgKCFUeXBlZEFycmF5UHJvdG90eXBlW0tFWV0gfHwgZm9yY2VkKSB7XG4gICAgcmVkZWZpbmUoVHlwZWRBcnJheVByb3RvdHlwZSwgS0VZLCBmb3JjZWQgPyBwcm9wZXJ0eVxuICAgICAgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVByb3RvdHlwZVtLRVldIHx8IHByb3BlcnR5KTtcbiAgfVxufTtcblxudmFyIGV4cG9ydFN0YXRpYyA9IGZ1bmN0aW9uIChLRVksIHByb3BlcnR5LCBmb3JjZWQpIHtcbiAgdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gIGlmICghREVTQ1JJUFRPUlMpIHJldHVybjtcbiAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgaWYgKGZvcmNlZCkgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICAgIGlmIChUeXBlZEFycmF5Q29uc3RydWN0b3IgJiYgaGFzKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgS0VZKSkge1xuICAgICAgICBkZWxldGUgVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghVHlwZWRBcnJheVtLRVldIHx8IGZvcmNlZCkge1xuICAgICAgLy8gVjggfiBDaHJvbWUgNDktNTAgYCVUeXBlZEFycmF5JWAgbWV0aG9kcyBhcmUgbm9uLXdyaXRhYmxlIG5vbi1jb25maWd1cmFibGVcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZWRlZmluZShUeXBlZEFycmF5LCBLRVksIGZvcmNlZCA/IHByb3BlcnR5IDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBJbnQ4QXJyYXlbS0VZXSB8fCBwcm9wZXJ0eSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gICAgfSBlbHNlIHJldHVybjtcbiAgfVxuICBmb3IgKEFSUkFZIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmICghVHlwZWRBcnJheUNvbnN0cnVjdG9yW0tFWV0gfHwgZm9yY2VkKSkge1xuICAgICAgcmVkZWZpbmUoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgICB9XG4gIH1cbn07XG5cbmZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICBpZiAoIWdsb2JhbFtOQU1FXSkgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IGZhbHNlO1xufVxuXG4vLyBXZWJLaXQgYnVnIC0gdHlwZWQgYXJyYXlzIGNvbnN0cnVjdG9ycyBwcm90b3R5cGUgaXMgT2JqZWN0LnByb3RvdHlwZVxuaWYgKCFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8IHR5cGVvZiBUeXBlZEFycmF5ICE9ICdmdW5jdGlvbicgfHwgVHlwZWRBcnJheSA9PT0gRnVuY3Rpb24ucHJvdG90eXBlKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcbiAgVHlwZWRBcnJheSA9IGZ1bmN0aW9uIFR5cGVkQXJyYXkoKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuICB9O1xuICBpZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykgZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KSB7XG4gICAgaWYgKGdsb2JhbFtOQU1FXSkgc2V0UHJvdG90eXBlT2YoZ2xvYmFsW05BTUVdLCBUeXBlZEFycmF5KTtcbiAgfVxufVxuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUgfHwgVHlwZWRBcnJheVByb3RvdHlwZSA9PT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBUeXBlZEFycmF5LnByb3RvdHlwZTtcbiAgaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIGlmIChnbG9iYWxbTkFNRV0pIHNldFByb3RvdHlwZU9mKGdsb2JhbFtOQU1FXS5wcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xuICB9XG59XG5cbi8vIFdlYktpdCBidWcgLSBvbmUgbW9yZSBvYmplY3QgaW4gVWludDhDbGFtcGVkQXJyYXkgcHJvdG90eXBlIGNoYWluXG5pZiAoTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBnZXRQcm90b3R5cGVPZihVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSkgIT09IFR5cGVkQXJyYXlQcm90b3R5cGUpIHtcbiAgc2V0UHJvdG90eXBlT2YoVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUsIFR5cGVkQXJyYXlQcm90b3R5cGUpO1xufVxuXG5pZiAoREVTQ1JJUFRPUlMgJiYgIWhhcyhUeXBlZEFycmF5UHJvdG90eXBlLCBUT19TVFJJTkdfVEFHKSkge1xuICBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCA9IHRydWU7XG4gIGRlZmluZVByb3BlcnR5KFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUddIDogdW5kZWZpbmVkO1xuICB9IH0pO1xuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIGlmIChnbG9iYWxbTkFNRV0pIHtcbiAgICBoaWRlKGdsb2JhbFtOQU1FXSwgVFlQRURfQVJSQVlfVEFHLCBOQU1FKTtcbiAgfVxufVxuXG4vLyBXZWJLaXQgYnVnIC0gdGhlIHNhbWUgcGFyZW50IHByb3RvdHlwZSBmb3IgdHlwZWQgYXJyYXlzIGFuZCBkYXRhIHZpZXdcbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSICYmIHNldFByb3RvdHlwZU9mICYmIGdldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlKSAhPT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gIHNldFByb3RvdHlwZU9mKERhdGFWaWV3UHJvdG90eXBlLCBPYmplY3RQcm90b3R5cGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUjogTkFUSVZFX0FSUkFZX0JVRkZFUixcbiAgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUzogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyxcbiAgVFlQRURfQVJSQVlfVEFHOiBUWVBFRF9BUlJBWV9UQUdfUkVRSVJFRCAmJiBUWVBFRF9BUlJBWV9UQUcsXG4gIGFUeXBlZEFycmF5OiBhVHlwZWRBcnJheSxcbiAgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiAgZXhwb3J0UHJvdG86IGV4cG9ydFByb3RvLFxuICBleHBvcnRTdGF0aWM6IGV4cG9ydFN0YXRpYyxcbiAgaXNWaWV3OiBpc1ZpZXcsXG4gIGlzVHlwZWRBcnJheTogaXNUeXBlZEFycmF5LFxuICBUeXBlZEFycmF5OiBUeXBlZEFycmF5LFxuICBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLk5BVElWRV9BUlJBWV9CVUZGRVI7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmVBbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUtYWxsJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgYXJyYXlGaWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZpbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgQVJSQVlfQlVGRkVSID0gJ0FycmF5QnVmZmVyJztcbnZhciBEQVRBX1ZJRVcgPSAnRGF0YVZpZXcnO1xudmFyIFBST1RPVFlQRSA9ICdwcm90b3R5cGUnO1xudmFyIFdST05HX0xFTkdUSCA9ICdXcm9uZyBsZW5ndGgnO1xudmFyIFdST05HX0lOREVYID0gJ1dyb25nIGluZGV4JztcbnZhciBOYXRpdmVBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xudmFyICRBcnJheUJ1ZmZlciA9IE5hdGl2ZUFycmF5QnVmZmVyO1xudmFyICREYXRhVmlldyA9IGdsb2JhbFtEQVRBX1ZJRVddO1xudmFyIE1hdGggPSBnbG9iYWwuTWF0aDtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2hhZG93LXJlc3RyaWN0ZWQtbmFtZXNcbnZhciBJbmZpbml0eSA9IDEgLyAwO1xudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuLy8gSUVFRTc1NCBjb252ZXJzaW9ucyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2llZWU3NTRcbnZhciBwYWNrSUVFRTc1NCA9IGZ1bmN0aW9uIChudW1iZXIsIG1hbnRpc3NhTGVuZ3RoLCBieXRlcykge1xuICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGJ5dGVzKTtcbiAgdmFyIGV4cG9uZW50TGVuZ3RoID0gYnl0ZXMgKiA4IC0gbWFudGlzc2FMZW5ndGggLSAxO1xuICB2YXIgZU1heCA9ICgxIDw8IGV4cG9uZW50TGVuZ3RoKSAtIDE7XG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMTtcbiAgdmFyIHJ0ID0gbWFudGlzc2FMZW5ndGggPT09IDIzID8gcG93KDIsIC0yNCkgLSBwb3coMiwgLTc3KSA6IDA7XG4gIHZhciBzaWduID0gbnVtYmVyIDwgMCB8fCBudW1iZXIgPT09IDAgJiYgMSAvIG51bWJlciA8IDAgPyAxIDogMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGV4cG9uZW50LCBtYW50aXNzYSwgYztcbiAgbnVtYmVyID0gYWJzKG51bWJlcik7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKG51bWJlciAhPSBudW1iZXIgfHwgbnVtYmVyID09PSBJbmZpbml0eSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICBtYW50aXNzYSA9IG51bWJlciAhPSBudW1iZXIgPyAxIDogMDtcbiAgICBleHBvbmVudCA9IGVNYXg7XG4gIH0gZWxzZSB7XG4gICAgZXhwb25lbnQgPSBmbG9vcihsb2cobnVtYmVyKSAvIExOMik7XG4gICAgaWYgKG51bWJlciAqIChjID0gcG93KDIsIC1leHBvbmVudCkpIDwgMSkge1xuICAgICAgZXhwb25lbnQtLTtcbiAgICAgIGMgKj0gMjtcbiAgICB9XG4gICAgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbnVtYmVyICs9IHJ0IC8gYztcbiAgICB9IGVsc2Uge1xuICAgICAgbnVtYmVyICs9IHJ0ICogcG93KDIsIDEgLSBlQmlhcyk7XG4gICAgfVxuICAgIGlmIChudW1iZXIgKiBjID49IDIpIHtcbiAgICAgIGV4cG9uZW50Kys7XG4gICAgICBjIC89IDI7XG4gICAgfVxuICAgIGlmIChleHBvbmVudCArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG1hbnRpc3NhID0gMDtcbiAgICAgIGV4cG9uZW50ID0gZU1heDtcbiAgICB9IGVsc2UgaWYgKGV4cG9uZW50ICsgZUJpYXMgPj0gMSkge1xuICAgICAgbWFudGlzc2EgPSAobnVtYmVyICogYyAtIDEpICogcG93KDIsIG1hbnRpc3NhTGVuZ3RoKTtcbiAgICAgIGV4cG9uZW50ID0gZXhwb25lbnQgKyBlQmlhcztcbiAgICB9IGVsc2Uge1xuICAgICAgbWFudGlzc2EgPSBudW1iZXIgKiBwb3coMiwgZUJpYXMgLSAxKSAqIHBvdygyLCBtYW50aXNzYUxlbmd0aCk7XG4gICAgICBleHBvbmVudCA9IDA7XG4gICAgfVxuICB9XG4gIGZvciAoOyBtYW50aXNzYUxlbmd0aCA+PSA4OyBidWZmZXJbaW5kZXgrK10gPSBtYW50aXNzYSAmIDI1NSwgbWFudGlzc2EgLz0gMjU2LCBtYW50aXNzYUxlbmd0aCAtPSA4KTtcbiAgZXhwb25lbnQgPSBleHBvbmVudCA8PCBtYW50aXNzYUxlbmd0aCB8IG1hbnRpc3NhO1xuICBleHBvbmVudExlbmd0aCArPSBtYW50aXNzYUxlbmd0aDtcbiAgZm9yICg7IGV4cG9uZW50TGVuZ3RoID4gMDsgYnVmZmVyW2luZGV4KytdID0gZXhwb25lbnQgJiAyNTUsIGV4cG9uZW50IC89IDI1NiwgZXhwb25lbnRMZW5ndGggLT0gOCk7XG4gIGJ1ZmZlclstLWluZGV4XSB8PSBzaWduICogMTI4O1xuICByZXR1cm4gYnVmZmVyO1xufTtcblxudmFyIHVucGFja0lFRUU3NTQgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYW50aXNzYUxlbmd0aCkge1xuICB2YXIgYnl0ZXMgPSBidWZmZXIubGVuZ3RoO1xuICB2YXIgZXhwb25lbnRMZW5ndGggPSBieXRlcyAqIDggLSBtYW50aXNzYUxlbmd0aCAtIDE7XG4gIHZhciBlTWF4ID0gKDEgPDwgZXhwb25lbnRMZW5ndGgpIC0gMTtcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxO1xuICB2YXIgbkJpdHMgPSBleHBvbmVudExlbmd0aCAtIDc7XG4gIHZhciBpbmRleCA9IGJ5dGVzIC0gMTtcbiAgdmFyIHNpZ24gPSBidWZmZXJbaW5kZXgtLV07XG4gIHZhciBleHBvbmVudCA9IHNpZ24gJiAxMjc7XG4gIHZhciBtYW50aXNzYTtcbiAgc2lnbiA+Pj0gNztcbiAgZm9yICg7IG5CaXRzID4gMDsgZXhwb25lbnQgPSBleHBvbmVudCAqIDI1NiArIGJ1ZmZlcltpbmRleF0sIGluZGV4LS0sIG5CaXRzIC09IDgpO1xuICBtYW50aXNzYSA9IGV4cG9uZW50ICYgKDEgPDwgLW5CaXRzKSAtIDE7XG4gIGV4cG9uZW50ID4+PSAtbkJpdHM7XG4gIG5CaXRzICs9IG1hbnRpc3NhTGVuZ3RoO1xuICBmb3IgKDsgbkJpdHMgPiAwOyBtYW50aXNzYSA9IG1hbnRpc3NhICogMjU2ICsgYnVmZmVyW2luZGV4XSwgaW5kZXgtLSwgbkJpdHMgLT0gOCk7XG4gIGlmIChleHBvbmVudCA9PT0gMCkge1xuICAgIGV4cG9uZW50ID0gMSAtIGVCaWFzO1xuICB9IGVsc2UgaWYgKGV4cG9uZW50ID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG1hbnRpc3NhID8gTmFOIDogc2lnbiA/IC1JbmZpbml0eSA6IEluZmluaXR5O1xuICB9IGVsc2Uge1xuICAgIG1hbnRpc3NhID0gbWFudGlzc2EgKyBwb3coMiwgbWFudGlzc2FMZW5ndGgpO1xuICAgIGV4cG9uZW50ID0gZXhwb25lbnQgLSBlQmlhcztcbiAgfSByZXR1cm4gKHNpZ24gPyAtMSA6IDEpICogbWFudGlzc2EgKiBwb3coMiwgZXhwb25lbnQgLSBtYW50aXNzYUxlbmd0aCk7XG59O1xuXG52YXIgdW5wYWNrSW50MzIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gIHJldHVybiBidWZmZXJbM10gPDwgMjQgfCBidWZmZXJbMl0gPDwgMTYgfCBidWZmZXJbMV0gPDwgOCB8IGJ1ZmZlclswXTtcbn07XG5cbnZhciBwYWNrSW50OCA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIFtudW1iZXIgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MTYgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGXTtcbn07XG5cbnZhciBwYWNrSW50MzIgPSBmdW5jdGlvbiAobnVtYmVyKSB7XG4gIHJldHVybiBbbnVtYmVyICYgMHhGRiwgbnVtYmVyID4+IDggJiAweEZGLCBudW1iZXIgPj4gMTYgJiAweEZGLCBudW1iZXIgPj4gMjQgJiAweEZGXTtcbn07XG5cbnZhciBwYWNrRmxvYXQzMiA9IGZ1bmN0aW9uIChudW1iZXIpIHtcbiAgcmV0dXJuIHBhY2tJRUVFNzU0KG51bWJlciwgMjMsIDQpO1xufTtcblxudmFyIHBhY2tGbG9hdDY0ID0gZnVuY3Rpb24gKG51bWJlcikge1xuICByZXR1cm4gcGFja0lFRUU3NTQobnVtYmVyLCA1MiwgOCk7XG59O1xuXG52YXIgYWRkR2V0dGVyID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBrZXkpIHtcbiAgZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3JbUFJPVE9UWVBFXSwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKVtrZXldOyB9IH0pO1xufTtcblxudmFyIGdldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGlzTGl0dGxlRW5kaWFuKSB7XG4gIHZhciBudW1JbmRleCA9ICtpbmRleDtcbiAgdmFyIGludEluZGV4ID0gdG9JbmRleChudW1JbmRleCk7XG4gIHZhciBzdG9yZSA9IGdldEludGVybmFsU3RhdGUodmlldyk7XG4gIGlmIChpbnRJbmRleCArIGNvdW50ID4gc3RvcmUuYnl0ZUxlbmd0aCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19JTkRFWCk7XG4gIHZhciBieXRlcyA9IGdldEludGVybmFsU3RhdGUoc3RvcmUuYnVmZmVyKS5ieXRlcztcbiAgdmFyIHN0YXJ0ID0gaW50SW5kZXggKyBzdG9yZS5ieXRlT2Zmc2V0O1xuICB2YXIgcGFjayA9IGJ5dGVzLnNsaWNlKHN0YXJ0LCBzdGFydCArIGNvdW50KTtcbiAgcmV0dXJuIGlzTGl0dGxlRW5kaWFuID8gcGFjayA6IHBhY2sucmV2ZXJzZSgpO1xufTtcblxudmFyIHNldCA9IGZ1bmN0aW9uICh2aWV3LCBjb3VudCwgaW5kZXgsIGNvbnZlcnNpb24sIHZhbHVlLCBpc0xpdHRsZUVuZGlhbikge1xuICB2YXIgbnVtSW5kZXggPSAraW5kZXg7XG4gIHZhciBpbnRJbmRleCA9IHRvSW5kZXgobnVtSW5kZXgpO1xuICB2YXIgc3RvcmUgPSBnZXRJbnRlcm5hbFN0YXRlKHZpZXcpO1xuICBpZiAoaW50SW5kZXggKyBjb3VudCA+IHN0b3JlLmJ5dGVMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfSU5ERVgpO1xuICB2YXIgYnl0ZXMgPSBnZXRJbnRlcm5hbFN0YXRlKHN0b3JlLmJ1ZmZlcikuYnl0ZXM7XG4gIHZhciBzdGFydCA9IGludEluZGV4ICsgc3RvcmUuYnl0ZU9mZnNldDtcbiAgdmFyIHBhY2sgPSBjb252ZXJzaW9uKCt2YWx1ZSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgYnl0ZXNbc3RhcnQgKyBpXSA9IHBhY2tbaXNMaXR0bGVFbmRpYW4gPyBpIDogY291bnQgLSBpIC0gMV07XG59O1xuXG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVIpIHtcbiAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCAkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0b0luZGV4KGxlbmd0aCk7XG4gICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgICBieXRlczogYXJyYXlGaWxsLmNhbGwobmV3IEFycmF5KGJ5dGVMZW5ndGgpLCAwKSxcbiAgICAgIGJ5dGVMZW5ndGg6IGJ5dGVMZW5ndGhcbiAgICB9KTtcbiAgICBpZiAoIURFU0NSSVBUT1JTKSB0aGlzLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoO1xuICB9O1xuXG4gICREYXRhVmlldyA9IGZ1bmN0aW9uIERhdGFWaWV3KGJ1ZmZlciwgYnl0ZU9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICAgIGFuSW5zdGFuY2UodGhpcywgJERhdGFWaWV3LCBEQVRBX1ZJRVcpO1xuICAgIGFuSW5zdGFuY2UoYnVmZmVyLCAkQXJyYXlCdWZmZXIsIERBVEFfVklFVyk7XG4gICAgdmFyIGJ1ZmZlckxlbmd0aCA9IGdldEludGVybmFsU3RhdGUoYnVmZmVyKS5ieXRlTGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSB0b0ludGVnZXIoYnl0ZU9mZnNldCk7XG4gICAgaWYgKG9mZnNldCA8IDAgfHwgb2Zmc2V0ID4gYnVmZmVyTGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiAgICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA9PT0gdW5kZWZpbmVkID8gYnVmZmVyTGVuZ3RoIC0gb2Zmc2V0IDogdG9MZW5ndGgoYnl0ZUxlbmd0aCk7XG4gICAgaWYgKG9mZnNldCArIGJ5dGVMZW5ndGggPiBidWZmZXJMZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgIGJ1ZmZlcjogYnVmZmVyLFxuICAgICAgYnl0ZUxlbmd0aDogYnl0ZUxlbmd0aCxcbiAgICAgIGJ5dGVPZmZzZXQ6IG9mZnNldFxuICAgIH0pO1xuICAgIGlmICghREVTQ1JJUFRPUlMpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gYnVmZmVyO1xuICAgICAgdGhpcy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aDtcbiAgICAgIHRoaXMuYnl0ZU9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gIH07XG5cbiAgaWYgKERFU0NSSVBUT1JTKSB7XG4gICAgYWRkR2V0dGVyKCRBcnJheUJ1ZmZlciwgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCAnYnVmZmVyJyk7XG4gICAgYWRkR2V0dGVyKCREYXRhVmlldywgJ2J5dGVMZW5ndGgnKTtcbiAgICBhZGRHZXR0ZXIoJERhdGFWaWV3LCAnYnl0ZU9mZnNldCcpO1xuICB9XG5cbiAgcmVkZWZpbmVBbGwoJERhdGFWaWV3W1BST1RPVFlQRV0sIHtcbiAgICBnZXRJbnQ4OiBmdW5jdGlvbiBnZXRJbnQ4KGJ5dGVPZmZzZXQpIHtcbiAgICAgIHJldHVybiBnZXQodGhpcywgMSwgYnl0ZU9mZnNldClbMF0gPDwgMjQgPj4gMjQ7XG4gICAgfSxcbiAgICBnZXRVaW50ODogZnVuY3Rpb24gZ2V0VWludDgoYnl0ZU9mZnNldCkge1xuICAgICAgcmV0dXJuIGdldCh0aGlzLCAxLCBieXRlT2Zmc2V0KVswXTtcbiAgICB9LFxuICAgIGdldEludDE2OiBmdW5jdGlvbiBnZXRJbnQxNihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICB2YXIgYnl0ZXMgPSBnZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIChieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF0pIDw8IDE2ID4+IDE2O1xuICAgIH0sXG4gICAgZ2V0VWludDE2OiBmdW5jdGlvbiBnZXRVaW50MTYoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgdmFyIGJ5dGVzID0gZ2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICAgIHJldHVybiBieXRlc1sxXSA8PCA4IHwgYnl0ZXNbMF07XG4gICAgfSxcbiAgICBnZXRJbnQzMjogZnVuY3Rpb24gZ2V0SW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpO1xuICAgIH0sXG4gICAgZ2V0VWludDMyOiBmdW5jdGlvbiBnZXRVaW50MzIoYnl0ZU9mZnNldCAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgcmV0dXJuIHVucGFja0ludDMyKGdldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCkpID4+PiAwO1xuICAgIH0sXG4gICAgZ2V0RmxvYXQzMjogZnVuY3Rpb24gZ2V0RmxvYXQzMihieXRlT2Zmc2V0IC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICByZXR1cm4gdW5wYWNrSUVFRTc1NChnZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpLCAyMyk7XG4gICAgfSxcbiAgICBnZXRGbG9hdDY0OiBmdW5jdGlvbiBnZXRGbG9hdDY0KGJ5dGVPZmZzZXQgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHJldHVybiB1bnBhY2tJRUVFNzU0KGdldCh0aGlzLCA4LCBieXRlT2Zmc2V0LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCksIDUyKTtcbiAgICB9LFxuICAgIHNldEludDg6IGZ1bmN0aW9uIHNldEludDgoYnl0ZU9mZnNldCwgdmFsdWUpIHtcbiAgICAgIHNldCh0aGlzLCAxLCBieXRlT2Zmc2V0LCBwYWNrSW50OCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2V0VWludDg6IGZ1bmN0aW9uIHNldFVpbnQ4KGJ5dGVPZmZzZXQsIHZhbHVlKSB7XG4gICAgICBzZXQodGhpcywgMSwgYnl0ZU9mZnNldCwgcGFja0ludDgsIHZhbHVlKTtcbiAgICB9LFxuICAgIHNldEludDE2OiBmdW5jdGlvbiBzZXRJbnQxNihieXRlT2Zmc2V0LCB2YWx1ZSAvKiAsIGxpdHRsZUVuZGlhbiAqLykge1xuICAgICAgc2V0KHRoaXMsIDIsIGJ5dGVPZmZzZXQsIHBhY2tJbnQxNiwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbiAgICB9LFxuICAgIHNldFVpbnQxNjogZnVuY3Rpb24gc2V0VWludDE2KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgMiwgYnl0ZU9mZnNldCwgcGFja0ludDE2LCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0SW50MzI6IGZ1bmN0aW9uIHNldEludDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0ludDMyLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDIgPyBhcmd1bWVudHNbMl0gOiB1bmRlZmluZWQpO1xuICAgIH0sXG4gICAgc2V0VWludDMyOiBmdW5jdGlvbiBzZXRVaW50MzIoYnl0ZU9mZnNldCwgdmFsdWUgLyogLCBsaXR0bGVFbmRpYW4gKi8pIHtcbiAgICAgIHNldCh0aGlzLCA0LCBieXRlT2Zmc2V0LCBwYWNrSW50MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDMyOiBmdW5jdGlvbiBzZXRGbG9hdDMyKGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgNCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0MzIsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzZXRGbG9hdDY0OiBmdW5jdGlvbiBzZXRGbG9hdDY0KGJ5dGVPZmZzZXQsIHZhbHVlIC8qICwgbGl0dGxlRW5kaWFuICovKSB7XG4gICAgICBzZXQodGhpcywgOCwgYnl0ZU9mZnNldCwgcGFja0Zsb2F0NjQsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIGlmICghZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIE5hdGl2ZUFycmF5QnVmZmVyKDEpO1xuICB9KSB8fCAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIG5ldyBOYXRpdmVBcnJheUJ1ZmZlcigtMSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gIH0pIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoMS41KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICBuZXcgTmF0aXZlQXJyYXlCdWZmZXIoTmFOKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXdcbiAgICByZXR1cm4gTmF0aXZlQXJyYXlCdWZmZXIubmFtZSAhPSBBUlJBWV9CVUZGRVI7XG4gIH0pKSB7XG4gICAgJEFycmF5QnVmZmVyID0gZnVuY3Rpb24gQXJyYXlCdWZmZXIobGVuZ3RoKSB7XG4gICAgICBhbkluc3RhbmNlKHRoaXMsICRBcnJheUJ1ZmZlcik7XG4gICAgICByZXR1cm4gbmV3IE5hdGl2ZUFycmF5QnVmZmVyKHRvSW5kZXgobGVuZ3RoKSk7XG4gICAgfTtcbiAgICB2YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUgPSAkQXJyYXlCdWZmZXJbUFJPVE9UWVBFXSA9IE5hdGl2ZUFycmF5QnVmZmVyW1BST1RPVFlQRV07XG4gICAgZm9yICh2YXIga2V5cyA9IGdldE93blByb3BlcnR5TmFtZXMoTmF0aXZlQXJyYXlCdWZmZXIpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7KSB7XG4gICAgICBpZiAoISgoa2V5ID0ga2V5c1tqKytdKSBpbiAkQXJyYXlCdWZmZXIpKSBoaWRlKCRBcnJheUJ1ZmZlciwga2V5LCBOYXRpdmVBcnJheUJ1ZmZlcltrZXldKTtcbiAgICB9XG4gICAgQXJyYXlCdWZmZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSAkQXJyYXlCdWZmZXI7XG4gIH1cbiAgLy8gaU9TIFNhZmFyaSA3LnggYnVnXG4gIHZhciB0ZXN0VmlldyA9IG5ldyAkRGF0YVZpZXcobmV3ICRBcnJheUJ1ZmZlcigyKSk7XG4gIHZhciBuYXRpdmVTZXRJbnQ4ID0gJERhdGFWaWV3W1BST1RPVFlQRV0uc2V0SW50ODtcbiAgdGVzdFZpZXcuc2V0SW50OCgwLCAyMTQ3NDgzNjQ4KTtcbiAgdGVzdFZpZXcuc2V0SW50OCgxLCAyMTQ3NDgzNjQ5KTtcbiAgaWYgKHRlc3RWaWV3LmdldEludDgoMCkgfHwgIXRlc3RWaWV3LmdldEludDgoMSkpIHJlZGVmaW5lQWxsKCREYXRhVmlld1tQUk9UT1RZUEVdLCB7XG4gICAgc2V0SW50ODogZnVuY3Rpb24gc2V0SW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgbmF0aXZlU2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9LFxuICAgIHNldFVpbnQ4OiBmdW5jdGlvbiBzZXRVaW50OChieXRlT2Zmc2V0LCB2YWx1ZSkge1xuICAgICAgbmF0aXZlU2V0SW50OC5jYWxsKHRoaXMsIGJ5dGVPZmZzZXQsIHZhbHVlIDw8IDI0ID4+IDI0KTtcbiAgICB9XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuXG5zZXRUb1N0cmluZ1RhZygkQXJyYXlCdWZmZXIsIEFSUkFZX0JVRkZFUik7XG5zZXRUb1N0cmluZ1RhZygkRGF0YVZpZXcsIERBVEFfVklFVyk7XG5leHBvcnRzW0FSUkFZX0JVRkZFUl0gPSAkQXJyYXlCdWZmZXI7XG5leHBvcnRzW0RBVEFfVklFV10gPSAkRGF0YVZpZXc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5jb3B5d2l0aGluXG5tb2R1bGUuZXhwb3J0cyA9IFtdLmNvcHlXaXRoaW4gfHwgZnVuY3Rpb24gY29weVdpdGhpbih0YXJnZXQgLyogPSAwICovLCBzdGFydCAvKiA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIHRvID0gdG9BYnNvbHV0ZUluZGV4KHRhcmdldCwgbGVuKTtcbiAgdmFyIGZyb20gPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gIHZhciBlbmQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGNvdW50ID0gbWluKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbikpIC0gZnJvbSwgbGVuIC0gdG8pO1xuICB2YXIgaW5jID0gMTtcbiAgaWYgKGZyb20gPCB0byAmJiB0byA8IGZyb20gKyBjb3VudCkge1xuICAgIGluYyA9IC0xO1xuICAgIGZyb20gKz0gY291bnQgLSAxO1xuICAgIHRvICs9IGNvdW50IC0gMTtcbiAgfVxuICB3aGlsZSAoY291bnQtLSA+IDApIHtcbiAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgZWxzZSBkZWxldGUgT1t0b107XG4gICAgdG8gKz0gaW5jO1xuICAgIGZyb20gKz0gaW5jO1xuICB9IHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWxsYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maWxsXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZpbGwodmFsdWUgLyogLCBzdGFydCA9IDAsIGVuZCA9IEBsZW5ndGggKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBsZW5ndGgpO1xuICB2YXIgZW5kID0gYXJndW1lbnRzTGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgdmFyIGVuZFBvcyA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9BYnNvbHV0ZUluZGV4KGVuZCwgbGVuZ3RoKTtcbiAgd2hpbGUgKGVuZFBvcyA+IGluZGV4KSBPW2luZGV4KytdID0gdmFsdWU7XG4gIHJldHVybiBPO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkZm9yRWFjaCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5mb3JFYWNoO1xudmFyIHNsb3BweUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5mb3JlYWNoXG5tb2R1bGUuZXhwb3J0cyA9IHNsb3BweUFycmF5TWV0aG9kKCdmb3JFYWNoJykgPyBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHJldHVybiAkZm9yRWFjaCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59IDogW10uZm9yRWFjaDtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2FsbC13aXRoLXNhZmUtaXRlcmF0aW9uLWNsb3NpbmcnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG4vLyBgQXJyYXkuZnJvbWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5mcm9tXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oYXJyYXlMaWtlIC8qICwgbWFwZm4gPSB1bmRlZmluZWQsIHRoaXNBcmcgPSB1bmRlZmluZWQgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChhcnJheUxpa2UpO1xuICB2YXIgQyA9IHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXk7XG4gIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgbWFwZm4gPSBhcmd1bWVudHNMZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgbWFwcGluZyA9IG1hcGZuICE9PSB1bmRlZmluZWQ7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKE8pO1xuICB2YXIgbGVuZ3RoLCByZXN1bHQsIHN0ZXAsIGl0ZXJhdG9yO1xuICBpZiAobWFwcGluZykgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNMZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkLCAyKTtcbiAgLy8gaWYgdGhlIHRhcmdldCBpcyBub3QgaXRlcmFibGUgb3IgaXQncyBhbiBhcnJheSB3aXRoIHRoZSBkZWZhdWx0IGl0ZXJhdG9yIC0gdXNlIGEgc2ltcGxlIGNhc2VcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhKEMgPT0gQXJyYXkgJiYgaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEMoKTtcbiAgICBmb3IgKDshKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmU7IGluZGV4KyspIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwgaW5kZXgsIG1hcHBpbmdcbiAgICAgICAgPyBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nKGl0ZXJhdG9yLCBtYXBmbiwgW3N0ZXAudmFsdWUsIGluZGV4XSwgdHJ1ZSlcbiAgICAgICAgOiBzdGVwLnZhbHVlXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgcmVzdWx0ID0gbmV3IEMobGVuZ3RoKTtcbiAgICBmb3IgKDtsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICAgICAgY3JlYXRlUHJvcGVydHkocmVzdWx0LCBpbmRleCwgbWFwcGluZyA/IG1hcGZuKE9baW5kZXhdLCBpbmRleCkgOiBPW2luZGV4XSk7XG4gICAgfVxuICB9XG4gIHJlc3VsdC5sZW5ndGggPSBpbmRleDtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBpbmRleE9mLCBpbmNsdWRlcyB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKElTX0lOQ0xVREVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCgkdGhpcyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSB0b0Fic29sdXRlSW5kZXgoZnJvbUluZGV4LCBsZW5ndGgpO1xuICAgIHZhciB2YWx1ZTtcbiAgICAvLyBBcnJheSNpbmNsdWRlcyB1c2VzIFNhbWVWYWx1ZVplcm8gZXF1YWxpdHkgYWxnb3JpdGhtXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChJU19JTkNMVURFUyAmJiBlbCAhPSBlbCkgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YWx1ZSA9IE9baW5kZXgrK107XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgICBpZiAodmFsdWUgIT0gdmFsdWUpIHJldHVybiB0cnVlO1xuICAgIC8vIEFycmF5I2luZGV4T2YgaWdub3JlcyBob2xlcywgQXJyYXkjaW5jbHVkZXMgLSBub3RcbiAgICB9IGVsc2UgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIHtcbiAgICAgIGlmICgoSVNfSU5DTFVERVMgfHwgaW5kZXggaW4gTykgJiYgT1tpbmRleF0gPT09IGVsKSByZXR1cm4gSVNfSU5DTFVERVMgfHwgaW5kZXggfHwgMDtcbiAgICB9IHJldHVybiAhSVNfSU5DTFVERVMgJiYgLTE7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5pbmNsdWRlc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuICBpbmNsdWRlczogY3JlYXRlTWV0aG9kKHRydWUpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuaW5kZXhvZlxuICBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuIiwidmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG52YXIgcHVzaCA9IFtdLnB1c2g7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUueyBmb3JFYWNoLCBtYXAsIGZpbHRlciwgc29tZSwgZXZlcnksIGZpbmQsIGZpbmRJbmRleCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgdmFyIElTX01BUCA9IFRZUEUgPT0gMTtcbiAgdmFyIElTX0ZJTFRFUiA9IFRZUEUgPT0gMjtcbiAgdmFyIElTX1NPTUUgPSBUWVBFID09IDM7XG4gIHZhciBJU19FVkVSWSA9IFRZUEUgPT0gNDtcbiAgdmFyIElTX0ZJTkRfSU5ERVggPSBUWVBFID09IDY7XG4gIHZhciBOT19IT0xFUyA9IFRZUEUgPT0gNSB8fCBJU19GSU5EX0lOREVYO1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBjYWxsYmFja2ZuLCB0aGF0LCBzcGVjaWZpY0NyZWF0ZSkge1xuICAgIHZhciBPID0gdG9PYmplY3QoJHRoaXMpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2tmbiwgdGhhdCwgMyk7XG4gICAgdmFyIGxlbmd0aCA9IHRvTGVuZ3RoKHNlbGYubGVuZ3RoKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBjcmVhdGUgPSBzcGVjaWZpY0NyZWF0ZSB8fCBhcnJheVNwZWNpZXNDcmVhdGU7XG4gICAgdmFyIHRhcmdldCA9IElTX01BUCA/IGNyZWF0ZSgkdGhpcywgbGVuZ3RoKSA6IElTX0ZJTFRFUiA/IGNyZWF0ZSgkdGhpcywgMCkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gICAgZm9yICg7bGVuZ3RoID4gaW5kZXg7IGluZGV4KyspIGlmIChOT19IT0xFUyB8fCBpbmRleCBpbiBzZWxmKSB7XG4gICAgICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICAgICAgcmVzdWx0ID0gYm91bmRGdW5jdGlvbih2YWx1ZSwgaW5kZXgsIE8pO1xuICAgICAgaWYgKFRZUEUpIHtcbiAgICAgICAgaWYgKElTX01BUCkgdGFyZ2V0W2luZGV4XSA9IHJlc3VsdDsgLy8gbWFwXG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdCkgc3dpdGNoIChUWVBFKSB7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gdHJ1ZTsgICAgICAgICAgICAgIC8vIHNvbWVcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiB2YWx1ZTsgICAgICAgICAgICAgLy8gZmluZFxuICAgICAgICAgIGNhc2UgNjogcmV0dXJuIGluZGV4OyAgICAgICAgICAgICAvLyBmaW5kSW5kZXhcbiAgICAgICAgICBjYXNlIDI6IHB1c2guY2FsbCh0YXJnZXQsIHZhbHVlKTsgLy8gZmlsdGVyXG4gICAgICAgIH0gZWxzZSBpZiAoSVNfRVZFUlkpIHJldHVybiBmYWxzZTsgIC8vIGV2ZXJ5XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBJU19GSU5EX0lOREVYID8gLTEgOiBJU19TT01FIHx8IElTX0VWRVJZID8gSVNfRVZFUlkgOiB0YXJnZXQ7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZvcmVhY2hcbiAgZm9yRWFjaDogY3JlYXRlTWV0aG9kKDApLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5tYXBcbiAgbWFwOiBjcmVhdGVNZXRob2QoMSksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmlsdGVyYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuICBmaWx0ZXI6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5zb21lYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnNvbWVcbiAgc29tZTogY3JlYXRlTWV0aG9kKDMpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLmV2ZXJ5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4gIGV2ZXJ5OiBjcmVhdGVNZXRob2QoNCksXG4gIC8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kXG4gIGZpbmQ6IGNyZWF0ZU1ldGhvZCg1KSxcbiAgLy8gYEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXhgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZEluZGV4XG4gIGZpbmRJbmRleDogY3JlYXRlTWV0aG9kKDYpXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgc2xvcHB5QXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpO1xuXG52YXIgbWluID0gTWF0aC5taW47XG52YXIgbmF0aXZlTGFzdEluZGV4T2YgPSBbXS5sYXN0SW5kZXhPZjtcbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVMYXN0SW5kZXhPZiAmJiAxIC8gWzFdLmxhc3RJbmRleE9mKDEsIC0wKSA8IDA7XG52YXIgU0xPUFBZX01FVEhPRCA9IHNsb3BweUFycmF5TWV0aG9kKCdsYXN0SW5kZXhPZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5sYXN0aW5kZXhvZlxubW9kdWxlLmV4cG9ydHMgPSAoTkVHQVRJVkVfWkVSTyB8fCBTTE9QUFlfTUVUSE9EKSA/IGZ1bmN0aW9uIGxhc3RJbmRleE9mKHNlYXJjaEVsZW1lbnQgLyogLCBmcm9tSW5kZXggPSBAWyotMV0gKi8pIHtcbiAgLy8gY29udmVydCAtMCB0byArMFxuICBpZiAoTkVHQVRJVkVfWkVSTykgcmV0dXJuIG5hdGl2ZUxhc3RJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMDtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QodGhpcyk7XG4gIHZhciBsZW5ndGggPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IGxlbmd0aCAtIDE7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkgaW5kZXggPSBtaW4oaW5kZXgsIHRvSW50ZWdlcihhcmd1bWVudHNbMV0pKTtcbiAgaWYgKGluZGV4IDwgMCkgaW5kZXggPSBsZW5ndGggKyBpbmRleDtcbiAgZm9yICg7aW5kZXggPj0gMDsgaW5kZXgtLSkgaWYgKGluZGV4IGluIE8gJiYgT1tpbmRleF0gPT09IHNlYXJjaEVsZW1lbnQpIHJldHVybiBpbmRleCB8fCAwO1xuICByZXR1cm4gLTE7XG59IDogbmF0aXZlTGFzdEluZGV4T2Y7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgcmV0dXJuICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gYXJyYXkuY29uc3RydWN0b3IgPSB7fTtcbiAgICBjb25zdHJ1Y3RvcltTUEVDSUVTXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB7IGZvbzogMSB9O1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5W01FVEhPRF9OQU1FXShCb29sZWFuKS5mb28gIT09IDE7XG4gIH0pO1xufTtcbiIsInZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS57IHJlZHVjZSwgcmVkdWNlUmlnaHQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19SSUdIVCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRoYXQsIGNhbGxiYWNrZm4sIGFyZ3VtZW50c0xlbmd0aCwgbWVtbykge1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoYXQpO1xuICAgIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBpbmRleCA9IElTX1JJR0hUID8gbGVuZ3RoIC0gMSA6IDA7XG4gICAgdmFyIGkgPSBJU19SSUdIVCA/IC0xIDogMTtcbiAgICBpZiAoYXJndW1lbnRzTGVuZ3RoIDwgMikgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChpbmRleCBpbiBzZWxmKSB7XG4gICAgICAgIG1lbW8gPSBzZWxmW2luZGV4XTtcbiAgICAgICAgaW5kZXggKz0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBpO1xuICAgICAgaWYgKElTX1JJR0hUID8gaW5kZXggPCAwIDogbGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGFycmF5IHdpdGggbm8gaW5pdGlhbCB2YWx1ZScpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKDtJU19SSUdIVCA/IGluZGV4ID49IDAgOiBsZW5ndGggPiBpbmRleDsgaW5kZXggKz0gaSkgaWYgKGluZGV4IGluIHNlbGYpIHtcbiAgICAgIG1lbW8gPSBjYWxsYmFja2ZuKG1lbW8sIHNlbGZbaW5kZXhdLCBpbmRleCwgTyk7XG4gICAgfVxuICAgIHJldHVybiBtZW1vO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZVxuICBsZWZ0OiBjcmVhdGVNZXRob2QoZmFsc2UpLFxuICAvLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnJlZHVjZXJpZ2h0XG4gIHJpZ2h0OiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgU1BFQ0lFUyA9IHdlbGxLbm93blN5bWJvbCgnc3BlY2llcycpO1xuXG4vLyBgQXJyYXlTcGVjaWVzQ3JlYXRlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5c3BlY2llc2NyZWF0ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3JpZ2luYWxBcnJheSwgbGVuZ3RoKSB7XG4gIHZhciBDO1xuICBpZiAoaXNBcnJheShvcmlnaW5hbEFycmF5KSkge1xuICAgIEMgPSBvcmlnaW5hbEFycmF5LmNvbnN0cnVjdG9yO1xuICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgaWYgKHR5cGVvZiBDID09ICdmdW5jdGlvbicgJiYgKEMgPT09IEFycmF5IHx8IGlzQXJyYXkoQy5wcm90b3R5cGUpKSkgQyA9IHVuZGVmaW5lZDtcbiAgICBlbHNlIGlmIChpc09iamVjdChDKSkge1xuICAgICAgQyA9IENbU1BFQ0lFU107XG4gICAgICBpZiAoQyA9PT0gbnVsbCkgQyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH0gcmV0dXJuIG5ldyAoQyA9PT0gdW5kZWZpbmVkID8gQXJyYXkgOiBDKShsZW5ndGggPT09IDAgPyAwIDogbGVuZ3RoKTtcbn07XG4iLCJ2YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcblxuLy8gb3B0aW9uYWwgLyBzaW1wbGUgY29udGV4dCBiaW5kaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCwgbGVuZ3RoKSB7XG4gIGFGdW5jdGlvbihmbik7XG4gIGlmICh0aGF0ID09PSB1bmRlZmluZWQpIHJldHVybiBmbjtcbiAgc3dpdGNoIChsZW5ndGgpIHtcbiAgICBjYXNlIDA6IHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0KTtcbiAgICB9O1xuICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uIChhKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhKTtcbiAgICB9O1xuICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiKTtcbiAgICB9O1xuICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uIChhLCBiLCBjKSB7XG4gICAgICByZXR1cm4gZm4uY2FsbCh0aGF0LCBhLCBiLCBjKTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBmdW5jdGlvbiAoLyogLi4uYXJncyAqLykge1xuICAgIHJldHVybiBmbi5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xuICB9O1xufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gY2FsbCBzb21ldGhpbmcgb24gaXRlcmF0b3Igc3RlcCB3aXRoIHNhZmUgY2xvc2luZyBvbiBlcnJvclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGZuLCB2YWx1ZSwgRU5UUklFUykge1xuICB0cnkge1xuICAgIHJldHVybiBFTlRSSUVTID8gZm4oYW5PYmplY3QodmFsdWUpWzBdLCB2YWx1ZVsxXSkgOiBmbih2YWx1ZSk7XG4gIC8vIDcuNC42IEl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsIGNvbXBsZXRpb24pXG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdmFyIHJldHVybk1ldGhvZCA9IGl0ZXJhdG9yWydyZXR1cm4nXTtcbiAgICBpZiAocmV0dXJuTWV0aG9kICE9PSB1bmRlZmluZWQpIGFuT2JqZWN0KHJldHVybk1ldGhvZC5jYWxsKGl0ZXJhdG9yKSk7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBTQUZFX0NMT1NJTkcgPSBmYWxzZTtcblxudHJ5IHtcbiAgdmFyIGNhbGxlZCA9IDA7XG4gIHZhciBpdGVyYXRvcldpdGhSZXR1cm4gPSB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHsgZG9uZTogISFjYWxsZWQrKyB9O1xuICAgIH0sXG4gICAgJ3JldHVybic6IGZ1bmN0aW9uICgpIHtcbiAgICAgIFNBRkVfQ0xPU0lORyA9IHRydWU7XG4gICAgfVxuICB9O1xuICBpdGVyYXRvcldpdGhSZXR1cm5bSVRFUkFUT1JdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdGhyb3ctbGl0ZXJhbFxuICBBcnJheS5mcm9tKGl0ZXJhdG9yV2l0aFJldHVybiwgZnVuY3Rpb24gKCkgeyB0aHJvdyAyOyB9KTtcbn0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYywgU0tJUF9DTE9TSU5HKSB7XG4gIGlmICghU0tJUF9DTE9TSU5HICYmICFTQUZFX0NMT1NJTkcpIHJldHVybiBmYWxzZTtcbiAgdmFyIElURVJBVElPTl9TVVBQT1JUID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG9iamVjdCA9IHt9O1xuICAgIG9iamVjdFtJVEVSQVRPUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHsgZG9uZTogSVRFUkFUSU9OX1NVUFBPUlQgPSB0cnVlIH07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBleGVjKG9iamVjdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuIElURVJBVElPTl9TVVBQT1JUO1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChpdCkuc2xpY2UoOCwgLTEpO1xufTtcbiIsInZhciBjbGFzc29mUmF3ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xuLy8gRVMzIHdyb25nIGhlcmVcbnZhciBDT1JSRUNUX0FSR1VNRU5UUyA9IGNsYXNzb2ZSYXcoZnVuY3Rpb24gKCkgeyByZXR1cm4gYXJndW1lbnRzOyB9KCkpID09ICdBcmd1bWVudHMnO1xuXG4vLyBmYWxsYmFjayBmb3IgSUUxMSBTY3JpcHQgQWNjZXNzIERlbmllZCBlcnJvclxudmFyIHRyeUdldCA9IGZ1bmN0aW9uIChpdCwga2V5KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGl0W2tleV07XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbn07XG5cbi8vIGdldHRpbmcgdGFnIGZyb20gRVM2KyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2Bcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHZhciBPLCB0YWcsIHJlc3VsdDtcbiAgcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnXG4gICAgLy8gQEB0b1N0cmluZ1RhZyBjYXNlXG4gICAgOiB0eXBlb2YgKHRhZyA9IHRyeUdldChPID0gT2JqZWN0KGl0KSwgVE9fU1RSSU5HX1RBRykpID09ICdzdHJpbmcnID8gdGFnXG4gICAgLy8gYnVpbHRpblRhZyBjYXNlXG4gICAgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTylcbiAgICAvLyBFUzMgYXJndW1lbnRzIGZhbGxiYWNrXG4gICAgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT0gJ09iamVjdCcgJiYgdHlwZW9mIE8uY2FsbGVlID09ICdmdW5jdGlvbicgPyAnQXJndW1lbnRzJyA6IHJlc3VsdDtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBkZWZpbmVJdGVyYXRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZWZpbmUtaXRlcmF0b3InKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBmYXN0S2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJykuZmFzdEtleTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgaW50ZXJuYWxTdGF0ZUdldHRlckZvciA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0Q29uc3RydWN0b3I6IGZ1bmN0aW9uICh3cmFwcGVyLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVAsIEFEREVSKSB7XG4gICAgdmFyIEMgPSB3cmFwcGVyKGZ1bmN0aW9uICh0aGF0LCBpdGVyYWJsZSkge1xuICAgICAgYW5JbnN0YW5jZSh0aGF0LCBDLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgIHNldEludGVybmFsU3RhdGUodGhhdCwge1xuICAgICAgICB0eXBlOiBDT05TVFJVQ1RPUl9OQU1FLFxuICAgICAgICBpbmRleDogY3JlYXRlKG51bGwpLFxuICAgICAgICBmaXJzdDogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemU6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKCFERVNDUklQVE9SUykgdGhhdC5zaXplID0gMDtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgIHZhciBwcmV2aW91cywgaW5kZXg7XG4gICAgICAvLyBjaGFuZ2UgZXhpc3RpbmcgZW50cnlcbiAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICBlbnRyeS52YWx1ZSA9IHZhbHVlO1xuICAgICAgLy8gY3JlYXRlIG5ldyBlbnRyeVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUubGFzdCA9IGVudHJ5ID0ge1xuICAgICAgICAgIGluZGV4OiBpbmRleCA9IGZhc3RLZXkoa2V5LCB0cnVlKSxcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzID0gc3RhdGUubGFzdCxcbiAgICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgICAgcmVtb3ZlZDogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFzdGF0ZS5maXJzdCkgc3RhdGUuZmlyc3QgPSBlbnRyeTtcbiAgICAgICAgaWYgKHByZXZpb3VzKSBwcmV2aW91cy5uZXh0ID0gZW50cnk7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSsrO1xuICAgICAgICBlbHNlIHRoYXQuc2l6ZSsrO1xuICAgICAgICAvLyBhZGQgdG8gaW5kZXhcbiAgICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHN0YXRlLmluZGV4W2luZGV4XSA9IGVudHJ5O1xuICAgICAgfSByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgdmFyIGdldEVudHJ5ID0gZnVuY3Rpb24gKHRoYXQsIGtleSkge1xuICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgIC8vIGZhc3QgY2FzZVxuICAgICAgdmFyIGluZGV4ID0gZmFzdEtleShrZXkpO1xuICAgICAgdmFyIGVudHJ5O1xuICAgICAgaWYgKGluZGV4ICE9PSAnRicpIHJldHVybiBzdGF0ZS5pbmRleFtpbmRleF07XG4gICAgICAvLyBmcm96ZW4gb2JqZWN0IGNhc2VcbiAgICAgIGZvciAoZW50cnkgPSBzdGF0ZS5maXJzdDsgZW50cnk7IGVudHJ5ID0gZW50cnkubmV4dCkge1xuICAgICAgICBpZiAoZW50cnkua2V5ID09IGtleSkgcmV0dXJuIGVudHJ5O1xuICAgICAgfVxuICAgIH07XG5cbiAgICByZWRlZmluZUFsbChDLnByb3RvdHlwZSwge1xuICAgICAgLy8gMjMuMS4zLjEgTWFwLnByb3RvdHlwZS5jbGVhcigpXG4gICAgICAvLyAyMy4yLjMuMiBTZXQucHJvdG90eXBlLmNsZWFyKClcbiAgICAgIGNsZWFyOiBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgICB2YXIgZGF0YSA9IHN0YXRlLmluZGV4O1xuICAgICAgICB2YXIgZW50cnkgPSBzdGF0ZS5maXJzdDtcbiAgICAgICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkucmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgaWYgKGVudHJ5LnByZXZpb3VzKSBlbnRyeS5wcmV2aW91cyA9IGVudHJ5LnByZXZpb3VzLm5leHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgZGVsZXRlIGRhdGFbZW50cnkuaW5kZXhdO1xuICAgICAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5maXJzdCA9IHN0YXRlLmxhc3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZSA9IDA7XG4gICAgICAgIGVsc2UgdGhhdC5zaXplID0gMDtcbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuMyBNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy4yLjMuNCBTZXQucHJvdG90eXBlLmRlbGV0ZSh2YWx1ZSlcbiAgICAgICdkZWxldGUnOiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGF0KTtcbiAgICAgICAgdmFyIGVudHJ5ID0gZ2V0RW50cnkodGhhdCwga2V5KTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgdmFyIG5leHQgPSBlbnRyeS5uZXh0O1xuICAgICAgICAgIHZhciBwcmV2ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgICAgZGVsZXRlIHN0YXRlLmluZGV4W2VudHJ5LmluZGV4XTtcbiAgICAgICAgICBlbnRyeS5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocHJldikgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgICAgICBpZiAobmV4dCkgbmV4dC5wcmV2aW91cyA9IHByZXY7XG4gICAgICAgICAgaWYgKHN0YXRlLmZpcnN0ID09IGVudHJ5KSBzdGF0ZS5maXJzdCA9IG5leHQ7XG4gICAgICAgICAgaWYgKHN0YXRlLmxhc3QgPT0gZW50cnkpIHN0YXRlLmxhc3QgPSBwcmV2O1xuICAgICAgICAgIGlmIChERVNDUklQVE9SUykgc3RhdGUuc2l6ZS0tO1xuICAgICAgICAgIGVsc2UgdGhhdC5zaXplLS07XG4gICAgICAgIH0gcmV0dXJuICEhZW50cnk7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMi4zLjYgU2V0LnByb3RvdHlwZS5mb3JFYWNoKGNhbGxiYWNrZm4sIHRoaXNBcmcgPSB1bmRlZmluZWQpXG4gICAgICAvLyAyMy4xLjMuNSBNYXAucHJvdG90eXBlLmZvckVhY2goY2FsbGJhY2tmbiwgdGhpc0FyZyA9IHVuZGVmaW5lZClcbiAgICAgIGZvckVhY2g6IGZ1bmN0aW9uIGZvckVhY2goY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICAgICAgdmFyIGVudHJ5O1xuICAgICAgICB3aGlsZSAoZW50cnkgPSBlbnRyeSA/IGVudHJ5Lm5leHQgOiBzdGF0ZS5maXJzdCkge1xuICAgICAgICAgIGJvdW5kRnVuY3Rpb24oZW50cnkudmFsdWUsIGVudHJ5LmtleSwgdGhpcyk7XG4gICAgICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICAgICAgd2hpbGUgKGVudHJ5ICYmIGVudHJ5LnJlbW92ZWQpIGVudHJ5ID0gZW50cnkucHJldmlvdXM7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyAyMy4xLjMuNyBNYXAucHJvdG90eXBlLmhhcyhrZXkpXG4gICAgICAvLyAyMy4yLjMuNyBTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICByZXR1cm4gISFnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIElTX01BUCA/IHtcbiAgICAgIC8vIDIzLjEuMy42IE1hcC5wcm90b3R5cGUuZ2V0KGtleSlcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgICB2YXIgZW50cnkgPSBnZXRFbnRyeSh0aGlzLCBrZXkpO1xuICAgICAgICByZXR1cm4gZW50cnkgJiYgZW50cnkudmFsdWU7XG4gICAgICB9LFxuICAgICAgLy8gMjMuMS4zLjkgTWFwLnByb3RvdHlwZS5zZXQoa2V5LCB2YWx1ZSlcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCBrZXkgPT09IDAgPyAwIDoga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSA6IHtcbiAgICAgIC8vIDIzLjIuMy4xIFNldC5wcm90b3R5cGUuYWRkKHZhbHVlKVxuICAgICAgYWRkOiBmdW5jdGlvbiBhZGQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGRlZmluZSh0aGlzLCB2YWx1ZSA9IHZhbHVlID09PSAwID8gMCA6IHZhbHVlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKERFU0NSSVBUT1JTKSBkZWZpbmVQcm9wZXJ0eShDLnByb3RvdHlwZSwgJ3NpemUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykuc2l6ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gQztcbiAgfSxcbiAgc2V0U3Ryb25nOiBmdW5jdGlvbiAoQywgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQKSB7XG4gICAgdmFyIElURVJBVE9SX05BTUUgPSBDT05TVFJVQ1RPUl9OQU1FICsgJyBJdGVyYXRvcic7XG4gICAgdmFyIGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICB2YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gaW50ZXJuYWxTdGF0ZUdldHRlckZvcihJVEVSQVRPUl9OQU1FKTtcbiAgICAvLyBhZGQgLmtleXMsIC52YWx1ZXMsIC5lbnRyaWVzLCBbQEBpdGVyYXRvcl1cbiAgICAvLyAyMy4xLjMuNCwgMjMuMS4zLjgsIDIzLjEuMy4xMSwgMjMuMS4zLjEyLCAyMy4yLjMuNSwgMjMuMi4zLjgsIDIzLjIuMy4xMCwgMjMuMi4zLjExXG4gICAgZGVmaW5lSXRlcmF0b3IoQywgQ09OU1RSVUNUT1JfTkFNRSwgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoaXMsIHtcbiAgICAgICAgdHlwZTogSVRFUkFUT1JfTkFNRSxcbiAgICAgICAgdGFyZ2V0OiBpdGVyYXRlZCxcbiAgICAgICAgc3RhdGU6IGdldEludGVybmFsQ29sbGVjdGlvblN0YXRlKGl0ZXJhdGVkKSxcbiAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgbGFzdDogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbEl0ZXJhdG9yU3RhdGUodGhpcyk7XG4gICAgICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gICAgICB2YXIgZW50cnkgPSBzdGF0ZS5sYXN0O1xuICAgICAgLy8gcmV2ZXJ0IHRvIHRoZSBsYXN0IGV4aXN0aW5nIGVudHJ5XG4gICAgICB3aGlsZSAoZW50cnkgJiYgZW50cnkucmVtb3ZlZCkgZW50cnkgPSBlbnRyeS5wcmV2aW91cztcbiAgICAgIC8vIGdldCBuZXh0IGVudHJ5XG4gICAgICBpZiAoIXN0YXRlLnRhcmdldCB8fCAhKHN0YXRlLmxhc3QgPSBlbnRyeSA9IGVudHJ5ID8gZW50cnkubmV4dCA6IHN0YXRlLnN0YXRlLmZpcnN0KSkge1xuICAgICAgICAvLyBvciBmaW5pc2ggdGhlIGl0ZXJhdGlvblxuICAgICAgICBzdGF0ZS50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgICAgIH1cbiAgICAgIC8vIHJldHVybiBzdGVwIGJ5IGtpbmRcbiAgICAgIGlmIChraW5kID09ICdrZXlzJykgcmV0dXJuIHsgdmFsdWU6IGVudHJ5LmtleSwgZG9uZTogZmFsc2UgfTtcbiAgICAgIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogZW50cnkudmFsdWUsIGRvbmU6IGZhbHNlIH07XG4gICAgICByZXR1cm4geyB2YWx1ZTogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdLCBkb25lOiBmYWxzZSB9O1xuICAgIH0sIElTX01BUCA/ICdlbnRyaWVzJyA6ICd2YWx1ZXMnLCAhSVNfTUFQLCB0cnVlKTtcblxuICAgIC8vIGFkZCBbQEBzcGVjaWVzXSwgMjMuMS4yLjIsIDIzLjIuMi4yXG4gICAgc2V0U3BlY2llcyhDT05TVFJVQ1RPUl9OQU1FKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBnZXRXZWFrRGF0YSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YScpLmdldFdlYWtEYXRhO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpdGVyYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdGUnKTtcbnZhciBBcnJheUl0ZXJhdGlvbk1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKTtcbnZhciAkaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcblxudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3I7XG52YXIgZmluZCA9IEFycmF5SXRlcmF0aW9uTW9kdWxlLmZpbmQ7XG52YXIgZmluZEluZGV4ID0gQXJyYXlJdGVyYXRpb25Nb2R1bGUuZmluZEluZGV4O1xudmFyIGlkID0gMDtcblxuLy8gZmFsbGJhY2sgZm9yIHVuY2F1Z2h0IGZyb3plbiBrZXlzXG52YXIgdW5jYXVnaHRGcm96ZW5TdG9yZSA9IGZ1bmN0aW9uIChzdG9yZSkge1xuICByZXR1cm4gc3RvcmUuZnJvemVuIHx8IChzdG9yZS5mcm96ZW4gPSBuZXcgVW5jYXVnaHRGcm96ZW5TdG9yZSgpKTtcbn07XG5cbnZhciBVbmNhdWdodEZyb3plblN0b3JlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVudHJpZXMgPSBbXTtcbn07XG5cbnZhciBmaW5kVW5jYXVnaHRGcm96ZW4gPSBmdW5jdGlvbiAoc3RvcmUsIGtleSkge1xuICByZXR1cm4gZmluZChzdG9yZS5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gaXRbMF0gPT09IGtleTtcbiAgfSk7XG59O1xuXG5VbmNhdWdodEZyb3plblN0b3JlLnByb3RvdHlwZSA9IHtcbiAgZ2V0OiBmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSByZXR1cm4gZW50cnlbMV07XG4gIH0sXG4gIGhhczogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiAhIWZpbmRVbmNhdWdodEZyb3plbih0aGlzLCBrZXkpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgdmFyIGVudHJ5ID0gZmluZFVuY2F1Z2h0RnJvemVuKHRoaXMsIGtleSk7XG4gICAgaWYgKGVudHJ5KSBlbnRyeVsxXSA9IHZhbHVlO1xuICAgIGVsc2UgdGhpcy5lbnRyaWVzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgfSxcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgaW5kZXggPSBmaW5kSW5kZXgodGhpcy5lbnRyaWVzLCBmdW5jdGlvbiAoaXQpIHtcbiAgICAgIHJldHVybiBpdFswXSA9PT0ga2V5O1xuICAgIH0pO1xuICAgIGlmICh+aW5kZXgpIHRoaXMuZW50cmllcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIHJldHVybiAhIX5pbmRleDtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbiAod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUikge1xuICAgIHZhciBDID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgaXRlcmFibGUpIHtcbiAgICAgIGFuSW5zdGFuY2UodGhhdCwgQywgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICBzZXRJbnRlcm5hbFN0YXRlKHRoYXQsIHtcbiAgICAgICAgdHlwZTogQ09OU1RSVUNUT1JfTkFNRSxcbiAgICAgICAgaWQ6IGlkKyssXG4gICAgICAgIGZyb3plbjogdW5kZWZpbmVkXG4gICAgICB9KTtcbiAgICAgIGlmIChpdGVyYWJsZSAhPSB1bmRlZmluZWQpIGl0ZXJhdGUoaXRlcmFibGUsIHRoYXRbQURERVJdLCB0aGF0LCBJU19NQVApO1xuICAgIH0pO1xuXG4gICAgdmFyIGdldEludGVybmFsU3RhdGUgPSBpbnRlcm5hbFN0YXRlR2V0dGVyRm9yKENPTlNUUlVDVE9SX05BTUUpO1xuXG4gICAgdmFyIGRlZmluZSA9IGZ1bmN0aW9uICh0aGF0LCBrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShhbk9iamVjdChrZXkpLCB0cnVlKTtcbiAgICAgIGlmIChkYXRhID09PSB0cnVlKSB1bmNhdWdodEZyb3plblN0b3JlKHN0YXRlKS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICBlbHNlIGRhdGFbc3RhdGUuaWRdID0gdmFsdWU7XG4gICAgICByZXR1cm4gdGhhdDtcbiAgICB9O1xuXG4gICAgcmVkZWZpbmVBbGwoQy5wcm90b3R5cGUsIHtcbiAgICAgIC8vIDIzLjMuMy4yIFdlYWtNYXAucHJvdG90eXBlLmRlbGV0ZShrZXkpXG4gICAgICAvLyAyMy40LjMuMyBXZWFrU2V0LnByb3RvdHlwZS5kZWxldGUodmFsdWUpXG4gICAgICAnZGVsZXRlJzogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpWydkZWxldGUnXShrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHN0YXRlLmlkKSAmJiBkZWxldGUgZGF0YVtzdGF0ZS5pZF07XG4gICAgICB9LFxuICAgICAgLy8gMjMuMy4zLjQgV2Vha01hcC5wcm90b3R5cGUuaGFzKGtleSlcbiAgICAgIC8vIDIzLjQuMy40IFdlYWtTZXQucHJvdG90eXBlLmhhcyh2YWx1ZSlcbiAgICAgIGhhczogZnVuY3Rpb24gaGFzKGtleSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIWlzT2JqZWN0KGtleSkpIHJldHVybiBmYWxzZTtcbiAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICBpZiAoZGF0YSA9PT0gdHJ1ZSkgcmV0dXJuIHVuY2F1Z2h0RnJvemVuU3RvcmUoc3RhdGUpLmhhcyhrZXkpO1xuICAgICAgICByZXR1cm4gZGF0YSAmJiAkaGFzKGRhdGEsIHN0YXRlLmlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJlZGVmaW5lQWxsKEMucHJvdG90eXBlLCBJU19NQVAgPyB7XG4gICAgICAvLyAyMy4zLjMuMyBXZWFrTWFwLnByb3RvdHlwZS5nZXQoa2V5KVxuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoa2V5KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmIChpc09iamVjdChrZXkpKSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBnZXRXZWFrRGF0YShrZXkpO1xuICAgICAgICAgIGlmIChkYXRhID09PSB0cnVlKSByZXR1cm4gdW5jYXVnaHRGcm96ZW5TdG9yZShzdGF0ZSkuZ2V0KGtleSk7XG4gICAgICAgICAgcmV0dXJuIGRhdGEgPyBkYXRhW3N0YXRlLmlkXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIDIzLjMuMy41IFdlYWtNYXAucHJvdG90eXBlLnNldChrZXksIHZhbHVlKVxuICAgICAgc2V0OiBmdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH0gOiB7XG4gICAgICAvLyAyMy40LjMuMSBXZWFrU2V0LnByb3RvdHlwZS5hZGQodmFsdWUpXG4gICAgICBhZGQ6IGZ1bmN0aW9uIGFkZCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZGVmaW5lKHRoaXMsIHZhbHVlLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBDO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGlzRm9yY2VkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWZvcmNlZCcpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YScpO1xudmFyIGl0ZXJhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0ZScpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jaGVjay1jb3JyZWN0bmVzcy1vZi1pdGVyYXRpb24nKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGluaGVyaXRJZlJlcXVpcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2luaGVyaXQtaWYtcmVxdWlyZWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSwgd3JhcHBlciwgY29tbW9uLCBJU19NQVAsIElTX1dFQUspIHtcbiAgdmFyIE5hdGl2ZUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xuICB2YXIgTmF0aXZlUHJvdG90eXBlID0gTmF0aXZlQ29uc3RydWN0b3IgJiYgTmF0aXZlQ29uc3RydWN0b3IucHJvdG90eXBlO1xuICB2YXIgQ29uc3RydWN0b3IgPSBOYXRpdmVDb25zdHJ1Y3RvcjtcbiAgdmFyIEFEREVSID0gSVNfTUFQID8gJ3NldCcgOiAnYWRkJztcbiAgdmFyIGV4cG9ydGVkID0ge307XG5cbiAgdmFyIGZpeE1ldGhvZCA9IGZ1bmN0aW9uIChLRVkpIHtcbiAgICB2YXIgbmF0aXZlTWV0aG9kID0gTmF0aXZlUHJvdG90eXBlW0tFWV07XG4gICAgcmVkZWZpbmUoTmF0aXZlUHJvdG90eXBlLCBLRVksXG4gICAgICBLRVkgPT0gJ2FkZCcgPyBmdW5jdGlvbiBhZGQoYSkge1xuICAgICAgICBuYXRpdmVNZXRob2QuY2FsbCh0aGlzLCBhID09PSAwID8gMCA6IGEpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gOiBLRVkgPT0gJ2RlbGV0ZScgPyBmdW5jdGlvbiAoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogS0VZID09ICdnZXQnID8gZnVuY3Rpb24gZ2V0KGEpIHtcbiAgICAgICAgcmV0dXJuIElTX1dFQUsgJiYgIWlzT2JqZWN0KGEpID8gdW5kZWZpbmVkIDogbmF0aXZlTWV0aG9kLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhKTtcbiAgICAgIH0gOiBLRVkgPT0gJ2hhcycgPyBmdW5jdGlvbiBoYXMoYSkge1xuICAgICAgICByZXR1cm4gSVNfV0VBSyAmJiAhaXNPYmplY3QoYSkgPyBmYWxzZSA6IG5hdGl2ZU1ldGhvZC5jYWxsKHRoaXMsIGEgPT09IDAgPyAwIDogYSk7XG4gICAgICB9IDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcbiAgICAgICAgbmF0aXZlTWV0aG9kLmNhbGwodGhpcywgYSA9PT0gMCA/IDAgOiBhLCBiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgKTtcbiAgfTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICBpZiAoaXNGb3JjZWQoQ09OU1RSVUNUT1JfTkFNRSwgdHlwZW9mIE5hdGl2ZUNvbnN0cnVjdG9yICE9ICdmdW5jdGlvbicgfHwgIShJU19XRUFLIHx8IE5hdGl2ZVByb3RvdHlwZS5mb3JFYWNoICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKCkuZW50cmllcygpLm5leHQoKTtcbiAgfSkpKSkge1xuICAgIC8vIGNyZWF0ZSBjb2xsZWN0aW9uIGNvbnN0cnVjdG9yXG4gICAgQ29uc3RydWN0b3IgPSBjb21tb24uZ2V0Q29uc3RydWN0b3Iod3JhcHBlciwgQ09OU1RSVUNUT1JfTkFNRSwgSVNfTUFQLCBBRERFUik7XG4gICAgSW50ZXJuYWxNZXRhZGF0YU1vZHVsZS5SRVFVSVJFRCA9IHRydWU7XG4gIH0gZWxzZSBpZiAoaXNGb3JjZWQoQ09OU1RSVUNUT1JfTkFNRSwgdHJ1ZSkpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAvLyBlYXJseSBpbXBsZW1lbnRhdGlvbnMgbm90IHN1cHBvcnRzIGNoYWluaW5nXG4gICAgdmFyIEhBU05UX0NIQUlOSU5HID0gaW5zdGFuY2VbQURERVJdKElTX1dFQUsgPyB7fSA6IC0wLCAxKSAhPSBpbnN0YW5jZTtcbiAgICAvLyBWOCB+ICBDaHJvbWl1bSA0MC0gd2Vhay1jb2xsZWN0aW9ucyB0aHJvd3Mgb24gcHJpbWl0aXZlcywgYnV0IHNob3VsZCByZXR1cm4gZmFsc2VcbiAgICB2YXIgVEhST1dTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IGluc3RhbmNlLmhhcygxKTsgfSk7XG4gICAgLy8gbW9zdCBlYXJseSBpbXBsZW1lbnRhdGlvbnMgZG9lc24ndCBzdXBwb3J0cyBpdGVyYWJsZXMsIG1vc3QgbW9kZXJuIC0gbm90IGNsb3NlIGl0IGNvcnJlY3RseVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXdcbiAgICB2YXIgQUNDRVBUX0lURVJBQkxFUyA9IGNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHsgbmV3IE5hdGl2ZUNvbnN0cnVjdG9yKGl0ZXJhYmxlKTsgfSk7XG4gICAgLy8gZm9yIGVhcmx5IGltcGxlbWVudGF0aW9ucyAtMCBhbmQgKzAgbm90IHRoZSBzYW1lXG4gICAgdmFyIEJVR0dZX1pFUk8gPSAhSVNfV0VBSyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBWOCB+IENocm9taXVtIDQyLSBmYWlscyBvbmx5IHdpdGggNSsgZWxlbWVudHNcbiAgICAgIHZhciAkaW5zdGFuY2UgPSBuZXcgTmF0aXZlQ29uc3RydWN0b3IoKTtcbiAgICAgIHZhciBpbmRleCA9IDU7XG4gICAgICB3aGlsZSAoaW5kZXgtLSkgJGluc3RhbmNlW0FEREVSXShpbmRleCwgaW5kZXgpO1xuICAgICAgcmV0dXJuICEkaW5zdGFuY2UuaGFzKC0wKTtcbiAgICB9KTtcblxuICAgIGlmICghQUNDRVBUX0lURVJBQkxFUykge1xuICAgICAgQ29uc3RydWN0b3IgPSB3cmFwcGVyKGZ1bmN0aW9uIChkdW1teSwgaXRlcmFibGUpIHtcbiAgICAgICAgYW5JbnN0YW5jZShkdW1teSwgQ29uc3RydWN0b3IsIENPTlNUUlVDVE9SX05BTUUpO1xuICAgICAgICB2YXIgdGhhdCA9IGluaGVyaXRJZlJlcXVpcmVkKG5ldyBOYXRpdmVDb25zdHJ1Y3RvcigpLCBkdW1teSwgQ29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoaXRlcmFibGUgIT0gdW5kZWZpbmVkKSBpdGVyYXRlKGl0ZXJhYmxlLCB0aGF0W0FEREVSXSwgdGhhdCwgSVNfTUFQKTtcbiAgICAgICAgcmV0dXJuIHRoYXQ7XG4gICAgICB9KTtcbiAgICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZSA9IE5hdGl2ZVByb3RvdHlwZTtcbiAgICAgIE5hdGl2ZVByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuICAgIH1cblxuICAgIGlmIChUSFJPV1NfT05fUFJJTUlUSVZFUyB8fCBCVUdHWV9aRVJPKSB7XG4gICAgICBmaXhNZXRob2QoJ2RlbGV0ZScpO1xuICAgICAgZml4TWV0aG9kKCdoYXMnKTtcbiAgICAgIElTX01BUCAmJiBmaXhNZXRob2QoJ2dldCcpO1xuICAgIH1cblxuICAgIGlmIChCVUdHWV9aRVJPIHx8IEhBU05UX0NIQUlOSU5HKSBmaXhNZXRob2QoQURERVIpO1xuXG4gICAgLy8gd2VhayBjb2xsZWN0aW9ucyBzaG91bGQgbm90IGNvbnRhaW5zIC5jbGVhciBtZXRob2RcbiAgICBpZiAoSVNfV0VBSyAmJiBOYXRpdmVQcm90b3R5cGUuY2xlYXIpIGRlbGV0ZSBOYXRpdmVQcm90b3R5cGUuY2xlYXI7XG4gIH1cblxuICBleHBvcnRlZFtDT05TVFJVQ1RPUl9OQU1FXSA9IENvbnN0cnVjdG9yO1xuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IENvbnN0cnVjdG9yICE9IE5hdGl2ZUNvbnN0cnVjdG9yIH0sIGV4cG9ydGVkKTtcblxuICBzZXRUb1N0cmluZ1RhZyhDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG5cbiAgaWYgKCFJU19XRUFLKSBjb21tb24uc2V0U3Ryb25nKENvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FLCBJU19NQVApO1xuXG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIG93bktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb3duLWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcbiAgdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gIHZhciBkZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG4gIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgaWYgKCFoYXModGFyZ2V0LCBrZXkpKSBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XG4gIH1cbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTUVUSE9EX05BTUUpIHtcbiAgdmFyIHJlZ2V4cCA9IC8uLztcbiAgdHJ5IHtcbiAgICAnLy4vJ1tNRVRIT0RfTkFNRV0ocmVnZXhwKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHRyeSB7XG4gICAgICByZWdleHBbTUFUQ0hdID0gZmFsc2U7XG4gICAgICByZXR1cm4gJy8uLydbTUVUSE9EX05BTUVdKHJlZ2V4cCk7XG4gICAgfSBjYXRjaCAoZikgeyAvKiBlbXB0eSAqLyB9XG4gIH0gcmV0dXJuIGZhbHNlO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgRi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBudWxsO1xuICByZXR1cm4gT2JqZWN0LmdldFByb3RvdHlwZU9mKG5ldyBGKCkpICE9PSBGLnByb3RvdHlwZTtcbn0pO1xuIiwidmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG5cbnZhciBxdW90ID0gL1wiL2c7XG5cbi8vIEIuMi4zLjIuMSBDcmVhdGVIVE1MKHN0cmluZywgdGFnLCBhdHRyaWJ1dGUsIHZhbHVlKVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlaHRtbFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyaW5nLCB0YWcsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgdmFyIFMgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZShzdHJpbmcpKTtcbiAgdmFyIHAxID0gJzwnICsgdGFnO1xuICBpZiAoYXR0cmlidXRlICE9PSAnJykgcDEgKz0gJyAnICsgYXR0cmlidXRlICsgJz1cIicgKyBTdHJpbmcodmFsdWUpLnJlcGxhY2UocXVvdCwgJyZxdW90OycpICsgJ1wiJztcbiAgcmV0dXJuIHAxICsgJz4nICsgUyArICc8LycgKyB0YWcgKyAnPic7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycy1jb3JlJykuSXRlcmF0b3JQcm90b3R5cGU7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIEl0ZXJhdG9ycyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRvcnMnKTtcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KSB7XG4gIHZhciBUT19TVFJJTkdfVEFHID0gTkFNRSArICcgSXRlcmF0b3InO1xuICBJdGVyYXRvckNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSwgeyBuZXh0OiBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgbmV4dCkgfSk7XG4gIHNldFRvU3RyaW5nVGFnKEl0ZXJhdG9yQ29uc3RydWN0b3IsIFRPX1NUUklOR19UQUcsIGZhbHNlLCB0cnVlKTtcbiAgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgcmV0dXJuIEl0ZXJhdG9yQ29uc3RydWN0b3I7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYml0bWFwLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGVudW1lcmFibGU6ICEoYml0bWFwICYgMSksXG4gICAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICAgIHdyaXRhYmxlOiAhKGJpdG1hcCAmIDQpLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICB2YXIgcHJvcGVydHlLZXkgPSB0b1ByaW1pdGl2ZShrZXkpO1xuICBpZiAocHJvcGVydHlLZXkgaW4gb2JqZWN0KSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCB2YWx1ZSkpO1xuICBlbHNlIG9iamVjdFtwcm9wZXJ0eUtleV0gPSB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBwYWRTdGFydCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctcGFkJykuc3RhcnQ7XG5cbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBEYXRlUHJvdG90eXBlID0gRGF0ZS5wcm90b3R5cGU7XG52YXIgZ2V0VGltZSA9IERhdGVQcm90b3R5cGUuZ2V0VGltZTtcbnZhciBuYXRpdmVEYXRlVG9JU09TdHJpbmcgPSBEYXRlUHJvdG90eXBlLnRvSVNPU3RyaW5nO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUudG9pc29zdHJpbmdcbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgZmFpbHMgaGVyZTpcbm1vZHVsZS5leHBvcnRzID0gKGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5hdGl2ZURhdGVUb0lTT1N0cmluZy5jYWxsKG5ldyBEYXRlKC01ZTEzIC0gMSkpICE9ICcwMzg1LTA3LTI1VDA3OjA2OjM5Ljk5OVonO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlRGF0ZVRvSVNPU3RyaW5nLmNhbGwobmV3IERhdGUoTmFOKSk7XG59KSkgPyBmdW5jdGlvbiB0b0lTT1N0cmluZygpIHtcbiAgaWYgKCFpc0Zpbml0ZShnZXRUaW1lLmNhbGwodGhpcykpKSB0aHJvdyBSYW5nZUVycm9yKCdJbnZhbGlkIHRpbWUgdmFsdWUnKTtcbiAgdmFyIGRhdGUgPSB0aGlzO1xuICB2YXIgeWVhciA9IGRhdGUuZ2V0VVRDRnVsbFllYXIoKTtcbiAgdmFyIG1pbGxpc2Vjb25kcyA9IGRhdGUuZ2V0VVRDTWlsbGlzZWNvbmRzKCk7XG4gIHZhciBzaWduID0geWVhciA8IDAgPyAnLScgOiB5ZWFyID4gOTk5OSA/ICcrJyA6ICcnO1xuICByZXR1cm4gc2lnbiArIHBhZFN0YXJ0KGFicyh5ZWFyKSwgc2lnbiA/IDYgOiA0LCAwKSArXG4gICAgJy0nICsgcGFkU3RhcnQoZGF0ZS5nZXRVVENNb250aCgpICsgMSwgMiwgMCkgK1xuICAgICctJyArIHBhZFN0YXJ0KGRhdGUuZ2V0VVRDRGF0ZSgpLCAyLCAwKSArXG4gICAgJ1QnICsgcGFkU3RhcnQoZGF0ZS5nZXRVVENIb3VycygpLCAyLCAwKSArXG4gICAgJzonICsgcGFkU3RhcnQoZGF0ZS5nZXRVVENNaW51dGVzKCksIDIsIDApICtcbiAgICAnOicgKyBwYWRTdGFydChkYXRlLmdldFVUQ1NlY29uZHMoKSwgMiwgMCkgK1xuICAgICcuJyArIHBhZFN0YXJ0KG1pbGxpc2Vjb25kcywgMywgMCkgK1xuICAgICdaJztcbn0gOiBuYXRpdmVEYXRlVG9JU09TdHJpbmc7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGhpbnQpIHtcbiAgaWYgKGhpbnQgIT09ICdzdHJpbmcnICYmIGhpbnQgIT09ICdudW1iZXInICYmIGhpbnQgIT09ICdkZWZhdWx0Jykge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGhpbnQnKTtcbiAgfSByZXR1cm4gdG9QcmltaXRpdmUoYW5PYmplY3QodGhpcyksIGhpbnQgIT09ICdudW1iZXInKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIEl0ZXJhdG9yc0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzLWNvcmUnKTtcblxudmFyIEl0ZXJhdG9yUHJvdG90eXBlID0gSXRlcmF0b3JzQ29yZS5JdGVyYXRvclByb3RvdHlwZTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gSXRlcmF0b3JzQ29yZS5CVUdHWV9TQUZBUklfSVRFUkFUT1JTO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEtFWVMgPSAna2V5cyc7XG52YXIgVkFMVUVTID0gJ3ZhbHVlcyc7XG52YXIgRU5UUklFUyA9ICdlbnRyaWVzJztcblxudmFyIHJldHVyblRoaXMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChJdGVyYWJsZSwgTkFNRSwgSXRlcmF0b3JDb25zdHJ1Y3RvciwgbmV4dCwgREVGQVVMVCwgSVNfU0VULCBGT1JDRUQpIHtcbiAgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihJdGVyYXRvckNvbnN0cnVjdG9yLCBOQU1FLCBuZXh0KTtcblxuICB2YXIgZ2V0SXRlcmF0aW9uTWV0aG9kID0gZnVuY3Rpb24gKEtJTkQpIHtcbiAgICBpZiAoS0lORCA9PT0gREVGQVVMVCAmJiBkZWZhdWx0SXRlcmF0b3IpIHJldHVybiBkZWZhdWx0SXRlcmF0b3I7XG4gICAgaWYgKCFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIEtJTkQgaW4gSXRlcmFibGVQcm90b3R5cGUpIHJldHVybiBJdGVyYWJsZVByb3RvdHlwZVtLSU5EXTtcbiAgICBzd2l0Y2ggKEtJTkQpIHtcbiAgICAgIGNhc2UgS0VZUzogcmV0dXJuIGZ1bmN0aW9uIGtleXMoKSB7IHJldHVybiBuZXcgSXRlcmF0b3JDb25zdHJ1Y3Rvcih0aGlzLCBLSU5EKTsgfTtcbiAgICAgIGNhc2UgVkFMVUVTOiByZXR1cm4gZnVuY3Rpb24gdmFsdWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgICBjYXNlIEVOVFJJRVM6IHJldHVybiBmdW5jdGlvbiBlbnRyaWVzKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcywgS0lORCk7IH07XG4gICAgfSByZXR1cm4gZnVuY3Rpb24gKCkgeyByZXR1cm4gbmV3IEl0ZXJhdG9yQ29uc3RydWN0b3IodGhpcyk7IH07XG4gIH07XG5cbiAgdmFyIFRPX1NUUklOR19UQUcgPSBOQU1FICsgJyBJdGVyYXRvcic7XG4gIHZhciBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSBmYWxzZTtcbiAgdmFyIEl0ZXJhYmxlUHJvdG90eXBlID0gSXRlcmFibGUucHJvdG90eXBlO1xuICB2YXIgbmF0aXZlSXRlcmF0b3IgPSBJdGVyYWJsZVByb3RvdHlwZVtJVEVSQVRPUl1cbiAgICB8fCBJdGVyYWJsZVByb3RvdHlwZVsnQEBpdGVyYXRvciddXG4gICAgfHwgREVGQVVMVCAmJiBJdGVyYWJsZVByb3RvdHlwZVtERUZBVUxUXTtcbiAgdmFyIGRlZmF1bHRJdGVyYXRvciA9ICFCVUdHWV9TQUZBUklfSVRFUkFUT1JTICYmIG5hdGl2ZUl0ZXJhdG9yIHx8IGdldEl0ZXJhdGlvbk1ldGhvZChERUZBVUxUKTtcbiAgdmFyIGFueU5hdGl2ZUl0ZXJhdG9yID0gTkFNRSA9PSAnQXJyYXknID8gSXRlcmFibGVQcm90b3R5cGUuZW50cmllcyB8fCBuYXRpdmVJdGVyYXRvciA6IG5hdGl2ZUl0ZXJhdG9yO1xuICB2YXIgQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBtZXRob2RzLCBLRVk7XG5cbiAgLy8gZml4IG5hdGl2ZVxuICBpZiAoYW55TmF0aXZlSXRlcmF0b3IpIHtcbiAgICBDdXJyZW50SXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZihhbnlOYXRpdmVJdGVyYXRvci5jYWxsKG5ldyBJdGVyYWJsZSgpKSk7XG4gICAgaWYgKEl0ZXJhdG9yUHJvdG90eXBlICE9PSBPYmplY3QucHJvdG90eXBlICYmIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZS5uZXh0KSB7XG4gICAgICBpZiAoIUlTX1BVUkUgJiYgZ2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlKSAhPT0gSXRlcmF0b3JQcm90b3R5cGUpIHtcbiAgICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgc2V0UHJvdG90eXBlT2YoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJdGVyYXRvclByb3RvdHlwZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZVtJVEVSQVRPUl0gIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGhpZGUoQ3VycmVudEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFNldCBAQHRvU3RyaW5nVGFnIHRvIG5hdGl2ZSBpdGVyYXRvcnNcbiAgICAgIHNldFRvU3RyaW5nVGFnKEN1cnJlbnRJdGVyYXRvclByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywgdHJ1ZSwgdHJ1ZSk7XG4gICAgICBpZiAoSVNfUFVSRSkgSXRlcmF0b3JzW1RPX1NUUklOR19UQUddID0gcmV0dXJuVGhpcztcbiAgICB9XG4gIH1cblxuICAvLyBmaXggQXJyYXkje3ZhbHVlcywgQEBpdGVyYXRvcn0ubmFtZSBpbiBWOCAvIEZGXG4gIGlmIChERUZBVUxUID09IFZBTFVFUyAmJiBuYXRpdmVJdGVyYXRvciAmJiBuYXRpdmVJdGVyYXRvci5uYW1lICE9PSBWQUxVRVMpIHtcbiAgICBJTkNPUlJFQ1RfVkFMVUVTX05BTUUgPSB0cnVlO1xuICAgIGRlZmF1bHRJdGVyYXRvciA9IGZ1bmN0aW9uIHZhbHVlcygpIHsgcmV0dXJuIG5hdGl2ZUl0ZXJhdG9yLmNhbGwodGhpcyk7IH07XG4gIH1cblxuICAvLyBkZWZpbmUgaXRlcmF0b3JcbiAgaWYgKCghSVNfUFVSRSB8fCBGT1JDRUQpICYmIEl0ZXJhYmxlUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gZGVmYXVsdEl0ZXJhdG9yKSB7XG4gICAgaGlkZShJdGVyYWJsZVByb3RvdHlwZSwgSVRFUkFUT1IsIGRlZmF1bHRJdGVyYXRvcik7XG4gIH1cbiAgSXRlcmF0b3JzW05BTUVdID0gZGVmYXVsdEl0ZXJhdG9yO1xuXG4gIC8vIGV4cG9ydCBhZGRpdGlvbmFsIG1ldGhvZHNcbiAgaWYgKERFRkFVTFQpIHtcbiAgICBtZXRob2RzID0ge1xuICAgICAgdmFsdWVzOiBnZXRJdGVyYXRpb25NZXRob2QoVkFMVUVTKSxcbiAgICAgIGtleXM6IElTX1NFVCA/IGRlZmF1bHRJdGVyYXRvciA6IGdldEl0ZXJhdGlvbk1ldGhvZChLRVlTKSxcbiAgICAgIGVudHJpZXM6IGdldEl0ZXJhdGlvbk1ldGhvZChFTlRSSUVTKVxuICAgIH07XG4gICAgaWYgKEZPUkNFRCkgZm9yIChLRVkgaW4gbWV0aG9kcykge1xuICAgICAgaWYgKEJVR0dZX1NBRkFSSV9JVEVSQVRPUlMgfHwgSU5DT1JSRUNUX1ZBTFVFU19OQU1FIHx8ICEoS0VZIGluIEl0ZXJhYmxlUHJvdG90eXBlKSkge1xuICAgICAgICByZWRlZmluZShJdGVyYWJsZVByb3RvdHlwZSwgS0VZLCBtZXRob2RzW0tFWV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSAkKHsgdGFyZ2V0OiBOQU1FLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBCVUdHWV9TQUZBUklfSVRFUkFUT1JTIHx8IElOQ09SUkVDVF9WQUxVRVNfTkFNRSB9LCBtZXRob2RzKTtcbiAgfVxuXG4gIHJldHVybiBtZXRob2RzO1xufTtcbiIsInZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd3JhcHBlZFdlbGxLbm93blN5bWJvbE1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93cmFwcGVkLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE5BTUUpIHtcbiAgdmFyIFN5bWJvbCA9IHBhdGguU3ltYm9sIHx8IChwYXRoLlN5bWJvbCA9IHt9KTtcbiAgaWYgKCFoYXMoU3ltYm9sLCBOQU1FKSkgZGVmaW5lUHJvcGVydHkoU3ltYm9sLCBOQU1FLCB7XG4gICAgdmFsdWU6IHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZihOQU1FKVxuICB9KTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxuLy8gVGhhbmsncyBJRTggZm9yIGhpcyBmdW5ueSBkZWZpbmVQcm9wZXJ0eVxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAnYScsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiA3OyB9IH0pLmEgIT0gNztcbn0pO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcblxudmFyIGRvY3VtZW50ID0gZ2xvYmFsLmRvY3VtZW50O1xuLy8gdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQgaXMgJ29iamVjdCcgaW4gb2xkIElFXG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG4iLCIvLyBpdGVyYWJsZSBET00gY29sbGVjdGlvbnNcbi8vIGZsYWcgLSBgaXRlcmFibGVgIGludGVyZmFjZSAtICdlbnRyaWVzJywgJ2tleXMnLCAndmFsdWVzJywgJ2ZvckVhY2gnIG1ldGhvZHNcbm1vZHVsZS5leHBvcnRzID0ge1xuICBDU1NSdWxlTGlzdDogMCxcbiAgQ1NTU3R5bGVEZWNsYXJhdGlvbjogMCxcbiAgQ1NTVmFsdWVMaXN0OiAwLFxuICBDbGllbnRSZWN0TGlzdDogMCxcbiAgRE9NUmVjdExpc3Q6IDAsXG4gIERPTVN0cmluZ0xpc3Q6IDAsXG4gIERPTVRva2VuTGlzdDogMSxcbiAgRGF0YVRyYW5zZmVySXRlbUxpc3Q6IDAsXG4gIEZpbGVMaXN0OiAwLFxuICBIVE1MQWxsQ29sbGVjdGlvbjogMCxcbiAgSFRNTENvbGxlY3Rpb246IDAsXG4gIEhUTUxGb3JtRWxlbWVudDogMCxcbiAgSFRNTFNlbGVjdEVsZW1lbnQ6IDAsXG4gIE1lZGlhTGlzdDogMCxcbiAgTWltZVR5cGVBcnJheTogMCxcbiAgTmFtZWROb2RlTWFwOiAwLFxuICBOb2RlTGlzdDogMSxcbiAgUGFpbnRSZXF1ZXN0TGlzdDogMCxcbiAgUGx1Z2luOiAwLFxuICBQbHVnaW5BcnJheTogMCxcbiAgU1ZHTGVuZ3RoTGlzdDogMCxcbiAgU1ZHTnVtYmVyTGlzdDogMCxcbiAgU1ZHUGF0aFNlZ0xpc3Q6IDAsXG4gIFNWR1BvaW50TGlzdDogMCxcbiAgU1ZHU3RyaW5nTGlzdDogMCxcbiAgU1ZHVHJhbnNmb3JtTGlzdDogMCxcbiAgU291cmNlQnVmZmVyTGlzdDogMCxcbiAgU3R5bGVTaGVldExpc3Q6IDAsXG4gIFRleHRUcmFja0N1ZUxpc3Q6IDAsXG4gIFRleHRUcmFja0xpc3Q6IDAsXG4gIFRvdWNoTGlzdDogMFxufTtcbiIsIi8vIElFOC0gZG9uJ3QgZW51bSBidWcga2V5c1xubW9kdWxlLmV4cG9ydHMgPSBbXG4gICdjb25zdHJ1Y3RvcicsXG4gICdoYXNPd25Qcm9wZXJ0eScsXG4gICdpc1Byb3RvdHlwZU9mJyxcbiAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgJ3RvTG9jYWxlU3RyaW5nJyxcbiAgJ3RvU3RyaW5nJyxcbiAgJ3ZhbHVlT2YnXG5dO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29weS1jb25zdHJ1Y3Rvci1wcm9wZXJ0aWVzJyk7XG52YXIgaXNGb3JjZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtZm9yY2VkJyk7XG5cbi8qXG4gIG9wdGlvbnMudGFyZ2V0ICAgICAgLSBuYW1lIG9mIHRoZSB0YXJnZXQgb2JqZWN0XG4gIG9wdGlvbnMuZ2xvYmFsICAgICAgLSB0YXJnZXQgaXMgdGhlIGdsb2JhbCBvYmplY3RcbiAgb3B0aW9ucy5zdGF0ICAgICAgICAtIGV4cG9ydCBhcyBzdGF0aWMgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5wcm90byAgICAgICAtIGV4cG9ydCBhcyBwcm90b3R5cGUgbWV0aG9kcyBvZiB0YXJnZXRcbiAgb3B0aW9ucy5yZWFsICAgICAgICAtIHJlYWwgcHJvdG90eXBlIG1ldGhvZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMuZm9yY2VkICAgICAgLSBleHBvcnQgZXZlbiBpZiB0aGUgbmF0aXZlIGZlYXR1cmUgaXMgYXZhaWxhYmxlXG4gIG9wdGlvbnMuYmluZCAgICAgICAgLSBiaW5kIG1ldGhvZHMgdG8gdGhlIHRhcmdldCwgcmVxdWlyZWQgZm9yIHRoZSBgcHVyZWAgdmVyc2lvblxuICBvcHRpb25zLndyYXAgICAgICAgIC0gd3JhcCBjb25zdHJ1Y3RvcnMgdG8gcHJldmVudGluZyBnbG9iYWwgcG9sbHV0aW9uLCByZXF1aXJlZCBmb3IgdGhlIGBwdXJlYCB2ZXJzaW9uXG4gIG9wdGlvbnMudW5zYWZlICAgICAgLSB1c2UgdGhlIHNpbXBsZSBhc3NpZ25tZW50IG9mIHByb3BlcnR5IGluc3RlYWQgb2YgZGVsZXRlICsgZGVmaW5lUHJvcGVydHlcbiAgb3B0aW9ucy5zaGFtICAgICAgICAtIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgb3B0aW9ucy5lbnVtZXJhYmxlICAtIGV4cG9ydCBhcyBlbnVtZXJhYmxlIHByb3BlcnR5XG4gIG9wdGlvbnMubm9UYXJnZXRHZXQgLSBwcmV2ZW50IGNhbGxpbmcgYSBnZXR0ZXIgb24gdGFyZ2V0XG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0aW9ucywgc291cmNlKSB7XG4gIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiAgdmFyIEdMT0JBTCA9IG9wdGlvbnMuZ2xvYmFsO1xuICB2YXIgU1RBVElDID0gb3B0aW9ucy5zdGF0O1xuICB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuICBpZiAoR0xPQkFMKSB7XG4gICAgdGFyZ2V0ID0gZ2xvYmFsO1xuICB9IGVsc2UgaWYgKFNUQVRJQykge1xuICAgIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IHNldEdsb2JhbChUQVJHRVQsIHt9KTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQgPSAoZ2xvYmFsW1RBUkdFVF0gfHwge30pLnByb3RvdHlwZTtcbiAgfVxuICBpZiAodGFyZ2V0KSBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgICBzb3VyY2VQcm9wZXJ0eSA9IHNvdXJjZVtrZXldO1xuICAgIGlmIChvcHRpb25zLm5vVGFyZ2V0R2V0KSB7XG4gICAgICBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbiAgICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIH0gZWxzZSB0YXJnZXRQcm9wZXJ0eSA9IHRhcmdldFtrZXldO1xuICAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICAgLy8gY29udGFpbmVkIGluIHRhcmdldFxuICAgIGlmICghRk9SQ0VEICYmIHRhcmdldFByb3BlcnR5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2Ygc291cmNlUHJvcGVydHkgPT09IHR5cGVvZiB0YXJnZXRQcm9wZXJ0eSkgY29udGludWU7XG4gICAgICBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKHNvdXJjZVByb3BlcnR5LCB0YXJnZXRQcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8vIGFkZCBhIGZsYWcgdG8gbm90IGNvbXBsZXRlbHkgZnVsbCBwb2x5ZmlsbHNcbiAgICBpZiAob3B0aW9ucy5zaGFtIHx8ICh0YXJnZXRQcm9wZXJ0eSAmJiB0YXJnZXRQcm9wZXJ0eS5zaGFtKSkge1xuICAgICAgaGlkZShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgICB9XG4gICAgLy8gZXh0ZW5kIGdsb2JhbFxuICAgIHJlZGVmaW5lKHRhcmdldCwga2V5LCBzb3VyY2VQcm9wZXJ0eSwgb3B0aW9ucyk7XG4gIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICEhZXhlYygpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciByZWdleHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG5cbnZhciBSRVBMQUNFX1NVUFBPUlRTX05BTUVEX0dST1VQUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vICNyZXBsYWNlIG5lZWRzIGJ1aWx0LWluIHN1cHBvcnQgZm9yIG5hbWVkIGdyb3Vwcy5cbiAgLy8gI21hdGNoIHdvcmtzIGZpbmUgYmVjYXVzZSBpdCBqdXN0IHJldHVybiB0aGUgZXhlYyByZXN1bHRzLCBldmVuIGlmIGl0IGhhc1xuICAvLyBhIFwiZ3JvcHNcIiBwcm9wZXJ0eS5cbiAgdmFyIHJlID0gLy4vO1xuICByZS5leGVjID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICByZXN1bHQuZ3JvdXBzID0geyBhOiAnNycgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuICByZXR1cm4gJycucmVwbGFjZShyZSwgJyQ8YT4nKSAhPT0gJzcnO1xufSk7XG5cbi8vIENocm9tZSA1MSBoYXMgYSBidWdneSBcInNwbGl0XCIgaW1wbGVtZW50YXRpb24gd2hlbiBSZWdFeHAjZXhlYyAhPT0gbmF0aXZlRXhlY1xuLy8gV2VleCBKUyBoYXMgZnJvemVuIGJ1aWx0LWluIHByb3RvdHlwZXMsIHNvIHVzZSB0cnkgLyBjYXRjaCB3cmFwcGVyXG52YXIgU1BMSVRfV09SS1NfV0lUSF9PVkVSV1JJVFRFTl9FWEVDID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJlID0gLyg/OikvO1xuICB2YXIgb3JpZ2luYWxFeGVjID0gcmUuZXhlYztcbiAgcmUuZXhlYyA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG9yaWdpbmFsRXhlYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9O1xuICB2YXIgcmVzdWx0ID0gJ2FiJy5zcGxpdChyZSk7XG4gIHJldHVybiByZXN1bHQubGVuZ3RoICE9PSAyIHx8IHJlc3VsdFswXSAhPT0gJ2EnIHx8IHJlc3VsdFsxXSAhPT0gJ2InO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEtFWSwgbGVuZ3RoLCBleGVjLCBzaGFtKSB7XG4gIHZhciBTWU1CT0wgPSB3ZWxsS25vd25TeW1ib2woS0VZKTtcblxuICB2YXIgREVMRUdBVEVTX1RPX1NZTUJPTCA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3RyaW5nIG1ldGhvZHMgY2FsbCBzeW1ib2wtbmFtZWQgUmVnRXAgbWV0aG9kc1xuICAgIHZhciBPID0ge307XG4gICAgT1tTWU1CT0xdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfTtcbiAgICByZXR1cm4gJydbS0VZXShPKSAhPSA3O1xuICB9KTtcblxuICB2YXIgREVMRUdBVEVTX1RPX0VYRUMgPSBERUxFR0FURVNfVE9fU1lNQk9MICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gICAgLy8gU3ltYm9sLW5hbWVkIFJlZ0V4cCBtZXRob2RzIGNhbGwgLmV4ZWNcbiAgICB2YXIgZXhlY0NhbGxlZCA9IGZhbHNlO1xuICAgIHZhciByZSA9IC9hLztcbiAgICByZS5leGVjID0gZnVuY3Rpb24gKCkgeyBleGVjQ2FsbGVkID0gdHJ1ZTsgcmV0dXJuIG51bGw7IH07XG5cbiAgICBpZiAoS0VZID09PSAnc3BsaXQnKSB7XG4gICAgICAvLyBSZWdFeHBbQEBzcGxpdF0gZG9lc24ndCBjYWxsIHRoZSByZWdleCdzIGV4ZWMgbWV0aG9kLCBidXQgZmlyc3QgY3JlYXRlc1xuICAgICAgLy8gYSBuZXcgb25lLiBXZSBuZWVkIHRvIHJldHVybiB0aGUgcGF0Y2hlZCByZWdleCB3aGVuIGNyZWF0aW5nIHRoZSBuZXcgb25lLlxuICAgICAgcmUuY29uc3RydWN0b3IgPSB7fTtcbiAgICAgIHJlLmNvbnN0cnVjdG9yW1NQRUNJRVNdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcmU7IH07XG4gICAgfVxuXG4gICAgcmVbU1lNQk9MXSgnJyk7XG4gICAgcmV0dXJuICFleGVjQ2FsbGVkO1xuICB9KTtcblxuICBpZiAoXG4gICAgIURFTEVHQVRFU19UT19TWU1CT0wgfHxcbiAgICAhREVMRUdBVEVTX1RPX0VYRUMgfHxcbiAgICAoS0VZID09PSAncmVwbGFjZScgJiYgIVJFUExBQ0VfU1VQUE9SVFNfTkFNRURfR1JPVVBTKSB8fFxuICAgIChLRVkgPT09ICdzcGxpdCcgJiYgIVNQTElUX1dPUktTX1dJVEhfT1ZFUldSSVRURU5fRVhFQylcbiAgKSB7XG4gICAgdmFyIG5hdGl2ZVJlZ0V4cE1ldGhvZCA9IC8uL1tTWU1CT0xdO1xuICAgIHZhciBtZXRob2RzID0gZXhlYyhTWU1CT0wsICcnW0tFWV0sIGZ1bmN0aW9uIChuYXRpdmVNZXRob2QsIHJlZ2V4cCwgc3RyLCBhcmcyLCBmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgaWYgKHJlZ2V4cC5leGVjID09PSByZWdleHBFeGVjKSB7XG4gICAgICAgIGlmIChERUxFR0FURVNfVE9fU1lNQk9MICYmICFmb3JjZVN0cmluZ01ldGhvZCkge1xuICAgICAgICAgIC8vIFRoZSBuYXRpdmUgU3RyaW5nIG1ldGhvZCBhbHJlYWR5IGRlbGVnYXRlcyB0byBAQG1ldGhvZCAodGhpc1xuICAgICAgICAgIC8vIHBvbHlmaWxsZWQgZnVuY3Rpb24pLCBsZWFzaW5nIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgICAgICAgICAvLyBXZSBhdm9pZCBpdCBieSBkaXJlY3RseSBjYWxsaW5nIHRoZSBuYXRpdmUgQEBtZXRob2QgbWV0aG9kLlxuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBuYXRpdmVSZWdFeHBNZXRob2QuY2FsbChyZWdleHAsIHN0ciwgYXJnMikgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkb25lOiB0cnVlLCB2YWx1ZTogbmF0aXZlTWV0aG9kLmNhbGwoc3RyLCByZWdleHAsIGFyZzIpIH07XG4gICAgICB9XG4gICAgICByZXR1cm4geyBkb25lOiBmYWxzZSB9O1xuICAgIH0pO1xuICAgIHZhciBzdHJpbmdNZXRob2QgPSBtZXRob2RzWzBdO1xuICAgIHZhciByZWdleE1ldGhvZCA9IG1ldGhvZHNbMV07XG5cbiAgICByZWRlZmluZShTdHJpbmcucHJvdG90eXBlLCBLRVksIHN0cmluZ01ldGhvZCk7XG4gICAgcmVkZWZpbmUoUmVnRXhwLnByb3RvdHlwZSwgU1lNQk9MLCBsZW5ndGggPT0gMlxuICAgICAgLy8gMjEuMi41LjggUmVnRXhwLnByb3RvdHlwZVtAQHJlcGxhY2VdKHN0cmluZywgcmVwbGFjZVZhbHVlKVxuICAgICAgLy8gMjEuMi41LjExIFJlZ0V4cC5wcm90b3R5cGVbQEBzcGxpdF0oc3RyaW5nLCBsaW1pdClcbiAgICAgID8gZnVuY3Rpb24gKHN0cmluZywgYXJnKSB7IHJldHVybiByZWdleE1ldGhvZC5jYWxsKHN0cmluZywgdGhpcywgYXJnKTsgfVxuICAgICAgLy8gMjEuMi41LjYgUmVnRXhwLnByb3RvdHlwZVtAQG1hdGNoXShzdHJpbmcpXG4gICAgICAvLyAyMS4yLjUuOSBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXShzdHJpbmcpXG4gICAgICA6IGZ1bmN0aW9uIChzdHJpbmcpIHsgcmV0dXJuIHJlZ2V4TWV0aG9kLmNhbGwoc3RyaW5nLCB0aGlzKTsgfVxuICAgICk7XG4gICAgaWYgKHNoYW0pIGhpZGUoUmVnRXhwLnByb3RvdHlwZVtTWU1CT0xdLCAnc2hhbScsIHRydWUpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xuXG4vLyBgRmxhdHRlbkludG9BcnJheWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL3Byb3Bvc2FsLWZsYXRNYXAvI3NlYy1GbGF0dGVuSW50b0FycmF5XG52YXIgZmxhdHRlbkludG9BcnJheSA9IGZ1bmN0aW9uICh0YXJnZXQsIG9yaWdpbmFsLCBzb3VyY2UsIHNvdXJjZUxlbiwgc3RhcnQsIGRlcHRoLCBtYXBwZXIsIHRoaXNBcmcpIHtcbiAgdmFyIHRhcmdldEluZGV4ID0gc3RhcnQ7XG4gIHZhciBzb3VyY2VJbmRleCA9IDA7XG4gIHZhciBtYXBGbiA9IG1hcHBlciA/IGJpbmQobWFwcGVyLCB0aGlzQXJnLCAzKSA6IGZhbHNlO1xuICB2YXIgZWxlbWVudDtcblxuICB3aGlsZSAoc291cmNlSW5kZXggPCBzb3VyY2VMZW4pIHtcbiAgICBpZiAoc291cmNlSW5kZXggaW4gc291cmNlKSB7XG4gICAgICBlbGVtZW50ID0gbWFwRm4gPyBtYXBGbihzb3VyY2Vbc291cmNlSW5kZXhdLCBzb3VyY2VJbmRleCwgb3JpZ2luYWwpIDogc291cmNlW3NvdXJjZUluZGV4XTtcblxuICAgICAgaWYgKGRlcHRoID4gMCAmJiBpc0FycmF5KGVsZW1lbnQpKSB7XG4gICAgICAgIHRhcmdldEluZGV4ID0gZmxhdHRlbkludG9BcnJheSh0YXJnZXQsIG9yaWdpbmFsLCBlbGVtZW50LCB0b0xlbmd0aChlbGVtZW50Lmxlbmd0aCksIHRhcmdldEluZGV4LCBkZXB0aCAtIDEpIC0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0YXJnZXRJbmRleCA+PSAweDFGRkZGRkZGRkZGRkZGKSB0aHJvdyBUeXBlRXJyb3IoJ0V4Y2VlZCB0aGUgYWNjZXB0YWJsZSBhcnJheSBsZW5ndGgnKTtcbiAgICAgICAgdGFyZ2V0W3RhcmdldEluZGV4XSA9IGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIHRhcmdldEluZGV4Kys7XG4gICAgfVxuICAgIHNvdXJjZUluZGV4Kys7XG4gIH1cbiAgcmV0dXJuIHRhcmdldEluZGV4O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmbGF0dGVuSW50b0FycmF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBGb3JjZWQgcmVwbGFjZW1lbnQgb2JqZWN0IHByb3RvdHlwZSBhY2Nlc3NvcnMgbWV0aG9kc1xubW9kdWxlLmV4cG9ydHMgPSBJU19QVVJFIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXkgPSBNYXRoLnJhbmRvbSgpO1xuICAvLyBJbiBGRiB0aHJvd3Mgb25seSBkZWZpbmUgbWV0aG9kc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWYsIG5vLXVzZWxlc3MtY2FsbFxuICBfX2RlZmluZVNldHRlcl9fLmNhbGwobnVsbCwga2V5LCBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xuICBkZWxldGUgZ2xvYmFsW2tleV07XG59KTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBjaGVjayB0aGUgZXhpc3RlbmNlIG9mIGEgbWV0aG9kLCBsb3dlcmNhc2Vcbi8vIG9mIGEgdGFnIGFuZCBlc2NhcGluZyBxdW90ZXMgaW4gYXJndW1lbnRzXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHZhciB0ZXN0ID0gJydbTUVUSE9EX05BTUVdKCdcIicpO1xuICAgIHJldHVybiB0ZXN0ICE9PSB0ZXN0LnRvTG93ZXJDYXNlKCkgfHwgdGVzdC5zcGxpdCgnXCInKS5sZW5ndGggPiAzO1xuICB9KTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgbm9uID0gJ1xcdTIwMEJcXHUwMDg1XFx1MTgwRSc7XG5cbi8vIGNoZWNrIHRoYXQgYSBtZXRob2Qgd29ya3Mgd2l0aCB0aGUgY29ycmVjdCBsaXN0XG4vLyBvZiB3aGl0ZXNwYWNlcyBhbmQgaGFzIGEgY29ycmVjdCBuYW1lXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSkge1xuICByZXR1cm4gZmFpbHMoZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXdoaXRlc3BhY2VzW01FVEhPRF9OQU1FXSgpIHx8IG5vbltNRVRIT0RfTkFNRV0oKSAhPSBub24gfHwgd2hpdGVzcGFjZXNbTUVUSE9EX05BTUVdLm5hbWUgIT09IE1FVEhPRF9OQU1FO1xuICB9KTtcbn07XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gT2JqZWN0LmlzRXh0ZW5zaWJsZShPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIGZhY3RvcmllcyA9IHt9O1xuXG52YXIgY29uc3RydWN0ID0gZnVuY3Rpb24gKEMsIGFyZ3NMZW5ndGgsIGFyZ3MpIHtcbiAgaWYgKCEoYXJnc0xlbmd0aCBpbiBmYWN0b3JpZXMpKSB7XG4gICAgZm9yICh2YXIgbGlzdCA9IFtdLCBpID0gMDsgaSA8IGFyZ3NMZW5ndGg7IGkrKykgbGlzdFtpXSA9ICdhWycgKyBpICsgJ10nO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgIGZhY3Rvcmllc1thcmdzTGVuZ3RoXSA9IEZ1bmN0aW9uKCdDLGEnLCAncmV0dXJuIG5ldyBDKCcgKyBsaXN0LmpvaW4oJywnKSArICcpJyk7XG4gIH0gcmV0dXJuIGZhY3Rvcmllc1thcmdzTGVuZ3RoXShDLCBhcmdzKTtcbn07XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxubW9kdWxlLmV4cG9ydHMgPSBGdW5jdGlvbi5iaW5kIHx8IGZ1bmN0aW9uIGJpbmQodGhhdCAvKiAsIC4uLmFyZ3MgKi8pIHtcbiAgdmFyIGZuID0gYUZ1bmN0aW9uKHRoaXMpO1xuICB2YXIgcGFydEFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gZnVuY3Rpb24gYm91bmQoLyogYXJncy4uLiAqLykge1xuICAgIHZhciBhcmdzID0gcGFydEFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBib3VuZEZ1bmN0aW9uID8gY29uc3RydWN0KGZuLCBhcmdzLmxlbmd0aCwgYXJncykgOiBmbi5hcHBseSh0aGF0LCBhcmdzKTtcbiAgfTtcbiAgaWYgKGlzT2JqZWN0KGZuLnByb3RvdHlwZSkpIGJvdW5kRnVuY3Rpb24ucHJvdG90eXBlID0gZm4ucHJvdG90eXBlO1xuICByZXR1cm4gYm91bmRGdW5jdGlvbjtcbn07XG4iLCJ2YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHNoYXJlZCgnbmF0aXZlLWZ1bmN0aW9uLXRvLXN0cmluZycsIEZ1bmN0aW9uLnRvU3RyaW5nKTtcbiIsInZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YXJpYWJsZSA9PSAnZnVuY3Rpb24nID8gdmFyaWFibGUgOiB1bmRlZmluZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDIgPyBhRnVuY3Rpb24ocGF0aFtuYW1lc3BhY2VdKSB8fCBhRnVuY3Rpb24oZ2xvYmFsW25hbWVzcGFjZV0pXG4gICAgOiBwYXRoW25hbWVzcGFjZV0gJiYgcGF0aFtuYW1lc3BhY2VdW21ldGhvZF0gfHwgZ2xvYmFsW25hbWVzcGFjZV0gJiYgZ2xvYmFsW25hbWVzcGFjZV1bbWV0aG9kXTtcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIGlmIChpdCAhPSB1bmRlZmluZWQpIHJldHVybiBpdFtJVEVSQVRPUl1cbiAgICB8fCBpdFsnQEBpdGVyYXRvciddXG4gICAgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZ2V0SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2V0LWl0ZXJhdG9yLW1ldGhvZCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChpdCk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JNZXRob2QgIT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IFR5cGVFcnJvcihTdHJpbmcoaXQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbiAgfSByZXR1cm4gYW5PYmplY3QoaXRlcmF0b3JNZXRob2QuY2FsbChpdCkpO1xufTtcbiIsInZhciBPID0gJ29iamVjdCc7XG52YXIgY2hlY2sgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT0gTWF0aCAmJiBpdDtcbn07XG5cbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy84NiNpc3N1ZWNvbW1lbnQtMTE1NzU5MDI4XG5tb2R1bGUuZXhwb3J0cyA9XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSBPICYmIGdsb2JhbFRoaXMpIHx8XG4gIGNoZWNrKHR5cGVvZiB3aW5kb3cgPT0gTyAmJiB3aW5kb3cpIHx8XG4gIGNoZWNrKHR5cGVvZiBzZWxmID09IE8gJiYgc2VsZikgfHxcbiAgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSBPICYmIGdsb2JhbCkgfHxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gIEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG4iLCJ2YXIgaGFzT3duUHJvcGVydHkgPSB7fS5oYXNPd25Qcm9wZXJ0eTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChpdCwga2V5KTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHktZGVzY3JpcHRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gZGVmaW5lUHJvcGVydHlNb2R1bGUuZihvYmplY3QsIGtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG59IDogZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICBvYmplY3Rba2V5XSA9IHZhbHVlO1xuICByZXR1cm4gb2JqZWN0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgdmFyIGNvbnNvbGUgPSBnbG9iYWwuY29uc29sZTtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS5lcnJvcikge1xuICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBjb25zb2xlLmVycm9yKGEpIDogY29uc29sZS5lcnJvcihhLCBiKTtcbiAgfVxufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBjcmVhdGVFbGVtZW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvY3VtZW50LWNyZWF0ZS1lbGVtZW50Jyk7XG5cbi8vIFRoYW5rJ3MgSUU4IGZvciBoaXMgZnVubnkgZGVmaW5lUHJvcGVydHlcbm1vZHVsZS5leHBvcnRzID0gIURFU0NSSVBUT1JTICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3JlYXRlRWxlbWVudCgnZGl2JyksICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gNzsgfVxuICB9KS5hICE9IDc7XG59KTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2xhc3NvZi1yYXcnKTtcblxudmFyIHNwbGl0ID0gJycuc3BsaXQ7XG5cbi8vIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgYW5kIG5vbi1lbnVtZXJhYmxlIG9sZCBWOCBzdHJpbmdzXG5tb2R1bGUuZXhwb3J0cyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gdGhyb3dzIGFuIGVycm9yIGluIHJoaW5vLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvcmhpbm8vaXNzdWVzLzM0NlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIHJldHVybiAhT2JqZWN0KCd6JykucHJvcGVydHlJc0VudW1lcmFibGUoMCk7XG59KSA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gY2xhc3NvZihpdCkgPT0gJ1N0cmluZycgPyBzcGxpdC5jYWxsKGl0LCAnJykgOiBPYmplY3QoaXQpO1xufSA6IE9iamVjdDtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3Qtc2V0LXByb3RvdHlwZS1vZicpO1xuXG4vLyBtYWtlcyBzdWJjbGFzc2luZyB3b3JrIGNvcnJlY3QgZm9yIHdyYXBwZWQgYnVpbHQtaW5zXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiAgdmFyIE5ld1RhcmdldCwgTmV3VGFyZ2V0UHJvdG90eXBlO1xuICBpZiAoXG4gICAgLy8gaXQgY2FuIHdvcmsgb25seSB3aXRoIG5hdGl2ZSBgc2V0UHJvdG90eXBlT2ZgXG4gICAgc2V0UHJvdG90eXBlT2YgJiZcbiAgICAvLyB3ZSBoYXZlbid0IGNvbXBsZXRlbHkgY29ycmVjdCBwcmUtRVM2IHdheSBmb3IgZ2V0dGluZyBgbmV3LnRhcmdldGAsIHNvIHVzZSB0aGlzXG4gICAgdHlwZW9mIChOZXdUYXJnZXQgPSBkdW1teS5jb25zdHJ1Y3RvcikgPT0gJ2Z1bmN0aW9uJyAmJlxuICAgIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJlxuICAgIGlzT2JqZWN0KE5ld1RhcmdldFByb3RvdHlwZSA9IE5ld1RhcmdldC5wcm90b3R5cGUpICYmXG4gICAgTmV3VGFyZ2V0UHJvdG90eXBlICE9PSBXcmFwcGVyLnByb3RvdHlwZVxuICApIHNldFByb3RvdHlwZU9mKCR0aGlzLCBOZXdUYXJnZXRQcm90b3R5cGUpO1xuICByZXR1cm4gJHRoaXM7XG59O1xuIiwidmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgdWlkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3VpZCcpO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG5cbnZhciBNRVRBREFUQSA9IHVpZCgnbWV0YScpO1xudmFyIGlkID0gMDtcblxudmFyIGlzRXh0ZW5zaWJsZSA9IE9iamVjdC5pc0V4dGVuc2libGUgfHwgZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBzZXRNZXRhZGF0YSA9IGZ1bmN0aW9uIChpdCkge1xuICBkZWZpbmVQcm9wZXJ0eShpdCwgTUVUQURBVEEsIHsgdmFsdWU6IHtcbiAgICBvYmplY3RJRDogJ08nICsgKytpZCwgLy8gb2JqZWN0IElEXG4gICAgd2Vha0RhdGE6IHt9ICAgICAgICAgIC8vIHdlYWsgY29sbGVjdGlvbnMgSURzXG4gIH0gfSk7XG59O1xuXG52YXIgZmFzdEtleSA9IGZ1bmN0aW9uIChpdCwgY3JlYXRlKSB7XG4gIC8vIHJldHVybiBhIHByaW1pdGl2ZSB3aXRoIHByZWZpeFxuICBpZiAoIWlzT2JqZWN0KGl0KSkgcmV0dXJuIHR5cGVvZiBpdCA9PSAnc3ltYm9sJyA/IGl0IDogKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyA/ICdTJyA6ICdQJykgKyBpdDtcbiAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gJ0YnO1xuICAgIC8vIG5vdCBuZWNlc3NhcnkgdG8gYWRkIG1ldGFkYXRhXG4gICAgaWYgKCFjcmVhdGUpIHJldHVybiAnRSc7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiBvYmplY3QgSURcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLm9iamVjdElEO1xufTtcblxudmFyIGdldFdlYWtEYXRhID0gZnVuY3Rpb24gKGl0LCBjcmVhdGUpIHtcbiAgaWYgKCFoYXMoaXQsIE1FVEFEQVRBKSkge1xuICAgIC8vIGNhbid0IHNldCBtZXRhZGF0YSB0byB1bmNhdWdodCBmcm96ZW4gb2JqZWN0XG4gICAgaWYgKCFpc0V4dGVuc2libGUoaXQpKSByZXR1cm4gdHJ1ZTtcbiAgICAvLyBub3QgbmVjZXNzYXJ5IHRvIGFkZCBtZXRhZGF0YVxuICAgIGlmICghY3JlYXRlKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gYWRkIG1pc3NpbmcgbWV0YWRhdGFcbiAgICBzZXRNZXRhZGF0YShpdCk7XG4gIC8vIHJldHVybiB0aGUgc3RvcmUgb2Ygd2VhayBjb2xsZWN0aW9ucyBJRHNcbiAgfSByZXR1cm4gaXRbTUVUQURBVEFdLndlYWtEYXRhO1xufTtcblxuLy8gYWRkIG1ldGFkYXRhIG9uIGZyZWV6ZS1mYW1pbHkgbWV0aG9kcyBjYWxsaW5nXG52YXIgb25GcmVlemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKEZSRUVaSU5HICYmIG1ldGEuUkVRVUlSRUQgJiYgaXNFeHRlbnNpYmxlKGl0KSAmJiAhaGFzKGl0LCBNRVRBREFUQSkpIHNldE1ldGFkYXRhKGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcblxudmFyIG1ldGEgPSBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgUkVRVUlSRUQ6IGZhbHNlLFxuICBmYXN0S2V5OiBmYXN0S2V5LFxuICBnZXRXZWFrRGF0YTogZ2V0V2Vha0RhdGEsXG4gIG9uRnJlZXplOiBvbkZyZWV6ZVxufTtcblxuaGlkZGVuS2V5c1tNRVRBREFUQV0gPSB0cnVlO1xuIiwidmFyIE5BVElWRV9XRUFLX01BUCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtd2Vhay1tYXAnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgb2JqZWN0SGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xuXG52YXIgV2Vha01hcCA9IGdsb2JhbC5XZWFrTWFwO1xudmFyIHNldCwgZ2V0LCBoYXM7XG5cbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBoYXMoaXQpID8gZ2V0KGl0KSA6IHNldChpdCwge30pO1xufTtcblxudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgc3RhdGU7XG4gICAgaWYgKCFpc09iamVjdChpdCkgfHwgKHN0YXRlID0gZ2V0KGl0KSkudHlwZSAhPT0gVFlQRSkge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdJbmNvbXBhdGlibGUgcmVjZWl2ZXIsICcgKyBUWVBFICsgJyByZXF1aXJlZCcpO1xuICAgIH0gcmV0dXJuIHN0YXRlO1xuICB9O1xufTtcblxuaWYgKE5BVElWRV9XRUFLX01BUCkge1xuICB2YXIgc3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuICB2YXIgd21nZXQgPSBzdG9yZS5nZXQ7XG4gIHZhciB3bWhhcyA9IHN0b3JlLmhhcztcbiAgdmFyIHdtc2V0ID0gc3RvcmUuc2V0O1xuICBzZXQgPSBmdW5jdGlvbiAoaXQsIG1ldGFkYXRhKSB7XG4gICAgd21zZXQuY2FsbChzdG9yZSwgaXQsIG1ldGFkYXRhKTtcbiAgICByZXR1cm4gbWV0YWRhdGE7XG4gIH07XG4gIGdldCA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWdldC5jYWxsKHN0b3JlLCBpdCkgfHwge307XG4gIH07XG4gIGhhcyA9IGZ1bmN0aW9uIChpdCkge1xuICAgIHJldHVybiB3bWhhcy5jYWxsKHN0b3JlLCBpdCk7XG4gIH07XG59IGVsc2Uge1xuICB2YXIgU1RBVEUgPSBzaGFyZWRLZXkoJ3N0YXRlJyk7XG4gIGhpZGRlbktleXNbU1RBVEVdID0gdHJ1ZTtcbiAgc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICAgIGhpZGUoaXQsIFNUQVRFLCBtZXRhZGF0YSk7XG4gICAgcmV0dXJuIG1ldGFkYXRhO1xuICB9O1xuICBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgICByZXR1cm4gb2JqZWN0SGFzKGl0LCBTVEFURSkgPyBpdFtTVEFURV0gOiB7fTtcbiAgfTtcbiAgaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gICAgcmV0dXJuIG9iamVjdEhhcyhpdCwgU1RBVEUpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgc2V0OiBzZXQsXG4gIGdldDogZ2V0LFxuICBoYXM6IGhhcyxcbiAgZW5mb3JjZTogZW5mb3JjZSxcbiAgZ2V0dGVyRm9yOiBnZXR0ZXJGb3Jcbn07XG4iLCJ2YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2l0ZXJhdG9ycycpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5cbi8vIGNoZWNrIG9uIGRlZmF1bHQgQXJyYXkgaXRlcmF0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBpdCAhPT0gdW5kZWZpbmVkICYmIChJdGVyYXRvcnMuQXJyYXkgPT09IGl0IHx8IEFycmF5UHJvdG90eXBlW0lURVJBVE9SXSA9PT0gaXQpO1xufTtcbiIsInZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbi8vIGBJc0FycmF5YCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzYXJyYXlcbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICByZXR1cm4gY2xhc3NvZihhcmcpID09ICdBcnJheSc7XG59O1xuIiwidmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciByZXBsYWNlbWVudCA9IC8jfFxcLnByb3RvdHlwZVxcLi87XG5cbnZhciBpc0ZvcmNlZCA9IGZ1bmN0aW9uIChmZWF0dXJlLCBkZXRlY3Rpb24pIHtcbiAgdmFyIHZhbHVlID0gZGF0YVtub3JtYWxpemUoZmVhdHVyZSldO1xuICByZXR1cm4gdmFsdWUgPT0gUE9MWUZJTEwgPyB0cnVlXG4gICAgOiB2YWx1ZSA9PSBOQVRJVkUgPyBmYWxzZVxuICAgIDogdHlwZW9mIGRldGVjdGlvbiA9PSAnZnVuY3Rpb24nID8gZmFpbHMoZGV0ZWN0aW9uKVxuICAgIDogISFkZXRlY3Rpb247XG59O1xuXG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuICByZXR1cm4gU3RyaW5nKHN0cmluZykucmVwbGFjZShyZXBsYWNlbWVudCwgJy4nKS50b0xvd2VyQ2FzZSgpO1xufTtcblxudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5cbm1vZHVsZS5leHBvcnRzID0gaXNGb3JjZWQ7XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG5cbi8vIGBOdW1iZXIuaXNJbnRlZ2VyYCBtZXRob2QgaW1wbGVtZW50YXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5pc2ludGVnZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNJbnRlZ2VyKGl0KSB7XG4gIHJldHVybiAhaXNPYmplY3QoaXQpICYmIGlzRmluaXRlKGl0KSAmJiBmbG9vcihpdCkgPT09IGl0O1xufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiB0eXBlb2YgaXQgPT09ICdvYmplY3QnID8gaXQgIT09IG51bGwgOiB0eXBlb2YgaXQgPT09ICdmdW5jdGlvbic7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcbiIsInZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBNQVRDSCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2gnKTtcblxuLy8gYElzUmVnRXhwYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWlzcmVnZXhwXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgaXNSZWdFeHA7XG4gIHJldHVybiBpc09iamVjdChpdCkgJiYgKChpc1JlZ0V4cCA9IGl0W01BVENIXSkgIT09IHVuZGVmaW5lZCA/ICEhaXNSZWdFeHAgOiBjbGFzc29mKGl0KSA9PSAnUmVnRXhwJyk7XG59O1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzQXJyYXlJdGVyYXRvck1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheS1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBjYWxsV2l0aFNhZmVJdGVyYXRpb25DbG9zaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NhbGwtd2l0aC1zYWZlLWl0ZXJhdGlvbi1jbG9zaW5nJyk7XG5cbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gIHRoaXMuc3RvcHBlZCA9IHN0b3BwZWQ7XG4gIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xufTtcblxudmFyIGl0ZXJhdGUgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgZm4sIHRoYXQsIEFTX0VOVFJJRVMsIElTX0lURVJBVE9SKSB7XG4gIHZhciBib3VuZEZ1bmN0aW9uID0gYmluZChmbiwgdGhhdCwgQVNfRU5UUklFUyA/IDIgOiAxKTtcbiAgdmFyIGl0ZXJhdG9yLCBpdGVyRm4sIGluZGV4LCBsZW5ndGgsIHJlc3VsdCwgc3RlcDtcblxuICBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgICBpdGVyYXRvciA9IGl0ZXJhYmxlO1xuICB9IGVsc2Uge1xuICAgIGl0ZXJGbiA9IGdldEl0ZXJhdG9yTWV0aG9kKGl0ZXJhYmxlKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJGbiAhPSAnZnVuY3Rpb24nKSB0aHJvdyBUeXBlRXJyb3IoJ1RhcmdldCBpcyBub3QgaXRlcmFibGUnKTtcbiAgICAvLyBvcHRpbWlzYXRpb24gZm9yIGFycmF5IGl0ZXJhdG9yc1xuICAgIGlmIChpc0FycmF5SXRlcmF0b3JNZXRob2QoaXRlckZuKSkge1xuICAgICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IHRvTGVuZ3RoKGl0ZXJhYmxlLmxlbmd0aCk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgICAgIHJlc3VsdCA9IEFTX0VOVFJJRVNcbiAgICAgICAgICA/IGJvdW5kRnVuY3Rpb24oYW5PYmplY3Qoc3RlcCA9IGl0ZXJhYmxlW2luZGV4XSlbMF0sIHN0ZXBbMV0pXG4gICAgICAgICAgOiBib3VuZEZ1bmN0aW9uKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICAgICAgfSByZXR1cm4gbmV3IFJlc3VsdChmYWxzZSk7XG4gICAgfVxuICAgIGl0ZXJhdG9yID0gaXRlckZuLmNhbGwoaXRlcmFibGUpO1xuICB9XG5cbiAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgIHJlc3VsdCA9IGNhbGxXaXRoU2FmZUl0ZXJhdGlvbkNsb3NpbmcoaXRlcmF0b3IsIGJvdW5kRnVuY3Rpb24sIHN0ZXAudmFsdWUsIEFTX0VOVFJJRVMpO1xuICAgIGlmIChyZXN1bHQgJiYgcmVzdWx0IGluc3RhbmNlb2YgUmVzdWx0KSByZXR1cm4gcmVzdWx0O1xuICB9IHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbn07XG5cbml0ZXJhdGUuc3RvcCA9IGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgcmV0dXJuIG5ldyBSZXN1bHQodHJ1ZSwgcmVzdWx0KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgSVNfUFVSRSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1wdXJlJyk7XG5cbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbnZhciBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gZmFsc2U7XG5cbnZhciByZXR1cm5UaGlzID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfTtcblxuLy8gYCVJdGVyYXRvclByb3RvdHlwZSVgIG9iamVjdFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJWl0ZXJhdG9ycHJvdG90eXBlJS1vYmplY3RcbnZhciBJdGVyYXRvclByb3RvdHlwZSwgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlLCBhcnJheUl0ZXJhdG9yO1xuXG5pZiAoW10ua2V5cykge1xuICBhcnJheUl0ZXJhdG9yID0gW10ua2V5cygpO1xuICAvLyBTYWZhcmkgOCBoYXMgYnVnZ3kgaXRlcmF0b3JzIHcvbyBgbmV4dGBcbiAgaWYgKCEoJ25leHQnIGluIGFycmF5SXRlcmF0b3IpKSBCVUdHWV9TQUZBUklfSVRFUkFUT1JTID0gdHJ1ZTtcbiAgZWxzZSB7XG4gICAgUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YoZ2V0UHJvdG90eXBlT2YoYXJyYXlJdGVyYXRvcikpO1xuICAgIGlmIChQcm90b3R5cGVPZkFycmF5SXRlcmF0b3JQcm90b3R5cGUgIT09IE9iamVjdC5wcm90b3R5cGUpIEl0ZXJhdG9yUHJvdG90eXBlID0gUHJvdG90eXBlT2ZBcnJheUl0ZXJhdG9yUHJvdG90eXBlO1xuICB9XG59XG5cbmlmIChJdGVyYXRvclByb3RvdHlwZSA9PSB1bmRlZmluZWQpIEl0ZXJhdG9yUHJvdG90eXBlID0ge307XG5cbi8vIDI1LjEuMi4xLjEgJUl0ZXJhdG9yUHJvdG90eXBlJVtAQGl0ZXJhdG9yXSgpXG5pZiAoIUlTX1BVUkUgJiYgIWhhcyhJdGVyYXRvclByb3RvdHlwZSwgSVRFUkFUT1IpKSBoaWRlKEl0ZXJhdG9yUHJvdG90eXBlLCBJVEVSQVRPUiwgcmV0dXJuVGhpcyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBJdGVyYXRvclByb3RvdHlwZTogSXRlcmF0b3JQcm90b3R5cGUsXG4gIEJVR0dZX1NBRkFSSV9JVEVSQVRPUlM6IEJVR0dZX1NBRkFSSV9JVEVSQVRPUlNcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHt9O1xuIiwidmFyIG5hdGl2ZUV4cG0xID0gTWF0aC5leHBtMTtcbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gYE1hdGguZXhwbTFgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5leHBtMVxubW9kdWxlLmV4cG9ydHMgPSAoIW5hdGl2ZUV4cG0xXG4gIC8vIE9sZCBGRiBidWdcbiAgfHwgbmF0aXZlRXhwbTEoMTApID4gMjIwMjUuNDY1Nzk0ODA2NzE5IHx8IG5hdGl2ZUV4cG0xKDEwKSA8IDIyMDI1LjQ2NTc5NDgwNjcxNjUxNjhcbiAgLy8gVG9yIEJyb3dzZXIgYnVnXG4gIHx8IG5hdGl2ZUV4cG0xKC0yZS0xNykgIT0gLTJlLTE3XG4pID8gZnVuY3Rpb24gZXhwbTEoeCkge1xuICByZXR1cm4gKHggPSAreCkgPT0gMCA/IHggOiB4ID4gLTFlLTYgJiYgeCA8IDFlLTYgPyB4ICsgeCAqIHggLyAyIDogZXhwKHgpIC0gMTtcbn0gOiBuYXRpdmVFeHBtMTtcbiIsInZhciBzaWduID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtc2lnbicpO1xuXG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgcG93ID0gTWF0aC5wb3c7XG52YXIgRVBTSUxPTiA9IHBvdygyLCAtNTIpO1xudmFyIEVQU0lMT04zMiA9IHBvdygyLCAtMjMpO1xudmFyIE1BWDMyID0gcG93KDIsIDEyNykgKiAoMiAtIEVQU0lMT04zMik7XG52YXIgTUlOMzIgPSBwb3coMiwgLTEyNik7XG5cbnZhciByb3VuZFRpZXNUb0V2ZW4gPSBmdW5jdGlvbiAobikge1xuICByZXR1cm4gbiArIDEgLyBFUFNJTE9OIC0gMSAvIEVQU0lMT047XG59O1xuXG4vLyBgTWF0aC5mcm91bmRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5mcm91bmRcbm1vZHVsZS5leHBvcnRzID0gTWF0aC5mcm91bmQgfHwgZnVuY3Rpb24gZnJvdW5kKHgpIHtcbiAgdmFyICRhYnMgPSBhYnMoeCk7XG4gIHZhciAkc2lnbiA9IHNpZ24oeCk7XG4gIHZhciBhLCByZXN1bHQ7XG4gIGlmICgkYWJzIDwgTUlOMzIpIHJldHVybiAkc2lnbiAqIHJvdW5kVGllc1RvRXZlbigkYWJzIC8gTUlOMzIgLyBFUFNJTE9OMzIpICogTUlOMzIgKiBFUFNJTE9OMzI7XG4gIGEgPSAoMSArIEVQU0lMT04zMiAvIEVQU0lMT04pICogJGFicztcbiAgcmVzdWx0ID0gYSAtIChhIC0gJGFicyk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgaWYgKHJlc3VsdCA+IE1BWDMyIHx8IHJlc3VsdCAhPSByZXN1bHQpIHJldHVybiAkc2lnbiAqIEluZmluaXR5O1xuICByZXR1cm4gJHNpZ24gKiByZXN1bHQ7XG59O1xuIiwidmFyIGxvZyA9IE1hdGgubG9nO1xuXG4vLyBgTWF0aC5sb2cxcGAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzFwXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGgubG9nMXAgfHwgZnVuY3Rpb24gbG9nMXAoeCkge1xuICByZXR1cm4gKHggPSAreCkgPiAtMWUtOCAmJiB4IDwgMWUtOCA/IHggLSB4ICogeCAvIDIgOiBsb2coMSArIHgpO1xufTtcbiIsIi8vIGBNYXRoLnNpZ25gIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5zaWduXG5tb2R1bGUuZXhwb3J0cyA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbiBzaWduKHgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICByZXR1cm4gKHggPSAreCkgPT0gMCB8fCB4ICE9IHggPyB4IDogeCA8IDAgPyAtMSA6IDE7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIG1hY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2VyLWFnZW50Jyk7XG5cbnZhciBNdXRhdGlvbk9ic2VydmVyID0gZ2xvYmFsLk11dGF0aW9uT2JzZXJ2ZXIgfHwgZ2xvYmFsLldlYktpdE11dGF0aW9uT2JzZXJ2ZXI7XG52YXIgcHJvY2VzcyA9IGdsb2JhbC5wcm9jZXNzO1xudmFyIFByb21pc2UgPSBnbG9iYWwuUHJvbWlzZTtcbnZhciBJU19OT0RFID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG4vLyBOb2RlLmpzIDExIHNob3dzIEV4cGVyaW1lbnRhbFdhcm5pbmcgb24gZ2V0dGluZyBgcXVldWVNaWNyb3Rhc2tgXG52YXIgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCwgJ3F1ZXVlTWljcm90YXNrJyk7XG52YXIgcXVldWVNaWNyb3Rhc2sgPSBxdWV1ZU1pY3JvdGFza0Rlc2NyaXB0b3IgJiYgcXVldWVNaWNyb3Rhc2tEZXNjcmlwdG9yLnZhbHVlO1xuXG52YXIgZmx1c2gsIGhlYWQsIGxhc3QsIG5vdGlmeSwgdG9nZ2xlLCBub2RlLCBwcm9taXNlO1xuXG4vLyBtb2Rlcm4gZW5naW5lcyBoYXZlIHF1ZXVlTWljcm90YXNrIG1ldGhvZFxuaWYgKCFxdWV1ZU1pY3JvdGFzaykge1xuICBmbHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50LCBmbjtcbiAgICBpZiAoSVNfTk9ERSAmJiAocGFyZW50ID0gcHJvY2Vzcy5kb21haW4pKSBwYXJlbnQuZXhpdCgpO1xuICAgIHdoaWxlIChoZWFkKSB7XG4gICAgICBmbiA9IGhlYWQuZm47XG4gICAgICBoZWFkID0gaGVhZC5uZXh0O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChoZWFkKSBub3RpZnkoKTtcbiAgICAgICAgZWxzZSBsYXN0ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgIH1cbiAgICB9IGxhc3QgPSB1bmRlZmluZWQ7XG4gICAgaWYgKHBhcmVudCkgcGFyZW50LmVudGVyKCk7XG4gIH07XG5cbiAgLy8gTm9kZS5qc1xuICBpZiAoSVNfTk9ERSkge1xuICAgIG5vdGlmeSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZmx1c2gpO1xuICAgIH07XG4gIC8vIGJyb3dzZXJzIHdpdGggTXV0YXRpb25PYnNlcnZlciwgZXhjZXB0IGlPUyAtIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8zMzlcbiAgfSBlbHNlIGlmIChNdXRhdGlvbk9ic2VydmVyICYmICEvKGlwaG9uZXxpcG9kfGlwYWQpLiphcHBsZXdlYmtpdC9pLnRlc3QodXNlckFnZW50KSkge1xuICAgIHRvZ2dsZSA9IHRydWU7XG4gICAgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICBuZXcgTXV0YXRpb25PYnNlcnZlcihmbHVzaCkub2JzZXJ2ZShub2RlLCB7IGNoYXJhY3RlckRhdGE6IHRydWUgfSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgbm9kZS5kYXRhID0gdG9nZ2xlID0gIXRvZ2dsZTtcbiAgICB9O1xuICAvLyBlbnZpcm9ubWVudHMgd2l0aCBtYXliZSBub24tY29tcGxldGVseSBjb3JyZWN0LCBidXQgZXhpc3RlbnQgUHJvbWlzZVxuICB9IGVsc2UgaWYgKFByb21pc2UgJiYgUHJvbWlzZS5yZXNvbHZlKSB7XG4gICAgLy8gUHJvbWlzZS5yZXNvbHZlIHdpdGhvdXQgYW4gYXJndW1lbnQgdGhyb3dzIGFuIGVycm9yIGluIExHIFdlYk9TIDJcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9O1xuICAvLyBmb3Igb3RoZXIgZW52aXJvbm1lbnRzIC0gbWFjcm90YXNrIGJhc2VkIG9uOlxuICAvLyAtIHNldEltbWVkaWF0ZVxuICAvLyAtIE1lc3NhZ2VDaGFubmVsXG4gIC8vIC0gd2luZG93LnBvc3RNZXNzYWdcbiAgLy8gLSBvbnJlYWR5c3RhdGVjaGFuZ2VcbiAgLy8gLSBzZXRUaW1lb3V0XG4gIH0gZWxzZSB7XG4gICAgbm90aWZ5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gc3RyYW5nZSBJRSArIHdlYnBhY2sgZGV2IHNlcnZlciBidWcgLSB1c2UgLmNhbGwoZ2xvYmFsKVxuICAgICAgbWFjcm90YXNrLmNhbGwoZ2xvYmFsLCBmbHVzaCk7XG4gICAgfTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHF1ZXVlTWljcm90YXNrIHx8IGZ1bmN0aW9uIChmbikge1xuICB2YXIgdGFzayA9IHsgZm46IGZuLCBuZXh0OiB1bmRlZmluZWQgfTtcbiAgaWYgKGxhc3QpIGxhc3QubmV4dCA9IHRhc2s7XG4gIGlmICghaGVhZCkge1xuICAgIGhlYWQgPSB0YXNrO1xuICAgIG5vdGlmeSgpO1xuICB9IGxhc3QgPSB0YXNrO1xufTtcbiIsInZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICEhT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBDaHJvbWUgMzggU3ltYm9sIGhhcyBpbmNvcnJlY3QgdG9TdHJpbmcgY29udmVyc2lvblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgcmV0dXJuICFTdHJpbmcoU3ltYm9sKCkpO1xufSk7XG4iLCJ2YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBuZXcgVVJMKCdiP2U9MScsICdodHRwOi8vYScpO1xuICB2YXIgc2VhcmNoUGFyYW1zID0gdXJsLnNlYXJjaFBhcmFtcztcbiAgdXJsLnBhdGhuYW1lID0gJ2MlMjBkJztcbiAgcmV0dXJuIChJU19QVVJFICYmICF1cmwudG9KU09OKVxuICAgIHx8ICFzZWFyY2hQYXJhbXMuc29ydFxuICAgIHx8IHVybC5ocmVmICE9PSAnaHR0cDovL2EvYyUyMGQ/ZT0xJ1xuICAgIHx8IHNlYXJjaFBhcmFtcy5nZXQoJ2UnKSAhPT0gJzEnXG4gICAgfHwgU3RyaW5nKG5ldyBVUkxTZWFyY2hQYXJhbXMoJz9hPTEnKSkgIT09ICdhPTEnXG4gICAgfHwgIXNlYXJjaFBhcmFtc1tJVEVSQVRPUl1cbiAgICAvLyB0aHJvd3MgaW4gRWRnZVxuICAgIHx8IG5ldyBVUkwoJ2h0dHBzOi8vYUBiJykudXNlcm5hbWUgIT09ICdhJ1xuICAgIHx8IG5ldyBVUkxTZWFyY2hQYXJhbXMobmV3IFVSTFNlYXJjaFBhcmFtcygnYT1iJykpLmdldCgnYScpICE9PSAnYidcbiAgICAvLyBub3QgcHVueWNvZGVkIGluIEVkZ2VcbiAgICB8fCBuZXcgVVJMKCdodHRwOi8v0YLQtdGB0YInKS5ob3N0ICE9PSAneG4tLWUxYXliYydcbiAgICAvLyBub3QgZXNjYXBlZCBpbiBDaHJvbWUgNjItXG4gICAgfHwgbmV3IFVSTCgnaHR0cDovL2Ej0LEnKS5oYXNoICE9PSAnIyVEMCVCMSc7XG59KTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgbmF0aXZlRnVuY3Rpb25Ub1N0cmluZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi10by1zdHJpbmcnKTtcblxudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcblxubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QobmF0aXZlRnVuY3Rpb25Ub1N0cmluZy5jYWxsKFdlYWtNYXApKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xuXG52YXIgUHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICB2YXIgcmVzb2x2ZSwgcmVqZWN0O1xuICB0aGlzLnByb21pc2UgPSBuZXcgQyhmdW5jdGlvbiAoJCRyZXNvbHZlLCAkJHJlamVjdCkge1xuICAgIGlmIChyZXNvbHZlICE9PSB1bmRlZmluZWQgfHwgcmVqZWN0ICE9PSB1bmRlZmluZWQpIHRocm93IFR5cGVFcnJvcignQmFkIFByb21pc2UgY29uc3RydWN0b3InKTtcbiAgICByZXNvbHZlID0gJCRyZXNvbHZlO1xuICAgIHJlamVjdCA9ICQkcmVqZWN0O1xuICB9KTtcbiAgdGhpcy5yZXNvbHZlID0gYUZ1bmN0aW9uKHJlc29sdmUpO1xuICB0aGlzLnJlamVjdCA9IGFGdW5jdGlvbihyZWplY3QpO1xufTtcblxuLy8gMjUuNC4xLjUgTmV3UHJvbWlzZUNhcGFiaWxpdHkoQylcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiAoQykge1xuICByZXR1cm4gbmV3IFByb21pc2VDYXBhYmlsaXR5KEMpO1xufTtcbiIsInZhciBpc1JlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1yZWdleHAnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgaWYgKGlzUmVnRXhwKGl0KSkge1xuICAgIHRocm93IFR5cGVFcnJvcihcIlRoZSBtZXRob2QgZG9lc24ndCBhY2NlcHQgcmVndWxhciBleHByZXNzaW9uc1wiKTtcbiAgfSByZXR1cm4gaXQ7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcblxudmFyIGdsb2JhbElzRmluaXRlID0gZ2xvYmFsLmlzRmluaXRlO1xuXG4vLyBgTnVtYmVyLmlzRmluaXRlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5pc2Zpbml0ZVxubW9kdWxlLmV4cG9ydHMgPSBOdW1iZXIuaXNGaW5pdGUgfHwgZnVuY3Rpb24gaXNGaW5pdGUoaXQpIHtcbiAgcmV0dXJuIHR5cGVvZiBpdCA9PSAnbnVtYmVyJyAmJiBnbG9iYWxJc0Zpbml0ZShpdCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1rZXlzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcblxudmFyIG5hdGl2ZUFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbi8vIHNob3VsZCB3b3JrIHdpdGggc3ltYm9scyBhbmQgc2hvdWxkIGhhdmUgZGV0ZXJtaW5pc3RpYyBwcm9wZXJ0eSBvcmRlciAoVjggYnVnKVxubW9kdWxlLmV4cG9ydHMgPSAhbmF0aXZlQXNzaWduIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIEEgPSB7fTtcbiAgdmFyIEIgPSB7fTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIHZhciBzeW1ib2wgPSBTeW1ib2woKTtcbiAgdmFyIGFscGhhYmV0ID0gJ2FiY2RlZmdoaWprbG1ub3BxcnN0JztcbiAgQVtzeW1ib2xdID0gNztcbiAgYWxwaGFiZXQuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGNocikgeyBCW2Nocl0gPSBjaHI7IH0pO1xuICByZXR1cm4gbmF0aXZlQXNzaWduKHt9LCBBKVtzeW1ib2xdICE9IDcgfHwgb2JqZWN0S2V5cyhuYXRpdmVBc3NpZ24oe30sIEIpKS5qb2luKCcnKSAhPSBhbHBoYWJldDtcbn0pID8gZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgc291cmNlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgdmFyIFQgPSB0b09iamVjdCh0YXJnZXQpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIGluZGV4ID0gMTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICB2YXIgcHJvcGVydHlJc0VudW1lcmFibGUgPSBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mO1xuICB3aGlsZSAoYXJndW1lbnRzTGVuZ3RoID4gaW5kZXgpIHtcbiAgICB2YXIgUyA9IEluZGV4ZWRPYmplY3QoYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICB2YXIga2V5cyA9IGdldE93blByb3BlcnR5U3ltYm9scyA/IG9iamVjdEtleXMoUykuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhTKSkgOiBvYmplY3RLZXlzKFMpO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIGtleTtcbiAgICB3aGlsZSAobGVuZ3RoID4gaikge1xuICAgICAga2V5ID0ga2V5c1tqKytdO1xuICAgICAgaWYgKCFERVNDUklQVE9SUyB8fCBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKFMsIGtleSkpIFRba2V5XSA9IFNba2V5XTtcbiAgICB9XG4gIH0gcmV0dXJuIFQ7XG59IDogbmF0aXZlQXNzaWduO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG52YXIgZW51bUJ1Z0tleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZW51bS1idWcta2V5cycpO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcbnZhciBodG1sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2h0bWwnKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9jdW1lbnQtY3JlYXRlLWVsZW1lbnQnKTtcbnZhciBzaGFyZWRLZXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2hhcmVkLWtleScpO1xudmFyIElFX1BST1RPID0gc2hhcmVkS2V5KCdJRV9QUk9UTycpO1xuXG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgRW1wdHkgPSBmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH07XG5cbi8vIENyZWF0ZSBvYmplY3Qgd2l0aCBmYWtlIGBudWxsYCBwcm90b3R5cGU6IHVzZSBpZnJhbWUgT2JqZWN0IHdpdGggY2xlYXJlZCBwcm90b3R5cGVcbnZhciBjcmVhdGVEaWN0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBUaHJhc2gsIHdhc3RlIGFuZCBzb2RvbXk6IElFIEdDIGJ1Z1xuICB2YXIgaWZyYW1lID0gZG9jdW1lbnRDcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiAgdmFyIGx0ID0gJzwnO1xuICB2YXIgc2NyaXB0ID0gJ3NjcmlwdCc7XG4gIHZhciBndCA9ICc+JztcbiAgdmFyIGpzID0gJ2phdmEnICsgc2NyaXB0ICsgJzonO1xuICB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICBodG1sLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gIGlmcmFtZS5zcmMgPSBTdHJpbmcoanMpO1xuICBpZnJhbWVEb2N1bWVudCA9IGlmcmFtZS5jb250ZW50V2luZG93LmRvY3VtZW50O1xuICBpZnJhbWVEb2N1bWVudC5vcGVuKCk7XG4gIGlmcmFtZURvY3VtZW50LndyaXRlKGx0ICsgc2NyaXB0ICsgZ3QgKyAnZG9jdW1lbnQuRj1PYmplY3QnICsgbHQgKyAnLycgKyBzY3JpcHQgKyBndCk7XG4gIGlmcmFtZURvY3VtZW50LmNsb3NlKCk7XG4gIGNyZWF0ZURpY3QgPSBpZnJhbWVEb2N1bWVudC5GO1xuICB3aGlsZSAobGVuZ3RoLS0pIGRlbGV0ZSBjcmVhdGVEaWN0W1BST1RPVFlQRV1bZW51bUJ1Z0tleXNbbGVuZ3RoXV07XG4gIHJldHVybiBjcmVhdGVEaWN0KCk7XG59O1xuXG4vLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuY3JlYXRlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24gY3JlYXRlKE8sIFByb3BlcnRpZXMpIHtcbiAgdmFyIHJlc3VsdDtcbiAgaWYgKE8gIT09IG51bGwpIHtcbiAgICBFbXB0eVtQUk9UT1RZUEVdID0gYW5PYmplY3QoTyk7XG4gICAgcmVzdWx0ID0gbmV3IEVtcHR5KCk7XG4gICAgRW1wdHlbUFJPVE9UWVBFXSA9IG51bGw7XG4gICAgLy8gYWRkIFwiX19wcm90b19fXCIgZm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZiBwb2x5ZmlsbFxuICAgIHJlc3VsdFtJRV9QUk9UT10gPSBPO1xuICB9IGVsc2UgcmVzdWx0ID0gY3JlYXRlRGljdCgpO1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gcmVzdWx0IDogZGVmaW5lUHJvcGVydGllcyhyZXN1bHQsIFByb3BlcnRpZXMpO1xufTtcblxuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcblxuLy8gYE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhQcm9wZXJ0aWVzKTtcbiAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIga2V5O1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5ID0ga2V5c1tpbmRleCsrXSwgUHJvcGVydGllc1trZXldKTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcblxudmFyIG5hdGl2ZURlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgYW5PYmplY3QoTyk7XG4gIFAgPSB0b1ByaW1pdGl2ZShQLCB0cnVlKTtcbiAgYW5PYmplY3QoQXR0cmlidXRlcyk7XG4gIGlmIChJRThfRE9NX0RFRklORSkgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7IC8qIGVtcHR5ICovIH1cbiAgaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcykgdGhyb3cgVHlwZUVycm9yKCdBY2Nlc3NvcnMgbm90IHN1cHBvcnRlZCcpO1xuICBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKSBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiAgcmV0dXJuIE87XG59O1xuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgcHJvcGVydHlJc0VudW1lcmFibGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXByb3BlcnR5LWlzLWVudW1lcmFibGUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaWU4LWRvbS1kZWZpbmUnKTtcblxudmFyIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JcbmV4cG9ydHMuZiA9IERFU0NSSVBUT1JTID8gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiAgTyA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgUCA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoSUU4X0RPTV9ERUZJTkUpIHRyeSB7XG4gICAgcmV0dXJuIG5hdGl2ZUdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHsgLyogZW1wdHkgKi8gfVxuICBpZiAoaGFzKE8sIFApKSByZXR1cm4gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKCFwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLmNhbGwoTywgUCksIE9bUF0pO1xufTtcbiIsInZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcblxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbnZhciB3aW5kb3dOYW1lcyA9IHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgd2luZG93ICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzXG4gID8gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMod2luZG93KSA6IFtdO1xuXG52YXIgZ2V0V2luZG93TmFtZXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlOYW1lcyhpdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHdpbmRvd05hbWVzLnNsaWNlKCk7XG4gIH1cbn07XG5cbi8vIGZhbGxiYWNrIGZvciBJRTExIGJ1Z2d5IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzIHdpdGggaWZyYW1lIGFuZCB3aW5kb3dcbm1vZHVsZS5leHBvcnRzLmYgPSBmdW5jdGlvbiBnZXRPd25Qcm9wZXJ0eU5hbWVzKGl0KSB7XG4gIHJldHVybiB3aW5kb3dOYW1lcyAmJiB0b1N0cmluZy5jYWxsKGl0KSA9PSAnW29iamVjdCBXaW5kb3ddJ1xuICAgID8gZ2V0V2luZG93TmFtZXMoaXQpXG4gICAgOiBuYXRpdmVHZXRPd25Qcm9wZXJ0eU5hbWVzKHRvSW5kZXhlZE9iamVjdChpdCkpO1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbnZhciBoaWRkZW5LZXlzID0gZW51bUJ1Z0tleXMuY29uY2F0KCdsZW5ndGgnLCAncHJvdG90eXBlJyk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHJldHVybiBpbnRlcm5hbE9iamVjdEtleXMoTywgaGlkZGVuS2V5cyk7XG59O1xuIiwiZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbiIsInZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgc2hhcmVkS2V5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZC1rZXknKTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29ycmVjdC1wcm90b3R5cGUtZ2V0dGVyJyk7XG5cbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3QucHJvdG90eXBlO1xuXG4vLyBgT2JqZWN0LmdldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRwcm90b3R5cGVvZlxubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YgOiBmdW5jdGlvbiAoTykge1xuICBPID0gdG9PYmplY3QoTyk7XG4gIGlmIChoYXMoTywgSUVfUFJPVE8pKSByZXR1cm4gT1tJRV9QUk9UT107XG4gIGlmICh0eXBlb2YgTy5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmIE8gaW5zdGFuY2VvZiBPLmNvbnN0cnVjdG9yKSB7XG4gICAgcmV0dXJuIE8uY29uc3RydWN0b3IucHJvdG90eXBlO1xuICB9IHJldHVybiBPIGluc3RhbmNlb2YgT2JqZWN0ID8gT2JqZWN0UHJvdG90eXBlIDogbnVsbDtcbn07XG4iLCJ2YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIGluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmRleE9mO1xudmFyIGhpZGRlbktleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZGVuLWtleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBuYW1lcykge1xuICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICB2YXIgaSA9IDA7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gTykgIWhhcyhoaWRkZW5LZXlzLCBrZXkpICYmIGhhcyhPLCBrZXkpICYmIHJlc3VsdC5wdXNoKGtleSk7XG4gIC8vIERvbid0IGVudW0gYnVnICYgaGlkZGVuIGtleXNcbiAgd2hpbGUgKG5hbWVzLmxlbmd0aCA+IGkpIGlmIChoYXMoTywga2V5ID0gbmFtZXNbaSsrXSkpIHtcbiAgICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcmVzdWx0LnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufTtcbiIsInZhciBpbnRlcm5hbE9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMtaW50ZXJuYWwnKTtcbnZhciBlbnVtQnVnS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9lbnVtLWJ1Zy1rZXlzJyk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiBrZXlzKE8pIHtcbiAgcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlID0ge30ucHJvcGVydHlJc0VudW1lcmFibGU7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuLy8gTmFzaG9ybiB+IEpESzggYnVnXG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgIW5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoeyAxOiAyIH0sIDEpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZWAgbWV0aG9kIGltcGxlbWVudGF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QucHJvdG90eXBlLnByb3BlcnR5aXNlbnVtZXJhYmxlXG5leHBvcnRzLmYgPSBOQVNIT1JOX0JVRyA/IGZ1bmN0aW9uIHByb3BlcnR5SXNFbnVtZXJhYmxlKFYpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGhpcywgVik7XG4gIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6IG5hdGl2ZVByb3BlcnR5SXNFbnVtZXJhYmxlO1xuIiwidmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLXBvc3NpYmxlLXByb3RvdHlwZScpO1xuXG4vLyBgT2JqZWN0LnNldFByb3RvdHlwZU9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZXRwcm90b3R5cGVvZlxuLy8gV29ya3Mgd2l0aCBfX3Byb3RvX18gb25seS4gT2xkIHY4IGNhbid0IHdvcmsgd2l0aCBudWxsIHByb3RvIG9iamVjdHMuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gZnVuY3Rpb24gKCkge1xuICB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiAgdmFyIHRlc3QgPSB7fTtcbiAgdmFyIHNldHRlcjtcbiAgdHJ5IHtcbiAgICBzZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE9iamVjdC5wcm90b3R5cGUsICdfX3Byb3RvX18nKS5zZXQ7XG4gICAgc2V0dGVyLmNhbGwodGVzdCwgW10pO1xuICAgIENPUlJFQ1RfU0VUVEVSID0gdGVzdCBpbnN0YW5jZW9mIEFycmF5O1xuICB9IGNhdGNoIChlcnJvcikgeyAvKiBlbXB0eSAqLyB9XG4gIHJldHVybiBmdW5jdGlvbiBzZXRQcm90b3R5cGVPZihPLCBwcm90bykge1xuICAgIGFuT2JqZWN0KE8pO1xuICAgIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gICAgaWYgKENPUlJFQ1RfU0VUVEVSKSBzZXR0ZXIuY2FsbChPLCBwcm90byk7XG4gICAgZWxzZSBPLl9fcHJvdG9fXyA9IHByb3RvO1xuICAgIHJldHVybiBPO1xuICB9O1xufSgpIDogdW5kZWZpbmVkKTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpLmY7XG5cbi8vIGBPYmplY3QueyBlbnRyaWVzLCB2YWx1ZXMgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChUT19FTlRSSUVTKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaXQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChpdCk7XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKE8pO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBrZXk7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGtleSA9IGtleXNbaSsrXTtcbiAgICAgIGlmICghREVTQ1JJUFRPUlMgfHwgcHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChPLCBrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKFRPX0VOVFJJRVMgPyBba2V5LCBPW2tleV1dIDogT1trZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgT2JqZWN0LmVudHJpZXNgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZW50cmllc1xuICBlbnRyaWVzOiBjcmVhdGVNZXRob2QodHJ1ZSksXG4gIC8vIGBPYmplY3QudmFsdWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnZhbHVlc1xuICB2YWx1ZXM6IGNyZWF0ZU1ldGhvZChmYWxzZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mJyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIHRlc3QgPSB7fTtcblxudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6JztcblxuLy8gYE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZ1xubW9kdWxlLmV4cG9ydHMgPSBTdHJpbmcodGVzdCkgIT09ICdbb2JqZWN0IHpdJyA/IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ1tvYmplY3QgJyArIGNsYXNzb2YodGhpcykgKyAnXSc7XG59IDogdGVzdC50b1N0cmluZztcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHNNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktc3ltYm9scycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG4vLyBhbGwgb2JqZWN0IGtleXMsIGluY2x1ZGVzIG5vbi1lbnVtZXJhYmxlIGFuZCBzeW1ib2xzXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ1JlZmxlY3QnLCAnb3duS2V5cycpIHx8IGZ1bmN0aW9uIG93bktleXMoaXQpIHtcbiAgdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiAgdmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mO1xuICByZXR1cm4gZ2V0T3duUHJvcGVydHlTeW1ib2xzID8ga2V5cy5jb25jYXQoZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSkgOiBrZXlzO1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG52YXIgd2hpdGVzcGFjZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2hpdGVzcGFjZXMnKTtcblxudmFyIG5hdGl2ZVBhcnNlRmxvYXQgPSBnbG9iYWwucGFyc2VGbG9hdDtcbnZhciBGT1JDRUQgPSAxIC8gbmF0aXZlUGFyc2VGbG9hdCh3aGl0ZXNwYWNlcyArICctMCcpICE9PSAtSW5maW5pdHk7XG5cbi8vIGBwYXJzZUZsb2F0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlZmxvYXQtc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IEZPUkNFRCA/IGZ1bmN0aW9uIHBhcnNlRmxvYXQoc3RyaW5nKSB7XG4gIHZhciB0cmltbWVkU3RyaW5nID0gdHJpbShTdHJpbmcoc3RyaW5nKSk7XG4gIHZhciByZXN1bHQgPSBuYXRpdmVQYXJzZUZsb2F0KHRyaW1tZWRTdHJpbmcpO1xuICByZXR1cm4gcmVzdWx0ID09PSAwICYmIHRyaW1tZWRTdHJpbmcuY2hhckF0KDApID09ICctJyA/IC0wIDogcmVzdWx0O1xufSA6IG5hdGl2ZVBhcnNlRmxvYXQ7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHRyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIHdoaXRlc3BhY2VzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3doaXRlc3BhY2VzJyk7XG5cbnZhciBuYXRpdmVQYXJzZUludCA9IGdsb2JhbC5wYXJzZUludDtcbnZhciBoZXggPSAvXlsrLV0/MFtYeF0vO1xudmFyIEZPUkNFRCA9IG5hdGl2ZVBhcnNlSW50KHdoaXRlc3BhY2VzICsgJzA4JykgIT09IDggfHwgbmF0aXZlUGFyc2VJbnQod2hpdGVzcGFjZXMgKyAnMHgxNicpICE9PSAyMjtcblxuLy8gYHBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXBhcnNlaW50LXN0cmluZy1yYWRpeFxubW9kdWxlLmV4cG9ydHMgPSBGT1JDRUQgPyBmdW5jdGlvbiBwYXJzZUludChzdHJpbmcsIHJhZGl4KSB7XG4gIHZhciBTID0gdHJpbShTdHJpbmcoc3RyaW5nKSk7XG4gIHJldHVybiBuYXRpdmVQYXJzZUludChTLCAocmFkaXggPj4+IDApIHx8IChoZXgudGVzdChTKSA/IDE2IDogMTApKTtcbn0gOiBuYXRpdmVQYXJzZUludDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZXhlYykge1xuICB0cnkge1xuICAgIHJldHVybiB7IGVycm9yOiBmYWxzZSwgdmFsdWU6IGV4ZWMoKSB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7IGVycm9yOiB0cnVlLCB2YWx1ZTogZXJyb3IgfTtcbiAgfVxufTtcbiIsInZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBuZXdQcm9taXNlQ2FwYWJpbGl0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uZXctcHJvbWlzZS1jYXBhYmlsaXR5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKEMsIHgpIHtcbiAgYW5PYmplY3QoQyk7XG4gIGlmIChpc09iamVjdCh4KSAmJiB4LmNvbnN0cnVjdG9yID09PSBDKSByZXR1cm4geDtcbiAgdmFyIHByb21pc2VDYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkuZihDKTtcbiAgdmFyIHJlc29sdmUgPSBwcm9taXNlQ2FwYWJpbGl0eS5yZXNvbHZlO1xuICByZXNvbHZlKHgpO1xuICByZXR1cm4gcHJvbWlzZUNhcGFiaWxpdHkucHJvbWlzZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvcHVueWNvZGUuanMvYmxvYi9tYXN0ZXIvcHVueWNvZGUuanNcbnZhciBtYXhJbnQgPSAyMTQ3NDgzNjQ3OyAvLyBha2EuIDB4N0ZGRkZGRkYgb3IgMl4zMS0xXG52YXIgYmFzZSA9IDM2O1xudmFyIHRNaW4gPSAxO1xudmFyIHRNYXggPSAyNjtcbnZhciBza2V3ID0gMzg7XG52YXIgZGFtcCA9IDcwMDtcbnZhciBpbml0aWFsQmlhcyA9IDcyO1xudmFyIGluaXRpYWxOID0gMTI4OyAvLyAweDgwXG52YXIgZGVsaW1pdGVyID0gJy0nOyAvLyAnXFx4MkQnXG52YXIgcmVnZXhOb25BU0NJSSA9IC9bXlxcMC1cXHUwMDdFXS87IC8vIG5vbi1BU0NJSSBjaGFyc1xudmFyIHJlZ2V4U2VwYXJhdG9ycyA9IC9bLlxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZzsgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xudmFyIE9WRVJGTE9XX0VSUk9SID0gJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJztcbnZhciBiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW47XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcbiAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuICogbWF0Y2hpbmcgVVRGLTE2LlxuICovXG52YXIgdWNzMmRlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgY291bnRlciA9IDA7XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgaWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgLy8gSXQncyBhIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3Rlci5cbiAgICAgIHZhciBleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICBpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gTG93IHN1cnJvZ2F0ZS5cbiAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEl0J3MgYW4gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlXG4gICAgICAgIC8vIG5leHQgY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgIGNvdW50ZXItLTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cHV0O1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG4gKi9cbnZhciBkaWdpdFRvQmFzaWMgPSBmdW5jdGlvbiAoZGlnaXQpIHtcbiAgLy8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcbiAgLy8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG4gIHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNik7XG59O1xuXG4vKipcbiAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG4gKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuICovXG52YXIgYWRhcHQgPSBmdW5jdGlvbiAoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG4gIHZhciBrID0gMDtcbiAgZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcbiAgZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuICBmb3IgKDsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcbiAgICBkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG4gIH1cbiAgcmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG4gKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgIG1heC1zdGF0ZW1lbnRzXG52YXIgZW5jb2RlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBvdXRwdXQgPSBbXTtcblxuICAvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBhbiBhcnJheSBvZiBVbmljb2RlIGNvZGUgcG9pbnRzLlxuICBpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG4gIC8vIENhY2hlIHRoZSBsZW5ndGguXG4gIHZhciBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuICAvLyBJbml0aWFsaXplIHRoZSBzdGF0ZS5cbiAgdmFyIG4gPSBpbml0aWFsTjtcbiAgdmFyIGRlbHRhID0gMDtcbiAgdmFyIGJpYXMgPSBpbml0aWFsQmlhcztcbiAgdmFyIGksIGN1cnJlbnRWYWx1ZTtcblxuICAvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjdXJyZW50VmFsdWUgPSBpbnB1dFtpXTtcbiAgICBpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7IC8vIG51bWJlciBvZiBiYXNpYyBjb2RlIHBvaW50cy5cbiAgdmFyIGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGg7IC8vIG51bWJlciBvZiBjb2RlIHBvaW50cyB0aGF0IGhhdmUgYmVlbiBoYW5kbGVkO1xuXG4gIC8vIEZpbmlzaCB0aGUgYmFzaWMgc3RyaW5nIHdpdGggYSBkZWxpbWl0ZXIgdW5sZXNzIGl0J3MgZW1wdHkuXG4gIGlmIChiYXNpY0xlbmd0aCkge1xuICAgIG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG4gIH1cblxuICAvLyBNYWluIGVuY29kaW5nIGxvb3A6XG4gIHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG4gICAgLy8gQWxsIG5vbi1iYXNpYyBjb2RlIHBvaW50cyA8IG4gaGF2ZSBiZWVuIGhhbmRsZWQgYWxyZWFkeS4gRmluZCB0aGUgbmV4dCBsYXJnZXIgb25lOlxuICAgIHZhciBtID0gbWF4SW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlID49IG4gJiYgY3VycmVudFZhbHVlIDwgbSkge1xuICAgICAgICBtID0gY3VycmVudFZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPiwgYnV0IGd1YXJkIGFnYWluc3Qgb3ZlcmZsb3cuXG4gICAgdmFyIGhhbmRsZWRDUENvdW50UGx1c09uZSA9IGhhbmRsZWRDUENvdW50ICsgMTtcbiAgICBpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuICAgICAgdGhyb3cgUmFuZ2VFcnJvcihPVkVSRkxPV19FUlJPUik7XG4gICAgfVxuXG4gICAgZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcbiAgICBuID0gbTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgY3VycmVudFZhbHVlID0gaW5wdXRbaV07XG4gICAgICBpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG4gICAgICAgIHRocm93IFJhbmdlRXJyb3IoT1ZFUkZMT1dfRVJST1IpO1xuICAgICAgfVxuICAgICAgaWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG4gICAgICAgIC8vIFJlcHJlc2VudCBkZWx0YSBhcyBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyLlxuICAgICAgICB2YXIgcSA9IGRlbHRhO1xuICAgICAgICBmb3IgKHZhciBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcbiAgICAgICAgICB2YXIgdCA9IGsgPD0gYmlhcyA/IHRNaW4gOiAoayA+PSBiaWFzICsgdE1heCA/IHRNYXggOiBrIC0gYmlhcyk7XG4gICAgICAgICAgaWYgKHEgPCB0KSBicmVhaztcbiAgICAgICAgICB2YXIgcU1pbnVzVCA9IHEgLSB0O1xuICAgICAgICAgIHZhciBiYXNlTWludXNUID0gYmFzZSAtIHQ7XG4gICAgICAgICAgb3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGRpZ2l0VG9CYXNpYyh0ICsgcU1pbnVzVCAlIGJhc2VNaW51c1QpKSk7XG4gICAgICAgICAgcSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSkpKTtcbiAgICAgICAgYmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcbiAgICAgICAgZGVsdGEgPSAwO1xuICAgICAgICArK2hhbmRsZWRDUENvdW50O1xuICAgICAgfVxuICAgIH1cblxuICAgICsrZGVsdGE7XG4gICAgKytuO1xuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICB2YXIgZW5jb2RlZCA9IFtdO1xuICB2YXIgbGFiZWxzID0gaW5wdXQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xcdTAwMkUnKS5zcGxpdCgnLicpO1xuICB2YXIgaSwgbGFiZWw7XG4gIGZvciAoaSA9IDA7IGkgPCBsYWJlbHMubGVuZ3RoOyBpKyspIHtcbiAgICBsYWJlbCA9IGxhYmVsc1tpXTtcbiAgICBlbmNvZGVkLnB1c2gocmVnZXhOb25BU0NJSS50ZXN0KGxhYmVsKSA/ICd4bi0tJyArIGVuY29kZShsYWJlbCkgOiBsYWJlbCk7XG4gIH1cbiAgcmV0dXJuIGVuY29kZWQuam9pbignLicpO1xufTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIHNyYywgb3B0aW9ucykge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSByZWRlZmluZSh0YXJnZXQsIGtleSwgc3JjW2tleV0sIG9wdGlvbnMpO1xuICByZXR1cm4gdGFyZ2V0O1xufTtcbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnVuY3Rpb24tdG8tc3RyaW5nJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIGVuZm9yY2VJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5lbmZvcmNlO1xudmFyIFRFTVBMQVRFID0gU3RyaW5nKG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcpLnNwbGl0KCd0b1N0cmluZycpO1xuXG5zaGFyZWQoJ2luc3BlY3RTb3VyY2UnLCBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbChpdCk7XG59KTtcblxuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGtleSwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgdmFyIHVuc2FmZSA9IG9wdGlvbnMgPyAhIW9wdGlvbnMudW5zYWZlIDogZmFsc2U7XG4gIHZhciBzaW1wbGUgPSBvcHRpb25zID8gISFvcHRpb25zLmVudW1lcmFibGUgOiBmYWxzZTtcbiAgdmFyIG5vVGFyZ2V0R2V0ID0gb3B0aW9ucyA/ICEhb3B0aW9ucy5ub1RhcmdldEdldCA6IGZhbHNlO1xuICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJyAmJiAhaGFzKHZhbHVlLCAnbmFtZScpKSBoaWRlKHZhbHVlLCAnbmFtZScsIGtleSk7XG4gICAgZW5mb3JjZUludGVybmFsU3RhdGUodmFsdWUpLnNvdXJjZSA9IFRFTVBMQVRFLmpvaW4odHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/IGtleSA6ICcnKTtcbiAgfVxuICBpZiAoTyA9PT0gZ2xvYmFsKSB7XG4gICAgaWYgKHNpbXBsZSkgT1trZXldID0gdmFsdWU7XG4gICAgZWxzZSBzZXRHbG9iYWwoa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKCF1bnNhZmUpIHtcbiAgICBkZWxldGUgT1trZXldO1xuICB9IGVsc2UgaWYgKCFub1RhcmdldEdldCAmJiBPW2tleV0pIHtcbiAgICBzaW1wbGUgPSB0cnVlO1xuICB9XG4gIGlmIChzaW1wbGUpIE9ba2V5XSA9IHZhbHVlO1xuICBlbHNlIGhpZGUoTywga2V5LCB2YWx1ZSk7XG4vLyBhZGQgZmFrZSBGdW5jdGlvbiN0b1N0cmluZyBmb3IgY29ycmVjdCB3b3JrIHdyYXBwZWQgbWV0aG9kcyAvIGNvbnN0cnVjdG9ycyB3aXRoIG1ldGhvZHMgbGlrZSBMb0Rhc2ggaXNOYXRpdmVcbn0pKEZ1bmN0aW9uLnByb3RvdHlwZSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiB0eXBlb2YgdGhpcyA9PSAnZnVuY3Rpb24nICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IG5hdGl2ZUZ1bmN0aW9uVG9TdHJpbmcuY2FsbCh0aGlzKTtcbn0pO1xuIiwidmFyIGNsYXNzb2YgPSByZXF1aXJlKCcuL2NsYXNzb2YtcmF3Jyk7XG52YXIgcmVnZXhwRXhlYyA9IHJlcXVpcmUoJy4vcmVnZXhwLWV4ZWMnKTtcblxuLy8gYFJlZ0V4cEV4ZWNgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwZXhlY1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoUiwgUykge1xuICB2YXIgZXhlYyA9IFIuZXhlYztcbiAgaWYgKHR5cGVvZiBleGVjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlc3VsdCA9IGV4ZWMuY2FsbChSLCBTKTtcbiAgICBpZiAodHlwZW9mIHJlc3VsdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignUmVnRXhwIGV4ZWMgbWV0aG9kIHJldHVybmVkIHNvbWV0aGluZyBvdGhlciB0aGFuIGFuIE9iamVjdCBvciBudWxsJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAoY2xhc3NvZihSKSAhPT0gJ1JlZ0V4cCcpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1JlZ0V4cCNleGVjIGNhbGxlZCBvbiBpbmNvbXBhdGlibGUgcmVjZWl2ZXInKTtcbiAgfVxuXG4gIHJldHVybiByZWdleHBFeGVjLmNhbGwoUiwgUyk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG52YXIgcmVnZXhwRmxhZ3MgPSByZXF1aXJlKCcuL3JlZ2V4cC1mbGFncycpO1xuXG52YXIgbmF0aXZlRXhlYyA9IFJlZ0V4cC5wcm90b3R5cGUuZXhlYztcbi8vIFRoaXMgYWx3YXlzIHJlZmVycyB0byB0aGUgbmF0aXZlIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlIHRoZVxuLy8gU3RyaW5nI3JlcGxhY2UgcG9seWZpbGwgdXNlcyAuL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMuanMsXG4vLyB3aGljaCBsb2FkcyB0aGlzIGZpbGUgYmVmb3JlIHBhdGNoaW5nIHRoZSBtZXRob2QuXG52YXIgbmF0aXZlUmVwbGFjZSA9IFN0cmluZy5wcm90b3R5cGUucmVwbGFjZTtcblxudmFyIHBhdGNoZWRFeGVjID0gbmF0aXZlRXhlYztcblxudmFyIFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciByZTEgPSAvYS87XG4gIHZhciByZTIgPSAvYiovZztcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMSwgJ2EnKTtcbiAgbmF0aXZlRXhlYy5jYWxsKHJlMiwgJ2EnKTtcbiAgcmV0dXJuIHJlMS5sYXN0SW5kZXggIT09IDAgfHwgcmUyLmxhc3RJbmRleCAhPT0gMDtcbn0pKCk7XG5cbi8vIG5vbnBhcnRpY2lwYXRpbmcgY2FwdHVyaW5nIGdyb3VwLCBjb3BpZWQgZnJvbSBlczUtc2hpbSdzIFN0cmluZyNzcGxpdCBwYXRjaC5cbnZhciBOUENHX0lOQ0xVREVEID0gLygpPz8vLmV4ZWMoJycpWzFdICE9PSB1bmRlZmluZWQ7XG5cbnZhciBQQVRDSCA9IFVQREFURVNfTEFTVF9JTkRFWF9XUk9ORyB8fCBOUENHX0lOQ0xVREVEO1xuXG5pZiAoUEFUQ0gpIHtcbiAgcGF0Y2hlZEV4ZWMgPSBmdW5jdGlvbiBleGVjKHN0cikge1xuICAgIHZhciByZSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCwgcmVDb3B5LCBtYXRjaCwgaTtcblxuICAgIGlmIChOUENHX0lOQ0xVREVEKSB7XG4gICAgICByZUNvcHkgPSBuZXcgUmVnRXhwKCdeJyArIHJlLnNvdXJjZSArICckKD8hXFxcXHMpJywgcmVnZXhwRmxhZ3MuY2FsbChyZSkpO1xuICAgIH1cbiAgICBpZiAoVVBEQVRFU19MQVNUX0lOREVYX1dST05HKSBsYXN0SW5kZXggPSByZS5sYXN0SW5kZXg7XG5cbiAgICBtYXRjaCA9IG5hdGl2ZUV4ZWMuY2FsbChyZSwgc3RyKTtcblxuICAgIGlmIChVUERBVEVTX0xBU1RfSU5ERVhfV1JPTkcgJiYgbWF0Y2gpIHtcbiAgICAgIHJlLmxhc3RJbmRleCA9IHJlLmdsb2JhbCA/IG1hdGNoLmluZGV4ICsgbWF0Y2hbMF0ubGVuZ3RoIDogbGFzdEluZGV4O1xuICAgIH1cbiAgICBpZiAoTlBDR19JTkNMVURFRCAmJiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPiAxKSB7XG4gICAgICAvLyBGaXggYnJvd3NlcnMgd2hvc2UgYGV4ZWNgIG1ldGhvZHMgZG9uJ3QgY29uc2lzdGVudGx5IHJldHVybiBgdW5kZWZpbmVkYFxuICAgICAgLy8gZm9yIE5QQ0csIGxpa2UgSUU4LiBOT1RFOiBUaGlzIGRvZXNuJyB3b3JrIGZvciAvKC4/KT8vXG4gICAgICBuYXRpdmVSZXBsYWNlLmNhbGwobWF0Y2hbMF0sIHJlQ29weSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgIGlmIChhcmd1bWVudHNbaV0gPT09IHVuZGVmaW5lZCkgbWF0Y2hbaV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiBtYXRjaDtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwYXRjaGVkRXhlYztcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlciBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3Ncbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIGlmICh0aGF0Lmdsb2JhbCkgcmVzdWx0ICs9ICdnJztcbiAgaWYgKHRoYXQuaWdub3JlQ2FzZSkgcmVzdWx0ICs9ICdpJztcbiAgaWYgKHRoYXQubXVsdGlsaW5lKSByZXN1bHQgKz0gJ20nO1xuICBpZiAodGhhdC5kb3RBbGwpIHJlc3VsdCArPSAncyc7XG4gIGlmICh0aGF0LnVuaWNvZGUpIHJlc3VsdCArPSAndSc7XG4gIGlmICh0aGF0LnN0aWNreSkgcmVzdWx0ICs9ICd5JztcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCIvLyBgUmVxdWlyZU9iamVjdENvZXJjaWJsZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZXF1aXJlb2JqZWN0Y29lcmNpYmxlXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT0gdW5kZWZpbmVkKSB0aHJvdyBUeXBlRXJyb3IoXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIiArIGl0KTtcbiAgcmV0dXJuIGl0O1xufTtcbiIsIi8vIGBTYW1lVmFsdWVgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc2FtZXZhbHVlXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgcmV0dXJuIHggPT09IHkgPyB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSA6IHggIT0geCAmJiB5ICE9IHk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICB0cnkge1xuICAgIGhpZGUoZ2xvYmFsLCBrZXksIHZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBnbG9iYWxba2V5XSA9IHZhbHVlO1xuICB9IHJldHVybiB2YWx1ZTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2V0QnVpbHRJbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nZXQtYnVpbHQtaW4nKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoQ09OU1RSVUNUT1JfTkFNRSkge1xuICB2YXIgQ29uc3RydWN0b3IgPSBnZXRCdWlsdEluKENPTlNUUlVDVE9SX05BTUUpO1xuICB2YXIgZGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xuXG4gIGlmIChERVNDUklQVE9SUyAmJiBDb25zdHJ1Y3RvciAmJiAhQ29uc3RydWN0b3JbU1BFQ0lFU10pIHtcbiAgICBkZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgU1BFQ0lFUywge1xuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9XG4gICAgfSk7XG4gIH1cbn07XG4iLCJ2YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFRBRywgU1RBVElDKSB7XG4gIGlmIChpdCAmJiAhaGFzKGl0ID0gU1RBVElDID8gaXQgOiBpdC5wcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoaXQsIFRPX1NUUklOR19UQUcsIHsgY29uZmlndXJhYmxlOiB0cnVlLCB2YWx1ZTogVEFHIH0pO1xuICB9XG59O1xuIiwidmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG5cbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBzZXRHbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LWdsb2JhbCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xuXG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBzZXRHbG9iYWwoU0hBUkVELCB7fSk7XG5cbihtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gIHJldHVybiBzdG9yZVtrZXldIHx8IChzdG9yZVtrZXldID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDoge30pO1xufSkoJ3ZlcnNpb25zJywgW10pLnB1c2goe1xuICB2ZXJzaW9uOiAnMy4xLjMnLFxuICBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gIGNvcHlyaWdodDogJ8KpIDIwMTkgRGVuaXMgUHVzaGthcmV2ICh6bG9pcm9jay5ydSknXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChNRVRIT0RfTkFNRSwgYXJndW1lbnQpIHtcbiAgdmFyIG1ldGhvZCA9IFtdW01FVEhPRF9OQU1FXTtcbiAgcmV0dXJuICFtZXRob2QgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1jYWxsLG5vLXRocm93LWxpdGVyYWxcbiAgICBtZXRob2QuY2FsbChudWxsLCBhcmd1bWVudCB8fCBmdW5jdGlvbiAoKSB7IHRocm93IDE7IH0sIDEpO1xuICB9KTtcbn07XG4iLCJ2YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcblxuLy8gYFNwZWNpZXNDb25zdHJ1Y3RvcmAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zcGVjaWVzY29uc3RydWN0b3Jcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIGRlZmF1bHRDb25zdHJ1Y3Rvcikge1xuICB2YXIgQyA9IGFuT2JqZWN0KE8pLmNvbnN0cnVjdG9yO1xuICB2YXIgUztcbiAgcmV0dXJuIEMgPT09IHVuZGVmaW5lZCB8fCAoUyA9IGFuT2JqZWN0KEMpW1NQRUNJRVNdKSA9PSB1bmRlZmluZWQgPyBkZWZhdWx0Q29uc3RydWN0b3IgOiBhRnVuY3Rpb24oUyk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBjb2RlUG9pbnRBdCwgYXQgfWAgbWV0aG9kcyBpbXBsZW1lbnRhdGlvblxudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChDT05WRVJUX1RPX1NUUklORykge1xuICByZXR1cm4gZnVuY3Rpb24gKCR0aGlzLCBwb3MpIHtcbiAgICB2YXIgUyA9IFN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKCR0aGlzKSk7XG4gICAgdmFyIHBvc2l0aW9uID0gdG9JbnRlZ2VyKHBvcyk7XG4gICAgdmFyIHNpemUgPSBTLmxlbmd0aDtcbiAgICB2YXIgZmlyc3QsIHNlY29uZDtcbiAgICBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IHNpemUpIHJldHVybiBDT05WRVJUX1RPX1NUUklORyA/ICcnIDogdW5kZWZpbmVkO1xuICAgIGZpcnN0ID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uKTtcbiAgICByZXR1cm4gZmlyc3QgPCAweEQ4MDAgfHwgZmlyc3QgPiAweERCRkYgfHwgcG9zaXRpb24gKyAxID09PSBzaXplXG4gICAgICB8fCAoc2Vjb25kID0gUy5jaGFyQ29kZUF0KHBvc2l0aW9uICsgMSkpIDwgMHhEQzAwIHx8IHNlY29uZCA+IDB4REZGRlxuICAgICAgICA/IENPTlZFUlRfVE9fU1RSSU5HID8gUy5jaGFyQXQocG9zaXRpb24pIDogZmlyc3RcbiAgICAgICAgOiBDT05WRVJUX1RPX1NUUklORyA/IFMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgMikgOiAoZmlyc3QgLSAweEQ4MDAgPDwgMTApICsgKHNlY29uZCAtIDB4REMwMCkgKyAweDEwMDAwO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5jb2RlcG9pbnRhdFxuICBjb2RlQXQ6IGNyZWF0ZU1ldGhvZChmYWxzZSksXG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLmF0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21hdGhpYXNieW5lbnMvU3RyaW5nLnByb3RvdHlwZS5hdFxuICBjaGFyQXQ6IGNyZWF0ZU1ldGhvZCh0cnVlKVxufTtcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1wYWQtc3RhcnQtZW5kXG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG52YXIgY2VpbCA9IE1hdGguY2VpbDtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUueyBwYWRTdGFydCwgcGFkRW5kIH1gIG1ldGhvZHMgaW1wbGVtZW50YXRpb25cbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoSVNfRU5EKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIG1heExlbmd0aCwgZmlsbFN0cmluZykge1xuICAgIHZhciBTID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUoJHRoaXMpKTtcbiAgICB2YXIgc3RyaW5nTGVuZ3RoID0gUy5sZW5ndGg7XG4gICAgdmFyIGZpbGxTdHIgPSBmaWxsU3RyaW5nID09PSB1bmRlZmluZWQgPyAnICcgOiBTdHJpbmcoZmlsbFN0cmluZyk7XG4gICAgdmFyIGludE1heExlbmd0aCA9IHRvTGVuZ3RoKG1heExlbmd0aCk7XG4gICAgdmFyIGZpbGxMZW4sIHN0cmluZ0ZpbGxlcjtcbiAgICBpZiAoaW50TWF4TGVuZ3RoIDw9IHN0cmluZ0xlbmd0aCB8fCBmaWxsU3RyID09ICcnKSByZXR1cm4gUztcbiAgICBmaWxsTGVuID0gaW50TWF4TGVuZ3RoIC0gc3RyaW5nTGVuZ3RoO1xuICAgIHN0cmluZ0ZpbGxlciA9IHJlcGVhdC5jYWxsKGZpbGxTdHIsIGNlaWwoZmlsbExlbiAvIGZpbGxTdHIubGVuZ3RoKSk7XG4gICAgaWYgKHN0cmluZ0ZpbGxlci5sZW5ndGggPiBmaWxsTGVuKSBzdHJpbmdGaWxsZXIgPSBzdHJpbmdGaWxsZXIuc2xpY2UoMCwgZmlsbExlbik7XG4gICAgcmV0dXJuIElTX0VORCA/IFMgKyBzdHJpbmdGaWxsZXIgOiBzdHJpbmdGaWxsZXIgKyBTO1xuICB9O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIC8vIGBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5wYWRzdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKGZhbHNlKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUucGFkRW5kYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5wYWRlbmRcbiAgZW5kOiBjcmVhdGVNZXRob2QodHJ1ZSlcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWludGVnZXInKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5yZXBlYXRgIG1ldGhvZCBpbXBsZW1lbnRhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBlYXRcbm1vZHVsZS5leHBvcnRzID0gJycucmVwZWF0IHx8IGZ1bmN0aW9uIHJlcGVhdChjb3VudCkge1xuICB2YXIgc3RyID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICB2YXIgcmVzdWx0ID0gJyc7XG4gIHZhciBuID0gdG9JbnRlZ2VyKGNvdW50KTtcbiAgaWYgKG4gPCAwIHx8IG4gPT0gSW5maW5pdHkpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIG51bWJlciBvZiByZXBldGl0aW9ucycpO1xuICBmb3IgKDtuID4gMDsgKG4gPj4+PSAxKSAmJiAoc3RyICs9IHN0cikpIGlmIChuICYgMSkgcmVzdWx0ICs9IHN0cjtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciB3aGl0ZXNwYWNlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93aGl0ZXNwYWNlcycpO1xuXG52YXIgd2hpdGVzcGFjZSA9ICdbJyArIHdoaXRlc3BhY2VzICsgJ10nO1xudmFyIGx0cmltID0gUmVnRXhwKCdeJyArIHdoaXRlc3BhY2UgKyB3aGl0ZXNwYWNlICsgJyonKTtcbnZhciBydHJpbSA9IFJlZ0V4cCh3aGl0ZXNwYWNlICsgd2hpdGVzcGFjZSArICcqJCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW0sIHRyaW1TdGFydCwgdHJpbUVuZCwgdHJpbUxlZnQsIHRyaW1SaWdodCB9YCBtZXRob2RzIGltcGxlbWVudGF0aW9uXG52YXIgY3JlYXRlTWV0aG9kID0gZnVuY3Rpb24gKFRZUEUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgkdGhpcykge1xuICAgIHZhciBzdHJpbmcgPSBTdHJpbmcocmVxdWlyZU9iamVjdENvZXJjaWJsZSgkdGhpcykpO1xuICAgIGlmIChUWVBFICYgMSkgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UobHRyaW0sICcnKTtcbiAgICBpZiAoVFlQRSAmIDIpIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJ0cmltLCAnJyk7XG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1MZWZ0LCB0cmltU3RhcnQgfWAgbWV0aG9kc1xuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnRyaW1zdGFydFxuICBzdGFydDogY3JlYXRlTWV0aG9kKDEpLFxuICAvLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1SaWdodCwgdHJpbUVuZCB9YCBtZXRob2RzXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbWVuZFxuICBlbmQ6IGNyZWF0ZU1ldGhvZCgyKSxcbiAgLy8gYFN0cmluZy5wcm90b3R5cGUudHJpbWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuICB0cmltOiBjcmVhdGVNZXRob2QoMylcbn07XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYmluZC1jb250ZXh0Jyk7XG52YXIgaHRtbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9odG1sJyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kb2N1bWVudC1jcmVhdGUtZWxlbWVudCcpO1xuXG52YXIgbG9jYXRpb24gPSBnbG9iYWwubG9jYXRpb247XG52YXIgc2V0ID0gZ2xvYmFsLnNldEltbWVkaWF0ZTtcbnZhciBjbGVhciA9IGdsb2JhbC5jbGVhckltbWVkaWF0ZTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgTWVzc2FnZUNoYW5uZWwgPSBnbG9iYWwuTWVzc2FnZUNoYW5uZWw7XG52YXIgRGlzcGF0Y2ggPSBnbG9iYWwuRGlzcGF0Y2g7XG52YXIgY291bnRlciA9IDA7XG52YXIgcXVldWUgPSB7fTtcbnZhciBPTlJFQURZU1RBVEVDSEFOR0UgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbnZhciBkZWZlciwgY2hhbm5lbCwgcG9ydDtcblxudmFyIHJ1biA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChxdWV1ZS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICB2YXIgZm4gPSBxdWV1ZVtpZF07XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgICBmbigpO1xuICB9XG59O1xuXG52YXIgcnVubmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcnVuKGlkKTtcbiAgfTtcbn07XG5cbnZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudCkge1xuICBydW4oZXZlbnQuZGF0YSk7XG59O1xuXG52YXIgcG9zdCA9IGZ1bmN0aW9uIChpZCkge1xuICAvLyBvbGQgZW5naW5lcyBoYXZlIG5vdCBsb2NhdGlvbi5vcmlnaW5cbiAgZ2xvYmFsLnBvc3RNZXNzYWdlKGlkICsgJycsIGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QpO1xufTtcblxuLy8gTm9kZS5qcyAwLjkrICYgSUUxMCsgaGFzIHNldEltbWVkaWF0ZSwgb3RoZXJ3aXNlOlxuaWYgKCFzZXQgfHwgIWNsZWFyKSB7XG4gIHNldCA9IGZ1bmN0aW9uIHNldEltbWVkaWF0ZShmbikge1xuICAgIHZhciBhcmdzID0gW107XG4gICAgdmFyIGkgPSAxO1xuICAgIHdoaWxlIChhcmd1bWVudHMubGVuZ3RoID4gaSkgYXJncy5wdXNoKGFyZ3VtZW50c1tpKytdKTtcbiAgICBxdWV1ZVsrK2NvdW50ZXJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW5ldy1mdW5jXG4gICAgICAodHlwZW9mIGZuID09ICdmdW5jdGlvbicgPyBmbiA6IEZ1bmN0aW9uKGZuKSkuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICB9O1xuICAgIGRlZmVyKGNvdW50ZXIpO1xuICAgIHJldHVybiBjb3VudGVyO1xuICB9O1xuICBjbGVhciA9IGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGlkKSB7XG4gICAgZGVsZXRlIHF1ZXVlW2lkXTtcbiAgfTtcbiAgLy8gTm9kZS5qcyAwLjgtXG4gIGlmIChjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKHJ1bm5lcihpZCkpO1xuICAgIH07XG4gIC8vIFNwaGVyZSAoSlMgZ2FtZSBlbmdpbmUpIERpc3BhdGNoIEFQSVxuICB9IGVsc2UgaWYgKERpc3BhdGNoICYmIERpc3BhdGNoLm5vdykge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBEaXNwYXRjaC5ub3cocnVubmVyKGlkKSk7XG4gICAgfTtcbiAgLy8gQnJvd3NlcnMgd2l0aCBNZXNzYWdlQ2hhbm5lbCwgaW5jbHVkZXMgV2ViV29ya2Vyc1xuICB9IGVsc2UgaWYgKE1lc3NhZ2VDaGFubmVsKSB7XG4gICAgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICAgIHBvcnQgPSBjaGFubmVsLnBvcnQyO1xuICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gbGlzdGVuZXI7XG4gICAgZGVmZXIgPSBiaW5kKHBvcnQucG9zdE1lc3NhZ2UsIHBvcnQsIDEpO1xuICAvLyBCcm93c2VycyB3aXRoIHBvc3RNZXNzYWdlLCBza2lwIFdlYldvcmtlcnNcbiAgLy8gSUU4IGhhcyBwb3N0TWVzc2FnZSwgYnV0IGl0J3Mgc3luYyAmIHR5cGVvZiBpdHMgcG9zdE1lc3NhZ2UgaXMgJ29iamVjdCdcbiAgfSBlbHNlIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lciAmJiB0eXBlb2YgcG9zdE1lc3NhZ2UgPT0gJ2Z1bmN0aW9uJyAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMgJiYgIWZhaWxzKHBvc3QpKSB7XG4gICAgZGVmZXIgPSBwb3N0O1xuICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgbGlzdGVuZXIsIGZhbHNlKTtcbiAgLy8gSUU4LVxuICB9IGVsc2UgaWYgKE9OUkVBRFlTVEFURUNIQU5HRSBpbiBjcmVhdGVFbGVtZW50KCdzY3JpcHQnKSkge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBodG1sLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpKVtPTlJFQURZU1RBVEVDSEFOR0VdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBodG1sLnJlbW92ZUNoaWxkKHRoaXMpO1xuICAgICAgICBydW4oaWQpO1xuICAgICAgfTtcbiAgICB9O1xuICAvLyBSZXN0IG9sZCBicm93c2Vyc1xuICB9IGVsc2Uge1xuICAgIGRlZmVyID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICBzZXRUaW1lb3V0KHJ1bm5lcihpZCksIDApO1xuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHNldDogc2V0LFxuICBjbGVhcjogY2xlYXJcbn07XG4iLCJ2YXIgY2xhc3NvZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jbGFzc29mLXJhdycpO1xuXG4vLyBgdGhpc051bWJlclZhbHVlYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRoaXNudW1iZXJ2YWx1ZVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPSAnbnVtYmVyJyAmJiBjbGFzc29mKHZhbHVlKSAhPSAnTnVtYmVyJykge1xuICAgIHRocm93IFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbiAgfVxuICByZXR1cm4gK3ZhbHVlO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG52YXIgbWF4ID0gTWF0aC5tYXg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIEhlbHBlciBmb3IgYSBwb3B1bGFyIHJlcGVhdGluZyBjYXNlIG9mIHRoZSBzcGVjOlxuLy8gTGV0IGludGVnZXIgYmUgPyBUb0ludGVnZXIoaW5kZXgpLlxuLy8gSWYgaW50ZWdlciA8IDAsIGxldCByZXN1bHQgYmUgbWF4KChsZW5ndGggKyBpbnRlZ2VyKSwgMCk7IGVsc2UgbGV0IHJlc3VsdCBiZSBtaW4obGVuZ3RoLCBsZW5ndGgpLlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaW5kZXgsIGxlbmd0aCkge1xuICB2YXIgaW50ZWdlciA9IHRvSW50ZWdlcihpbmRleCk7XG4gIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgVG9JbmRleGAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b2luZGV4XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICBpZiAoaXQgPT09IHVuZGVmaW5lZCkgcmV0dXJuIDA7XG4gIHZhciBudW1iZXIgPSB0b0ludGVnZXIoaXQpO1xuICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgobnVtYmVyKTtcbiAgaWYgKG51bWJlciAhPT0gbGVuZ3RoKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBsZW5ndGggb3IgaW5kZXgnKTtcbiAgcmV0dXJuIGxlbmd0aDtcbn07XG4iLCIvLyB0b09iamVjdCB3aXRoIGZhbGxiYWNrIGZvciBub24tYXJyYXktbGlrZSBFUzMgc3RyaW5nc1xudmFyIEluZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5kZXhlZC1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gSW5kZXhlZE9iamVjdChyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKGl0KSk7XG59O1xuIiwidmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgVG9JbnRlZ2VyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvaW50ZWdlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgcmV0dXJuIGlzTmFOKGFyZ3VtZW50ID0gK2FyZ3VtZW50KSA/IDAgOiAoYXJndW1lbnQgPiAwID8gZmxvb3IgOiBjZWlsKShhcmd1bWVudCk7XG59O1xuIiwidmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG5cbnZhciBtaW4gPSBNYXRoLm1pbjtcblxuLy8gYFRvTGVuZ3RoYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbGVuZ3RoXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuICByZXR1cm4gYXJndW1lbnQgPiAwID8gbWluKHRvSW50ZWdlcihhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDsgLy8gMiAqKiA1MyAtIDEgPT0gOTAwNzE5OTI1NDc0MDk5MVxufTtcbiIsInZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xuXG4vLyBgVG9PYmplY3RgIGFic3RyYWN0IG9wZXJhdGlvblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdG9vYmplY3Rcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gIHJldHVybiBPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcbiIsInZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCwgQllURVMpIHtcbiAgdmFyIG9mZnNldCA9IHRvSW50ZWdlcihpdCk7XG4gIGlmIChvZmZzZXQgPCAwIHx8IG9mZnNldCAlIEJZVEVTKSB0aHJvdyBSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiAgcmV0dXJuIG9mZnNldDtcbn07XG4iLCJ2YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbi8vIGBUb1ByaW1pdGl2ZWAgYWJzdHJhY3Qgb3BlcmF0aW9uXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10b3ByaW1pdGl2ZVxuLy8gaW5zdGVhZCBvZiB0aGUgRVM2IHNwZWMgdmVyc2lvbiwgd2UgZGlkbid0IGltcGxlbWVudCBAQHRvUHJpbWl0aXZlIGNhc2Vcbi8vIGFuZCB0aGUgc2Vjb25kIGFyZ3VtZW50IC0gZmxhZyAtIHByZWZlcnJlZCB0eXBlIGlzIGEgc3RyaW5nXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgUFJFRkVSUkVEX1NUUklORykge1xuICBpZiAoIWlzT2JqZWN0KGlucHV0KSkgcmV0dXJuIGlucHV0O1xuICB2YXIgZm4sIHZhbDtcbiAgaWYgKFBSRUZFUlJFRF9TVFJJTkcgJiYgdHlwZW9mIChmbiA9IGlucHV0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIGlmICh0eXBlb2YgKGZuID0gaW5wdXQudmFsdWVPZikgPT0gJ2Z1bmN0aW9uJyAmJiAhaXNPYmplY3QodmFsID0gZm4uY2FsbChpbnB1dCkpKSByZXR1cm4gdmFsO1xuICBpZiAoIVBSRUZFUlJFRF9TVFJJTkcgJiYgdHlwZW9mIChmbiA9IGlucHV0LnRvU3RyaW5nKSA9PSAnZnVuY3Rpb24nICYmICFpc09iamVjdCh2YWwgPSBmbi5jYWxsKGlucHV0KSkpIHJldHVybiB2YWw7XG4gIHRocm93IFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgb2JqZWN0IHRvIHByaW1pdGl2ZSB2YWx1ZVwiKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5cy1jb25zdHJ1Y3RvcnMtcmVxdWlyZXMtd3JhcHBlcnMnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBBcnJheUJ1ZmZlck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXInKTtcbnZhciBhbkluc3RhbmNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLWluc3RhbmNlJyk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgaGlkZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRlJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgdG9JbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleCcpO1xudmFyIHRvT2Zmc2V0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9mZnNldCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBjcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIHNldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1zZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgdHlwZWRBcnJheUZyb20gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktZnJvbScpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xuXG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0O1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBuYXRpdmVEZWZpbmVQcm9wZXJ0eSA9IGRlZmluZVByb3BlcnR5TW9kdWxlLmY7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xudmFyIFJhbmdlRXJyb3IgPSBnbG9iYWwuUmFuZ2VFcnJvcjtcbnZhciBBcnJheUJ1ZmZlciA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xudmFyIERhdGFWaWV3ID0gQXJyYXlCdWZmZXJNb2R1bGUuRGF0YVZpZXc7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyA9IEFycmF5QnVmZmVyVmlld0NvcmUuTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUztcbnZhciBUWVBFRF9BUlJBWV9UQUcgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlRZUEVEX0FSUkFZX1RBRztcbnZhciBUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5UeXBlZEFycmF5O1xudmFyIFR5cGVkQXJyYXlQcm90b3R5cGUgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXlQcm90b3R5cGU7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBpc1R5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmlzVHlwZWRBcnJheTtcbnZhciBCWVRFU19QRVJfRUxFTUVOVCA9ICdCWVRFU19QRVJfRUxFTUVOVCc7XG52YXIgV1JPTkdfTEVOR1RIID0gJ1dyb25nIGxlbmd0aCc7XG5cbnZhciBmcm9tTGlzdCA9IGZ1bmN0aW9uIChDLCBsaXN0KSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgdmFyIHJlc3VsdCA9IG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihDKSkobGVuZ3RoKTtcbiAgd2hpbGUgKGxlbmd0aCA+IGluZGV4KSByZXN1bHRbaW5kZXhdID0gbGlzdFtpbmRleCsrXTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBhZGRHZXR0ZXIgPSBmdW5jdGlvbiAoaXQsIGtleSkge1xuICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShpdCwga2V5LCB7IGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpW2tleV07XG4gIH0gfSk7XG59O1xuXG52YXIgaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIga2xhc3M7XG4gIHJldHVybiBpdCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IChrbGFzcyA9IGNsYXNzb2YoaXQpKSA9PSAnQXJyYXlCdWZmZXInIHx8IGtsYXNzID09ICdTaGFyZWRBcnJheUJ1ZmZlcic7XG59O1xuXG52YXIgaXNUeXBlZEFycmF5SW5kZXggPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgcmV0dXJuIGlzVHlwZWRBcnJheSh0YXJnZXQpXG4gICAgJiYgdHlwZW9mIGtleSAhPSAnc3ltYm9sJ1xuICAgICYmIGtleSBpbiB0YXJnZXRcbiAgICAmJiBTdHJpbmcoK2tleSkgPT0gU3RyaW5nKGtleSk7XG59O1xuXG52YXIgd3JhcHBlZEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkge1xuICByZXR1cm4gaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgID8gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDIsIHRhcmdldFtrZXldKVxuICAgIDogbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KTtcbn07XG5cbnZhciB3cmFwcGVkRGVmaW5lUHJvcGVydHkgPSBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgZGVzY3JpcHRvcikge1xuICBpZiAoaXNUeXBlZEFycmF5SW5kZXgodGFyZ2V0LCBrZXkgPSB0b1ByaW1pdGl2ZShrZXksIHRydWUpKVxuICAgICYmIGlzT2JqZWN0KGRlc2NyaXB0b3IpXG4gICAgJiYgaGFzKGRlc2NyaXB0b3IsICd2YWx1ZScpXG4gICAgJiYgIWhhcyhkZXNjcmlwdG9yLCAnZ2V0JylcbiAgICAmJiAhaGFzKGRlc2NyaXB0b3IsICdzZXQnKVxuICAgIC8vIFRPRE86IGFkZCB2YWxpZGF0aW9uIGRlc2NyaXB0b3Igdy9vIGNhbGxpbmcgYWNjZXNzb3JzXG4gICAgJiYgIWRlc2NyaXB0b3IuY29uZmlndXJhYmxlXG4gICAgJiYgKCFoYXMoZGVzY3JpcHRvciwgJ3dyaXRhYmxlJykgfHwgZGVzY3JpcHRvci53cml0YWJsZSlcbiAgICAmJiAoIWhhcyhkZXNjcmlwdG9yLCAnZW51bWVyYWJsZScpIHx8IGRlc2NyaXB0b3IuZW51bWVyYWJsZSlcbiAgKSB7XG4gICAgdGFyZ2V0W2tleV0gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICAgIHJldHVybiB0YXJnZXQ7XG4gIH0gcmV0dXJuIG5hdGl2ZURlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBkZXNjcmlwdG9yKTtcbn07XG5cbmlmIChERVNDUklQVE9SUykge1xuICBpZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpIHtcbiAgICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9IHdyYXBwZWRHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgZGVmaW5lUHJvcGVydHlNb2R1bGUuZiA9IHdyYXBwZWREZWZpbmVQcm9wZXJ0eTtcbiAgICBhZGRHZXR0ZXIoVHlwZWRBcnJheVByb3RvdHlwZSwgJ2J1ZmZlcicpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZU9mZnNldCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcpO1xuICAgIGFkZEdldHRlcihUeXBlZEFycmF5UHJvdG90eXBlLCAnbGVuZ3RoJyk7XG4gIH1cblxuICAkKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB9LCB7XG4gICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiB3cmFwcGVkR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLFxuICAgIGRlZmluZVByb3BlcnR5OiB3cmFwcGVkRGVmaW5lUHJvcGVydHlcbiAgfSk7XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRZUEUsIEJZVEVTLCB3cmFwcGVyLCBDTEFNUEVEKSB7XG4gICAgdmFyIENPTlNUUlVDVE9SX05BTUUgPSBUWVBFICsgKENMQU1QRUQgPyAnQ2xhbXBlZCcgOiAnJykgKyAnQXJyYXknO1xuICAgIHZhciBHRVRURVIgPSAnZ2V0JyArIFRZUEU7XG4gICAgdmFyIFNFVFRFUiA9ICdzZXQnICsgVFlQRTtcbiAgICB2YXIgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0NPTlNUUlVDVE9SX05BTUVdO1xuICAgIHZhciBUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSA9IFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlO1xuICAgIHZhciBleHBvcnRlZCA9IHt9O1xuXG4gICAgdmFyIGdldHRlciA9IGZ1bmN0aW9uICh0aGF0LCBpbmRleCkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgcmV0dXJuIGRhdGEudmlld1tHRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHRydWUpO1xuICAgIH07XG5cbiAgICB2YXIgc2V0dGVyID0gZnVuY3Rpb24gKHRoYXQsIGluZGV4LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRJbnRlcm5hbFN0YXRlKHRoYXQpO1xuICAgICAgaWYgKENMQU1QRUQpIHZhbHVlID0gKHZhbHVlID0gcm91bmQodmFsdWUpKSA8IDAgPyAwIDogdmFsdWUgPiAweEZGID8gMHhGRiA6IHZhbHVlICYgMHhGRjtcbiAgICAgIGRhdGEudmlld1tTRVRURVJdKGluZGV4ICogQllURVMgKyBkYXRhLmJ5dGVPZmZzZXQsIHZhbHVlLCB0cnVlKTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZEVsZW1lbnQgPSBmdW5jdGlvbiAodGhhdCwgaW5kZXgpIHtcbiAgICAgIG5hdGl2ZURlZmluZVByb3BlcnR5KHRoYXQsIGluZGV4LCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBnZXR0ZXIodGhpcywgaW5kZXgpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBzZXR0ZXIodGhpcywgaW5kZXgsIHZhbHVlKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUykge1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gd3JhcHBlcihmdW5jdGlvbiAodGhhdCwgZGF0YSwgb2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UodGhhdCwgVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBDT05TVFJVQ1RPUl9OQU1FKTtcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIGJ5dGVPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgYnVmZmVyLCBieXRlTGVuZ3RoLCBsZW5ndGg7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICBsZW5ndGggPSB0b0luZGV4KGRhdGEpO1xuICAgICAgICAgIGJ5dGVMZW5ndGggPSBsZW5ndGggKiBCWVRFUztcbiAgICAgICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkge1xuICAgICAgICAgIGJ1ZmZlciA9IGRhdGE7XG4gICAgICAgICAgYnl0ZU9mZnNldCA9IHRvT2Zmc2V0KG9mZnNldCwgQllURVMpO1xuICAgICAgICAgIHZhciAkbGVuID0gZGF0YS5ieXRlTGVuZ3RoO1xuICAgICAgICAgIGlmICgkbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgkbGVuICUgQllURVMpIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICAgIGJ5dGVMZW5ndGggPSAkbGVuIC0gYnl0ZU9mZnNldDtcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoIDwgMCkgdGhyb3cgUmFuZ2VFcnJvcihXUk9OR19MRU5HVEgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBieXRlTGVuZ3RoID0gdG9MZW5ndGgoJGxlbmd0aCkgKiBCWVRFUztcbiAgICAgICAgICAgIGlmIChieXRlTGVuZ3RoICsgYnl0ZU9mZnNldCA+ICRsZW4pIHRocm93IFJhbmdlRXJyb3IoV1JPTkdfTEVOR1RIKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoID0gYnl0ZUxlbmd0aCAvIEJZVEVTO1xuICAgICAgICB9IGVsc2UgaWYgKGlzVHlwZWRBcnJheShkYXRhKSkge1xuICAgICAgICAgIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB0eXBlZEFycmF5RnJvbS5jYWxsKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgICAgYnl0ZU9mZnNldDogYnl0ZU9mZnNldCxcbiAgICAgICAgICBieXRlTGVuZ3RoOiBieXRlTGVuZ3RoLFxuICAgICAgICAgIGxlbmd0aDogbGVuZ3RoLFxuICAgICAgICAgIHZpZXc6IG5ldyBEYXRhVmlldyhidWZmZXIpXG4gICAgICAgIH0pO1xuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIGFkZEVsZW1lbnQodGhhdCwgaW5kZXgrKyk7XG4gICAgICB9KTtcblxuICAgICAgaWYgKHNldFByb3RvdHlwZU9mKSBzZXRQcm90b3R5cGVPZihUeXBlZEFycmF5Q29uc3RydWN0b3IsIFR5cGVkQXJyYXkpO1xuICAgICAgVHlwZWRBcnJheUNvbnN0cnVjdG9yUHJvdG90eXBlID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZShUeXBlZEFycmF5UHJvdG90eXBlKTtcbiAgICB9IGVsc2UgaWYgKFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMpIHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHdyYXBwZXIoZnVuY3Rpb24gKGR1bW15LCBkYXRhLCB0eXBlZEFycmF5T2Zmc2V0LCAkbGVuZ3RoKSB7XG4gICAgICAgIGFuSW5zdGFuY2UoZHVtbXksIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQ09OU1RSVUNUT1JfTkFNRSk7XG4gICAgICAgIGlmICghaXNPYmplY3QoZGF0YSkpIHJldHVybiBuZXcgTmF0aXZlVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRvSW5kZXgoZGF0YSkpO1xuICAgICAgICBpZiAoaXNBcnJheUJ1ZmZlcihkYXRhKSkgcmV0dXJuICRsZW5ndGggIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUyksICRsZW5ndGgpXG4gICAgICAgICAgOiB0eXBlZEFycmF5T2Zmc2V0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gbmV3IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihkYXRhLCB0b09mZnNldCh0eXBlZEFycmF5T2Zmc2V0LCBCWVRFUykpXG4gICAgICAgICAgICA6IG5ldyBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IoZGF0YSk7XG4gICAgICAgIGlmIChpc1R5cGVkQXJyYXkoZGF0YSkpIHJldHVybiBmcm9tTGlzdChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgICByZXR1cm4gdHlwZWRBcnJheUZyb20uY2FsbChUeXBlZEFycmF5Q29uc3RydWN0b3IsIGRhdGEpO1xuICAgICAgfSk7XG5cbiAgICAgIGlmIChzZXRQcm90b3R5cGVPZikgc2V0UHJvdG90eXBlT2YoVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBUeXBlZEFycmF5KTtcbiAgICAgIGZvckVhY2goZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3IpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICghKGtleSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwga2V5LCBOYXRpdmVUeXBlZEFycmF5Q29uc3RydWN0b3Jba2V5XSk7XG4gICAgICB9KTtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGU7XG4gICAgfVxuXG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZS5jb25zdHJ1Y3RvciAhPT0gVHlwZWRBcnJheUNvbnN0cnVjdG9yKSB7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgVHlwZWRBcnJheUNvbnN0cnVjdG9yKTtcbiAgICB9XG5cbiAgICBpZiAoVFlQRURfQVJSQVlfVEFHKSBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgVFlQRURfQVJSQVlfVEFHLCBDT05TVFJVQ1RPUl9OQU1FKTtcblxuICAgIGV4cG9ydGVkW0NPTlNUUlVDVE9SX05BTUVdID0gVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG4gICAgJCh7XG4gICAgICBnbG9iYWw6IHRydWUsIGZvcmNlZDogVHlwZWRBcnJheUNvbnN0cnVjdG9yICE9IE5hdGl2ZVR5cGVkQXJyYXlDb25zdHJ1Y3Rvciwgc2hhbTogIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1NcbiAgICB9LCBleHBvcnRlZCk7XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3IpKSB7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBpZiAoIShCWVRFU19QRVJfRUxFTUVOVCBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JQcm90b3R5cGUpKSB7XG4gICAgICBoaWRlKFR5cGVkQXJyYXlDb25zdHJ1Y3RvclByb3RvdHlwZSwgQllURVNfUEVSX0VMRU1FTlQsIEJZVEVTKTtcbiAgICB9XG5cbiAgICBzZXRTcGVjaWVzKENPTlNUUlVDVE9SX05BTUUpO1xuICB9O1xufSBlbHNlIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuIiwidmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciBpc0FycmF5SXRlcmF0b3JNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXktaXRlcmF0b3ItbWV0aG9kJyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9iaW5kLWNvbnRleHQnKTtcbnZhciBhVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKS5hVHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZyb20oc291cmNlIC8qICwgbWFwZm4sIHRoaXNBcmcgKi8pIHtcbiAgdmFyIE8gPSB0b09iamVjdChzb3VyY2UpO1xuICB2YXIgYXJndW1lbnRzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyIG1hcGZuID0gYXJndW1lbnRzTGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgdmFyIG1hcHBpbmcgPSBtYXBmbiAhPT0gdW5kZWZpbmVkO1xuICB2YXIgaXRlcmF0b3JNZXRob2QgPSBnZXRJdGVyYXRvck1ldGhvZChPKTtcbiAgdmFyIGksIGxlbmd0aCwgcmVzdWx0LCBzdGVwLCBpdGVyYXRvcjtcbiAgaWYgKGl0ZXJhdG9yTWV0aG9kICE9IHVuZGVmaW5lZCAmJiAhaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJhdG9yTWV0aG9kKSkge1xuICAgIGl0ZXJhdG9yID0gaXRlcmF0b3JNZXRob2QuY2FsbChPKTtcbiAgICBPID0gW107XG4gICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgTy5wdXNoKHN0ZXAudmFsdWUpO1xuICAgIH1cbiAgfVxuICBpZiAobWFwcGluZyAmJiBhcmd1bWVudHNMZW5ndGggPiAyKSB7XG4gICAgbWFwZm4gPSBiaW5kKG1hcGZuLCBhcmd1bWVudHNbMl0sIDIpO1xuICB9XG4gIGxlbmd0aCA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRoaXMpKShsZW5ndGgpO1xuICBmb3IgKGkgPSAwOyBsZW5ndGggPiBpOyBpKyspIHtcbiAgICByZXN1bHRbaV0gPSBtYXBwaW5nID8gbWFwZm4oT1tpXSwgaSkgOiBPW2ldO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG5cbnZhciBBcnJheUJ1ZmZlciA9IGdsb2JhbC5BcnJheUJ1ZmZlcjtcbnZhciBJbnQ4QXJyYXkgPSBnbG9iYWwuSW50OEFycmF5O1xuXG5tb2R1bGUuZXhwb3J0cyA9ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIEludDhBcnJheSgxKTtcbn0pIHx8ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIG5ldyBJbnQ4QXJyYXkoLTEpO1xufSkgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgbmV3IEludDhBcnJheSgpO1xuICBuZXcgSW50OEFycmF5KG51bGwpO1xuICBuZXcgSW50OEFycmF5KDEuNSk7XG4gIG5ldyBJbnQ4QXJyYXkoaXRlcmFibGUpO1xufSwgdHJ1ZSkgfHwgZmFpbHMoZnVuY3Rpb24gKCkge1xuICAvLyBTYWZhcmkgMTEgYnVnXG4gIHJldHVybiBuZXcgSW50OEFycmF5KG5ldyBBcnJheUJ1ZmZlcigyKSwgMSwgdW5kZWZpbmVkKS5sZW5ndGggIT09IDE7XG59KTtcbiIsInZhciBpZCA9IDA7XG52YXIgcG9zdGZpeCA9IE1hdGgucmFuZG9tKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSkge1xuICByZXR1cm4gJ1N5bWJvbCgnICsgU3RyaW5nKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArICgrK2lkICsgcG9zdGZpeCkudG9TdHJpbmcoMzYpO1xufTtcbiIsInZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ25hdmlnYXRvcicsICd1c2VyQWdlbnQnKSB8fCAnJztcbiIsIi8vIGh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzL2lzc3Vlcy8yODBcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlci1hZ2VudCcpO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgdW5pY29ybi9uby11bnNhZmUtcmVnZXhcbm1vZHVsZS5leHBvcnRzID0gL1ZlcnNpb25cXC8xMFxcLlxcZCsoXFwuXFxkKyk/KCBNb2JpbGVcXC9cXHcrKT8gU2FmYXJpXFwvLy50ZXN0KHVzZXJBZ2VudCk7XG4iLCJ2YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHNoYXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQnKTtcbnZhciB1aWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdWlkJyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9uYXRpdmUtc3ltYm9sJyk7XG5cbnZhciBTeW1ib2wgPSBnbG9iYWwuU3ltYm9sO1xudmFyIHN0b3JlID0gc2hhcmVkKCd3a3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gc3RvcmVbbmFtZV0gfHwgKHN0b3JlW25hbWVdID0gTkFUSVZFX1NZTUJPTCAmJiBTeW1ib2xbbmFtZV1cbiAgICB8fCAoTkFUSVZFX1NZTUJPTCA/IFN5bWJvbCA6IHVpZCkoJ1N5bWJvbC4nICsgbmFtZSkpO1xufTtcbiIsIi8vIGEgc3RyaW5nIG9mIGFsbCB2YWxpZCB1bmljb2RlIHdoaXRlc3BhY2VzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxubW9kdWxlLmV4cG9ydHMgPSAnXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MzAwMFxcdTIwMjhcXHUyMDI5XFx1RkVGRic7XG4iLCJleHBvcnRzLmYgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBhcnJheUJ1ZmZlck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXInKTtcbnZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG5cbnZhciBBUlJBWV9CVUZGRVIgPSAnQXJyYXlCdWZmZXInO1xudmFyIEFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXJNb2R1bGVbQVJSQVlfQlVGRkVSXTtcbnZhciBOYXRpdmVBcnJheUJ1ZmZlciA9IGdsb2JhbFtBUlJBWV9CVUZGRVJdO1xuXG4vLyBgQXJyYXlCdWZmZXJgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheWJ1ZmZlci1jb25zdHJ1Y3RvclxuJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBOYXRpdmVBcnJheUJ1ZmZlciAhPT0gQXJyYXlCdWZmZXIgfSwge1xuICBBcnJheUJ1ZmZlcjogQXJyYXlCdWZmZXJcbn0pO1xuXG5zZXRTcGVjaWVzKEFSUkFZX0JVRkZFUik7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcblxudmFyIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLk5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1M7XG5cbi8vIGBBcnJheUJ1ZmZlci5pc1ZpZXdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlidWZmZXIuaXN2aWV3XG4kKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTIH0sIHtcbiAgaXNWaWV3OiBBcnJheUJ1ZmZlclZpZXdDb3JlLmlzVmlld1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIEFycmF5QnVmZmVyTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlcicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciBBcnJheUJ1ZmZlciA9IEFycmF5QnVmZmVyTW9kdWxlLkFycmF5QnVmZmVyO1xudmFyIERhdGFWaWV3ID0gQXJyYXlCdWZmZXJNb2R1bGUuRGF0YVZpZXc7XG52YXIgbmF0aXZlQXJyYXlCdWZmZXJTbGljZSA9IEFycmF5QnVmZmVyLnByb3RvdHlwZS5zbGljZTtcblxudmFyIElOQ09SUkVDVF9TTElDRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICFuZXcgQXJyYXlCdWZmZXIoMikuc2xpY2UoMSwgdW5kZWZpbmVkKS5ieXRlTGVuZ3RoO1xufSk7XG5cbi8vIGBBcnJheUJ1ZmZlci5wcm90b3R5cGUuc2xpY2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXlidWZmZXIucHJvdG90eXBlLnNsaWNlXG4kKHsgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLCBwcm90bzogdHJ1ZSwgdW5zYWZlOiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9TTElDRSB9LCB7XG4gIHNsaWNlOiBmdW5jdGlvbiBzbGljZShzdGFydCwgZW5kKSB7XG4gICAgaWYgKG5hdGl2ZUFycmF5QnVmZmVyU2xpY2UgIT09IHVuZGVmaW5lZCAmJiBlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZUFycmF5QnVmZmVyU2xpY2UuY2FsbChhbk9iamVjdCh0aGlzKSwgc3RhcnQpOyAvLyBGRiBmaXhcbiAgICB9XG4gICAgdmFyIGxlbmd0aCA9IGFuT2JqZWN0KHRoaXMpLmJ5dGVMZW5ndGg7XG4gICAgdmFyIGZpcnN0ID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyAoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIEFycmF5QnVmZmVyKSkodG9MZW5ndGgoZmluIC0gZmlyc3QpKTtcbiAgICB2YXIgdmlld1NvdXJjZSA9IG5ldyBEYXRhVmlldyh0aGlzKTtcbiAgICB2YXIgdmlld1RhcmdldCA9IG5ldyBEYXRhVmlldyhyZXN1bHQpO1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgd2hpbGUgKGZpcnN0IDwgZmluKSB7XG4gICAgICB2aWV3VGFyZ2V0LnNldFVpbnQ4KGluZGV4KyssIHZpZXdTb3VyY2UuZ2V0VWludDgoZmlyc3QrKykpO1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheVNwZWNpZXNDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktc3BlY2llcy1jcmVhdGUnKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRSA9IHdlbGxLbm93blN5bWJvbCgnaXNDb25jYXRTcHJlYWRhYmxlJyk7XG52YXIgTUFYX1NBRkVfSU5URUdFUiA9IDB4MUZGRkZGRkZGRkZGRkY7XG52YXIgTUFYSU1VTV9BTExPV0VEX0lOREVYX0VYQ0VFREVEID0gJ01heGltdW0gYWxsb3dlZCBpbmRleCBleGNlZWRlZCc7XG5cbnZhciBJU19DT05DQVRfU1BSRUFEQUJMRV9TVVBQT1JUID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFycmF5ID0gW107XG4gIGFycmF5W0lTX0NPTkNBVF9TUFJFQURBQkxFXSA9IGZhbHNlO1xuICByZXR1cm4gYXJyYXkuY29uY2F0KClbMF0gIT09IGFycmF5O1xufSk7XG5cbnZhciBTUEVDSUVTX1NVUFBPUlQgPSBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdjb25jYXQnKTtcblxudmFyIGlzQ29uY2F0U3ByZWFkYWJsZSA9IGZ1bmN0aW9uIChPKSB7XG4gIGlmICghaXNPYmplY3QoTykpIHJldHVybiBmYWxzZTtcbiAgdmFyIHNwcmVhZGFibGUgPSBPW0lTX0NPTkNBVF9TUFJFQURBQkxFXTtcbiAgcmV0dXJuIHNwcmVhZGFibGUgIT09IHVuZGVmaW5lZCA/ICEhc3ByZWFkYWJsZSA6IGlzQXJyYXkoTyk7XG59O1xuXG52YXIgRk9SQ0VEID0gIUlTX0NPTkNBVF9TUFJFQURBQkxFX1NVUFBPUlQgfHwgIVNQRUNJRVNfU1VQUE9SVDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5jb25jYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmNvbmNhdFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQGlzQ29uY2F0U3ByZWFkYWJsZSBhbmQgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBjb25jYXQ6IGZ1bmN0aW9uIGNvbmNhdChhcmcpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgdmFyIG4gPSAwO1xuICAgIHZhciBpLCBrLCBsZW5ndGgsIGxlbiwgRTtcbiAgICBmb3IgKGkgPSAtMSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBFID0gaSA9PT0gLTEgPyBPIDogYXJndW1lbnRzW2ldO1xuICAgICAgaWYgKGlzQ29uY2F0U3ByZWFkYWJsZShFKSkge1xuICAgICAgICBsZW4gPSB0b0xlbmd0aChFLmxlbmd0aCk7XG4gICAgICAgIGlmIChuICsgbGVuID4gTUFYX1NBRkVfSU5URUdFUikgdGhyb3cgVHlwZUVycm9yKE1BWElNVU1fQUxMT1dFRF9JTkRFWF9FWENFRURFRCk7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBsZW47IGsrKywgbisrKSBpZiAoayBpbiBFKSBjcmVhdGVQcm9wZXJ0eShBLCBuLCBFW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuID49IE1BWF9TQUZFX0lOVEVHRVIpIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfSU5ERVhfRVhDRUVERUQpO1xuICAgICAgICBjcmVhdGVQcm9wZXJ0eShBLCBuKyssIEUpO1xuICAgICAgfVxuICAgIH1cbiAgICBBLmxlbmd0aCA9IG47XG4gICAgcmV0dXJuIEE7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY29weVdpdGhpbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1jb3B5LXdpdGhpbicpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuY29weXdpdGhpblxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBjb3B5V2l0aGluOiBjb3B5V2l0aGluXG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2NvcHlXaXRoaW4nKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRldmVyeSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5ldmVyeTtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmV2ZXJ5XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBzbG9wcHlBcnJheU1ldGhvZCgnZXZlcnknKSB9LCB7XG4gIGV2ZXJ5OiBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICAgIHJldHVybiAkZXZlcnkodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZpbGwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZmlsbCcpO1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmlsbGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmlsbFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmaWxsOiBmaWxsXG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2ZpbGwnKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaWx0ZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmlsdGVyO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5maWx0ZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmZpbHRlclxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdmaWx0ZXInKSB9LCB7XG4gIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRmaWx0ZXIodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaW5kSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmluZEluZGV4O1xudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbnZhciBGSU5EX0lOREVYID0gJ2ZpbmRJbmRleCc7XG52YXIgU0tJUFNfSE9MRVMgPSB0cnVlO1xuXG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEZJTkRfSU5ERVggaW4gW10pIEFycmF5KDEpW0ZJTkRfSU5ERVhdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZEluZGV4YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5maW5kaW5kZXhcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IFNLSVBTX0hPTEVTIH0sIHtcbiAgZmluZEluZGV4OiBmdW5jdGlvbiBmaW5kSW5kZXgoY2FsbGJhY2tmbiAvKiAsIHRoYXQgPSB1bmRlZmluZWQgKi8pIHtcbiAgICByZXR1cm4gJGZpbmRJbmRleCh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEB1bnNjb3BhYmxlc1xuYWRkVG9VbnNjb3BhYmxlcyhGSU5EX0lOREVYKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRmaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbmQ7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcblxudmFyIEZJTkQgPSAnZmluZCc7XG52YXIgU0tJUFNfSE9MRVMgPSB0cnVlO1xuXG4vLyBTaG91bGRuJ3Qgc2tpcCBob2xlc1xuaWYgKEZJTkQgaW4gW10pIEFycmF5KDEpW0ZJTkRdKGZ1bmN0aW9uICgpIHsgU0tJUFNfSE9MRVMgPSBmYWxzZTsgfSk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZmluZFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU0tJUFNfSE9MRVMgfSwge1xuICBmaW5kOiBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrZm4gLyogLCB0aGF0ID0gdW5kZWZpbmVkICovKSB7XG4gICAgcmV0dXJuICRmaW5kKHRoaXMsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG5cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS1AQHVuc2NvcGFibGVzXG5hZGRUb1Vuc2NvcGFibGVzKEZJTkQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmxhdHRlbkludG9BcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mbGF0dGVuLWludG8tYXJyYXknKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmZsYXRNYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtZmxhdE1hcFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBmbGF0TWFwOiBmdW5jdGlvbiBmbGF0TWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgdmFyIE8gPSB0b09iamVjdCh0aGlzKTtcbiAgICB2YXIgc291cmNlTGVuID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBBO1xuICAgIGFGdW5jdGlvbihjYWxsYmFja2ZuKTtcbiAgICBBID0gYXJyYXlTcGVjaWVzQ3JlYXRlKE8sIDApO1xuICAgIEEubGVuZ3RoID0gZmxhdHRlbkludG9BcnJheShBLCBPLCBPLCBzb3VyY2VMZW4sIDAsIDEsIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmbGF0dGVuSW50b0FycmF5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZsYXR0ZW4taW50by1hcnJheScpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgYXJyYXlTcGVjaWVzQ3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXNwZWNpZXMtY3JlYXRlJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZmxhdGAgbWV0aG9kXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1mbGF0TWFwXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGZsYXQ6IGZ1bmN0aW9uIGZsYXQoLyogZGVwdGhBcmcgPSAxICovKSB7XG4gICAgdmFyIGRlcHRoQXJnID0gYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBzb3VyY2VMZW4gPSB0b0xlbmd0aChPLmxlbmd0aCk7XG4gICAgdmFyIEEgPSBhcnJheVNwZWNpZXNDcmVhdGUoTywgMCk7XG4gICAgQS5sZW5ndGggPSBmbGF0dGVuSW50b0FycmF5KEEsIE8sIE8sIHNvdXJjZUxlbiwgMCwgZGVwdGhBcmcgPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGhBcmcpKTtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZvci1lYWNoJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuZm9yZWFjaFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogW10uZm9yRWFjaCAhPSBmb3JFYWNoIH0sIHtcbiAgZm9yRWFjaDogZm9yRWFjaFxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmcm9tID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWZyb20nKTtcbnZhciBjaGVja0NvcnJlY3RuZXNzT2ZJdGVyYXRpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY2hlY2stY29ycmVjdG5lc3Mtb2YtaXRlcmF0aW9uJyk7XG5cbnZhciBJTkNPUlJFQ1RfSVRFUkFUSU9OID0gIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgQXJyYXkuZnJvbShpdGVyYWJsZSk7XG59KTtcblxuLy8gYEFycmF5LmZyb21gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkuZnJvbVxuJCh7IHRhcmdldDogJ0FycmF5Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfSVRFUkFUSU9OIH0sIHtcbiAgZnJvbTogZnJvbVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5jbHVkZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaW5jbHVkZXMnKS5pbmNsdWRlcztcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FkZC10by11bnNjb3BhYmxlcycpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5pbmNsdWRlc1xuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoZWwgLyogLCBmcm9tSW5kZXggPSAwICovKSB7XG4gICAgcmV0dXJuICRpbmNsdWRlcyh0aGlzLCBlbCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2luY2x1ZGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG52YXIgc2xvcHB5QXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpO1xuXG52YXIgbmF0aXZlSW5kZXhPZiA9IFtdLmluZGV4T2Y7XG5cbnZhciBORUdBVElWRV9aRVJPID0gISFuYXRpdmVJbmRleE9mICYmIDEgLyBbMV0uaW5kZXhPZigxLCAtMCkgPCAwO1xudmFyIFNMT1BQWV9NRVRIT0QgPSBzbG9wcHlBcnJheU1ldGhvZCgnaW5kZXhPZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmluZGV4b2ZcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IE5FR0FUSVZFX1pFUk8gfHwgU0xPUFBZX01FVEhPRCB9LCB7XG4gIGluZGV4T2Y6IGZ1bmN0aW9uIGluZGV4T2Yoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCA9IDAgKi8pIHtcbiAgICByZXR1cm4gTkVHQVRJVkVfWkVST1xuICAgICAgLy8gY29udmVydCAtMCB0byArMFxuICAgICAgPyBuYXRpdmVJbmRleE9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgMFxuICAgICAgOiAkaW5kZXhPZih0aGlzLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xuXG4vLyBgQXJyYXkuaXNBcnJheWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5pc2FycmF5XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXNBcnJheTogaXNBcnJheVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcbnZhciBJdGVyYXRvcnMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXRlcmF0b3JzJyk7XG52YXIgSW50ZXJuYWxTdGF0ZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1zdGF0ZScpO1xudmFyIGRlZmluZUl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS1pdGVyYXRvcicpO1xuXG52YXIgQVJSQVlfSVRFUkFUT1IgPSAnQXJyYXkgSXRlcmF0b3InO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoQVJSQVlfSVRFUkFUT1IpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmVudHJpZXNcbi8vIGBBcnJheS5wcm90b3R5cGUua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUua2V5c1xuLy8gYEFycmF5LnByb3RvdHlwZS52YWx1ZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLnZhbHVlc1xuLy8gYEFycmF5LnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUtQEBpdGVyYXRvclxuLy8gYENyZWF0ZUFycmF5SXRlcmF0b3JgIGludGVybmFsIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRlYXJyYXlpdGVyYXRvclxubW9kdWxlLmV4cG9ydHMgPSBkZWZpbmVJdGVyYXRvcihBcnJheSwgJ0FycmF5JywgZnVuY3Rpb24gKGl0ZXJhdGVkLCBraW5kKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IEFSUkFZX0lURVJBVE9SLFxuICAgIHRhcmdldDogdG9JbmRleGVkT2JqZWN0KGl0ZXJhdGVkKSwgLy8gdGFyZ2V0XG4gICAgaW5kZXg6IDAsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0IGluZGV4XG4gICAga2luZDoga2luZCAgICAgICAgICAgICAgICAgICAgICAgICAvLyBraW5kXG4gIH0pO1xuLy8gYCVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVhcnJheWl0ZXJhdG9ycHJvdG90eXBlJS5uZXh0XG59LCBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIHZhciB0YXJnZXQgPSBzdGF0ZS50YXJnZXQ7XG4gIHZhciBraW5kID0gc3RhdGUua2luZDtcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXgrKztcbiAgaWYgKCF0YXJnZXQgfHwgaW5kZXggPj0gdGFyZ2V0Lmxlbmd0aCkge1xuICAgIHN0YXRlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cbiAgaWYgKGtpbmQgPT0gJ2tleXMnKSByZXR1cm4geyB2YWx1ZTogaW5kZXgsIGRvbmU6IGZhbHNlIH07XG4gIGlmIChraW5kID09ICd2YWx1ZXMnKSByZXR1cm4geyB2YWx1ZTogdGFyZ2V0W2luZGV4XSwgZG9uZTogZmFsc2UgfTtcbiAgcmV0dXJuIHsgdmFsdWU6IFtpbmRleCwgdGFyZ2V0W2luZGV4XV0sIGRvbmU6IGZhbHNlIH07XG59LCAndmFsdWVzJyk7XG5cbi8vIGFyZ3VtZW50c0xpc3RbQEBpdGVyYXRvcl0gaXMgJUFycmF5UHJvdG9fdmFsdWVzJVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtY3JlYXRldW5tYXBwZWRhcmd1bWVudHNvYmplY3Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWNyZWF0ZW1hcHBlZGFyZ3VtZW50c29iamVjdFxuSXRlcmF0b3JzLkFyZ3VtZW50cyA9IEl0ZXJhdG9ycy5BcnJheTtcblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLUBAdW5zY29wYWJsZXNcbmFkZFRvVW5zY29wYWJsZXMoJ2tleXMnKTtcbmFkZFRvVW5zY29wYWJsZXMoJ3ZhbHVlcycpO1xuYWRkVG9VbnNjb3BhYmxlcygnZW50cmllcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHNsb3BweUFycmF5TWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3Nsb3BweS1hcnJheS1tZXRob2QnKTtcblxudmFyIG5hdGl2ZUpvaW4gPSBbXS5qb2luO1xuXG52YXIgRVMzX1NUUklOR1MgPSBJbmRleGVkT2JqZWN0ICE9IE9iamVjdDtcbnZhciBTTE9QUFlfTUVUSE9EID0gc2xvcHB5QXJyYXlNZXRob2QoJ2pvaW4nLCAnLCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmpvaW5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLmpvaW5cbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEVTM19TVFJJTkdTIHx8IFNMT1BQWV9NRVRIT0QgfSwge1xuICBqb2luOiBmdW5jdGlvbiBqb2luKHNlcGFyYXRvcikge1xuICAgIHJldHVybiBuYXRpdmVKb2luLmNhbGwodG9JbmRleGVkT2JqZWN0KHRoaXMpLCBzZXBhcmF0b3IgPT09IHVuZGVmaW5lZCA/ICcsJyA6IHNlcGFyYXRvcik7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgbGFzdEluZGV4T2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbGFzdC1pbmRleC1vZicpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5sYXN0aW5kZXhvZlxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogbGFzdEluZGV4T2YgIT09IFtdLmxhc3RJbmRleE9mIH0sIHtcbiAgbGFzdEluZGV4T2Y6IGxhc3RJbmRleE9mXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRtYXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykubWFwO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5tYXBgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtYXJyYXkucHJvdG90eXBlLm1hcFxuLy8gd2l0aCBhZGRpbmcgc3VwcG9ydCBvZiBAQHNwZWNpZXNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdtYXAnKSB9LCB7XG4gIG1hcDogZnVuY3Rpb24gbWFwKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICAgcmV0dXJuICRtYXAodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG5cbnZhciBJU05UX0dFTkVSSUMgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEYoKSB7IC8qIGVtcHR5ICovIH1cbiAgcmV0dXJuICEoQXJyYXkub2YuY2FsbChGKSBpbnN0YW5jZW9mIEYpO1xufSk7XG5cbi8vIGBBcnJheS5vZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5vZlxuLy8gV2ViS2l0IEFycmF5Lm9mIGlzbid0IGdlbmVyaWNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHN0YXQ6IHRydWUsIGZvcmNlZDogSVNOVF9HRU5FUklDIH0sIHtcbiAgb2Y6IGZ1bmN0aW9uIG9mKC8qIC4uLmFyZ3MgKi8pIHtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIHZhciByZXN1bHQgPSBuZXcgKHR5cGVvZiB0aGlzID09ICdmdW5jdGlvbicgPyB0aGlzIDogQXJyYXkpKGFyZ3VtZW50c0xlbmd0aCk7XG4gICAgd2hpbGUgKGFyZ3VtZW50c0xlbmd0aCA+IGluZGV4KSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIGluZGV4LCBhcmd1bWVudHNbaW5kZXgrK10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBhcmd1bWVudHNMZW5ndGg7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkcmVkdWNlUmlnaHQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykucmlnaHQ7XG52YXIgc2xvcHB5QXJyYXlNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2xvcHB5LWFycmF5LW1ldGhvZCcpO1xuXG4vLyBgQXJyYXkucHJvdG90eXBlLnJlZHVjZVJpZ2h0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VyaWdodFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogc2xvcHB5QXJyYXlNZXRob2QoJ3JlZHVjZVJpZ2h0JykgfSwge1xuICByZWR1Y2VSaWdodDogZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICAgIHJldHVybiAkcmVkdWNlUmlnaHQodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyICRyZWR1Y2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykubGVmdDtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUucmVkdWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZWR1Y2VcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IHNsb3BweUFycmF5TWV0aG9kKCdyZWR1Y2UnKSB9LCB7XG4gIHJlZHVjZTogZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgICByZXR1cm4gJHJlZHVjZSh0aGlzLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1hcnJheScpO1xuXG52YXIgbmF0aXZlUmV2ZXJzZSA9IFtdLnJldmVyc2U7XG52YXIgdGVzdCA9IFsxLCAyXTtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5yZXZlcnNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5yZXZlcnNlXG4vLyBmaXggZm9yIFNhZmFyaSAxMi4wIGJ1Z1xuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4ODc5NFxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogU3RyaW5nKHRlc3QpID09PSBTdHJpbmcodGVzdC5yZXZlcnNlKCkpIH0sIHtcbiAgcmV2ZXJzZTogZnVuY3Rpb24gcmV2ZXJzZSgpIHtcbiAgICBpZiAoaXNBcnJheSh0aGlzKSkgdGhpcy5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gbmF0aXZlUmV2ZXJzZS5jYWxsKHRoaXMpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcbnZhciBhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LW1ldGhvZC1oYXMtc3BlY2llcy1zdXBwb3J0Jyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dlbGwta25vd24tc3ltYm9sJyk7XG5cbnZhciBTUEVDSUVTID0gd2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG52YXIgbmF0aXZlU2xpY2UgPSBbXS5zbGljZTtcbnZhciBtYXggPSBNYXRoLm1heDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc2xpY2Vcbi8vIGZhbGxiYWNrIGZvciBub3QgYXJyYXktbGlrZSBFUzMgc3RyaW5ncyBhbmQgRE9NIG9iamVjdHNcbiQoeyB0YXJnZXQ6ICdBcnJheScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6ICFhcnJheU1ldGhvZEhhc1NwZWNpZXNTdXBwb3J0KCdzbGljZScpIH0sIHtcbiAgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdCh0aGlzKTtcbiAgICB2YXIgbGVuZ3RoID0gdG9MZW5ndGgoTy5sZW5ndGgpO1xuICAgIHZhciBrID0gdG9BYnNvbHV0ZUluZGV4KHN0YXJ0LCBsZW5ndGgpO1xuICAgIHZhciBmaW4gPSB0b0Fic29sdXRlSW5kZXgoZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQsIGxlbmd0aCk7XG4gICAgLy8gaW5saW5lIGBBcnJheVNwZWNpZXNDcmVhdGVgIGZvciB1c2FnZSBuYXRpdmUgYEFycmF5I3NsaWNlYCB3aGVyZSBpdCdzIHBvc3NpYmxlXG4gICAgdmFyIENvbnN0cnVjdG9yLCByZXN1bHQsIG47XG4gICAgaWYgKGlzQXJyYXkoTykpIHtcbiAgICAgIENvbnN0cnVjdG9yID0gTy5jb25zdHJ1Y3RvcjtcbiAgICAgIC8vIGNyb3NzLXJlYWxtIGZhbGxiYWNrXG4gICAgICBpZiAodHlwZW9mIENvbnN0cnVjdG9yID09ICdmdW5jdGlvbicgJiYgKENvbnN0cnVjdG9yID09PSBBcnJheSB8fCBpc0FycmF5KENvbnN0cnVjdG9yLnByb3RvdHlwZSkpKSB7XG4gICAgICAgIENvbnN0cnVjdG9yID0gdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIGlmIChpc09iamVjdChDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgQ29uc3RydWN0b3IgPSBDb25zdHJ1Y3RvcltTUEVDSUVTXTtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yID09PSBudWxsKSBDb25zdHJ1Y3RvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChDb25zdHJ1Y3RvciA9PT0gQXJyYXkgfHwgQ29uc3RydWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gbmF0aXZlU2xpY2UuY2FsbChPLCBrLCBmaW4pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQgPSBuZXcgKENvbnN0cnVjdG9yID09PSB1bmRlZmluZWQgPyBBcnJheSA6IENvbnN0cnVjdG9yKShtYXgoZmluIC0gaywgMCkpO1xuICAgIGZvciAobiA9IDA7IGsgPCBmaW47IGsrKywgbisrKSBpZiAoayBpbiBPKSBjcmVhdGVQcm9wZXJ0eShyZXN1bHQsIG4sIE9ba10pO1xuICAgIHJlc3VsdC5sZW5ndGggPSBuO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHNvbWUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuc29tZTtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc29tZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1hcnJheS5wcm90b3R5cGUuc29tZVxuJCh7IHRhcmdldDogJ0FycmF5JywgcHJvdG86IHRydWUsIGZvcmNlZDogc2xvcHB5QXJyYXlNZXRob2QoJ3NvbWUnKSB9LCB7XG4gIHNvbWU6IGZ1bmN0aW9uIHNvbWUoY2FsbGJhY2tmbiAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICByZXR1cm4gJHNvbWUodGhpcywgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciBzbG9wcHlBcnJheU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zbG9wcHktYXJyYXktbWV0aG9kJyk7XG5cbnZhciBuYXRpdmVTb3J0ID0gW10uc29ydDtcbnZhciB0ZXN0ID0gWzEsIDIsIDNdO1xuXG4vLyBJRTgtXG52YXIgRkFJTFNfT05fVU5ERUZJTkVEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICB0ZXN0LnNvcnQodW5kZWZpbmVkKTtcbn0pO1xuLy8gVjggYnVnXG52YXIgRkFJTFNfT05fTlVMTCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgdGVzdC5zb3J0KG51bGwpO1xufSk7XG4vLyBPbGQgV2ViS2l0XG52YXIgU0xPUFBZX01FVEhPRCA9IHNsb3BweUFycmF5TWV0aG9kKCdzb3J0Jyk7XG5cbnZhciBGT1JDRUQgPSBGQUlMU19PTl9VTkRFRklORUQgfHwgIUZBSUxTX09OX05VTEwgfHwgU0xPUFBZX01FVEhPRDtcblxuLy8gYEFycmF5LnByb3RvdHlwZS5zb3J0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zb3J0XG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBzb3J0OiBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICAgIHJldHVybiBjb21wYXJlZm4gPT09IHVuZGVmaW5lZFxuICAgICAgPyBuYXRpdmVTb3J0LmNhbGwodG9PYmplY3QodGhpcykpXG4gICAgICA6IG5hdGl2ZVNvcnQuY2FsbCh0b09iamVjdCh0aGlzKSwgYUZ1bmN0aW9uKGNvbXBhcmVmbikpO1xuICB9XG59KTtcbiIsInZhciBzZXRTcGVjaWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC1zcGVjaWVzJyk7XG5cbi8vIGBBcnJheVtAQHNwZWNpZXNdYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWdldC1hcnJheS1AQHNwZWNpZXNcbnNldFNwZWNpZXMoJ0FycmF5Jyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tYWJzb2x1dGUtaW5kZXgnKTtcbnZhciB0b0ludGVnZXIgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW50ZWdlcicpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGFycmF5U3BlY2llc0NyZWF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1zcGVjaWVzLWNyZWF0ZScpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1wcm9wZXJ0eScpO1xudmFyIGFycmF5TWV0aG9kSGFzU3BlY2llc1N1cHBvcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktbWV0aG9kLWhhcy1zcGVjaWVzLXN1cHBvcnQnKTtcblxudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIG1pbiA9IE1hdGgubWluO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xudmFyIE1BWElNVU1fQUxMT1dFRF9MRU5HVEhfRVhDRUVERUQgPSAnTWF4aW11bSBhbGxvd2VkIGxlbmd0aCBleGNlZWRlZCc7XG5cbi8vIGBBcnJheS5wcm90b3R5cGUuc3BsaWNlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWFycmF5LnByb3RvdHlwZS5zcGxpY2Vcbi8vIHdpdGggYWRkaW5nIHN1cHBvcnQgb2YgQEBzcGVjaWVzXG4kKHsgdGFyZ2V0OiAnQXJyYXknLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhYXJyYXlNZXRob2RIYXNTcGVjaWVzU3VwcG9ydCgnc3BsaWNlJykgfSwge1xuICBzcGxpY2U6IGZ1bmN0aW9uIHNwbGljZShzdGFydCwgZGVsZXRlQ291bnQgLyogLCAuLi5pdGVtcyAqLykge1xuICAgIHZhciBPID0gdG9PYmplY3QodGhpcyk7XG4gICAgdmFyIGxlbiA9IHRvTGVuZ3RoKE8ubGVuZ3RoKTtcbiAgICB2YXIgYWN0dWFsU3RhcnQgPSB0b0Fic29sdXRlSW5kZXgoc3RhcnQsIGxlbik7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGluc2VydENvdW50LCBhY3R1YWxEZWxldGVDb3VudCwgQSwgaywgZnJvbSwgdG87XG4gICAgaWYgKGFyZ3VtZW50c0xlbmd0aCA9PT0gMCkge1xuICAgICAgaW5zZXJ0Q291bnQgPSBhY3R1YWxEZWxldGVDb3VudCA9IDA7XG4gICAgfSBlbHNlIGlmIChhcmd1bWVudHNMZW5ndGggPT09IDEpIHtcbiAgICAgIGluc2VydENvdW50ID0gMDtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbGVuIC0gYWN0dWFsU3RhcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluc2VydENvdW50ID0gYXJndW1lbnRzTGVuZ3RoIC0gMjtcbiAgICAgIGFjdHVhbERlbGV0ZUNvdW50ID0gbWluKG1heCh0b0ludGVnZXIoZGVsZXRlQ291bnQpLCAwKSwgbGVuIC0gYWN0dWFsU3RhcnQpO1xuICAgIH1cbiAgICBpZiAobGVuICsgaW5zZXJ0Q291bnQgLSBhY3R1YWxEZWxldGVDb3VudCA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcihNQVhJTVVNX0FMTE9XRURfTEVOR1RIX0VYQ0VFREVEKTtcbiAgICB9XG4gICAgQSA9IGFycmF5U3BlY2llc0NyZWF0ZShPLCBhY3R1YWxEZWxldGVDb3VudCk7XG4gICAgZm9yIChrID0gMDsgayA8IGFjdHVhbERlbGV0ZUNvdW50OyBrKyspIHtcbiAgICAgIGZyb20gPSBhY3R1YWxTdGFydCArIGs7XG4gICAgICBpZiAoZnJvbSBpbiBPKSBjcmVhdGVQcm9wZXJ0eShBLCBrLCBPW2Zyb21dKTtcbiAgICB9XG4gICAgQS5sZW5ndGggPSBhY3R1YWxEZWxldGVDb3VudDtcbiAgICBpZiAoaW5zZXJ0Q291bnQgPCBhY3R1YWxEZWxldGVDb3VudCkge1xuICAgICAgZm9yIChrID0gYWN0dWFsU3RhcnQ7IGsgPCBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgaysrKSB7XG4gICAgICAgIGZyb20gPSBrICsgYWN0dWFsRGVsZXRlQ291bnQ7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50O1xuICAgICAgICBpZiAoZnJvbSBpbiBPKSBPW3RvXSA9IE9bZnJvbV07XG4gICAgICAgIGVsc2UgZGVsZXRlIE9bdG9dO1xuICAgICAgfVxuICAgICAgZm9yIChrID0gbGVuOyBrID4gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDsgay0tKSBkZWxldGUgT1trIC0gMV07XG4gICAgfSBlbHNlIGlmIChpbnNlcnRDb3VudCA+IGFjdHVhbERlbGV0ZUNvdW50KSB7XG4gICAgICBmb3IgKGsgPSBsZW4gLSBhY3R1YWxEZWxldGVDb3VudDsgayA+IGFjdHVhbFN0YXJ0OyBrLS0pIHtcbiAgICAgICAgZnJvbSA9IGsgKyBhY3R1YWxEZWxldGVDb3VudCAtIDE7XG4gICAgICAgIHRvID0gayArIGluc2VydENvdW50IC0gMTtcbiAgICAgICAgaWYgKGZyb20gaW4gTykgT1t0b10gPSBPW2Zyb21dO1xuICAgICAgICBlbHNlIGRlbGV0ZSBPW3RvXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrID0gMDsgayA8IGluc2VydENvdW50OyBrKyspIHtcbiAgICAgIE9bayArIGFjdHVhbFN0YXJ0XSA9IGFyZ3VtZW50c1trICsgMl07XG4gICAgfVxuICAgIE8ubGVuZ3RoID0gbGVuIC0gYWN0dWFsRGVsZXRlQ291bnQgKyBpbnNlcnRDb3VudDtcbiAgICByZXR1cm4gQTtcbiAgfVxufSk7XG4iLCIvLyB0aGlzIG1ldGhvZCB3YXMgYWRkZWQgdG8gdW5zY29wYWJsZXMgYWZ0ZXIgaW1wbGVtZW50YXRpb25cbi8vIGluIHBvcHVsYXIgZW5naW5lcywgc28gaXQncyBtb3ZlZCB0byBhIHNlcGFyYXRlIG1vZHVsZVxudmFyIGFkZFRvVW5zY29wYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWRkLXRvLXVuc2NvcGFibGVzJyk7XG5cbmFkZFRvVW5zY29wYWJsZXMoJ2ZsYXRNYXAnKTtcbiIsIi8vIHRoaXMgbWV0aG9kIHdhcyBhZGRlZCB0byB1bnNjb3BhYmxlcyBhZnRlciBpbXBsZW1lbnRhdGlvblxuLy8gaW4gcG9wdWxhciBlbmdpbmVzLCBzbyBpdCdzIG1vdmVkIHRvIGEgc2VwYXJhdGUgbW9kdWxlXG52YXIgYWRkVG9VbnNjb3BhYmxlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZGQtdG8tdW5zY29wYWJsZXMnKTtcblxuYWRkVG9VbnNjb3BhYmxlcygnZmxhdCcpO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgQXJyYXlCdWZmZXJNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyJyk7XG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJykuTkFUSVZFX0FSUkFZX0JVRkZFUjtcblxuLy8gYERhdGFWaWV3YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0YXZpZXctY29uc3RydWN0b3JcbiQoeyBnbG9iYWw6IHRydWUsIGZvcmNlZDogIU5BVElWRV9BUlJBWV9CVUZGRVIgfSwge1xuICBEYXRhVmlldzogQXJyYXlCdWZmZXJNb2R1bGUuRGF0YVZpZXdcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG5cbi8vIGBEYXRlLm5vd2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1kYXRlLm5vd1xuJCh7IHRhcmdldDogJ0RhdGUnLCBzdGF0OiB0cnVlIH0sIHtcbiAgbm93OiBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvSVNPU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RhdGUtdG8taXNvLXN0cmluZycpO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUudG9pc29zdHJpbmdcbi8vIFBoYW50b21KUyAvIG9sZCBXZWJLaXQgaGFzIGEgYnJva2VuIGltcGxlbWVudGF0aW9uc1xuJCh7IHRhcmdldDogJ0RhdGUnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBEYXRlLnByb3RvdHlwZS50b0lTT1N0cmluZyAhPT0gdG9JU09TdHJpbmcgfSwge1xuICB0b0lTT1N0cmluZzogdG9JU09TdHJpbmdcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcblxudmFyIEZPUkNFRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIG5ldyBEYXRlKE5hTikudG9KU09OKCkgIT09IG51bGxcbiAgICB8fCBEYXRlLnByb3RvdHlwZS50b0pTT04uY2FsbCh7IHRvSVNPU3RyaW5nOiBmdW5jdGlvbiAoKSB7IHJldHVybiAxOyB9IH0pICE9PSAxO1xufSk7XG5cbi8vIGBEYXRlLnByb3RvdHlwZS50b0pTT05gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUudG9qc29uXG4kKHsgdGFyZ2V0OiAnRGF0ZScsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICB0b0pTT046IGZ1bmN0aW9uIHRvSlNPTihrZXkpIHtcbiAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgIHZhciBwdiA9IHRvUHJpbWl0aXZlKE8pO1xuICAgIHJldHVybiB0eXBlb2YgcHYgPT0gJ251bWJlcicgJiYgIWlzRmluaXRlKHB2KSA/IG51bGwgOiBPLnRvSVNPU3RyaW5nKCk7XG4gIH1cbn0pO1xuIiwidmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIGRhdGVUb1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kYXRlLXRvLXByaW1pdGl2ZScpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcblxuLy8gYERhdGUucHJvdG90eXBlW0BAdG9QcmltaXRpdmVdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWRhdGUucHJvdG90eXBlLUBAdG9wcmltaXRpdmVcbmlmICghKFRPX1BSSU1JVElWRSBpbiBEYXRlUHJvdG90eXBlKSkgaGlkZShEYXRlUHJvdG90eXBlLCBUT19QUklNSVRJVkUsIGRhdGVUb1ByaW1pdGl2ZSk7XG4iLCJ2YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcblxudmFyIERhdGVQcm90b3R5cGUgPSBEYXRlLnByb3RvdHlwZTtcbnZhciBJTlZBTElEX0RBVEUgPSAnSW52YWxpZCBEYXRlJztcbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIG5hdGl2ZURhdGVUb1N0cmluZyA9IERhdGVQcm90b3R5cGVbVE9fU1RSSU5HXTtcbnZhciBnZXRUaW1lID0gRGF0ZVByb3RvdHlwZS5nZXRUaW1lO1xuXG4vLyBgRGF0ZS5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZGF0ZS5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChuZXcgRGF0ZShOYU4pICsgJycgIT0gSU5WQUxJRF9EQVRFKSB7XG4gIHJlZGVmaW5lKERhdGVQcm90b3R5cGUsIFRPX1NUUklORywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgdmFyIHZhbHVlID0gZ2V0VGltZS5jYWxsKHRoaXMpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zZWxmLWNvbXBhcmVcbiAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlID8gbmF0aXZlRGF0ZVRvU3RyaW5nLmNhbGwodGhpcykgOiBJTlZBTElEX0RBVEU7XG4gIH0pO1xufVxuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYmluZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mdW5jdGlvbi1iaW5kJyk7XG5cbi8vIGBGdW5jdGlvbi5wcm90b3R5cGUuYmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuJCh7IHRhcmdldDogJ0Z1bmN0aW9uJywgcHJvdG86IHRydWUgfSwge1xuICBiaW5kOiBiaW5kXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIEhBU19JTlNUQU5DRSA9IHdlbGxLbm93blN5bWJvbCgnaGFzSW5zdGFuY2UnKTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuLy8gYEZ1bmN0aW9uLnByb3RvdHlwZVtAQGhhc0luc3RhbmNlXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUtQEBoYXNpbnN0YW5jZVxuaWYgKCEoSEFTX0lOU1RBTkNFIGluIEZ1bmN0aW9uUHJvdG90eXBlKSkge1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKEZ1bmN0aW9uUHJvdG90eXBlLCBIQVNfSU5TVEFOQ0UsIHsgdmFsdWU6IGZ1bmN0aW9uIChPKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzICE9ICdmdW5jdGlvbicgfHwgIWlzT2JqZWN0KE8pKSByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc09iamVjdCh0aGlzLnByb3RvdHlwZSkpIHJldHVybiBPIGluc3RhbmNlb2YgdGhpcztcbiAgICAvLyBmb3IgZW52aXJvbm1lbnQgdy9vIG5hdGl2ZSBgQEBoYXNJbnN0YW5jZWAgbG9naWMgZW5vdWdoIGBpbnN0YW5jZW9mYCwgYnV0IGFkZCB0aGlzOlxuICAgIHdoaWxlIChPID0gZ2V0UHJvdG90eXBlT2YoTykpIGlmICh0aGlzLnByb3RvdHlwZSA9PT0gTykgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IH0pO1xufVxuIiwidmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG5cbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBGdW5jdGlvblByb3RvdHlwZVRvU3RyaW5nID0gRnVuY3Rpb25Qcm90b3R5cGUudG9TdHJpbmc7XG52YXIgbmFtZVJFID0gL15cXHMqZnVuY3Rpb24gKFteIChdKikvO1xudmFyIE5BTUUgPSAnbmFtZSc7XG5cbi8vIEZ1bmN0aW9uIGluc3RhbmNlcyBgLm5hbWVgIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1mdW5jdGlvbi1pbnN0YW5jZXMtbmFtZVxuaWYgKERFU0NSSVBUT1JTICYmICEoTkFNRSBpbiBGdW5jdGlvblByb3RvdHlwZSkpIHtcbiAgZGVmaW5lUHJvcGVydHkoRnVuY3Rpb25Qcm90b3R5cGUsIE5BTUUsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gRnVuY3Rpb25Qcm90b3R5cGVUb1N0cmluZy5jYWxsKHRoaXMpLm1hdGNoKG5hbWVSRSlbMV07XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcblxuLy8gSlNPTltAQHRvU3RyaW5nVGFnXSBwcm9wZXJ0eVxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtanNvbi1AQHRvc3RyaW5ndGFnXG5zZXRUb1N0cmluZ1RhZyhnbG9iYWwuSlNPTiwgJ0pTT04nLCB0cnVlKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24nKTtcbnZhciBjb2xsZWN0aW9uU3Ryb25nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24tc3Ryb25nJyk7XG5cbi8vIGBNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXAtb2JqZWN0c1xubW9kdWxlLmV4cG9ydHMgPSBjb2xsZWN0aW9uKCdNYXAnLCBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBNYXAoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCBjb2xsZWN0aW9uU3Ryb25nLCB0cnVlKTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGxvZzFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtbG9nMXAnKTtcblxudmFyIG5hdGl2ZUFjb3NoID0gTWF0aC5hY29zaDtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG52YXIgRk9SQ0VEID0gIW5hdGl2ZUFjb3NoXG4gIC8vIFY4IGJ1ZzogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTM1MDlcbiAgfHwgTWF0aC5mbG9vcihuYXRpdmVBY29zaChOdW1iZXIuTUFYX1ZBTFVFKSkgIT0gNzEwXG4gIC8vIFRvciBCcm93c2VyIGJ1ZzogTWF0aC5hY29zaChJbmZpbml0eSkgLT4gTmFOXG4gIHx8IG5hdGl2ZUFjb3NoKEluZmluaXR5KSAhPSBJbmZpbml0eTtcblxuLy8gYE1hdGguYWNvc2hgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5hY29zaFxuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGFjb3NoOiBmdW5jdGlvbiBhY29zaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpIDwgMSA/IE5hTiA6IHggPiA5NDkwNjI2NS42MjQyNTE1NlxuICAgICAgPyBsb2coeCkgKyBMTjJcbiAgICAgIDogbG9nMXAoeCAtIDEgKyBzcXJ0KHggLSAxKSAqIHNxcnQoeCArIDEpKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxudmFyIG5hdGl2ZUFzaW5oID0gTWF0aC5hc2luaDtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG5mdW5jdGlvbiBhc2luaCh4KSB7XG4gIHJldHVybiAhaXNGaW5pdGUoeCA9ICt4KSB8fCB4ID09IDAgPyB4IDogeCA8IDAgPyAtYXNpbmgoLXgpIDogbG9nKHggKyBzcXJ0KHggKiB4ICsgMSkpO1xufVxuXG4vLyBgTWF0aC5hc2luaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmFzaW5oXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXNpbmgoMCkgLT4gLTBcbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhKG5hdGl2ZUFzaW5oICYmIDEgLyBuYXRpdmVBc2luaCgwKSA+IDApIH0sIHtcbiAgYXNpbmg6IGFzaW5oXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuXG52YXIgbmF0aXZlQXRhbmggPSBNYXRoLmF0YW5oO1xudmFyIGxvZyA9IE1hdGgubG9nO1xuXG4vLyBgTWF0aC5hdGFuaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmF0YW5oXG4vLyBUb3IgQnJvd3NlciBidWc6IE1hdGguYXRhbmgoLTApIC0+IDBcbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhKG5hdGl2ZUF0YW5oICYmIDEgLyBuYXRpdmVBdGFuaCgtMCkgPCAwKSB9LCB7XG4gIGF0YW5oOiBmdW5jdGlvbiBhdGFuaCh4KSB7XG4gICAgcmV0dXJuICh4ID0gK3gpID09IDAgPyB4IDogbG9nKCgxICsgeCkgLyAoMSAtIHgpKSAvIDI7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLXNpZ24nKTtcblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIHBvdyA9IE1hdGgucG93O1xuXG4vLyBgTWF0aC5jYnJ0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguY2JydFxuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcbiAgY2JydDogZnVuY3Rpb24gY2JydCh4KSB7XG4gICAgcmV0dXJuIHNpZ24oeCA9ICt4KSAqIHBvdyhhYnMoeCksIDEgLyAzKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbnZhciBsb2cgPSBNYXRoLmxvZztcbnZhciBMT0cyRSA9IE1hdGguTE9HMkU7XG5cbi8vIGBNYXRoLmNsejMyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguY2x6MzJcbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG4gIGNsejMyOiBmdW5jdGlvbiBjbHozMih4KSB7XG4gICAgcmV0dXJuICh4ID4+Pj0gMCkgPyAzMSAtIGZsb29yKGxvZyh4ICsgMC41KSAqIExPRzJFKSA6IDMyO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtZXhwbTEnKTtcblxudmFyIG5hdGl2ZUNvc2ggPSBNYXRoLmNvc2g7XG52YXIgYWJzID0gTWF0aC5hYnM7XG52YXIgRSA9IE1hdGguRTtcblxuLy8gYE1hdGguY29zaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmNvc2hcbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhbmF0aXZlQ29zaCB8fCBuYXRpdmVDb3NoKDcxMCkgPT09IEluZmluaXR5IH0sIHtcbiAgY29zaDogZnVuY3Rpb24gY29zaCh4KSB7XG4gICAgdmFyIHQgPSBleHBtMShhYnMoeCkgLSAxKSArIDE7XG4gICAgcmV0dXJuICh0ICsgMSAvICh0ICogRSAqIEUpKSAqIChFIC8gMik7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZXhwbTEgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWF0aC1leHBtMScpO1xuXG4vLyBgTWF0aC5leHBtMWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmV4cG0xXG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogZXhwbTEgIT0gTWF0aC5leHBtMSB9LCB7IGV4cG0xOiBleHBtMSB9KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZyb3VuZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLWZyb3VuZCcpO1xuXG4vLyBgTWF0aC5mcm91bmRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5mcm91bmRcbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7IGZyb3VuZDogZnJvdW5kIH0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG5cbnZhciBhYnMgPSBNYXRoLmFicztcbnZhciBzcXJ0ID0gTWF0aC5zcXJ0O1xuXG4vLyBgTWF0aC5oeXBvdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmh5cG90XG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUgfSwge1xuICBoeXBvdDogZnVuY3Rpb24gaHlwb3QodmFsdWUxLCB2YWx1ZTIpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIHZhciBzdW0gPSAwO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgYUxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGxhcmcgPSAwO1xuICAgIHZhciBhcmcsIGRpdjtcbiAgICB3aGlsZSAoaSA8IGFMZW4pIHtcbiAgICAgIGFyZyA9IGFicyhhcmd1bWVudHNbaSsrXSk7XG4gICAgICBpZiAobGFyZyA8IGFyZykge1xuICAgICAgICBkaXYgPSBsYXJnIC8gYXJnO1xuICAgICAgICBzdW0gPSBzdW0gKiBkaXYgKiBkaXYgKyAxO1xuICAgICAgICBsYXJnID0gYXJnO1xuICAgICAgfSBlbHNlIGlmIChhcmcgPiAwKSB7XG4gICAgICAgIGRpdiA9IGFyZyAvIGxhcmc7XG4gICAgICAgIHN1bSArPSBkaXYgKiBkaXY7XG4gICAgICB9IGVsc2Ugc3VtICs9IGFyZztcbiAgICB9XG4gICAgcmV0dXJuIGxhcmcgPT09IEluZmluaXR5ID8gSW5maW5pdHkgOiBsYXJnICogc3FydChzdW0pO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBuYXRpdmVJbXVsID0gTWF0aC5pbXVsO1xuXG52YXIgRk9SQ0VEID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmF0aXZlSW11bCgweEZGRkZGRkZGLCA1KSAhPSAtNSB8fCBuYXRpdmVJbXVsLmxlbmd0aCAhPSAyO1xufSk7XG5cbi8vIGBNYXRoLmltdWxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbWF0aC5pbXVsXG4vLyBzb21lIFdlYktpdCB2ZXJzaW9ucyBmYWlscyB3aXRoIGJpZyBudW1iZXJzLCBzb21lIGhhcyB3cm9uZyBhcml0eVxuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIGltdWw6IGZ1bmN0aW9uIGltdWwoeCwgeSkge1xuICAgIHZhciBVSU5UMTYgPSAweEZGRkY7XG4gICAgdmFyIHhuID0gK3g7XG4gICAgdmFyIHluID0gK3k7XG4gICAgdmFyIHhsID0gVUlOVDE2ICYgeG47XG4gICAgdmFyIHlsID0gVUlOVDE2ICYgeW47XG4gICAgcmV0dXJuIDAgfCB4bCAqIHlsICsgKChVSU5UMTYgJiB4biA+Pj4gMTYpICogeWwgKyB4bCAqIChVSU5UMTYgJiB5biA+Pj4gMTYpIDw8IDE2ID4+PiAwKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExPRzEwRSA9IE1hdGguTE9HMTBFO1xuXG4vLyBgTWF0aC5sb2cxMGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzEwXG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUgfSwge1xuICBsb2cxMDogZnVuY3Rpb24gbG9nMTAoeCkge1xuICAgIHJldHVybiBsb2coeCkgKiBMT0cxMEU7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgbG9nMXAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbWF0aC1sb2cxcCcpO1xuXG4vLyBgTWF0aC5sb2cxcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLmxvZzFwXG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUgfSwgeyBsb2cxcDogbG9nMXAgfSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxudmFyIGxvZyA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG4vLyBgTWF0aC5sb2cyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGgubG9nMlxuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcbiAgbG9nMjogZnVuY3Rpb24gbG9nMih4KSB7XG4gICAgcmV0dXJuIGxvZyh4KSAvIExOMjtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBzaWduID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtc2lnbicpO1xuXG4vLyBgTWF0aC5zaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW1hdGguc2lnblxuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlIH0sIHtcbiAgc2lnbjogc2lnblxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIGV4cG0xID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL21hdGgtZXhwbTEnKTtcblxudmFyIGFicyA9IE1hdGguYWJzO1xudmFyIGV4cCA9IE1hdGguZXhwO1xudmFyIEUgPSBNYXRoLkU7XG5cbnZhciBGT1JDRUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBNYXRoLnNpbmgoLTJlLTE3KSAhPSAtMmUtMTc7XG59KTtcblxuLy8gYE1hdGguc2luaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLnNpbmhcbi8vIFY4IG5lYXIgQ2hyb21pdW0gMzggaGFzIGEgcHJvYmxlbSB3aXRoIHZlcnkgc21hbGwgbnVtYmVyc1xuJCh7IHRhcmdldDogJ01hdGgnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHNpbmg6IGZ1bmN0aW9uIHNpbmgoeCkge1xuICAgIHJldHVybiBhYnMoeCA9ICt4KSA8IDEgPyAoZXhwbTEoeCkgLSBleHBtMSgteCkpIC8gMiA6IChleHAoeCAtIDEpIC0gZXhwKC14IC0gMSkpICogKEUgLyAyKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBleHBtMSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9tYXRoLWV4cG0xJyk7XG5cbnZhciBleHAgPSBNYXRoLmV4cDtcblxuLy8gYE1hdGgudGFuaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLnRhbmhcbiQoeyB0YXJnZXQ6ICdNYXRoJywgc3RhdDogdHJ1ZSB9LCB7XG4gIHRhbmg6IGZ1bmN0aW9uIHRhbmgoeCkge1xuICAgIHZhciBhID0gZXhwbTEoeCA9ICt4KTtcbiAgICB2YXIgYiA9IGV4cG0xKC14KTtcbiAgICByZXR1cm4gYSA9PSBJbmZpbml0eSA/IDEgOiBiID09IEluZmluaXR5ID8gLTEgOiAoYSAtIGIpIC8gKGV4cCh4KSArIGV4cCgteCkpO1xuICB9XG59KTtcbiIsInZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xuXG4vLyBNYXRoW0BAdG9TdHJpbmdUYWddIHByb3BlcnR5XG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLUBAdG9zdHJpbmd0YWdcbnNldFRvU3RyaW5nVGFnKE1hdGgsICdNYXRoJywgdHJ1ZSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4vLyBgTWF0aC50cnVuY2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1tYXRoLnRydW5jXG4kKHsgdGFyZ2V0OiAnTWF0aCcsIHN0YXQ6IHRydWUgfSwge1xuICB0cnVuYzogZnVuY3Rpb24gdHJ1bmMoaXQpIHtcbiAgICByZXR1cm4gKGl0ID4gMCA/IGZsb29yIDogY2VpbCkoaXQpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgaW5oZXJpdElmUmVxdWlyZWQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW5oZXJpdC1pZi1yZXF1aXJlZCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJykuZjtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgdHJpbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zdHJpbmctdHJpbScpLnRyaW07XG5cbnZhciBOVU1CRVIgPSAnTnVtYmVyJztcbnZhciBOYXRpdmVOdW1iZXIgPSBnbG9iYWxbTlVNQkVSXTtcbnZhciBOdW1iZXJQcm90b3R5cGUgPSBOYXRpdmVOdW1iZXIucHJvdG90eXBlO1xuXG4vLyBPcGVyYSB+MTIgaGFzIGJyb2tlbiBPYmplY3QjdG9TdHJpbmdcbnZhciBCUk9LRU5fQ0xBU1NPRiA9IGNsYXNzb2YoY3JlYXRlKE51bWJlclByb3RvdHlwZSkpID09IE5VTUJFUjtcblxuLy8gYFRvTnVtYmVyYCBhYnN0cmFjdCBvcGVyYXRpb25cbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXRvbnVtYmVyXG52YXIgdG9OdW1iZXIgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiAgdmFyIGl0ID0gdG9QcmltaXRpdmUoYXJndW1lbnQsIGZhbHNlKTtcbiAgdmFyIGZpcnN0LCB0aGlyZCwgcmFkaXgsIG1heENvZGUsIGRpZ2l0cywgbGVuZ3RoLCBpbmRleCwgY29kZTtcbiAgaWYgKHR5cGVvZiBpdCA9PSAnc3RyaW5nJyAmJiBpdC5sZW5ndGggPiAyKSB7XG4gICAgaXQgPSB0cmltKGl0KTtcbiAgICBmaXJzdCA9IGl0LmNoYXJDb2RlQXQoMCk7XG4gICAgaWYgKGZpcnN0ID09PSA0MyB8fCBmaXJzdCA9PT0gNDUpIHtcbiAgICAgIHRoaXJkID0gaXQuY2hhckNvZGVBdCgyKTtcbiAgICAgIGlmICh0aGlyZCA9PT0gODggfHwgdGhpcmQgPT09IDEyMCkgcmV0dXJuIE5hTjsgLy8gTnVtYmVyKCcrMHgxJykgc2hvdWxkIGJlIE5hTiwgb2xkIFY4IGZpeFxuICAgIH0gZWxzZSBpZiAoZmlyc3QgPT09IDQ4KSB7XG4gICAgICBzd2l0Y2ggKGl0LmNoYXJDb2RlQXQoMSkpIHtcbiAgICAgICAgY2FzZSA2NjogY2FzZSA5ODogcmFkaXggPSAyOyBtYXhDb2RlID0gNDk7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIG9mIC9eMGJbMDFdKyQvaVxuICAgICAgICBjYXNlIDc5OiBjYXNlIDExMTogcmFkaXggPSA4OyBtYXhDb2RlID0gNTU7IGJyZWFrOyAvLyBmYXN0IGVxdWFsIG9mIC9eMG9bMC03XSskL2lcbiAgICAgICAgZGVmYXVsdDogcmV0dXJuICtpdDtcbiAgICAgIH1cbiAgICAgIGRpZ2l0cyA9IGl0LnNsaWNlKDIpO1xuICAgICAgbGVuZ3RoID0gZGlnaXRzLmxlbmd0aDtcbiAgICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjb2RlID0gZGlnaXRzLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgICAgICAvLyBwYXJzZUludCBwYXJzZXMgYSBzdHJpbmcgdG8gYSBmaXJzdCB1bmF2YWlsYWJsZSBzeW1ib2xcbiAgICAgICAgLy8gYnV0IFRvTnVtYmVyIHNob3VsZCByZXR1cm4gTmFOIGlmIGEgc3RyaW5nIGNvbnRhaW5zIHVuYXZhaWxhYmxlIHN5bWJvbHNcbiAgICAgICAgaWYgKGNvZGUgPCA0OCB8fCBjb2RlID4gbWF4Q29kZSkgcmV0dXJuIE5hTjtcbiAgICAgIH0gcmV0dXJuIHBhcnNlSW50KGRpZ2l0cywgcmFkaXgpO1xuICAgIH1cbiAgfSByZXR1cm4gK2l0O1xufTtcblxuLy8gYE51bWJlcmAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci1jb25zdHJ1Y3RvclxuaWYgKGlzRm9yY2VkKE5VTUJFUiwgIU5hdGl2ZU51bWJlcignIDBvMScpIHx8ICFOYXRpdmVOdW1iZXIoJzBiMScpIHx8IE5hdGl2ZU51bWJlcignKzB4MScpKSkge1xuICB2YXIgTnVtYmVyV3JhcHBlciA9IGZ1bmN0aW9uIE51bWJlcih2YWx1ZSkge1xuICAgIHZhciBpdCA9IGFyZ3VtZW50cy5sZW5ndGggPCAxID8gMCA6IHZhbHVlO1xuICAgIHZhciBkdW1teSA9IHRoaXM7XG4gICAgcmV0dXJuIGR1bW15IGluc3RhbmNlb2YgTnVtYmVyV3JhcHBlclxuICAgICAgLy8gY2hlY2sgb24gMS4uY29uc3RydWN0b3IoZm9vKSBjYXNlXG4gICAgICAmJiAoQlJPS0VOX0NMQVNTT0YgPyBmYWlscyhmdW5jdGlvbiAoKSB7IE51bWJlclByb3RvdHlwZS52YWx1ZU9mLmNhbGwoZHVtbXkpOyB9KSA6IGNsYXNzb2YoZHVtbXkpICE9IE5VTUJFUilcbiAgICAgICAgPyBpbmhlcml0SWZSZXF1aXJlZChuZXcgTmF0aXZlTnVtYmVyKHRvTnVtYmVyKGl0KSksIGR1bW15LCBOdW1iZXJXcmFwcGVyKSA6IHRvTnVtYmVyKGl0KTtcbiAgfTtcbiAgZm9yICh2YXIga2V5cyA9IERFU0NSSVBUT1JTID8gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVOdW1iZXIpIDogKFxuICAgIC8vIEVTMzpcbiAgICAnTUFYX1ZBTFVFLE1JTl9WQUxVRSxOYU4sTkVHQVRJVkVfSU5GSU5JVFksUE9TSVRJVkVfSU5GSU5JVFksJyArXG4gICAgLy8gRVMyMDE1IChpbiBjYXNlLCBpZiBtb2R1bGVzIHdpdGggRVMyMDE1IE51bWJlciBzdGF0aWNzIHJlcXVpcmVkIGJlZm9yZSk6XG4gICAgJ0VQU0lMT04saXNGaW5pdGUsaXNJbnRlZ2VyLGlzTmFOLGlzU2FmZUludGVnZXIsTUFYX1NBRkVfSU5URUdFUiwnICtcbiAgICAnTUlOX1NBRkVfSU5URUdFUixwYXJzZUZsb2F0LHBhcnNlSW50LGlzSW50ZWdlcidcbiAgKS5zcGxpdCgnLCcpLCBqID0gMCwga2V5OyBrZXlzLmxlbmd0aCA+IGo7IGorKykge1xuICAgIGlmIChoYXMoTmF0aXZlTnVtYmVyLCBrZXkgPSBrZXlzW2pdKSAmJiAhaGFzKE51bWJlcldyYXBwZXIsIGtleSkpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5KE51bWJlcldyYXBwZXIsIGtleSwgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5hdGl2ZU51bWJlciwga2V5KSk7XG4gICAgfVxuICB9XG4gIE51bWJlcldyYXBwZXIucHJvdG90eXBlID0gTnVtYmVyUHJvdG90eXBlO1xuICBOdW1iZXJQcm90b3R5cGUuY29uc3RydWN0b3IgPSBOdW1iZXJXcmFwcGVyO1xuICByZWRlZmluZShnbG9iYWwsIE5VTUJFUiwgTnVtYmVyV3JhcHBlcik7XG59XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxuLy8gYE51bWJlci5FUFNJTE9OYCBjb25zdGFudFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmVwc2lsb25cbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgRVBTSUxPTjogTWF0aC5wb3coMiwgLTUyKVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBudW1iZXJJc0Zpbml0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9udW1iZXItaXMtZmluaXRlJyk7XG5cbi8vIGBOdW1iZXIuaXNGaW5pdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmlzZmluaXRlXG4kKHsgdGFyZ2V0OiAnTnVtYmVyJywgc3RhdDogdHJ1ZSB9LCB7IGlzRmluaXRlOiBudW1iZXJJc0Zpbml0ZSB9KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1pbnRlZ2VyJyk7XG5cbi8vIGBOdW1iZXIuaXNJbnRlZ2VyYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5pc2ludGVnZXJcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXNJbnRlZ2VyOiBpc0ludGVnZXJcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG5cbi8vIGBOdW1iZXIuaXNOYU5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmlzbmFuXG4kKHsgdGFyZ2V0OiAnTnVtYmVyJywgc3RhdDogdHJ1ZSB9LCB7XG4gIGlzTmFOOiBmdW5jdGlvbiBpc05hTihudW1iZXIpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gICAgcmV0dXJuIG51bWJlciAhPSBudW1iZXI7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXNJbnRlZ2VyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLWludGVnZXInKTtcblxudmFyIGFicyA9IE1hdGguYWJzO1xuXG4vLyBgTnVtYmVyLmlzU2FmZUludGVnZXJgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLmlzc2FmZWludGVnZXJcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXNTYWZlSW50ZWdlcjogZnVuY3Rpb24gaXNTYWZlSW50ZWdlcihudW1iZXIpIHtcbiAgICByZXR1cm4gaXNJbnRlZ2VyKG51bWJlcikgJiYgYWJzKG51bWJlcikgPD0gMHgxRkZGRkZGRkZGRkZGRjtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxuLy8gYE51bWJlci5NQVhfU0FGRV9JTlRFR0VSYCBjb25zdGFudFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLm1heF9zYWZlX2ludGVnZXJcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgTUFYX1NBRkVfSU5URUdFUjogMHgxRkZGRkZGRkZGRkZGRlxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxuLy8gYE51bWJlci5NSU5fU0FGRV9JTlRFR0VSYCBjb25zdGFudFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLm1pbl9zYWZlX2ludGVnZXJcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlIH0sIHtcbiAgTUlOX1NBRkVfSU5URUdFUjogLTB4MUZGRkZGRkZGRkZGRkZcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgcGFyc2VGbG9hdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXJzZS1mbG9hdCcpO1xuXG4vLyBgTnVtYmVyLnBhcnNlRmxvYXRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLnBhcnNlRmxvYXRcbiQoeyB0YXJnZXQ6ICdOdW1iZXInLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE51bWJlci5wYXJzZUZsb2F0ICE9IHBhcnNlRmxvYXQgfSwge1xuICBwYXJzZUZsb2F0OiBwYXJzZUZsb2F0XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlSW50ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhcnNlLWludCcpO1xuXG4vLyBgTnVtYmVyLnBhcnNlSW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5wYXJzZWludFxuJCh7IHRhcmdldDogJ051bWJlcicsIHN0YXQ6IHRydWUsIGZvcmNlZDogTnVtYmVyLnBhcnNlSW50ICE9IHBhcnNlSW50IH0sIHtcbiAgcGFyc2VJbnQ6IHBhcnNlSW50XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgdGhpc051bWJlclZhbHVlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RoaXMtbnVtYmVyLXZhbHVlJyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgbmF0aXZlVG9GaXhlZCA9IDEuMC50b0ZpeGVkO1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxudmFyIHBvdyA9IGZ1bmN0aW9uICh4LCBuLCBhY2MpIHtcbiAgcmV0dXJuIG4gPT09IDAgPyBhY2MgOiBuICUgMiA9PT0gMSA/IHBvdyh4LCBuIC0gMSwgYWNjICogeCkgOiBwb3coeCAqIHgsIG4gLyAyLCBhY2MpO1xufTtcblxudmFyIGxvZyA9IGZ1bmN0aW9uICh4KSB7XG4gIHZhciBuID0gMDtcbiAgdmFyIHgyID0geDtcbiAgd2hpbGUgKHgyID49IDQwOTYpIHtcbiAgICBuICs9IDEyO1xuICAgIHgyIC89IDQwOTY7XG4gIH1cbiAgd2hpbGUgKHgyID49IDIpIHtcbiAgICBuICs9IDE7XG4gICAgeDIgLz0gMjtcbiAgfSByZXR1cm4gbjtcbn07XG5cbnZhciBGT1JDRUQgPSBuYXRpdmVUb0ZpeGVkICYmIChcbiAgMC4wMDAwOC50b0ZpeGVkKDMpICE9PSAnMC4wMDAnIHx8XG4gIDAuOS50b0ZpeGVkKDApICE9PSAnMScgfHxcbiAgMS4yNTUudG9GaXhlZCgyKSAhPT0gJzEuMjUnIHx8XG4gIDEwMDAwMDAwMDAwMDAwMDAxMjguMC50b0ZpeGVkKDApICE9PSAnMTAwMDAwMDAwMDAwMDAwMDEyOCdcbikgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgbmF0aXZlVG9GaXhlZC5jYWxsKHt9KTtcbn0pO1xuXG4vLyBgTnVtYmVyLnByb3RvdHlwZS50b0ZpeGVkYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW51bWJlci5wcm90b3R5cGUudG9maXhlZFxuJCh7IHRhcmdldDogJ051bWJlcicsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtc3RhdGVtZW50c1xuICB0b0ZpeGVkOiBmdW5jdGlvbiB0b0ZpeGVkKGZyYWN0aW9uRGlnaXRzKSB7XG4gICAgdmFyIG51bWJlciA9IHRoaXNOdW1iZXJWYWx1ZSh0aGlzKTtcbiAgICB2YXIgZnJhY3REaWdpdHMgPSB0b0ludGVnZXIoZnJhY3Rpb25EaWdpdHMpO1xuICAgIHZhciBkYXRhID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciBzaWduID0gJyc7XG4gICAgdmFyIHJlc3VsdCA9ICcwJztcbiAgICB2YXIgZSwgeiwgaiwgaztcblxuICAgIHZhciBtdWx0aXBseSA9IGZ1bmN0aW9uIChuLCBjKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgIHZhciBjMiA9IGM7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IDYpIHtcbiAgICAgICAgYzIgKz0gbiAqIGRhdGFbaW5kZXhdO1xuICAgICAgICBkYXRhW2luZGV4XSA9IGMyICUgMWU3O1xuICAgICAgICBjMiA9IGZsb29yKGMyIC8gMWU3KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdmFyIGRpdmlkZSA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICB2YXIgaW5kZXggPSA2O1xuICAgICAgdmFyIGMgPSAwO1xuICAgICAgd2hpbGUgKC0taW5kZXggPj0gMCkge1xuICAgICAgICBjICs9IGRhdGFbaW5kZXhdO1xuICAgICAgICBkYXRhW2luZGV4XSA9IGZsb29yKGMgLyBuKTtcbiAgICAgICAgYyA9IChjICUgbikgKiAxZTc7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkYXRhVG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgaW5kZXggPSA2O1xuICAgICAgdmFyIHMgPSAnJztcbiAgICAgIHdoaWxlICgtLWluZGV4ID49IDApIHtcbiAgICAgICAgaWYgKHMgIT09ICcnIHx8IGluZGV4ID09PSAwIHx8IGRhdGFbaW5kZXhdICE9PSAwKSB7XG4gICAgICAgICAgdmFyIHQgPSBTdHJpbmcoZGF0YVtpbmRleF0pO1xuICAgICAgICAgIHMgPSBzID09PSAnJyA/IHQgOiBzICsgcmVwZWF0LmNhbGwoJzAnLCA3IC0gdC5sZW5ndGgpICsgdDtcbiAgICAgICAgfVxuICAgICAgfSByZXR1cm4gcztcbiAgICB9O1xuXG4gICAgaWYgKGZyYWN0RGlnaXRzIDwgMCB8fCBmcmFjdERpZ2l0cyA+IDIwKSB0aHJvdyBSYW5nZUVycm9yKCdJbmNvcnJlY3QgZnJhY3Rpb24gZGlnaXRzJyk7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNlbGYtY29tcGFyZVxuICAgIGlmIChudW1iZXIgIT0gbnVtYmVyKSByZXR1cm4gJ05hTic7XG4gICAgaWYgKG51bWJlciA8PSAtMWUyMSB8fCBudW1iZXIgPj0gMWUyMSkgcmV0dXJuIFN0cmluZyhudW1iZXIpO1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICBzaWduID0gJy0nO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA+IDFlLTIxKSB7XG4gICAgICBlID0gbG9nKG51bWJlciAqIHBvdygyLCA2OSwgMSkpIC0gNjk7XG4gICAgICB6ID0gZSA8IDAgPyBudW1iZXIgKiBwb3coMiwgLWUsIDEpIDogbnVtYmVyIC8gcG93KDIsIGUsIDEpO1xuICAgICAgeiAqPSAweDEwMDAwMDAwMDAwMDAwO1xuICAgICAgZSA9IDUyIC0gZTtcbiAgICAgIGlmIChlID4gMCkge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgaiA9IGZyYWN0RGlnaXRzO1xuICAgICAgICB3aGlsZSAoaiA+PSA3KSB7XG4gICAgICAgICAgbXVsdGlwbHkoMWU3LCAwKTtcbiAgICAgICAgICBqIC09IDc7XG4gICAgICAgIH1cbiAgICAgICAgbXVsdGlwbHkocG93KDEwLCBqLCAxKSwgMCk7XG4gICAgICAgIGogPSBlIC0gMTtcbiAgICAgICAgd2hpbGUgKGogPj0gMjMpIHtcbiAgICAgICAgICBkaXZpZGUoMSA8PCAyMyk7XG4gICAgICAgICAgaiAtPSAyMztcbiAgICAgICAgfVxuICAgICAgICBkaXZpZGUoMSA8PCBqKTtcbiAgICAgICAgbXVsdGlwbHkoMSwgMSk7XG4gICAgICAgIGRpdmlkZSgyKTtcbiAgICAgICAgcmVzdWx0ID0gZGF0YVRvU3RyaW5nKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtdWx0aXBseSgwLCB6KTtcbiAgICAgICAgbXVsdGlwbHkoMSA8PCAtZSwgMCk7XG4gICAgICAgIHJlc3VsdCA9IGRhdGFUb1N0cmluZygpICsgcmVwZWF0LmNhbGwoJzAnLCBmcmFjdERpZ2l0cyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFjdERpZ2l0cyA+IDApIHtcbiAgICAgIGsgPSByZXN1bHQubGVuZ3RoO1xuICAgICAgcmVzdWx0ID0gc2lnbiArIChrIDw9IGZyYWN0RGlnaXRzXG4gICAgICAgID8gJzAuJyArIHJlcGVhdC5jYWxsKCcwJywgZnJhY3REaWdpdHMgLSBrKSArIHJlc3VsdFxuICAgICAgICA6IHJlc3VsdC5zbGljZSgwLCBrIC0gZnJhY3REaWdpdHMpICsgJy4nICsgcmVzdWx0LnNsaWNlKGsgLSBmcmFjdERpZ2l0cykpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQgPSBzaWduICsgcmVzdWx0O1xuICAgIH0gcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHRoaXNOdW1iZXJWYWx1ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90aGlzLW51bWJlci12YWx1ZScpO1xuXG52YXIgbmF0aXZlVG9QcmVjaXNpb24gPSAxLjAudG9QcmVjaXNpb247XG5cbnZhciBGT1JDRUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIElFNy1cbiAgcmV0dXJuIG5hdGl2ZVRvUHJlY2lzaW9uLmNhbGwoMSwgdW5kZWZpbmVkKSAhPT0gJzEnO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gVjggfiBBbmRyb2lkIDQuMy1cbiAgbmF0aXZlVG9QcmVjaXNpb24uY2FsbCh7fSk7XG59KTtcblxuLy8gYE51bWJlci5wcm90b3R5cGUudG9QcmVjaXNpb25gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtbnVtYmVyLnByb3RvdHlwZS50b3ByZWNpc2lvblxuJCh7IHRhcmdldDogJ051bWJlcicsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHRvUHJlY2lzaW9uOiBmdW5jdGlvbiB0b1ByZWNpc2lvbihwcmVjaXNpb24pIHtcbiAgICByZXR1cm4gcHJlY2lzaW9uID09PSB1bmRlZmluZWRcbiAgICAgID8gbmF0aXZlVG9QcmVjaXNpb24uY2FsbCh0aGlzTnVtYmVyVmFsdWUodGhpcykpXG4gICAgICA6IG5hdGl2ZVRvUHJlY2lzaW9uLmNhbGwodGhpc051bWJlclZhbHVlKHRoaXMpLCBwcmVjaXNpb24pO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtYXNzaWduJyk7XG5cbi8vIGBPYmplY3QuYXNzaWduYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5hc3NpZ25cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IE9iamVjdC5hc3NpZ24gIT09IGFzc2lnbiB9LCB7XG4gIGFzc2lnbjogYXNzaWduXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcblxuLy8gYE9iamVjdC5jcmVhdGVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmNyZWF0ZVxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGNyZWF0ZTogY3JlYXRlXG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgRk9SQ0VEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1vYmplY3QtcHJvdG90eXBlLWFjY2Vzc29ycy1tZXRob2RzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5Jyk7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLl9fZGVmaW5lR2V0dGVyX19gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZUdldHRlcl9fXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgJCh7IHRhcmdldDogJ09iamVjdCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gICAgX19kZWZpbmVHZXR0ZXJfXzogZnVuY3Rpb24gX19kZWZpbmVHZXR0ZXJfXyhQLCBnZXR0ZXIpIHtcbiAgICAgIGRlZmluZVByb3BlcnR5TW9kdWxlLmYodG9PYmplY3QodGhpcyksIFAsIHsgZ2V0OiBhRnVuY3Rpb24oZ2V0dGVyKSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuICAgIH1cbiAgfSk7XG59XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGRlZmluZVByb3BlcnRpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0aWVzJyk7XG5cbi8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZGVmaW5lcHJvcGVydGllc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIURFU0NSSVBUT1JTLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0aWVzOiBkZWZpbmVQcm9wZXJ0aWVzXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgb2JqZWN0RGVmaW5lUHJvcGVydHlNb2RpbGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG4vLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0eVxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogIURFU0NSSVBUT1JTLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICBkZWZpbmVQcm9wZXJ0eTogb2JqZWN0RGVmaW5lUHJvcGVydHlNb2RpbGUuZlxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIEZPUkNFRCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtb2JqZWN0LXByb3RvdHlwZS1hY2Nlc3NvcnMtbWV0aG9kcycpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xuXG4vLyBgT2JqZWN0LnByb3RvdHlwZS5fX2RlZmluZVNldHRlcl9fYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUuX19kZWZpbmVTZXR0ZXJfX1xuaWYgKERFU0NSSVBUT1JTKSB7XG4gICQoeyB0YXJnZXQ6ICdPYmplY3QnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAgIF9fZGVmaW5lU2V0dGVyX186IGZ1bmN0aW9uIF9fZGVmaW5lU2V0dGVyX18oUCwgc2V0dGVyKSB7XG4gICAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKHRvT2JqZWN0KHRoaXMpLCBQLCB7IHNldDogYUZ1bmN0aW9uKHNldHRlciksIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJGVudHJpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXRvLWFycmF5JykuZW50cmllcztcblxuLy8gYE9iamVjdC5lbnRyaWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5lbnRyaWVzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGVudHJpZXM6IGZ1bmN0aW9uIGVudHJpZXMoTykge1xuICAgIHJldHVybiAkZW50cmllcyhPKTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBGUkVFWklORyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mcmVlemluZycpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgb25GcmVlemUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKS5vbkZyZWV6ZTtcblxudmFyIG5hdGl2ZUZyZWV6ZSA9IE9iamVjdC5mcmVlemU7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlRnJlZXplKDEpOyB9KTtcblxuLy8gYE9iamVjdC5mcmVlemVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmZyZWV6ZVxuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUywgc2hhbTogIUZSRUVaSU5HIH0sIHtcbiAgZnJlZXplOiBmdW5jdGlvbiBmcmVlemUoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlRnJlZXplICYmIGlzT2JqZWN0KGl0KSA/IG5hdGl2ZUZyZWV6ZShvbkZyZWV6ZShpdCkpIDogaXQ7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgY3JlYXRlUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5Jyk7XG5cbi8vIGBPYmplY3QuZnJvbUVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvcHJvcG9zYWwtb2JqZWN0LWZyb20tZW50cmllc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBmcm9tRW50cmllczogZnVuY3Rpb24gZnJvbUVudHJpZXMoaXRlcmFibGUpIHtcbiAgICB2YXIgb2JqID0ge307XG4gICAgaXRlcmF0ZShpdGVyYWJsZSwgZnVuY3Rpb24gKGssIHYpIHtcbiAgICAgIGNyZWF0ZVByb3BlcnR5KG9iaiwgaywgdik7XG4gICAgfSwgdW5kZWZpbmVkLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG5cbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoMSk7IH0pO1xudmFyIEZPUkNFRCA9ICFERVNDUklQVE9SUyB8fCBGQUlMU19PTl9QUklNSVRJVkVTO1xuXG4vLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGl0LCBrZXkpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRvSW5kZXhlZE9iamVjdChpdCksIGtleSk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgREVTQ1JJUFRPUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVzY3JpcHRvcnMnKTtcbnZhciBvd25LZXlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL293bi1rZXlzJyk7XG52YXIgdG9JbmRleGVkT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWluZGV4ZWQtb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBjcmVhdGVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtcHJvcGVydHknKTtcblxuLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhvYmplY3QpIHtcbiAgICB2YXIgTyA9IHRvSW5kZXhlZE9iamVjdChvYmplY3QpO1xuICAgIHZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZjtcbiAgICB2YXIga2V5cyA9IG93bktleXMoTyk7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIGtleSwgZGVzY3JpcHRvcjtcbiAgICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkge1xuICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBrZXkgPSBrZXlzW2luZGV4KytdKTtcbiAgICAgIGlmIChkZXNjcmlwdG9yICE9PSB1bmRlZmluZWQpIGNyZWF0ZVByb3BlcnR5KHJlc3VsdCwga2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktbmFtZXMtZXh0ZXJuYWwnKS5mO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcygxKTsgfSk7XG5cbi8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0b3ducHJvcGVydHluYW1lc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGdldE93blByb3BlcnR5TmFtZXM6IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXNcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciBuYXRpdmVHZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LXByb3RvdHlwZS1vZicpO1xudmFyIENPUlJFQ1RfUFJPVE9UWVBFX0dFVFRFUiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LXByb3RvdHlwZS1nZXR0ZXInKTtcblxudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUdldFByb3RvdHlwZU9mKDEpOyB9KTtcblxuLy8gYE9iamVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuZ2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMsIHNoYW06ICFDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgfSwge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlR2V0UHJvdG90eXBlT2YodG9PYmplY3QoaXQpKTtcbiAgfVxufSk7XG5cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBuYXRpdmVJc0V4dGVuc2libGUgPSBPYmplY3QuaXNFeHRlbnNpYmxlO1xudmFyIEZBSUxTX09OX1BSSU1JVElWRVMgPSBmYWlscyhmdW5jdGlvbiAoKSB7IG5hdGl2ZUlzRXh0ZW5zaWJsZSgxKTsgfSk7XG5cbi8vIGBPYmplY3QuaXNFeHRlbnNpYmxlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5pc2V4dGVuc2libGVcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZBSUxTX09OX1BSSU1JVElWRVMgfSwge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZShpdCkge1xuICAgIHJldHVybiBpc09iamVjdChpdCkgPyBuYXRpdmVJc0V4dGVuc2libGUgPyBuYXRpdmVJc0V4dGVuc2libGUoaXQpIDogdHJ1ZSA6IGZhbHNlO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBuYXRpdmVJc0Zyb3plbiA9IE9iamVjdC5pc0Zyb3plbjtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVJc0Zyb3plbigxKTsgfSk7XG5cbi8vIGBPYmplY3QuaXNGcm96ZW5gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmlzZnJvemVuXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAgaXNGcm96ZW46IGZ1bmN0aW9uIGlzRnJvemVuKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IG5hdGl2ZUlzRnJvemVuID8gbmF0aXZlSXNGcm96ZW4oaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG5cbnZhciBuYXRpdmVJc1NlYWxlZCA9IE9iamVjdC5pc1NlYWxlZDtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVJc1NlYWxlZCgxKTsgfSk7XG5cbi8vIGBPYmplY3QuaXNTZWFsZWRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0Lmlzc2VhbGVkXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTIH0sIHtcbiAgaXNTZWFsZWQ6IGZ1bmN0aW9uIGlzU2VhbGVkKGl0KSB7XG4gICAgcmV0dXJuIGlzT2JqZWN0KGl0KSA/IG5hdGl2ZUlzU2VhbGVkID8gbmF0aXZlSXNTZWFsZWQoaXQpIDogZmFsc2UgOiB0cnVlO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NhbWUtdmFsdWUnKTtcblxuLy8gYE9iamVjdC5pc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3QuaXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgaXM6IGlzXG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIG5hdGl2ZUtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlS2V5cygxKTsgfSk7XG5cbi8vIGBPYmplY3Qua2V5c2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Qua2V5c1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUyB9LCB7XG4gIGtleXM6IGZ1bmN0aW9uIGtleXMoaXQpIHtcbiAgICByZXR1cm4gbmF0aXZlS2V5cyh0b09iamVjdChpdCkpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgRk9SQ0VEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1vYmplY3QtcHJvdG90eXBlLWFjY2Vzc29ycy1tZXRob2RzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwR2V0dGVyX19gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cEdldHRlcl9fXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgJCh7IHRhcmdldDogJ09iamVjdCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gICAgX19sb29rdXBHZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBHZXR0ZXJfXyhQKSB7XG4gICAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgICAgdmFyIGRlc2M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSkpIHJldHVybiBkZXNjLmdldDtcbiAgICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gICAgfVxuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgRk9SQ0VEID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1vYmplY3QtcHJvdG90eXBlLWFjY2Vzc29ycy1tZXRob2RzJyk7XG52YXIgdG9PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tb2JqZWN0Jyk7XG52YXIgdG9QcmltaXRpdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tcHJpbWl0aXZlJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpLmY7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLl9fbG9va3VwU2V0dGVyX19gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LnByb3RvdHlwZS5fX2xvb2t1cFNldHRlcl9fXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgJCh7IHRhcmdldDogJ09iamVjdCcsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gICAgX19sb29rdXBTZXR0ZXJfXzogZnVuY3Rpb24gX19sb29rdXBTZXR0ZXJfXyhQKSB7XG4gICAgICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICAgICAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICAgICAgdmFyIGRlc2M7XG4gICAgICBkbyB7XG4gICAgICAgIGlmIChkZXNjID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIGtleSkpIHJldHVybiBkZXNjLnNldDtcbiAgICAgIH0gd2hpbGUgKE8gPSBnZXRQcm90b3R5cGVPZihPKSk7XG4gICAgfVxuICB9KTtcbn1cbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIG9uRnJlZXplID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLW1ldGFkYXRhJykub25GcmVlemU7XG52YXIgRlJFRVpJTkcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZnJlZXppbmcnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgbmF0aXZlUHJldmVudEV4dGVuc2lvbnMgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnM7XG52YXIgRkFJTFNfT05fUFJJTUlUSVZFUyA9IGZhaWxzKGZ1bmN0aW9uICgpIHsgbmF0aXZlUHJldmVudEV4dGVuc2lvbnMoMSk7IH0pO1xuXG4vLyBgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcmV2ZW50ZXh0ZW5zaW9uc1xuJCh7IHRhcmdldDogJ09iamVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRkFJTFNfT05fUFJJTUlUSVZFUywgc2hhbTogIUZSRUVaSU5HIH0sIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZVByZXZlbnRFeHRlbnNpb25zICYmIGlzT2JqZWN0KGl0KSA/IG5hdGl2ZVByZXZlbnRFeHRlbnNpb25zKG9uRnJlZXplKGl0KSkgOiBpdDtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBvbkZyZWV6ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbnRlcm5hbC1tZXRhZGF0YScpLm9uRnJlZXplO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIG5hdGl2ZVNlYWwgPSBPYmplY3Quc2VhbDtcbnZhciBGQUlMU19PTl9QUklNSVRJVkVTID0gZmFpbHMoZnVuY3Rpb24gKCkgeyBuYXRpdmVTZWFsKDEpOyB9KTtcblxuLy8gYE9iamVjdC5zZWFsYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5zZWFsXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGQUlMU19PTl9QUklNSVRJVkVTLCBzaGFtOiAhRlJFRVpJTkcgfSwge1xuICBzZWFsOiBmdW5jdGlvbiBzZWFsKGl0KSB7XG4gICAgcmV0dXJuIG5hdGl2ZVNlYWwgJiYgaXNPYmplY3QoaXQpID8gbmF0aXZlU2VhbChvbkZyZWV6ZShpdCkpIDogaXQ7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgc2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gYE9iamVjdC5zZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1vYmplY3Quc2V0cHJvdG90eXBlb2ZcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgc2V0UHJvdG90eXBlT2Y6IHNldFByb3RvdHlwZU9mXG59KTtcbiIsInZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHRvU3RyaW5nID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC10by1zdHJpbmcnKTtcblxudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8vIGBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmdcbmlmICh0b1N0cmluZyAhPT0gT2JqZWN0UHJvdG90eXBlLnRvU3RyaW5nKSB7XG4gIHJlZGVmaW5lKE9iamVjdFByb3RvdHlwZSwgJ3RvU3RyaW5nJywgdG9TdHJpbmcsIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHZhbHVlcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtdG8tYXJyYXknKS52YWx1ZXM7XG5cbi8vIGBPYmplY3QudmFsdWVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC52YWx1ZXNcbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoTykge1xuICAgIHJldHVybiAkdmFsdWVzKE8pO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHBhcnNlRmxvYXRJbXBsZW1lbnRhdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXJzZS1mbG9hdCcpO1xuXG4vLyBgcGFyc2VGbG9hdGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wYXJzZWZsb2F0LXN0cmluZ1xuJCh7IGdsb2JhbDogdHJ1ZSwgZm9yY2VkOiBwYXJzZUZsb2F0ICE9IHBhcnNlRmxvYXRJbXBsZW1lbnRhdGlvbiB9LCB7XG4gIHBhcnNlRmxvYXQ6IHBhcnNlRmxvYXRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBwYXJzZUludEltcGxlbWVudGF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhcnNlLWludCcpO1xuXG4vLyBgcGFyc2VJbnRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcGFyc2VpbnQtc3RyaW5nLXJhZGl4XG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHBhcnNlSW50ICE9IHBhcnNlSW50SW1wbGVtZW50YXRpb24gfSwge1xuICBwYXJzZUludDogcGFyc2VJbnRJbXBsZW1lbnRhdGlvblxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgcHJvbWlzZVJlc29sdmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcHJvbWlzZS1yZXNvbHZlJyk7XG5cbi8vIGBQcm9taXNlLnByb3RvdHlwZS5maW5hbGx5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmZpbmFsbHlcbiQoeyB0YXJnZXQ6ICdQcm9taXNlJywgcHJvdG86IHRydWUsIHJlYWw6IHRydWUgfSwge1xuICAnZmluYWxseSc6IGZ1bmN0aW9uIChvbkZpbmFsbHkpIHtcbiAgICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCBnZXRCdWlsdEluKCdQcm9taXNlJykpO1xuICAgIHZhciBpc0Z1bmN0aW9uID0gdHlwZW9mIG9uRmluYWxseSA9PSAnZnVuY3Rpb24nO1xuICAgIHJldHVybiB0aGlzLnRoZW4oXG4gICAgICBpc0Z1bmN0aW9uID8gZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKEMsIG9uRmluYWxseSgpKS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHg7IH0pO1xuICAgICAgfSA6IG9uRmluYWxseSxcbiAgICAgIGlzRnVuY3Rpb24gPyBmdW5jdGlvbiAoZSkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVJlc29sdmUoQywgb25GaW5hbGx5KCkpLnRoZW4oZnVuY3Rpb24gKCkgeyB0aHJvdyBlOyB9KTtcbiAgICAgIH0gOiBvbkZpbmFsbHlcbiAgICApO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIElTX1BVUkUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcHVyZScpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBwYXRoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BhdGgnKTtcbnZhciByZWRlZmluZUFsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZS1hbGwnKTtcbnZhciBzZXRUb1N0cmluZ1RhZyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zZXQtdG8tc3RyaW5nLXRhZycpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhRnVuY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYS1mdW5jdGlvbicpO1xudmFyIGFuSW5zdGFuY2UgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4taW5zdGFuY2UnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pdGVyYXRlJyk7XG52YXIgY2hlY2tDb3JyZWN0bmVzc09mSXRlcmF0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NoZWNrLWNvcnJlY3RuZXNzLW9mLWl0ZXJhdGlvbicpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJykuc2V0O1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9taWNyb3Rhc2snKTtcbnZhciBwcm9taXNlUmVzb2x2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wcm9taXNlLXJlc29sdmUnKTtcbnZhciBob3N0UmVwb3J0RXJyb3JzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hvc3QtcmVwb3J0LWVycm9ycycpO1xudmFyIG5ld1Byb21pc2VDYXBhYmlsaXR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25ldy1wcm9taXNlLWNhcGFiaWxpdHknKTtcbnZhciBwZXJmb3JtID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3BlcmZvcm0nKTtcbnZhciB1c2VyQWdlbnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdXNlci1hZ2VudCcpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIFNQRUNJRVMgPSB3ZWxsS25vd25TeW1ib2woJ3NwZWNpZXMnKTtcbnZhciBQUk9NSVNFID0gJ1Byb21pc2UnO1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldDtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxQcm9taXNlU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihQUk9NSVNFKTtcbnZhciBQcm9taXNlQ29uc3RydWN0b3IgPSBnbG9iYWxbUFJPTUlTRV07XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBkb2N1bWVudCA9IGdsb2JhbC5kb2N1bWVudDtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgJGZldGNoID0gZ2xvYmFsLmZldGNoO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjggfHwgJyc7XG52YXIgbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mO1xudmFyIG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5O1xudmFyIElTX05PREUgPSBjbGFzc29mKHByb2Nlc3MpID09ICdwcm9jZXNzJztcbnZhciBESVNQQVRDSF9FVkVOVCA9ICEhKGRvY3VtZW50ICYmIGRvY3VtZW50LmNyZWF0ZUV2ZW50ICYmIGdsb2JhbC5kaXNwYXRjaEV2ZW50KTtcbnZhciBVTkhBTkRMRURfUkVKRUNUSU9OID0gJ3VuaGFuZGxlZHJlamVjdGlvbic7XG52YXIgUkVKRUNUSU9OX0hBTkRMRUQgPSAncmVqZWN0aW9uaGFuZGxlZCc7XG52YXIgUEVORElORyA9IDA7XG52YXIgRlVMRklMTEVEID0gMTtcbnZhciBSRUpFQ1RFRCA9IDI7XG52YXIgSEFORExFRCA9IDE7XG52YXIgVU5IQU5ETEVEID0gMjtcbnZhciBJbnRlcm5hbCwgT3duUHJvbWlzZUNhcGFiaWxpdHksIFByb21pc2VXcmFwcGVyO1xuXG52YXIgRk9SQ0VEID0gaXNGb3JjZWQoUFJPTUlTRSwgZnVuY3Rpb24gKCkge1xuICAvLyBjb3JyZWN0IHN1YmNsYXNzaW5nIHdpdGggQEBzcGVjaWVzIHN1cHBvcnRcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlQ29uc3RydWN0b3IucmVzb2x2ZSgxKTtcbiAgdmFyIGVtcHR5ID0gZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9O1xuICB2YXIgRmFrZVByb21pc2UgPSAocHJvbWlzZS5jb25zdHJ1Y3RvciA9IHt9KVtTUEVDSUVTXSA9IGZ1bmN0aW9uIChleGVjKSB7XG4gICAgZXhlYyhlbXB0eSwgZW1wdHkpO1xuICB9O1xuICAvLyB1bmhhbmRsZWQgcmVqZWN0aW9ucyB0cmFja2luZyBzdXBwb3J0LCBOb2RlSlMgUHJvbWlzZSB3aXRob3V0IGl0IGZhaWxzIEBAc3BlY2llcyB0ZXN0XG4gIHJldHVybiAhKChJU19OT0RFIHx8IHR5cGVvZiBQcm9taXNlUmVqZWN0aW9uRXZlbnQgPT0gJ2Z1bmN0aW9uJylcbiAgICAmJiAoIUlTX1BVUkUgfHwgcHJvbWlzZVsnZmluYWxseSddKVxuICAgICYmIHByb21pc2UudGhlbihlbXB0eSkgaW5zdGFuY2VvZiBGYWtlUHJvbWlzZVxuICAgIC8vIHY4IDYuNiAoTm9kZSAxMCBhbmQgQ2hyb21lIDY2KSBoYXZlIGEgYnVnIHdpdGggcmVzb2x2aW5nIGN1c3RvbSB0aGVuYWJsZXNcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04MzA1NjVcbiAgICAvLyB3ZSBjYW4ndCBkZXRlY3QgaXQgc3luY2hyb25vdXNseSwgc28ganVzdCBjaGVjayB2ZXJzaW9uc1xuICAgICYmIHY4LmluZGV4T2YoJzYuNicpICE9PSAwXG4gICAgJiYgdXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZS82NicpID09PSAtMSk7XG59KTtcblxudmFyIElOQ09SUkVDVF9JVEVSQVRJT04gPSBGT1JDRUQgfHwgIWNoZWNrQ29ycmVjdG5lc3NPZkl0ZXJhdGlvbihmdW5jdGlvbiAoaXRlcmFibGUpIHtcbiAgUHJvbWlzZUNvbnN0cnVjdG9yLmFsbChpdGVyYWJsZSlbJ2NhdGNoJ10oZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9KTtcbn0pO1xuXG4vLyBoZWxwZXJzXG52YXIgaXNUaGVuYWJsZSA9IGZ1bmN0aW9uIChpdCkge1xuICB2YXIgdGhlbjtcbiAgcmV0dXJuIGlzT2JqZWN0KGl0KSAmJiB0eXBlb2YgKHRoZW4gPSBpdC50aGVuKSA9PSAnZnVuY3Rpb24nID8gdGhlbiA6IGZhbHNlO1xufTtcblxudmFyIG5vdGlmeSA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgaXNSZWplY3QpIHtcbiAgaWYgKHN0YXRlLm5vdGlmaWVkKSByZXR1cm47XG4gIHN0YXRlLm5vdGlmaWVkID0gdHJ1ZTtcbiAgdmFyIGNoYWluID0gc3RhdGUucmVhY3Rpb25zO1xuICBtaWNyb3Rhc2soZnVuY3Rpb24gKCkge1xuICAgIHZhciB2YWx1ZSA9IHN0YXRlLnZhbHVlO1xuICAgIHZhciBvayA9IHN0YXRlLnN0YXRlID09IEZVTEZJTExFRDtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIC8vIHZhcmlhYmxlIGxlbmd0aCAtIGNhbid0IHVzZSBmb3JFYWNoXG4gICAgd2hpbGUgKGNoYWluLmxlbmd0aCA+IGluZGV4KSB7XG4gICAgICB2YXIgcmVhY3Rpb24gPSBjaGFpbltpbmRleCsrXTtcbiAgICAgIHZhciBoYW5kbGVyID0gb2sgPyByZWFjdGlvbi5vayA6IHJlYWN0aW9uLmZhaWw7XG4gICAgICB2YXIgcmVzb2x2ZSA9IHJlYWN0aW9uLnJlc29sdmU7XG4gICAgICB2YXIgcmVqZWN0ID0gcmVhY3Rpb24ucmVqZWN0O1xuICAgICAgdmFyIGRvbWFpbiA9IHJlYWN0aW9uLmRvbWFpbjtcbiAgICAgIHZhciByZXN1bHQsIHRoZW4sIGV4aXRlZDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgaWYgKCFvaykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlamVjdGlvbiA9PT0gVU5IQU5ETEVEKSBvbkhhbmRsZVVuaGFuZGxlZChwcm9taXNlLCBzdGF0ZSk7XG4gICAgICAgICAgICBzdGF0ZS5yZWplY3Rpb24gPSBIQU5ETEVEO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaGFuZGxlciA9PT0gdHJ1ZSkgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoZG9tYWluKSBkb21haW4uZW50ZXIoKTtcbiAgICAgICAgICAgIHJlc3VsdCA9IGhhbmRsZXIodmFsdWUpOyAvLyBjYW4gdGhyb3dcbiAgICAgICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgICAgZG9tYWluLmV4aXQoKTtcbiAgICAgICAgICAgICAgZXhpdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdCA9PT0gcmVhY3Rpb24ucHJvbWlzZSkge1xuICAgICAgICAgICAgcmVqZWN0KFR5cGVFcnJvcignUHJvbWlzZS1jaGFpbiBjeWNsZScpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoZW4gPSBpc1RoZW5hYmxlKHJlc3VsdCkpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChyZXN1bHQsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgfSBlbHNlIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSBlbHNlIHJlamVjdCh2YWx1ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZG9tYWluICYmICFleGl0ZWQpIGRvbWFpbi5leGl0KCk7XG4gICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIHN0YXRlLnJlYWN0aW9ucyA9IFtdO1xuICAgIHN0YXRlLm5vdGlmaWVkID0gZmFsc2U7XG4gICAgaWYgKGlzUmVqZWN0ICYmICFzdGF0ZS5yZWplY3Rpb24pIG9uVW5oYW5kbGVkKHByb21pc2UsIHN0YXRlKTtcbiAgfSk7XG59O1xuXG52YXIgZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChuYW1lLCBwcm9taXNlLCByZWFzb24pIHtcbiAgdmFyIGV2ZW50LCBoYW5kbGVyO1xuICBpZiAoRElTUEFUQ0hfRVZFTlQpIHtcbiAgICBldmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LnByb21pc2UgPSBwcm9taXNlO1xuICAgIGV2ZW50LnJlYXNvbiA9IHJlYXNvbjtcbiAgICBldmVudC5pbml0RXZlbnQobmFtZSwgZmFsc2UsIHRydWUpO1xuICAgIGdsb2JhbC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgfSBlbHNlIGV2ZW50ID0geyBwcm9taXNlOiBwcm9taXNlLCByZWFzb246IHJlYXNvbiB9O1xuICBpZiAoaGFuZGxlciA9IGdsb2JhbFsnb24nICsgbmFtZV0pIGhhbmRsZXIoZXZlbnQpO1xuICBlbHNlIGlmIChuYW1lID09PSBVTkhBTkRMRURfUkVKRUNUSU9OKSBob3N0UmVwb3J0RXJyb3JzKCdVbmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24nLCByZWFzb24pO1xufTtcblxudmFyIG9uVW5oYW5kbGVkID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlKSB7XG4gIHRhc2suY2FsbChnbG9iYWwsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdmFsdWUgPSBzdGF0ZS52YWx1ZTtcbiAgICB2YXIgSVNfVU5IQU5ETEVEID0gaXNVbmhhbmRsZWQoc3RhdGUpO1xuICAgIHZhciByZXN1bHQ7XG4gICAgaWYgKElTX1VOSEFORExFRCkge1xuICAgICAgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChJU19OT0RFKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbWl0KCd1bmhhbmRsZWRSZWplY3Rpb24nLCB2YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFVOSEFORExFRF9SRUpFQ1RJT04sIHByb21pc2UsIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgLy8gQnJvd3NlcnMgc2hvdWxkIG5vdCB0cmlnZ2VyIGByZWplY3Rpb25IYW5kbGVkYCBldmVudCBpZiBpdCB3YXMgaGFuZGxlZCBoZXJlLCBOb2RlSlMgLSBzaG91bGRcbiAgICAgIHN0YXRlLnJlamVjdGlvbiA9IElTX05PREUgfHwgaXNVbmhhbmRsZWQoc3RhdGUpID8gVU5IQU5ETEVEIDogSEFORExFRDtcbiAgICAgIGlmIChyZXN1bHQuZXJyb3IpIHRocm93IHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gIH0pO1xufTtcblxudmFyIGlzVW5oYW5kbGVkID0gZnVuY3Rpb24gKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5yZWplY3Rpb24gIT09IEhBTkRMRUQgJiYgIXN0YXRlLnBhcmVudDtcbn07XG5cbnZhciBvbkhhbmRsZVVuaGFuZGxlZCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSkge1xuICB0YXNrLmNhbGwoZ2xvYmFsLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKElTX05PREUpIHtcbiAgICAgIHByb2Nlc3MuZW1pdCgncmVqZWN0aW9uSGFuZGxlZCcsIHByb21pc2UpO1xuICAgIH0gZWxzZSBkaXNwYXRjaEV2ZW50KFJFSkVDVElPTl9IQU5ETEVELCBwcm9taXNlLCBzdGF0ZS52YWx1ZSk7XG4gIH0pO1xufTtcblxudmFyIGJpbmQgPSBmdW5jdGlvbiAoZm4sIHByb21pc2UsIHN0YXRlLCB1bndyYXApIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGZuKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKTtcbiAgfTtcbn07XG5cbnZhciBpbnRlcm5hbFJlamVjdCA9IGZ1bmN0aW9uIChwcm9taXNlLCBzdGF0ZSwgdmFsdWUsIHVud3JhcCkge1xuICBpZiAoc3RhdGUuZG9uZSkgcmV0dXJuO1xuICBzdGF0ZS5kb25lID0gdHJ1ZTtcbiAgaWYgKHVud3JhcCkgc3RhdGUgPSB1bndyYXA7XG4gIHN0YXRlLnZhbHVlID0gdmFsdWU7XG4gIHN0YXRlLnN0YXRlID0gUkVKRUNURUQ7XG4gIG5vdGlmeShwcm9taXNlLCBzdGF0ZSwgdHJ1ZSk7XG59O1xuXG52YXIgaW50ZXJuYWxSZXNvbHZlID0gZnVuY3Rpb24gKHByb21pc2UsIHN0YXRlLCB2YWx1ZSwgdW53cmFwKSB7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm47XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICBpZiAodW53cmFwKSBzdGF0ZSA9IHVud3JhcDtcbiAgdHJ5IHtcbiAgICBpZiAocHJvbWlzZSA9PT0gdmFsdWUpIHRocm93IFR5cGVFcnJvcihcIlByb21pc2UgY2FuJ3QgYmUgcmVzb2x2ZWQgaXRzZWxmXCIpO1xuICAgIHZhciB0aGVuID0gaXNUaGVuYWJsZSh2YWx1ZSk7XG4gICAgaWYgKHRoZW4pIHtcbiAgICAgIG1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB3cmFwcGVyID0geyBkb25lOiBmYWxzZSB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoZW4uY2FsbCh2YWx1ZSxcbiAgICAgICAgICAgIGJpbmQoaW50ZXJuYWxSZXNvbHZlLCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSksXG4gICAgICAgICAgICBiaW5kKGludGVybmFsUmVqZWN0LCBwcm9taXNlLCB3cmFwcGVyLCBzdGF0ZSlcbiAgICAgICAgICApO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGludGVybmFsUmVqZWN0KHByb21pc2UsIHdyYXBwZXIsIGVycm9yLCBzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS52YWx1ZSA9IHZhbHVlO1xuICAgICAgc3RhdGUuc3RhdGUgPSBGVUxGSUxMRUQ7XG4gICAgICBub3RpZnkocHJvbWlzZSwgc3RhdGUsIGZhbHNlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaW50ZXJuYWxSZWplY3QocHJvbWlzZSwgeyBkb25lOiBmYWxzZSB9LCBlcnJvciwgc3RhdGUpO1xuICB9XG59O1xuXG4vLyBjb25zdHJ1Y3RvciBwb2x5ZmlsbFxuaWYgKEZPUkNFRCkge1xuICAvLyAyNS40LjMuMSBQcm9taXNlKGV4ZWN1dG9yKVxuICBQcm9taXNlQ29uc3RydWN0b3IgPSBmdW5jdGlvbiBQcm9taXNlKGV4ZWN1dG9yKSB7XG4gICAgYW5JbnN0YW5jZSh0aGlzLCBQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UpO1xuICAgIGFGdW5jdGlvbihleGVjdXRvcik7XG4gICAgSW50ZXJuYWwuY2FsbCh0aGlzKTtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpO1xuICAgIHRyeSB7XG4gICAgICBleGVjdXRvcihiaW5kKGludGVybmFsUmVzb2x2ZSwgdGhpcywgc3RhdGUpLCBiaW5kKGludGVybmFsUmVqZWN0LCB0aGlzLCBzdGF0ZSkpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpbnRlcm5hbFJlamVjdCh0aGlzLCBzdGF0ZSwgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gIEludGVybmFsID0gZnVuY3Rpb24gUHJvbWlzZShleGVjdXRvcikge1xuICAgIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgICAgdHlwZTogUFJPTUlTRSxcbiAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgbm90aWZpZWQ6IGZhbHNlLFxuICAgICAgcGFyZW50OiBmYWxzZSxcbiAgICAgIHJlYWN0aW9uczogW10sXG4gICAgICByZWplY3Rpb246IGZhbHNlLFxuICAgICAgc3RhdGU6IFBFTkRJTkcsXG4gICAgICB2YWx1ZTogdW5kZWZpbmVkXG4gICAgfSk7XG4gIH07XG4gIEludGVybmFsLnByb3RvdHlwZSA9IHJlZGVmaW5lQWxsKFByb21pc2VDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHtcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUudGhlbmAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5wcm90b3R5cGUudGhlblxuICAgIHRoZW46IGZ1bmN0aW9uIHRoZW4ob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUHJvbWlzZVN0YXRlKHRoaXMpO1xuICAgICAgdmFyIHJlYWN0aW9uID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIFByb21pc2VDb25zdHJ1Y3RvcikpO1xuICAgICAgcmVhY3Rpb24ub2sgPSB0eXBlb2Ygb25GdWxmaWxsZWQgPT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogdHJ1ZTtcbiAgICAgIHJlYWN0aW9uLmZhaWwgPSB0eXBlb2Ygb25SZWplY3RlZCA9PSAnZnVuY3Rpb24nICYmIG9uUmVqZWN0ZWQ7XG4gICAgICByZWFjdGlvbi5kb21haW4gPSBJU19OT0RFID8gcHJvY2Vzcy5kb21haW4gOiB1bmRlZmluZWQ7XG4gICAgICBzdGF0ZS5wYXJlbnQgPSB0cnVlO1xuICAgICAgc3RhdGUucmVhY3Rpb25zLnB1c2gocmVhY3Rpb24pO1xuICAgICAgaWYgKHN0YXRlLnN0YXRlICE9IFBFTkRJTkcpIG5vdGlmeSh0aGlzLCBzdGF0ZSwgZmFsc2UpO1xuICAgICAgcmV0dXJuIHJlYWN0aW9uLnByb21pc2U7XG4gICAgfSxcbiAgICAvLyBgUHJvbWlzZS5wcm90b3R5cGUuY2F0Y2hgIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucHJvdG90eXBlLmNhdGNoXG4gICAgJ2NhdGNoJzogZnVuY3Rpb24gKG9uUmVqZWN0ZWQpIHtcbiAgICAgIHJldHVybiB0aGlzLnRoZW4odW5kZWZpbmVkLCBvblJlamVjdGVkKTtcbiAgICB9XG4gIH0pO1xuICBPd25Qcm9taXNlQ2FwYWJpbGl0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBJbnRlcm5hbCgpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUocHJvbWlzZSk7XG4gICAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbiAgICB0aGlzLnJlc29sdmUgPSBiaW5kKGludGVybmFsUmVzb2x2ZSwgcHJvbWlzZSwgc3RhdGUpO1xuICAgIHRoaXMucmVqZWN0ID0gYmluZChpbnRlcm5hbFJlamVjdCwgcHJvbWlzZSwgc3RhdGUpO1xuICB9O1xuICBuZXdQcm9taXNlQ2FwYWJpbGl0eU1vZHVsZS5mID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkgPSBmdW5jdGlvbiAoQykge1xuICAgIHJldHVybiBDID09PSBQcm9taXNlQ29uc3RydWN0b3IgfHwgQyA9PT0gUHJvbWlzZVdyYXBwZXJcbiAgICAgID8gbmV3IE93blByb21pc2VDYXBhYmlsaXR5KEMpXG4gICAgICA6IG5ld0dlbmVyaWNQcm9taXNlQ2FwYWJpbGl0eShDKTtcbiAgfTtcblxuICAvLyB3cmFwIGZldGNoIHJlc3VsdFxuICBpZiAoIUlTX1BVUkUgJiYgdHlwZW9mICRmZXRjaCA9PSAnZnVuY3Rpb24nKSAkKHsgZ2xvYmFsOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuICAgIGZldGNoOiBmdW5jdGlvbiBmZXRjaChpbnB1dCkge1xuICAgICAgcmV0dXJuIHByb21pc2VSZXNvbHZlKFByb21pc2VDb25zdHJ1Y3RvciwgJGZldGNoLmFwcGx5KGdsb2JhbCwgYXJndW1lbnRzKSk7XG4gICAgfVxuICB9KTtcbn1cblxuJCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICBQcm9taXNlOiBQcm9taXNlQ29uc3RydWN0b3Jcbn0pO1xuXG5zZXRUb1N0cmluZ1RhZyhQcm9taXNlQ29uc3RydWN0b3IsIFBST01JU0UsIGZhbHNlLCB0cnVlKTtcbnNldFNwZWNpZXMoUFJPTUlTRSk7XG5cblByb21pc2VXcmFwcGVyID0gcGF0aFtQUk9NSVNFXTtcblxuLy8gc3RhdGljc1xuJCh7IHRhcmdldDogUFJPTUlTRSwgc3RhdDogdHJ1ZSwgZm9yY2VkOiBGT1JDRUQgfSwge1xuICAvLyBgUHJvbWlzZS5yZWplY3RgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLnJlamVjdFxuICByZWplY3Q6IGZ1bmN0aW9uIHJlamVjdChyKSB7XG4gICAgdmFyIGNhcGFiaWxpdHkgPSBuZXdQcm9taXNlQ2FwYWJpbGl0eSh0aGlzKTtcbiAgICBjYXBhYmlsaXR5LnJlamVjdC5jYWxsKHVuZGVmaW5lZCwgcik7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG5cbiQoeyB0YXJnZXQ6IFBST01JU0UsIHN0YXQ6IHRydWUsIGZvcmNlZDogSVNfUFVSRSB8fCBGT1JDRUQgfSwge1xuICAvLyBgUHJvbWlzZS5yZXNvbHZlYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvbWlzZS5yZXNvbHZlXG4gIHJlc29sdmU6IGZ1bmN0aW9uIHJlc29sdmUoeCkge1xuICAgIHJldHVybiBwcm9taXNlUmVzb2x2ZShJU19QVVJFICYmIHRoaXMgPT09IFByb21pc2VXcmFwcGVyID8gUHJvbWlzZUNvbnN0cnVjdG9yIDogdGhpcywgeCk7XG4gIH1cbn0pO1xuXG4kKHsgdGFyZ2V0OiBQUk9NSVNFLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IElOQ09SUkVDVF9JVEVSQVRJT04gfSwge1xuICAvLyBgUHJvbWlzZS5hbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1wcm9taXNlLmFsbFxuICBhbGw6IGZ1bmN0aW9uIGFsbChpdGVyYWJsZSkge1xuICAgIHZhciBDID0gdGhpcztcbiAgICB2YXIgY2FwYWJpbGl0eSA9IG5ld1Byb21pc2VDYXBhYmlsaXR5KEMpO1xuICAgIHZhciByZXNvbHZlID0gY2FwYWJpbGl0eS5yZXNvbHZlO1xuICAgIHZhciByZWplY3QgPSBjYXBhYmlsaXR5LnJlamVjdDtcbiAgICB2YXIgcmVzdWx0ID0gcGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgJHByb21pc2VSZXNvbHZlID0gYUZ1bmN0aW9uKEMucmVzb2x2ZSk7XG4gICAgICB2YXIgdmFsdWVzID0gW107XG4gICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICB2YXIgcmVtYWluaW5nID0gMTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGNvdW50ZXIrKztcbiAgICAgICAgdmFyIGFscmVhZHlDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzLnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgcmVtYWluaW5nKys7XG4gICAgICAgICRwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaWYgKGFscmVhZHlDYWxsZWQpIHJldHVybjtcbiAgICAgICAgICBhbHJlYWR5Q2FsbGVkID0gdHJ1ZTtcbiAgICAgICAgICB2YWx1ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgICAgICAgLS1yZW1haW5pbmcgfHwgcmVzb2x2ZSh2YWx1ZXMpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgICAtLXJlbWFpbmluZyB8fCByZXNvbHZlKHZhbHVlcyk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfSxcbiAgLy8gYFByb21pc2UucmFjZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXByb21pc2UucmFjZVxuICByYWNlOiBmdW5jdGlvbiByYWNlKGl0ZXJhYmxlKSB7XG4gICAgdmFyIEMgPSB0aGlzO1xuICAgIHZhciBjYXBhYmlsaXR5ID0gbmV3UHJvbWlzZUNhcGFiaWxpdHkoQyk7XG4gICAgdmFyIHJlamVjdCA9IGNhcGFiaWxpdHkucmVqZWN0O1xuICAgIHZhciByZXN1bHQgPSBwZXJmb3JtKGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciAkcHJvbWlzZVJlc29sdmUgPSBhRnVuY3Rpb24oQy5yZXNvbHZlKTtcbiAgICAgIGl0ZXJhdGUoaXRlcmFibGUsIGZ1bmN0aW9uIChwcm9taXNlKSB7XG4gICAgICAgICRwcm9taXNlUmVzb2x2ZS5jYWxsKEMsIHByb21pc2UpLnRoZW4oY2FwYWJpbGl0eS5yZXNvbHZlLCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHJlc3VsdC5lcnJvcikgcmVqZWN0KHJlc3VsdC52YWx1ZSk7XG4gICAgcmV0dXJuIGNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIG5hdGl2ZUFwcGx5ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdhcHBseScpO1xudmFyIGZ1bmN0aW9uQXBwbHkgPSBGdW5jdGlvbi5hcHBseTtcblxuLy8gTVMgRWRnZSBhcmd1bWVudHNMaXN0IGFyZ3VtZW50IGlzIG9wdGlvbmFsXG52YXIgT1BUSU9OQUxfQVJHVU1FTlRTX0xJU1QgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICBuYXRpdmVBcHBseShmdW5jdGlvbiAoKSB7IC8qIGVtcHR5ICovIH0pO1xufSk7XG5cbi8vIGBSZWZsZWN0LmFwcGx5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuYXBwbHlcbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBPUFRJT05BTF9BUkdVTUVOVFNfTElTVCB9LCB7XG4gIGFwcGx5OiBmdW5jdGlvbiBhcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdCkge1xuICAgIGFGdW5jdGlvbih0YXJnZXQpO1xuICAgIGFuT2JqZWN0KGFyZ3VtZW50c0xpc3QpO1xuICAgIHJldHVybiBuYXRpdmVBcHBseVxuICAgICAgPyBuYXRpdmVBcHBseSh0YXJnZXQsIHRoaXNBcmd1bWVudCwgYXJndW1lbnRzTGlzdClcbiAgICAgIDogZnVuY3Rpb25BcHBseS5jYWxsKHRhcmdldCwgdGhpc0FyZ3VtZW50LCBhcmd1bWVudHNMaXN0KTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFGdW5jdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hLWZ1bmN0aW9uJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgaXNPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtb2JqZWN0Jyk7XG52YXIgY3JlYXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1jcmVhdGUnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Z1bmN0aW9uLWJpbmQnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgbmF0aXZlQ29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcblxuLy8gYFJlZmxlY3QuY29uc3RydWN0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuY29uc3RydWN0XG4vLyBNUyBFZGdlIHN1cHBvcnRzIG9ubHkgMiBhcmd1bWVudHMgYW5kIGFyZ3VtZW50c0xpc3QgYXJndW1lbnQgaXMgb3B0aW9uYWxcbi8vIEZGIE5pZ2h0bHkgc2V0cyB0aGlyZCBhcmd1bWVudCBhcyBgbmV3LnRhcmdldGAsIGJ1dCBkb2VzIG5vdCBjcmVhdGUgYHRoaXNgIGZyb20gaXRcbnZhciBORVdfVEFSR0VUX0JVRyA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gRigpIHsgLyogZW1wdHkgKi8gfVxuICByZXR1cm4gIShuYXRpdmVDb25zdHJ1Y3QoZnVuY3Rpb24gKCkgeyAvKiBlbXB0eSAqLyB9LCBbXSwgRikgaW5zdGFuY2VvZiBGKTtcbn0pO1xudmFyIEFSR1NfQlVHID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgbmF0aXZlQ29uc3RydWN0KGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSk7XG59KTtcbnZhciBGT1JDRUQgPSBORVdfVEFSR0VUX0JVRyB8fCBBUkdTX0JVRztcblxuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCwgc2hhbTogRk9SQ0VEIH0sIHtcbiAgY29uc3RydWN0OiBmdW5jdGlvbiBjb25zdHJ1Y3QoVGFyZ2V0LCBhcmdzIC8qICwgbmV3VGFyZ2V0ICovKSB7XG4gICAgYUZ1bmN0aW9uKFRhcmdldCk7XG4gICAgYW5PYmplY3QoYXJncyk7XG4gICAgdmFyIG5ld1RhcmdldCA9IGFyZ3VtZW50cy5sZW5ndGggPCAzID8gVGFyZ2V0IDogYUZ1bmN0aW9uKGFyZ3VtZW50c1syXSk7XG4gICAgaWYgKEFSR1NfQlVHICYmICFORVdfVEFSR0VUX0JVRykgcmV0dXJuIG5hdGl2ZUNvbnN0cnVjdChUYXJnZXQsIGFyZ3MsIG5ld1RhcmdldCk7XG4gICAgaWYgKFRhcmdldCA9PSBuZXdUYXJnZXQpIHtcbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgb3B0aW1pemF0aW9uIGZvciAwLTQgYXJndW1lbnRzXG4gICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDogcmV0dXJuIG5ldyBUYXJnZXQoKTtcbiAgICAgICAgY2FzZSAxOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdKTtcbiAgICAgICAgY2FzZSAyOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgY2FzZSAzOiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgY2FzZSA0OiByZXR1cm4gbmV3IFRhcmdldChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgIH1cbiAgICAgIC8vIHcvbyBhbHRlcmVkIG5ld1RhcmdldCwgbG90IG9mIGFyZ3VtZW50cyBjYXNlXG4gICAgICB2YXIgJGFyZ3MgPSBbbnVsbF07XG4gICAgICAkYXJncy5wdXNoLmFwcGx5KCRhcmdzLCBhcmdzKTtcbiAgICAgIHJldHVybiBuZXcgKGJpbmQuYXBwbHkoVGFyZ2V0LCAkYXJncykpKCk7XG4gICAgfVxuICAgIC8vIHdpdGggYWx0ZXJlZCBuZXdUYXJnZXQsIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGNvbnN0cnVjdG9yc1xuICAgIHZhciBwcm90byA9IG5ld1RhcmdldC5wcm90b3R5cGU7XG4gICAgdmFyIGluc3RhbmNlID0gY3JlYXRlKGlzT2JqZWN0KHByb3RvKSA/IHByb3RvIDogT2JqZWN0LnByb3RvdHlwZSk7XG4gICAgdmFyIHJlc3VsdCA9IEZ1bmN0aW9uLmFwcGx5LmNhbGwoVGFyZ2V0LCBpbnN0YW5jZSwgYXJncyk7XG4gICAgcmV0dXJuIGlzT2JqZWN0KHJlc3VsdCkgPyByZXN1bHQgOiBpbnN0YW5jZTtcbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvUHJpbWl0aXZlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLXByaW1pdGl2ZScpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG4vLyBNUyBFZGdlIGhhcyBicm9rZW4gUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eSAtIHRocm93aW5nIGluc3RlYWQgb2YgcmV0dXJuaW5nIGZhbHNlXG52YXIgRVJST1JfSU5TVEVBRF9PRl9GQUxTRSA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIFJlZmxlY3QuZGVmaW5lUHJvcGVydHkoZGVmaW5lUHJvcGVydHlNb2R1bGUuZih7fSwgMSwgeyB2YWx1ZTogMSB9KSwgMSwgeyB2YWx1ZTogMiB9KTtcbn0pO1xuXG4vLyBgUmVmbGVjdC5kZWZpbmVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmRlZmluZXByb3BlcnR5XG4kKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUsIGZvcmNlZDogRVJST1JfSU5TVEVBRF9PRl9GQUxTRSwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgZGVmaW5lUHJvcGVydHk6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHRhcmdldCwgcHJvcGVydHlLZXksIGF0dHJpYnV0ZXMpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShwcm9wZXJ0eUtleSwgdHJ1ZSk7XG4gICAgYW5PYmplY3QoYXR0cmlidXRlcyk7XG4gICAgdHJ5IHtcbiAgICAgIGRlZmluZVByb3BlcnR5TW9kdWxlLmYodGFyZ2V0LCBrZXksIGF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKS5mO1xuXG4vLyBgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmRlbGV0ZXByb3BlcnR5XG4kKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBkZWxldGVQcm9wZXJ0eTogZnVuY3Rpb24gZGVsZXRlUHJvcGVydHkodGFyZ2V0LCBwcm9wZXJ0eUtleSkge1xuICAgIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgICByZXR1cm4gZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUgPyBmYWxzZSA6IGRlbGV0ZSB0YXJnZXRbcHJvcGVydHlLZXldO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxuLy8gYFJlZmxlY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuZ2V0b3ducHJvcGVydHlkZXNjcmlwdG9yXG4kKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFERVNDUklQVE9SUyB9LCB7XG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmYoYW5PYmplY3QodGFyZ2V0KSwgcHJvcGVydHlLZXkpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIG9iamVjdEdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG52YXIgQ09SUkVDVF9QUk9UT1RZUEVfR0VUVEVSID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtcHJvdG90eXBlLWdldHRlcicpO1xuXG4vLyBgUmVmbGVjdC5nZXRQcm90b3R5cGVPZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmdldHByb3RvdHlwZW9mXG4kKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUsIHNoYW06ICFDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgfSwge1xuICBnZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSB7XG4gICAgcmV0dXJuIG9iamVjdEdldFByb3RvdHlwZU9mKGFuT2JqZWN0KHRhcmdldCkpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGdldFByb3RvdHlwZU9mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtcHJvdG90eXBlLW9mJyk7XG5cbi8vIGBSZWZsZWN0LmdldGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWZsZWN0LmdldFxuZnVuY3Rpb24gZ2V0KHRhcmdldCwgcHJvcGVydHlLZXkgLyogLCByZWNlaXZlciAqLykge1xuICB2YXIgcmVjZWl2ZXIgPSBhcmd1bWVudHMubGVuZ3RoIDwgMyA/IHRhcmdldCA6IGFyZ3VtZW50c1syXTtcbiAgdmFyIGRlc2NyaXB0b3IsIHByb3RvdHlwZTtcbiAgaWYgKGFuT2JqZWN0KHRhcmdldCkgPT09IHJlY2VpdmVyKSByZXR1cm4gdGFyZ2V0W3Byb3BlcnR5S2V5XTtcbiAgaWYgKGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZih0YXJnZXQsIHByb3BlcnR5S2V5KSkgcmV0dXJuIGhhcyhkZXNjcmlwdG9yLCAndmFsdWUnKVxuICAgID8gZGVzY3JpcHRvci52YWx1ZVxuICAgIDogZGVzY3JpcHRvci5nZXQgPT09IHVuZGVmaW5lZFxuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogZGVzY3JpcHRvci5nZXQuY2FsbChyZWNlaXZlcik7XG4gIGlmIChpc09iamVjdChwcm90b3R5cGUgPSBnZXRQcm90b3R5cGVPZih0YXJnZXQpKSkgcmV0dXJuIGdldChwcm90b3R5cGUsIHByb3BlcnR5S2V5LCByZWNlaXZlcik7XG59XG5cbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGdldDogZ2V0XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xuXG4vLyBgUmVmbGVjdC5oYXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVmbGVjdC5oYXNcbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIGhhczogZnVuY3Rpb24gaGFzKHRhcmdldCwgcHJvcGVydHlLZXkpIHtcbiAgICByZXR1cm4gcHJvcGVydHlLZXkgaW4gdGFyZ2V0O1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xuXG52YXIgb2JqZWN0SXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcblxuLy8gYFJlZmxlY3QuaXNFeHRlbnNpYmxlYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QuaXNleHRlbnNpYmxlXG4kKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBpc0V4dGVuc2libGU6IGZ1bmN0aW9uIGlzRXh0ZW5zaWJsZSh0YXJnZXQpIHtcbiAgICBhbk9iamVjdCh0YXJnZXQpO1xuICAgIHJldHVybiBvYmplY3RJc0V4dGVuc2libGUgPyBvYmplY3RJc0V4dGVuc2libGUodGFyZ2V0KSA6IHRydWU7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgb3duS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vd24ta2V5cycpO1xuXG4vLyBgUmVmbGVjdC5vd25LZXlzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3Qub3dua2V5c1xuJCh7IHRhcmdldDogJ1JlZmxlY3QnLCBzdGF0OiB0cnVlIH0sIHtcbiAgb3duS2V5czogb3duS2V5c1xufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBnZXRCdWlsdEluID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1idWlsdC1pbicpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIEZSRUVaSU5HID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZyZWV6aW5nJyk7XG5cbi8vIGBSZWZsZWN0LnByZXZlbnRFeHRlbnNpb25zYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3QucHJldmVudGV4dGVuc2lvbnNcbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSwgc2hhbTogIUZSRUVaSU5HIH0sIHtcbiAgcHJldmVudEV4dGVuc2lvbnM6IGZ1bmN0aW9uIHByZXZlbnRFeHRlbnNpb25zKHRhcmdldCkge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvYmplY3RQcmV2ZW50RXh0ZW5zaW9ucyA9IGdldEJ1aWx0SW4oJ09iamVjdCcsICdwcmV2ZW50RXh0ZW5zaW9ucycpO1xuICAgICAgaWYgKG9iamVjdFByZXZlbnRFeHRlbnNpb25zKSBvYmplY3RQcmV2ZW50RXh0ZW5zaW9ucyh0YXJnZXQpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgYVBvc3NpYmxlUHJvdG90eXBlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtcG9zc2libGUtcHJvdG90eXBlJyk7XG52YXIgb2JqZWN0U2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LXNldC1wcm90b3R5cGUtb2YnKTtcblxuLy8gYFJlZmxlY3Quc2V0UHJvdG90eXBlT2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVmbGVjdC5zZXRwcm90b3R5cGVvZlxuaWYgKG9iamVjdFNldFByb3RvdHlwZU9mKSAkKHsgdGFyZ2V0OiAnUmVmbGVjdCcsIHN0YXQ6IHRydWUgfSwge1xuICBzZXRQcm90b3R5cGVPZjogZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90bykge1xuICAgIGFuT2JqZWN0KHRhcmdldCk7XG4gICAgYVBvc3NpYmxlUHJvdG90eXBlKHByb3RvKTtcbiAgICB0cnkge1xuICAgICAgb2JqZWN0U2V0UHJvdG90eXBlT2YodGFyZ2V0LCBwcm90byk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufSk7XG4iLCJ2YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBoYXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGFzJyk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1kZXNjcmlwdG9yJyk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1wcm90b3R5cGUtb2YnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcblxuLy8gYFJlZmxlY3Quc2V0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZmxlY3Quc2V0XG5mdW5jdGlvbiBzZXQodGFyZ2V0LCBwcm9wZXJ0eUtleSwgViAvKiAsIHJlY2VpdmVyICovKSB7XG4gIHZhciByZWNlaXZlciA9IGFyZ3VtZW50cy5sZW5ndGggPCA0ID8gdGFyZ2V0IDogYXJndW1lbnRzWzNdO1xuICB2YXIgb3duRGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZS5mKGFuT2JqZWN0KHRhcmdldCksIHByb3BlcnR5S2V5KTtcbiAgdmFyIGV4aXN0aW5nRGVzY3JpcHRvciwgcHJvdG90eXBlO1xuICBpZiAoIW93bkRlc2NyaXB0b3IpIHtcbiAgICBpZiAoaXNPYmplY3QocHJvdG90eXBlID0gZ2V0UHJvdG90eXBlT2YodGFyZ2V0KSkpIHtcbiAgICAgIHJldHVybiBzZXQocHJvdG90eXBlLCBwcm9wZXJ0eUtleSwgViwgcmVjZWl2ZXIpO1xuICAgIH1cbiAgICBvd25EZXNjcmlwdG9yID0gY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDApO1xuICB9XG4gIGlmIChoYXMob3duRGVzY3JpcHRvciwgJ3ZhbHVlJykpIHtcbiAgICBpZiAob3duRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UgfHwgIWlzT2JqZWN0KHJlY2VpdmVyKSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChleGlzdGluZ0Rlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZihyZWNlaXZlciwgcHJvcGVydHlLZXkpKSB7XG4gICAgICBpZiAoZXhpc3RpbmdEZXNjcmlwdG9yLmdldCB8fCBleGlzdGluZ0Rlc2NyaXB0b3Iuc2V0IHx8IGV4aXN0aW5nRGVzY3JpcHRvci53cml0YWJsZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIGV4aXN0aW5nRGVzY3JpcHRvci52YWx1ZSA9IFY7XG4gICAgICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKHJlY2VpdmVyLCBwcm9wZXJ0eUtleSwgZXhpc3RpbmdEZXNjcmlwdG9yKTtcbiAgICB9IGVsc2UgZGVmaW5lUHJvcGVydHlNb2R1bGUuZihyZWNlaXZlciwgcHJvcGVydHlLZXksIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBWKSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIG93bkRlc2NyaXB0b3Iuc2V0ID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IChvd25EZXNjcmlwdG9yLnNldC5jYWxsKHJlY2VpdmVyLCBWKSwgdHJ1ZSk7XG59XG5cbiQoeyB0YXJnZXQ6ICdSZWZsZWN0Jywgc3RhdDogdHJ1ZSB9LCB7XG4gIHNldDogc2V0XG59KTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBpc0ZvcmNlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1mb3JjZWQnKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pbmhlcml0LWlmLXJlcXVpcmVkJyk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWRlZmluZS1wcm9wZXJ0eScpLmY7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZ2V0LW93bi1wcm9wZXJ0eS1uYW1lcycpLmY7XG52YXIgaXNSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtcmVnZXhwJyk7XG52YXIgZ2V0RmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG52YXIgcmVkZWZpbmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVkZWZpbmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xudmFyIHNldFNwZWNpZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXNwZWNpZXMnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIE1BVENIID0gd2VsbEtub3duU3ltYm9sKCdtYXRjaCcpO1xudmFyIE5hdGl2ZVJlZ0V4cCA9IGdsb2JhbC5SZWdFeHA7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gTmF0aXZlUmVnRXhwLnByb3RvdHlwZTtcbnZhciByZTEgPSAvYS9nO1xudmFyIHJlMiA9IC9hL2c7XG5cbi8vIFwibmV3XCIgc2hvdWxkIGNyZWF0ZSBhIG5ldyBvYmplY3QsIG9sZCB3ZWJraXQgYnVnXG52YXIgQ09SUkVDVF9ORVcgPSBuZXcgTmF0aXZlUmVnRXhwKHJlMSkgIT09IHJlMTtcblxudmFyIEZPUkNFRCA9IERFU0NSSVBUT1JTICYmIGlzRm9yY2VkKCdSZWdFeHAnLCAoIUNPUlJFQ1RfTkVXIHx8IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmUyW01BVENIXSA9IGZhbHNlO1xuICAvLyBSZWdFeHAgY29uc3RydWN0b3IgY2FuIGFsdGVyIGZsYWdzIGFuZCBJc1JlZ0V4cCB3b3JrcyBjb3JyZWN0IHdpdGggQEBtYXRjaFxuICByZXR1cm4gTmF0aXZlUmVnRXhwKHJlMSkgIT0gcmUxIHx8IE5hdGl2ZVJlZ0V4cChyZTIpID09IHJlMiB8fCBOYXRpdmVSZWdFeHAocmUxLCAnaScpICE9ICcvYS9pJztcbn0pKSk7XG5cbi8vIGBSZWdFeHBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1yZWdleHAtY29uc3RydWN0b3JcbmlmIChGT1JDRUQpIHtcbiAgdmFyIFJlZ0V4cFdyYXBwZXIgPSBmdW5jdGlvbiBSZWdFeHAocGF0dGVybiwgZmxhZ3MpIHtcbiAgICB2YXIgdGhpc0lzUmVnRXhwID0gdGhpcyBpbnN0YW5jZW9mIFJlZ0V4cFdyYXBwZXI7XG4gICAgdmFyIHBhdHRlcm5Jc1JlZ0V4cCA9IGlzUmVnRXhwKHBhdHRlcm4pO1xuICAgIHZhciBmbGFnc0FyZVVuZGVmaW5lZCA9IGZsYWdzID09PSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuICF0aGlzSXNSZWdFeHAgJiYgcGF0dGVybklzUmVnRXhwICYmIHBhdHRlcm4uY29uc3RydWN0b3IgPT09IFJlZ0V4cFdyYXBwZXIgJiYgZmxhZ3NBcmVVbmRlZmluZWQgPyBwYXR0ZXJuXG4gICAgICA6IGluaGVyaXRJZlJlcXVpcmVkKENPUlJFQ1RfTkVXXG4gICAgICAgID8gbmV3IE5hdGl2ZVJlZ0V4cChwYXR0ZXJuSXNSZWdFeHAgJiYgIWZsYWdzQXJlVW5kZWZpbmVkID8gcGF0dGVybi5zb3VyY2UgOiBwYXR0ZXJuLCBmbGFncylcbiAgICAgICAgOiBOYXRpdmVSZWdFeHAoKHBhdHRlcm5Jc1JlZ0V4cCA9IHBhdHRlcm4gaW5zdGFuY2VvZiBSZWdFeHBXcmFwcGVyKVxuICAgICAgICAgID8gcGF0dGVybi5zb3VyY2VcbiAgICAgICAgICA6IHBhdHRlcm4sIHBhdHRlcm5Jc1JlZ0V4cCAmJiBmbGFnc0FyZVVuZGVmaW5lZCA/IGdldEZsYWdzLmNhbGwocGF0dGVybikgOiBmbGFncylcbiAgICAgICwgdGhpc0lzUmVnRXhwID8gdGhpcyA6IFJlZ0V4cFByb3RvdHlwZSwgUmVnRXhwV3JhcHBlcik7XG4gIH07XG4gIHZhciBwcm94eSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBrZXkgaW4gUmVnRXhwV3JhcHBlciB8fCBkZWZpbmVQcm9wZXJ0eShSZWdFeHBXcmFwcGVyLCBrZXksIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gTmF0aXZlUmVnRXhwW2tleV07IH0sXG4gICAgICBzZXQ6IGZ1bmN0aW9uIChpdCkgeyBOYXRpdmVSZWdFeHBba2V5XSA9IGl0OyB9XG4gICAgfSk7XG4gIH07XG4gIHZhciBrZXlzID0gZ2V0T3duUHJvcGVydHlOYW1lcyhOYXRpdmVSZWdFeHApO1xuICB2YXIgaW5kZXggPSAwO1xuICB3aGlsZSAoa2V5cy5sZW5ndGggPiBpbmRleCkgcHJveHkoa2V5c1tpbmRleCsrXSk7XG4gIFJlZ0V4cFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFJlZ0V4cFdyYXBwZXI7XG4gIFJlZ0V4cFdyYXBwZXIucHJvdG90eXBlID0gUmVnRXhwUHJvdG90eXBlO1xuICByZWRlZmluZShnbG9iYWwsICdSZWdFeHAnLCBSZWdFeHBXcmFwcGVyKTtcbn1cblxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC1AQHNwZWNpZXNcbnNldFNwZWNpZXMoJ1JlZ0V4cCcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYycpO1xuXG4kKHsgdGFyZ2V0OiAnUmVnRXhwJywgcHJvdG86IHRydWUsIGZvcmNlZDogLy4vLmV4ZWMgIT09IGV4ZWMgfSwge1xuICBleGVjOiBleGVjXG59KTtcbiIsInZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIG9iamVjdERlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciByZWdFeHBGbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcblxuLy8gYFJlZ0V4cC5wcm90b3R5cGUuZmxhZ3NgIGdldHRlclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtZ2V0LXJlZ2V4cC5wcm90b3R5cGUuZmxhZ3NcbmlmIChERVNDUklQVE9SUyAmJiAvLi9nLmZsYWdzICE9ICdnJykge1xuICBvYmplY3REZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKFJlZ0V4cC5wcm90b3R5cGUsICdmbGFncycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiByZWdFeHBGbGFnc1xuICB9KTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgZmxhZ3MgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWZsYWdzJyk7XG5cbnZhciBUT19TVFJJTkcgPSAndG9TdHJpbmcnO1xudmFyIFJlZ0V4cFByb3RvdHlwZSA9IFJlZ0V4cC5wcm90b3R5cGU7XG52YXIgbmF0aXZlVG9TdHJpbmcgPSBSZWdFeHBQcm90b3R5cGVbVE9fU1RSSU5HXTtcblxudmFyIE5PVF9HRU5FUklDID0gZmFpbHMoZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlVG9TdHJpbmcuY2FsbCh7IHNvdXJjZTogJ2EnLCBmbGFnczogJ2InIH0pICE9ICcvYS9iJzsgfSk7XG4vLyBGRjQ0LSBSZWdFeHAjdG9TdHJpbmcgaGFzIGEgd3JvbmcgbmFtZVxudmFyIElOQ09SUkVDVF9OQU1FID0gbmF0aXZlVG9TdHJpbmcubmFtZSAhPSBUT19TVFJJTkc7XG5cbi8vIGBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUudG9zdHJpbmdcbmlmIChOT1RfR0VORVJJQyB8fCBJTkNPUlJFQ1RfTkFNRSkge1xuICByZWRlZmluZShSZWdFeHAucHJvdG90eXBlLCBUT19TVFJJTkcsIGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHZhciBSID0gYW5PYmplY3QodGhpcyk7XG4gICAgdmFyIHAgPSBTdHJpbmcoUi5zb3VyY2UpO1xuICAgIHZhciByZiA9IFIuZmxhZ3M7XG4gICAgdmFyIGYgPSBTdHJpbmcocmYgPT09IHVuZGVmaW5lZCAmJiBSIGluc3RhbmNlb2YgUmVnRXhwICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpID8gZmxhZ3MuY2FsbChSKSA6IHJmKTtcbiAgICByZXR1cm4gJy8nICsgcCArICcvJyArIGY7XG4gIH0sIHsgdW5zYWZlOiB0cnVlIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGNvbGxlY3Rpb24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbicpO1xudmFyIGNvbGxlY3Rpb25TdHJvbmcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi1zdHJvbmcnKTtcblxuLy8gYFNldGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXNldC1vYmplY3RzXG5tb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Rpb24oJ1NldCcsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFNldCgpIHsgcmV0dXJuIGdldCh0aGlzLCBhcmd1bWVudHMubGVuZ3RoID8gYXJndW1lbnRzWzBdIDogdW5kZWZpbmVkKTsgfTtcbn0sIGNvbGxlY3Rpb25TdHJvbmcpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSFRNTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaHRtbCcpO1xudmFyIGZvcmNlZFN0cmluZ0hUTUxNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZm9yY2VkLXN0cmluZy1odG1sLW1ldGhvZCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5hbmNob3JgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5hbmNob3JcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kKCdhbmNob3InKSB9LCB7XG4gIGFuY2hvcjogZnVuY3Rpb24gYW5jaG9yKG5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICduYW1lJywgbmFtZSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSFRNTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaHRtbCcpO1xudmFyIGZvcmNlZFN0cmluZ0hUTUxNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZm9yY2VkLXN0cmluZy1odG1sLW1ldGhvZCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5iaWdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5iaWdcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kKCdiaWcnKSB9LCB7XG4gIGJpZzogZnVuY3Rpb24gYmlnKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdiaWcnLCAnJywgJycpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNyZWF0ZUhUTUwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWh0bWwnKTtcbnZhciBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1zdHJpbmctaHRtbC1tZXRob2QnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuYmxpbmtgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5ibGlua1xuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ2JsaW5rJykgfSwge1xuICBibGluazogZnVuY3Rpb24gYmxpbmsoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2JsaW5rJywgJycsICcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVIVE1MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sJyk7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLWh0bWwtbWV0aG9kJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmJvbGRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5ib2xkXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCgnYm9sZCcpIH0sIHtcbiAgYm9sZDogZnVuY3Rpb24gYm9sZCgpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYicsICcnLCAnJyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY29kZUF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jb2RlQXQ7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmNvZGVQb2ludEF0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuY29kZXBvaW50YXRcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSB9LCB7XG4gIGNvZGVQb2ludEF0OiBmdW5jdGlvbiBjb2RlUG9pbnRBdChwb3MpIHtcbiAgICByZXR1cm4gY29kZUF0KHRoaXMsIHBvcyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgbm90QVJlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3QtYS1yZWdleHAnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljJyk7XG5cbnZhciBuYXRpdmVFbmRzV2l0aCA9ICcnLmVuZHNXaXRoO1xudmFyIG1pbiA9IE1hdGgubWluO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmVuZHN3aXRoXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdlbmRzV2l0aCcpIH0sIHtcbiAgZW5kc1dpdGg6IGZ1bmN0aW9uIGVuZHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIGVuZFBvc2l0aW9uID0gQGxlbmd0aCAqLykge1xuICAgIHZhciB0aGF0ID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTtcbiAgICB2YXIgZW5kUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgbGVuID0gdG9MZW5ndGgodGhhdC5sZW5ndGgpO1xuICAgIHZhciBlbmQgPSBlbmRQb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gbGVuIDogbWluKHRvTGVuZ3RoKGVuZFBvc2l0aW9uKSwgbGVuKTtcbiAgICB2YXIgc2VhcmNoID0gU3RyaW5nKHNlYXJjaFN0cmluZyk7XG4gICAgcmV0dXJuIG5hdGl2ZUVuZHNXaXRoXG4gICAgICA/IG5hdGl2ZUVuZHNXaXRoLmNhbGwodGhhdCwgc2VhcmNoLCBlbmQpXG4gICAgICA6IHRoYXQuc2xpY2UoZW5kIC0gc2VhcmNoLmxlbmd0aCwgZW5kKSA9PT0gc2VhcmNoO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNyZWF0ZUhUTUwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWh0bWwnKTtcbnZhciBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1zdHJpbmctaHRtbC1tZXRob2QnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuZml4ZWRgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5maXhlZFxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ2ZpeGVkJykgfSwge1xuICBmaXhlZDogZnVuY3Rpb24gZml4ZWQoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3R0JywgJycsICcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVIVE1MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sJyk7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLWh0bWwtbWV0aG9kJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLmZvbnRjb2xvclxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ2ZvbnRjb2xvcicpIH0sIHtcbiAgZm9udGNvbG9yOiBmdW5jdGlvbiBmb250Y29sb3IoY29sb3IpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdjb2xvcicsIGNvbG9yKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVIVE1MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sJyk7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLWh0bWwtbWV0aG9kJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmZvbnRzaXplYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuZm9udHNpemVcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kKCdmb250c2l6ZScpIH0sIHtcbiAgZm9udHNpemU6IGZ1bmN0aW9uIGZvbnRzaXplKHNpemUpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnZm9udCcsICdzaXplJywgc2l6ZSk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgdG9BYnNvbHV0ZUluZGV4ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWFic29sdXRlLWluZGV4Jyk7XG5cbnZhciBmcm9tQ2hhckNvZGUgPSBTdHJpbmcuZnJvbUNoYXJDb2RlO1xudmFyIG5hdGl2ZUZyb21Db2RlUG9pbnQgPSBTdHJpbmcuZnJvbUNvZGVQb2ludDtcblxuLy8gbGVuZ3RoIHNob3VsZCBiZSAxLCBvbGQgRkYgcHJvYmxlbVxudmFyIElOQ09SUkVDVF9MRU5HVEggPSAhIW5hdGl2ZUZyb21Db2RlUG9pbnQgJiYgbmF0aXZlRnJvbUNvZGVQb2ludC5sZW5ndGggIT0gMTtcblxuLy8gYFN0cmluZy5mcm9tQ29kZVBvaW50YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5mcm9tY29kZXBvaW50XG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBJTkNPUlJFQ1RfTEVOR1RIIH0sIHtcbiAgZnJvbUNvZGVQb2ludDogZnVuY3Rpb24gZnJvbUNvZGVQb2ludCh4KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgICB2YXIgZWxlbWVudHMgPSBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNvZGU7XG4gICAgd2hpbGUgKGxlbmd0aCA+IGkpIHtcbiAgICAgIGNvZGUgPSArYXJndW1lbnRzW2krK107XG4gICAgICBpZiAodG9BYnNvbHV0ZUluZGV4KGNvZGUsIDB4MTBGRkZGKSAhPT0gY29kZSkgdGhyb3cgUmFuZ2VFcnJvcihjb2RlICsgJyBpcyBub3QgYSB2YWxpZCBjb2RlIHBvaW50Jyk7XG4gICAgICBlbGVtZW50cy5wdXNoKGNvZGUgPCAweDEwMDAwXG4gICAgICAgID8gZnJvbUNoYXJDb2RlKGNvZGUpXG4gICAgICAgIDogZnJvbUNoYXJDb2RlKCgoY29kZSAtPSAweDEwMDAwKSA+PiAxMCkgKyAweEQ4MDAsIGNvZGUgJSAweDQwMCArIDB4REMwMClcbiAgICAgICk7XG4gICAgfSByZXR1cm4gZWxlbWVudHMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgbm90QVJlZ0V4cCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9ub3QtYS1yZWdleHAnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIGNvcnJlY3RJc1JlZ0V4cExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcnJlY3QtaXMtcmVnZXhwLWxvZ2ljJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaW5jbHVkZXNcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiAhY29ycmVjdElzUmVnRXhwTG9naWMoJ2luY2x1ZGVzJykgfSwge1xuICBpbmNsdWRlczogZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoU3RyaW5nIC8qICwgcG9zaXRpb24gPSAwICovKSB7XG4gICAgcmV0dXJuICEhflN0cmluZyhyZXF1aXJlT2JqZWN0Q29lcmNpYmxlKHRoaXMpKVxuICAgICAgLmluZGV4T2Yobm90QVJlZ0V4cChzZWFyY2hTdHJpbmcpLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSFRNTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaHRtbCcpO1xudmFyIGZvcmNlZFN0cmluZ0hUTUxNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZm9yY2VkLXN0cmluZy1odG1sLW1ldGhvZCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5pdGFsaWNzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuaXRhbGljc1xuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ2l0YWxpY3MnKSB9LCB7XG4gIGl0YWxpY3M6IGZ1bmN0aW9uIGl0YWxpY3MoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ2knLCAnJywgJycpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBjaGFyQXQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLW11bHRpYnl0ZScpLmNoYXJBdDtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgZGVmaW5lSXRlcmF0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLWl0ZXJhdG9yJyk7XG5cbnZhciBTVFJJTkdfSVRFUkFUT1IgPSAnU3RyaW5nIEl0ZXJhdG9yJztcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKFNUUklOR19JVEVSQVRPUik7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlW0BAaXRlcmF0b3JdYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUtQEBpdGVyYXRvclxuZGVmaW5lSXRlcmF0b3IoU3RyaW5nLCAnU3RyaW5nJywgZnVuY3Rpb24gKGl0ZXJhdGVkKSB7XG4gIHNldEludGVybmFsU3RhdGUodGhpcywge1xuICAgIHR5cGU6IFNUUklOR19JVEVSQVRPUixcbiAgICBzdHJpbmc6IFN0cmluZyhpdGVyYXRlZCksXG4gICAgaW5kZXg6IDBcbiAgfSk7XG4vLyBgJVN0cmluZ0l0ZXJhdG9yUHJvdG90eXBlJS5uZXh0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSVzdHJpbmdpdGVyYXRvcnByb3RvdHlwZSUubmV4dFxufSwgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgdmFyIHN0cmluZyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIGluZGV4ID0gc3RhdGUuaW5kZXg7XG4gIHZhciBwb2ludDtcbiAgaWYgKGluZGV4ID49IHN0cmluZy5sZW5ndGgpIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgcG9pbnQgPSBjaGFyQXQoc3RyaW5nLCBpbmRleCk7XG4gIHN0YXRlLmluZGV4ICs9IHBvaW50Lmxlbmd0aDtcbiAgcmV0dXJuIHsgdmFsdWU6IHBvaW50LCBkb25lOiBmYWxzZSB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVIVE1MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sJyk7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLWh0bWwtbWV0aG9kJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLmxpbmtgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5saW5rXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCgnbGluaycpIH0sIHtcbiAgbGluazogZnVuY3Rpb24gbGluayh1cmwpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnYScsICdocmVmJywgdXJsKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVJdGVyYXRvckNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1pdGVyYXRvci1jb25zdHJ1Y3RvcicpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgYUZ1bmN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2EtZnVuY3Rpb24nKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YnKTtcbnZhciBnZXRGbGFncyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZmxhZ3MnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGFkdmFuY2VTdHJpbmdJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hZHZhbmNlLXN0cmluZy1pbmRleCcpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtc3RhdGUnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcblxudmFyIE1BVENIX0FMTCA9IHdlbGxLbm93blN5bWJvbCgnbWF0Y2hBbGwnKTtcbnZhciBSRUdFWFBfU1RSSU5HID0gJ1JlZ0V4cCBTdHJpbmcnO1xudmFyIFJFR0VYUF9TVFJJTkdfSVRFUkFUT1IgPSBSRUdFWFBfU1RSSU5HICsgJyBJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihSRUdFWFBfU1RSSU5HX0lURVJBVE9SKTtcbnZhciBSZWdFeHBQcm90b3R5cGUgPSBSZWdFeHAucHJvdG90eXBlO1xudmFyIHJlZ0V4cEJ1aWx0aW5FeGVjID0gUmVnRXhwUHJvdG90eXBlLmV4ZWM7XG5cbnZhciByZWdFeHBFeGVjID0gZnVuY3Rpb24gKFIsIFMpIHtcbiAgdmFyIGV4ZWMgPSBSLmV4ZWM7XG4gIHZhciByZXN1bHQ7XG4gIGlmICh0eXBlb2YgZXhlYyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVzdWx0ID0gZXhlYy5jYWxsKFIsIFMpO1xuICAgIGlmICh0eXBlb2YgcmVzdWx0ICE9ICdvYmplY3QnKSB0aHJvdyBUeXBlRXJyb3IoJ0luY29ycmVjdCBleGVjIHJlc3VsdCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gcmV0dXJuIHJlZ0V4cEJ1aWx0aW5FeGVjLmNhbGwoUiwgUyk7XG59O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxudmFyICRSZWdFeHBTdHJpbmdJdGVyYXRvciA9IGNyZWF0ZUl0ZXJhdG9yQ29uc3RydWN0b3IoZnVuY3Rpb24gUmVnRXhwU3RyaW5nSXRlcmF0b3IocmVnZXhwLCBzdHJpbmcsIGdsb2JhbCwgZnVsbFVuaWNvZGUpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogUkVHRVhQX1NUUklOR19JVEVSQVRPUixcbiAgICByZWdleHA6IHJlZ2V4cCxcbiAgICBzdHJpbmc6IHN0cmluZyxcbiAgICBnbG9iYWw6IGdsb2JhbCxcbiAgICB1bmljb2RlOiBmdWxsVW5pY29kZSxcbiAgICBkb25lOiBmYWxzZVxuICB9KTtcbn0sIFJFR0VYUF9TVFJJTkcsIGZ1bmN0aW9uIG5leHQoKSB7XG4gIHZhciBzdGF0ZSA9IGdldEludGVybmFsU3RhdGUodGhpcyk7XG4gIGlmIChzdGF0ZS5kb25lKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIHZhciBSID0gc3RhdGUucmVnZXhwO1xuICB2YXIgUyA9IHN0YXRlLnN0cmluZztcbiAgdmFyIG1hdGNoID0gcmVnRXhwRXhlYyhSLCBTKTtcbiAgaWYgKG1hdGNoID09PSBudWxsKSByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiBzdGF0ZS5kb25lID0gdHJ1ZSB9O1xuICBpZiAoc3RhdGUuZ2xvYmFsKSB7XG4gICAgaWYgKFN0cmluZyhtYXRjaFswXSkgPT0gJycpIFIubGFzdEluZGV4ID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHRvTGVuZ3RoKFIubGFzdEluZGV4KSwgc3RhdGUudW5pY29kZSk7XG4gICAgcmV0dXJuIHsgdmFsdWU6IG1hdGNoLCBkb25lOiBmYWxzZSB9O1xuICB9XG4gIHN0YXRlLmRvbmUgPSB0cnVlO1xuICByZXR1cm4geyB2YWx1ZTogbWF0Y2gsIGRvbmU6IGZhbHNlIH07XG59KTtcblxudmFyICRtYXRjaEFsbCA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIFIgPSBhbk9iamVjdCh0aGlzKTtcbiAgdmFyIFMgPSBTdHJpbmcoc3RyaW5nKTtcbiAgdmFyIEMsIGZsYWdzVmFsdWUsIGZsYWdzLCBtYXRjaGVyLCBnbG9iYWwsIGZ1bGxVbmljb2RlO1xuICBDID0gc3BlY2llc0NvbnN0cnVjdG9yKFIsIFJlZ0V4cCk7XG4gIGZsYWdzVmFsdWUgPSBSLmZsYWdzO1xuICBpZiAoZmxhZ3NWYWx1ZSA9PT0gdW5kZWZpbmVkICYmIFIgaW5zdGFuY2VvZiBSZWdFeHAgJiYgISgnZmxhZ3MnIGluIFJlZ0V4cFByb3RvdHlwZSkpIHtcbiAgICBmbGFnc1ZhbHVlID0gZ2V0RmxhZ3MuY2FsbChSKTtcbiAgfVxuICBmbGFncyA9IGZsYWdzVmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKGZsYWdzVmFsdWUpO1xuICBtYXRjaGVyID0gbmV3IEMoQyA9PT0gUmVnRXhwID8gUi5zb3VyY2UgOiBSLCBmbGFncyk7XG4gIGdsb2JhbCA9ICEhfmZsYWdzLmluZGV4T2YoJ2cnKTtcbiAgZnVsbFVuaWNvZGUgPSAhIX5mbGFncy5pbmRleE9mKCd1Jyk7XG4gIG1hdGNoZXIubGFzdEluZGV4ID0gdG9MZW5ndGgoUi5sYXN0SW5kZXgpO1xuICByZXR1cm4gbmV3ICRSZWdFeHBTdHJpbmdJdGVyYXRvcihtYXRjaGVyLCBTLCBnbG9iYWwsIGZ1bGxVbmljb2RlKTtcbn07XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoQWxsYCBtZXRob2Rcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L3Byb3Bvc2FsLXN0cmluZy1tYXRjaGFsbFxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlIH0sIHtcbiAgbWF0Y2hBbGw6IGZ1bmN0aW9uIG1hdGNoQWxsKHJlZ2V4cCkge1xuICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICB2YXIgUywgbWF0Y2hlciwgcng7XG4gICAgaWYgKHJlZ2V4cCAhPSBudWxsKSB7XG4gICAgICBtYXRjaGVyID0gcmVnZXhwW01BVENIX0FMTF07XG4gICAgICBpZiAobWF0Y2hlciA9PT0gdW5kZWZpbmVkICYmIElTX1BVUkUgJiYgY2xhc3NvZihyZWdleHApID09ICdSZWdFeHAnKSBtYXRjaGVyID0gJG1hdGNoQWxsO1xuICAgICAgaWYgKG1hdGNoZXIgIT0gbnVsbCkgcmV0dXJuIGFGdW5jdGlvbihtYXRjaGVyKS5jYWxsKHJlZ2V4cCwgTyk7XG4gICAgfVxuICAgIFMgPSBTdHJpbmcoTyk7XG4gICAgcnggPSBuZXcgUmVnRXhwKHJlZ2V4cCwgJ2cnKTtcbiAgICByZXR1cm4gSVNfUFVSRSA/ICRtYXRjaEFsbC5jYWxsKHJ4LCBTKSA6IHJ4W01BVENIX0FMTF0oUyk7XG4gIH1cbn0pO1xuXG5JU19QVVJFIHx8IE1BVENIX0FMTCBpbiBSZWdFeHBQcm90b3R5cGUgfHwgaGlkZShSZWdFeHBQcm90b3R5cGUsIE1BVENIX0FMTCwgJG1hdGNoQWxsKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBmaXhSZWdFeHBXZWxsS25vd25TeW1ib2xMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9maXgtcmVnZXhwLXdlbGwta25vd24tc3ltYm9sLWxvZ2ljJyk7XG52YXIgYW5PYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYW4tb2JqZWN0Jyk7XG52YXIgdG9MZW5ndGggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8tbGVuZ3RoJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbi8vIEBAbWF0Y2ggbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdtYXRjaCcsIDEsIGZ1bmN0aW9uIChNQVRDSCwgbmF0aXZlTWF0Y2gsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICByZXR1cm4gW1xuICAgIC8vIGBTdHJpbmcucHJvdG90eXBlLm1hdGNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLm1hdGNoXG4gICAgZnVuY3Rpb24gbWF0Y2gocmVnZXhwKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgbWF0Y2hlciA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbTUFUQ0hdO1xuICAgICAgcmV0dXJuIG1hdGNoZXIgIT09IHVuZGVmaW5lZCA/IG1hdGNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW01BVENIXShTdHJpbmcoTykpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEBtYXRjaF1gIG1ldGhvZFxuICAgIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXJlZ2V4cC5wcm90b3R5cGUtQEBtYXRjaFxuICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlTWF0Y2gsIHJlZ2V4cCwgdGhpcyk7XG4gICAgICBpZiAocmVzLmRvbmUpIHJldHVybiByZXMudmFsdWU7XG5cbiAgICAgIHZhciByeCA9IGFuT2JqZWN0KHJlZ2V4cCk7XG4gICAgICB2YXIgUyA9IFN0cmluZyh0aGlzKTtcblxuICAgICAgaWYgKCFyeC5nbG9iYWwpIHJldHVybiByZWdFeHBFeGVjKHJ4LCBTKTtcblxuICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgIHJ4Lmxhc3RJbmRleCA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgdmFyIG4gPSAwO1xuICAgICAgdmFyIHJlc3VsdDtcbiAgICAgIHdoaWxlICgocmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUykpICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBtYXRjaFN0ciA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICBBW25dID0gbWF0Y2hTdHI7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICAgIG4rKztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuID09PSAwID8gbnVsbCA6IEE7XG4gICAgfVxuICBdO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkcGFkRW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1wYWQnKS5lbmQ7XG52YXIgV0VCS0lUX0JVRyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWJraXQtc3RyaW5nLXBhZC1idWcnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUucGFkRW5kYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucGFkZW5kXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogV0VCS0lUX0JVRyB9LCB7XG4gIHBhZEVuZDogZnVuY3Rpb24gcGFkRW5kKG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZEVuZCh0aGlzLCBtYXhMZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkcGFkU3RhcnQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXBhZCcpLnN0YXJ0O1xudmFyIFdFQktJVF9CVUcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2Via2l0LXN0cmluZy1wYWQtYnVnJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnBhZFN0YXJ0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucGFkc3RhcnRcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBXRUJLSVRfQlVHIH0sIHtcbiAgcGFkU3RhcnQ6IGZ1bmN0aW9uIHBhZFN0YXJ0KG1heExlbmd0aCAvKiAsIGZpbGxTdHJpbmcgPSAnICcgKi8pIHtcbiAgICByZXR1cm4gJHBhZFN0YXJ0KHRoaXMsIG1heExlbmd0aCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB9XG59KTtcbiIsInZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbmRleGVkLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xuXG4vLyBgU3RyaW5nLnJhd2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucmF3XG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgc3RhdDogdHJ1ZSB9LCB7XG4gIHJhdzogZnVuY3Rpb24gcmF3KHRlbXBsYXRlKSB7XG4gICAgdmFyIHJhd1RlbXBsYXRlID0gdG9JbmRleGVkT2JqZWN0KHRlbXBsYXRlLnJhdyk7XG4gICAgdmFyIGxpdGVyYWxTZWdtZW50cyA9IHRvTGVuZ3RoKHJhd1RlbXBsYXRlLmxlbmd0aCk7XG4gICAgdmFyIGFyZ3VtZW50c0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgdmFyIGVsZW1lbnRzID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlIChsaXRlcmFsU2VnbWVudHMgPiBpKSB7XG4gICAgICBlbGVtZW50cy5wdXNoKFN0cmluZyhyYXdUZW1wbGF0ZVtpKytdKSk7XG4gICAgICBpZiAoaSA8IGFyZ3VtZW50c0xlbmd0aCkgZWxlbWVudHMucHVzaChTdHJpbmcoYXJndW1lbnRzW2ldKSk7XG4gICAgfSByZXR1cm4gZWxlbWVudHMuam9pbignJyk7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgcmVwZWF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1yZXBlYXQnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUucmVwZWF0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUucmVwZWF0XG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUgfSwge1xuICByZXBlYXQ6IHJlcGVhdFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvSW50ZWdlciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1pbnRlZ2VyJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciByZWdFeHBFeGVjID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZ2V4cC1leGVjLWFic3RyYWN0Jyk7XG5cbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFMgPSAvXFwkKFskJidgXXxcXGRcXGQ/fDxbXj5dKj4pL2c7XG52YXIgU1VCU1RJVFVUSU9OX1NZTUJPTFNfTk9fTkFNRUQgPSAvXFwkKFskJidgXXxcXGRcXGQ/KS9nO1xuXG52YXIgbWF5YmVUb1N0cmluZyA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gaXQgPT09IHVuZGVmaW5lZCA/IGl0IDogU3RyaW5nKGl0KTtcbn07XG5cbi8vIEBAcmVwbGFjZSBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3JlcGxhY2UnLCAyLCBmdW5jdGlvbiAoUkVQTEFDRSwgbmF0aXZlUmVwbGFjZSwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUucmVwbGFjZWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5yZXBsYWNlXG4gICAgZnVuY3Rpb24gcmVwbGFjZShzZWFyY2hWYWx1ZSwgcmVwbGFjZVZhbHVlKSB7XG4gICAgICB2YXIgTyA9IHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcyk7XG4gICAgICB2YXIgcmVwbGFjZXIgPSBzZWFyY2hWYWx1ZSA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZWFyY2hWYWx1ZVtSRVBMQUNFXTtcbiAgICAgIHJldHVybiByZXBsYWNlciAhPT0gdW5kZWZpbmVkXG4gICAgICAgID8gcmVwbGFjZXIuY2FsbChzZWFyY2hWYWx1ZSwgTywgcmVwbGFjZVZhbHVlKVxuICAgICAgICA6IG5hdGl2ZVJlcGxhY2UuY2FsbChTdHJpbmcoTyksIHNlYXJjaFZhbHVlLCByZXBsYWNlVmFsdWUpO1xuICAgIH0sXG4gICAgLy8gYFJlZ0V4cC5wcm90b3R5cGVbQEByZXBsYWNlXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHJlcGxhY2VcbiAgICBmdW5jdGlvbiAocmVnZXhwLCByZXBsYWNlVmFsdWUpIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlUmVwbGFjZSwgcmVnZXhwLCB0aGlzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgIHZhciBmdW5jdGlvbmFsUmVwbGFjZSA9IHR5cGVvZiByZXBsYWNlVmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICBpZiAoIWZ1bmN0aW9uYWxSZXBsYWNlKSByZXBsYWNlVmFsdWUgPSBTdHJpbmcocmVwbGFjZVZhbHVlKTtcblxuICAgICAgdmFyIGdsb2JhbCA9IHJ4Lmdsb2JhbDtcbiAgICAgIGlmIChnbG9iYWwpIHtcbiAgICAgICAgdmFyIGZ1bGxVbmljb2RlID0gcngudW5pY29kZTtcbiAgICAgICAgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVnRXhwRXhlYyhyeCwgUyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IG51bGwpIGJyZWFrO1xuXG4gICAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgICBpZiAoIWdsb2JhbCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIG1hdGNoU3RyID0gU3RyaW5nKHJlc3VsdFswXSk7XG4gICAgICAgIGlmIChtYXRjaFN0ciA9PT0gJycpIHJ4Lmxhc3RJbmRleCA9IGFkdmFuY2VTdHJpbmdJbmRleChTLCB0b0xlbmd0aChyeC5sYXN0SW5kZXgpLCBmdWxsVW5pY29kZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhY2N1bXVsYXRlZFJlc3VsdCA9ICcnO1xuICAgICAgdmFyIG5leHRTb3VyY2VQb3NpdGlvbiA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0c1tpXTtcblxuICAgICAgICB2YXIgbWF0Y2hlZCA9IFN0cmluZyhyZXN1bHRbMF0pO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBtYXgobWluKHRvSW50ZWdlcihyZXN1bHQuaW5kZXgpLCBTLmxlbmd0aCksIDApO1xuICAgICAgICB2YXIgY2FwdHVyZXMgPSBbXTtcbiAgICAgICAgLy8gTk9URTogVGhpcyBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgIC8vICAgY2FwdHVyZXMgPSByZXN1bHQuc2xpY2UoMSkubWFwKG1heWJlVG9TdHJpbmcpXG4gICAgICAgIC8vIGJ1dCBmb3Igc29tZSByZWFzb24gYG5hdGl2ZVNsaWNlLmNhbGwocmVzdWx0LCAxLCByZXN1bHQubGVuZ3RoKWAgKGNhbGxlZCBpblxuICAgICAgICAvLyB0aGUgc2xpY2UgcG9seWZpbGwgd2hlbiBzbGljaW5nIG5hdGl2ZSBhcnJheXMpIFwiZG9lc24ndCB3b3JrXCIgaW4gc2FmYXJpIDkgYW5kXG4gICAgICAgIC8vIGNhdXNlcyBhIGNyYXNoIChodHRwczovL3Bhc3RlYmluLmNvbS9OMjFRemVRQSkgd2hlbiB0cnlpbmcgdG8gZGVidWcgaXQuXG4gICAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgcmVzdWx0Lmxlbmd0aDsgaisrKSBjYXB0dXJlcy5wdXNoKG1heWJlVG9TdHJpbmcocmVzdWx0W2pdKSk7XG4gICAgICAgIHZhciBuYW1lZENhcHR1cmVzID0gcmVzdWx0Lmdyb3VwcztcbiAgICAgICAgaWYgKGZ1bmN0aW9uYWxSZXBsYWNlKSB7XG4gICAgICAgICAgdmFyIHJlcGxhY2VyQXJncyA9IFttYXRjaGVkXS5jb25jYXQoY2FwdHVyZXMsIHBvc2l0aW9uLCBTKTtcbiAgICAgICAgICBpZiAobmFtZWRDYXB0dXJlcyAhPT0gdW5kZWZpbmVkKSByZXBsYWNlckFyZ3MucHVzaChuYW1lZENhcHR1cmVzKTtcbiAgICAgICAgICB2YXIgcmVwbGFjZW1lbnQgPSBTdHJpbmcocmVwbGFjZVZhbHVlLmFwcGx5KHVuZGVmaW5lZCwgcmVwbGFjZXJBcmdzKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVwbGFjZW1lbnQgPSBnZXRTdWJzdGl0dXRpb24obWF0Y2hlZCwgUywgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSBuZXh0U291cmNlUG9zaXRpb24pIHtcbiAgICAgICAgICBhY2N1bXVsYXRlZFJlc3VsdCArPSBTLnNsaWNlKG5leHRTb3VyY2VQb3NpdGlvbiwgcG9zaXRpb24pICsgcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgbmV4dFNvdXJjZVBvc2l0aW9uID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY3VtdWxhdGVkUmVzdWx0ICsgUy5zbGljZShuZXh0U291cmNlUG9zaXRpb24pO1xuICAgIH1cbiAgXTtcblxuICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1nZXRzdWJzdGl0dXRpb25cbiAgZnVuY3Rpb24gZ2V0U3Vic3RpdHV0aW9uKG1hdGNoZWQsIHN0ciwgcG9zaXRpb24sIGNhcHR1cmVzLCBuYW1lZENhcHR1cmVzLCByZXBsYWNlbWVudCkge1xuICAgIHZhciB0YWlsUG9zID0gcG9zaXRpb24gKyBtYXRjaGVkLmxlbmd0aDtcbiAgICB2YXIgbSA9IGNhcHR1cmVzLmxlbmd0aDtcbiAgICB2YXIgc3ltYm9scyA9IFNVQlNUSVRVVElPTl9TWU1CT0xTX05PX05BTUVEO1xuICAgIGlmIChuYW1lZENhcHR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIG5hbWVkQ2FwdHVyZXMgPSB0b09iamVjdChuYW1lZENhcHR1cmVzKTtcbiAgICAgIHN5bWJvbHMgPSBTVUJTVElUVVRJT05fU1lNQk9MUztcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJlcGxhY2UuY2FsbChyZXBsYWNlbWVudCwgc3ltYm9scywgZnVuY3Rpb24gKG1hdGNoLCBjaCkge1xuICAgICAgdmFyIGNhcHR1cmU7XG4gICAgICBzd2l0Y2ggKGNoLmNoYXJBdCgwKSkge1xuICAgICAgICBjYXNlICckJzogcmV0dXJuICckJztcbiAgICAgICAgY2FzZSAnJic6IHJldHVybiBtYXRjaGVkO1xuICAgICAgICBjYXNlICdgJzogcmV0dXJuIHN0ci5zbGljZSgwLCBwb3NpdGlvbik7XG4gICAgICAgIGNhc2UgXCInXCI6IHJldHVybiBzdHIuc2xpY2UodGFpbFBvcyk7XG4gICAgICAgIGNhc2UgJzwnOlxuICAgICAgICAgIGNhcHR1cmUgPSBuYW1lZENhcHR1cmVzW2NoLnNsaWNlKDEsIC0xKV07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6IC8vIFxcZFxcZD9cbiAgICAgICAgICB2YXIgbiA9ICtjaDtcbiAgICAgICAgICBpZiAobiA9PT0gMCkgcmV0dXJuIG1hdGNoO1xuICAgICAgICAgIGlmIChuID4gbSkge1xuICAgICAgICAgICAgdmFyIGYgPSBmbG9vcihuIC8gMTApO1xuICAgICAgICAgICAgaWYgKGYgPT09IDApIHJldHVybiBtYXRjaDtcbiAgICAgICAgICAgIGlmIChmIDw9IG0pIHJldHVybiBjYXB0dXJlc1tmIC0gMV0gPT09IHVuZGVmaW5lZCA/IGNoLmNoYXJBdCgxKSA6IGNhcHR1cmVzW2YgLSAxXSArIGNoLmNoYXJBdCgxKTtcbiAgICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FwdHVyZSA9IGNhcHR1cmVzW24gLSAxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXB0dXJlID09PSB1bmRlZmluZWQgPyAnJyA6IGNhcHR1cmU7XG4gICAgfSk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZpeC1yZWdleHAtd2VsbC1rbm93bi1zeW1ib2wtbG9naWMnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlcXVpcmUtb2JqZWN0LWNvZXJjaWJsZScpO1xudmFyIHNhbWVWYWx1ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zYW1lLXZhbHVlJyk7XG52YXIgcmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xuXG4vLyBAQHNlYXJjaCBsb2dpY1xuZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMoJ3NlYXJjaCcsIDEsIGZ1bmN0aW9uIChTRUFSQ0gsIG5hdGl2ZVNlYXJjaCwgbWF5YmVDYWxsTmF0aXZlKSB7XG4gIHJldHVybiBbXG4gICAgLy8gYFN0cmluZy5wcm90b3R5cGUuc2VhcmNoYCBtZXRob2RcbiAgICAvLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnNlYXJjaFxuICAgIGZ1bmN0aW9uIHNlYXJjaChyZWdleHApIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBzZWFyY2hlciA9IHJlZ2V4cCA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiByZWdleHBbU0VBUkNIXTtcbiAgICAgIHJldHVybiBzZWFyY2hlciAhPT0gdW5kZWZpbmVkID8gc2VhcmNoZXIuY2FsbChyZWdleHAsIE8pIDogbmV3IFJlZ0V4cChyZWdleHApW1NFQVJDSF0oU3RyaW5nKE8pKTtcbiAgICB9LFxuICAgIC8vIGBSZWdFeHAucHJvdG90eXBlW0BAc2VhcmNoXWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNlYXJjaFxuICAgIGZ1bmN0aW9uIChyZWdleHApIHtcbiAgICAgIHZhciByZXMgPSBtYXliZUNhbGxOYXRpdmUobmF0aXZlU2VhcmNoLCByZWdleHAsIHRoaXMpO1xuICAgICAgaWYgKHJlcy5kb25lKSByZXR1cm4gcmVzLnZhbHVlO1xuXG4gICAgICB2YXIgcnggPSBhbk9iamVjdChyZWdleHApO1xuICAgICAgdmFyIFMgPSBTdHJpbmcodGhpcyk7XG5cbiAgICAgIHZhciBwcmV2aW91c0xhc3RJbmRleCA9IHJ4Lmxhc3RJbmRleDtcbiAgICAgIGlmICghc2FtZVZhbHVlKHByZXZpb3VzTGFzdEluZGV4LCAwKSkgcngubGFzdEluZGV4ID0gMDtcbiAgICAgIHZhciByZXN1bHQgPSByZWdFeHBFeGVjKHJ4LCBTKTtcbiAgICAgIGlmICghc2FtZVZhbHVlKHJ4Lmxhc3RJbmRleCwgcHJldmlvdXNMYXN0SW5kZXgpKSByeC5sYXN0SW5kZXggPSBwcmV2aW91c0xhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IG51bGwgPyAtMSA6IHJlc3VsdC5pbmRleDtcbiAgICB9XG4gIF07XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNyZWF0ZUhUTUwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWh0bWwnKTtcbnZhciBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1zdHJpbmctaHRtbC1tZXRob2QnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuc21hbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zbWFsbFxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ3NtYWxsJykgfSwge1xuICBzbWFsbDogZnVuY3Rpb24gc21hbGwoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3NtYWxsJywgJycsICcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZml4UmVnRXhwV2VsbEtub3duU3ltYm9sTG9naWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZml4LXJlZ2V4cC13ZWxsLWtub3duLXN5bWJvbC1sb2dpYycpO1xudmFyIGlzUmVnRXhwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXJlZ2V4cCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVxdWlyZS1vYmplY3QtY29lcmNpYmxlJyk7XG52YXIgc3BlY2llc0NvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NwZWNpZXMtY29uc3RydWN0b3InKTtcbnZhciBhZHZhbmNlU3RyaW5nSW5kZXggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYWR2YW5jZS1zdHJpbmctaW5kZXgnKTtcbnZhciB0b0xlbmd0aCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1sZW5ndGgnKTtcbnZhciBjYWxsUmVnRXhwRXhlYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWdleHAtZXhlYy1hYnN0cmFjdCcpO1xudmFyIHJlZ2V4cEV4ZWMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcmVnZXhwLWV4ZWMnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgYXJyYXlQdXNoID0gW10ucHVzaDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbnZhciBNQVhfVUlOVDMyID0gMHhGRkZGRkZGRjtcblxuLy8gYmFiZWwtbWluaWZ5IHRyYW5zcGlsZXMgUmVnRXhwKCd4JywgJ3knKSAtPiAveC95IGFuZCBpdCBjYXVzZXMgU3ludGF4RXJyb3JcbnZhciBTVVBQT1JUU19ZID0gIWZhaWxzKGZ1bmN0aW9uICgpIHsgcmV0dXJuICFSZWdFeHAoTUFYX1VJTlQzMiwgJ3knKTsgfSk7XG5cbi8vIEBAc3BsaXQgbG9naWNcbmZpeFJlZ0V4cFdlbGxLbm93blN5bWJvbExvZ2ljKCdzcGxpdCcsIDIsIGZ1bmN0aW9uIChTUExJVCwgbmF0aXZlU3BsaXQsIG1heWJlQ2FsbE5hdGl2ZSkge1xuICB2YXIgaW50ZXJuYWxTcGxpdDtcbiAgaWYgKFxuICAgICdhYmJjJy5zcGxpdCgvKGIpKi8pWzFdID09ICdjJyB8fFxuICAgICd0ZXN0Jy5zcGxpdCgvKD86KS8sIC0xKS5sZW5ndGggIT0gNCB8fFxuICAgICdhYicuc3BsaXQoLyg/OmFiKSovKS5sZW5ndGggIT0gMiB8fFxuICAgICcuJy5zcGxpdCgvKC4/KSguPykvKS5sZW5ndGggIT0gNCB8fFxuICAgICcuJy5zcGxpdCgvKCkoKS8pLmxlbmd0aCA+IDEgfHxcbiAgICAnJy5zcGxpdCgvLj8vKS5sZW5ndGhcbiAgKSB7XG4gICAgLy8gYmFzZWQgb24gZXM1LXNoaW0gaW1wbGVtZW50YXRpb24sIG5lZWQgdG8gcmV3b3JrIGl0XG4gICAgaW50ZXJuYWxTcGxpdCA9IGZ1bmN0aW9uIChzZXBhcmF0b3IsIGxpbWl0KSB7XG4gICAgICB2YXIgc3RyaW5nID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgICAgdmFyIGxpbSA9IGxpbWl0ID09PSB1bmRlZmluZWQgPyBNQVhfVUlOVDMyIDogbGltaXQgPj4+IDA7XG4gICAgICBpZiAobGltID09PSAwKSByZXR1cm4gW107XG4gICAgICBpZiAoc2VwYXJhdG9yID09PSB1bmRlZmluZWQpIHJldHVybiBbc3RyaW5nXTtcbiAgICAgIC8vIElmIGBzZXBhcmF0b3JgIGlzIG5vdCBhIHJlZ2V4LCB1c2UgbmF0aXZlIHNwbGl0XG4gICAgICBpZiAoIWlzUmVnRXhwKHNlcGFyYXRvcikpIHtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZVNwbGl0LmNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbSk7XG4gICAgICB9XG4gICAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgICB2YXIgZmxhZ3MgPSAoc2VwYXJhdG9yLmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci5tdWx0aWxpbmUgPyAnbScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHNlcGFyYXRvci51bmljb2RlID8gJ3UnIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChzZXBhcmF0b3Iuc3RpY2t5ID8gJ3knIDogJycpO1xuICAgICAgdmFyIGxhc3RMYXN0SW5kZXggPSAwO1xuICAgICAgLy8gTWFrZSBgZ2xvYmFsYCBhbmQgYXZvaWQgYGxhc3RJbmRleGAgaXNzdWVzIGJ5IHdvcmtpbmcgd2l0aCBhIGNvcHlcbiAgICAgIHZhciBzZXBhcmF0b3JDb3B5ID0gbmV3IFJlZ0V4cChzZXBhcmF0b3Iuc291cmNlLCBmbGFncyArICdnJyk7XG4gICAgICB2YXIgbWF0Y2gsIGxhc3RJbmRleCwgbGFzdExlbmd0aDtcbiAgICAgIHdoaWxlIChtYXRjaCA9IHJlZ2V4cEV4ZWMuY2FsbChzZXBhcmF0b3JDb3B5LCBzdHJpbmcpKSB7XG4gICAgICAgIGxhc3RJbmRleCA9IHNlcGFyYXRvckNvcHkubGFzdEluZGV4O1xuICAgICAgICBpZiAobGFzdEluZGV4ID4gbGFzdExhc3RJbmRleCkge1xuICAgICAgICAgIG91dHB1dC5wdXNoKHN0cmluZy5zbGljZShsYXN0TGFzdEluZGV4LCBtYXRjaC5pbmRleCkpO1xuICAgICAgICAgIGlmIChtYXRjaC5sZW5ndGggPiAxICYmIG1hdGNoLmluZGV4IDwgc3RyaW5nLmxlbmd0aCkgYXJyYXlQdXNoLmFwcGx5KG91dHB1dCwgbWF0Y2guc2xpY2UoMSkpO1xuICAgICAgICAgIGxhc3RMZW5ndGggPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgbGFzdExhc3RJbmRleCA9IGxhc3RJbmRleDtcbiAgICAgICAgICBpZiAob3V0cHV0Lmxlbmd0aCA+PSBsaW0pIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZXBhcmF0b3JDb3B5Lmxhc3RJbmRleCA9PT0gbWF0Y2guaW5kZXgpIHNlcGFyYXRvckNvcHkubGFzdEluZGV4Kys7IC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3BcbiAgICAgIH1cbiAgICAgIGlmIChsYXN0TGFzdEluZGV4ID09PSBzdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIGlmIChsYXN0TGVuZ3RoIHx8ICFzZXBhcmF0b3JDb3B5LnRlc3QoJycpKSBvdXRwdXQucHVzaCgnJyk7XG4gICAgICB9IGVsc2Ugb3V0cHV0LnB1c2goc3RyaW5nLnNsaWNlKGxhc3RMYXN0SW5kZXgpKTtcbiAgICAgIHJldHVybiBvdXRwdXQubGVuZ3RoID4gbGltID8gb3V0cHV0LnNsaWNlKDAsIGxpbSkgOiBvdXRwdXQ7XG4gICAgfTtcbiAgLy8gQ2hha3JhLCBWOFxuICB9IGVsc2UgaWYgKCcwJy5zcGxpdCh1bmRlZmluZWQsIDApLmxlbmd0aCkge1xuICAgIGludGVybmFsU3BsaXQgPSBmdW5jdGlvbiAoc2VwYXJhdG9yLCBsaW1pdCkge1xuICAgICAgcmV0dXJuIHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkICYmIGxpbWl0ID09PSAwID8gW10gOiBuYXRpdmVTcGxpdC5jYWxsKHRoaXMsIHNlcGFyYXRvciwgbGltaXQpO1xuICAgIH07XG4gIH0gZWxzZSBpbnRlcm5hbFNwbGl0ID0gbmF0aXZlU3BsaXQ7XG5cbiAgcmV0dXJuIFtcbiAgICAvLyBgU3RyaW5nLnByb3RvdHlwZS5zcGxpdGAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zcGxpdFxuICAgIGZ1bmN0aW9uIHNwbGl0KHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIHZhciBPID0gcmVxdWlyZU9iamVjdENvZXJjaWJsZSh0aGlzKTtcbiAgICAgIHZhciBzcGxpdHRlciA9IHNlcGFyYXRvciA9PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBzZXBhcmF0b3JbU1BMSVRdO1xuICAgICAgcmV0dXJuIHNwbGl0dGVyICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBzcGxpdHRlci5jYWxsKHNlcGFyYXRvciwgTywgbGltaXQpXG4gICAgICAgIDogaW50ZXJuYWxTcGxpdC5jYWxsKFN0cmluZyhPKSwgc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfSxcbiAgICAvLyBgUmVnRXhwLnByb3RvdHlwZVtAQHNwbGl0XWAgbWV0aG9kXG4gICAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcmVnZXhwLnByb3RvdHlwZS1AQHNwbGl0XG4gICAgLy9cbiAgICAvLyBOT1RFOiBUaGlzIGNhbm5vdCBiZSBwcm9wZXJseSBwb2x5ZmlsbGVkIGluIGVuZ2luZXMgdGhhdCBkb24ndCBzdXBwb3J0XG4gICAgLy8gdGhlICd5JyBmbGFnLlxuICAgIGZ1bmN0aW9uIChyZWdleHAsIGxpbWl0KSB7XG4gICAgICB2YXIgcmVzID0gbWF5YmVDYWxsTmF0aXZlKGludGVybmFsU3BsaXQsIHJlZ2V4cCwgdGhpcywgbGltaXQsIGludGVybmFsU3BsaXQgIT09IG5hdGl2ZVNwbGl0KTtcbiAgICAgIGlmIChyZXMuZG9uZSkgcmV0dXJuIHJlcy52YWx1ZTtcblxuICAgICAgdmFyIHJ4ID0gYW5PYmplY3QocmVnZXhwKTtcbiAgICAgIHZhciBTID0gU3RyaW5nKHRoaXMpO1xuICAgICAgdmFyIEMgPSBzcGVjaWVzQ29uc3RydWN0b3IocngsIFJlZ0V4cCk7XG5cbiAgICAgIHZhciB1bmljb2RlTWF0Y2hpbmcgPSByeC51bmljb2RlO1xuICAgICAgdmFyIGZsYWdzID0gKHJ4Lmlnbm9yZUNhc2UgPyAnaScgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJ4Lm11bHRpbGluZSA/ICdtJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAocngudW5pY29kZSA/ICd1JyA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAoU1VQUE9SVFNfWSA/ICd5JyA6ICdnJyk7XG5cbiAgICAgIC8vIF4oPyArIHJ4ICsgKSBpcyBuZWVkZWQsIGluIGNvbWJpbmF0aW9uIHdpdGggc29tZSBTIHNsaWNpbmcsIHRvXG4gICAgICAvLyBzaW11bGF0ZSB0aGUgJ3knIGZsYWcuXG4gICAgICB2YXIgc3BsaXR0ZXIgPSBuZXcgQyhTVVBQT1JUU19ZID8gcnggOiAnXig/OicgKyByeC5zb3VyY2UgKyAnKScsIGZsYWdzKTtcbiAgICAgIHZhciBsaW0gPSBsaW1pdCA9PT0gdW5kZWZpbmVkID8gTUFYX1VJTlQzMiA6IGxpbWl0ID4+PiAwO1xuICAgICAgaWYgKGxpbSA9PT0gMCkgcmV0dXJuIFtdO1xuICAgICAgaWYgKFMubGVuZ3RoID09PSAwKSByZXR1cm4gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFMpID09PSBudWxsID8gW1NdIDogW107XG4gICAgICB2YXIgcCA9IDA7XG4gICAgICB2YXIgcSA9IDA7XG4gICAgICB2YXIgQSA9IFtdO1xuICAgICAgd2hpbGUgKHEgPCBTLmxlbmd0aCkge1xuICAgICAgICBzcGxpdHRlci5sYXN0SW5kZXggPSBTVVBQT1JUU19ZID8gcSA6IDA7XG4gICAgICAgIHZhciB6ID0gY2FsbFJlZ0V4cEV4ZWMoc3BsaXR0ZXIsIFNVUFBPUlRTX1kgPyBTIDogUy5zbGljZShxKSk7XG4gICAgICAgIHZhciBlO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgeiA9PT0gbnVsbCB8fFxuICAgICAgICAgIChlID0gbWluKHRvTGVuZ3RoKHNwbGl0dGVyLmxhc3RJbmRleCArIChTVVBQT1JUU19ZID8gMCA6IHEpKSwgUy5sZW5ndGgpKSA9PT0gcFxuICAgICAgICApIHtcbiAgICAgICAgICBxID0gYWR2YW5jZVN0cmluZ0luZGV4KFMsIHEsIHVuaWNvZGVNYXRjaGluZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgQS5wdXNoKFMuc2xpY2UocCwgcSkpO1xuICAgICAgICAgIGlmIChBLmxlbmd0aCA9PT0gbGltKSByZXR1cm4gQTtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8PSB6Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgQS5wdXNoKHpbaV0pO1xuICAgICAgICAgICAgaWYgKEEubGVuZ3RoID09PSBsaW0pIHJldHVybiBBO1xuICAgICAgICAgIH1cbiAgICAgICAgICBxID0gcCA9IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEEucHVzaChTLnNsaWNlKHApKTtcbiAgICAgIHJldHVybiBBO1xuICAgIH1cbiAgXTtcbn0sICFTVVBQT1JUU19ZKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIG5vdEFSZWdFeHAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbm90LWEtcmVnZXhwJyk7XG52YXIgcmVxdWlyZU9iamVjdENvZXJjaWJsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZXF1aXJlLW9iamVjdC1jb2VyY2libGUnKTtcbnZhciBjb3JyZWN0SXNSZWdFeHBMb2dpYyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb3JyZWN0LWlzLXJlZ2V4cC1sb2dpYycpO1xuXG52YXIgbmF0aXZlU3RhcnRzV2l0aCA9ICcnLnN0YXJ0c1dpdGg7XG52YXIgbWluID0gTWF0aC5taW47XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnN0YXJ0c1dpdGhgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zdGFydHN3aXRoXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogIWNvcnJlY3RJc1JlZ0V4cExvZ2ljKCdzdGFydHNXaXRoJykgfSwge1xuICBzdGFydHNXaXRoOiBmdW5jdGlvbiBzdGFydHNXaXRoKHNlYXJjaFN0cmluZyAvKiAsIHBvc2l0aW9uID0gMCAqLykge1xuICAgIHZhciB0aGF0ID0gU3RyaW5nKHJlcXVpcmVPYmplY3RDb2VyY2libGUodGhpcykpO1xuICAgIG5vdEFSZWdFeHAoc2VhcmNoU3RyaW5nKTtcbiAgICB2YXIgaW5kZXggPSB0b0xlbmd0aChtaW4oYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIHRoYXQubGVuZ3RoKSk7XG4gICAgdmFyIHNlYXJjaCA9IFN0cmluZyhzZWFyY2hTdHJpbmcpO1xuICAgIHJldHVybiBuYXRpdmVTdGFydHNXaXRoXG4gICAgICA/IG5hdGl2ZVN0YXJ0c1dpdGguY2FsbCh0aGF0LCBzZWFyY2gsIGluZGV4KVxuICAgICAgOiB0aGF0LnNsaWNlKGluZGV4LCBpbmRleCArIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgY3JlYXRlSFRNTCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaHRtbCcpO1xudmFyIGZvcmNlZFN0cmluZ0hUTUxNZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZm9yY2VkLXN0cmluZy1odG1sLW1ldGhvZCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS5zdHJpa2VgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3RyaW5nLnByb3RvdHlwZS5zdHJpa2VcbiQoeyB0YXJnZXQ6ICdTdHJpbmcnLCBwcm90bzogdHJ1ZSwgZm9yY2VkOiBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kKCdzdHJpa2UnKSB9LCB7XG4gIHN0cmlrZTogZnVuY3Rpb24gc3RyaWtlKCkge1xuICAgIHJldHVybiBjcmVhdGVIVE1MKHRoaXMsICdzdHJpa2UnLCAnJywgJycpO1xuICB9XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGNyZWF0ZUhUTUwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLWh0bWwnKTtcbnZhciBmb3JjZWRTdHJpbmdIVE1MTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZvcmNlZC1zdHJpbmctaHRtbC1tZXRob2QnKTtcblxuLy8gYFN0cmluZy5wcm90b3R5cGUuc3ViYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUuc3ViXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCgnc3ViJykgfSwge1xuICBzdWI6IGZ1bmN0aW9uIHN1YigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRNTCh0aGlzLCAnc3ViJywgJycsICcnKTtcbiAgfVxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciBjcmVhdGVIVE1MID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NyZWF0ZS1odG1sJyk7XG52YXIgZm9yY2VkU3RyaW5nSFRNTE1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLWh0bWwtbWV0aG9kJyk7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnN1cGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zdHJpbmcucHJvdG90eXBlLnN1cFxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ0hUTUxNZXRob2QoJ3N1cCcpIH0sIHtcbiAgc3VwOiBmdW5jdGlvbiBzdXAoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUhUTUwodGhpcywgJ3N1cCcsICcnLCAnJyk7XG4gIH1cbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHRyaW1FbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS5lbmQ7XG52YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLXRyaW0tbWV0aG9kJyk7XG5cbnZhciBGT1JDRUQgPSBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltRW5kJyk7XG5cbnZhciB0cmltRW5kID0gRk9SQ0VEID8gZnVuY3Rpb24gdHJpbUVuZCgpIHtcbiAgcmV0dXJuICR0cmltRW5kKHRoaXMpO1xufSA6ICcnLnRyaW1FbmQ7XG5cbi8vIGBTdHJpbmcucHJvdG90eXBlLnsgdHJpbUVuZCwgdHJpbVJpZ2h0IH1gIG1ldGhvZHNcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS90YzM5L2VjbWFzY3JpcHQtc3RyaW5nLWxlZnQtcmlnaHQtdHJpbVxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IEZPUkNFRCB9LCB7XG4gIHRyaW1FbmQ6IHRyaW1FbmQsXG4gIHRyaW1SaWdodDogdHJpbUVuZFxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcbnZhciAkdHJpbVN0YXJ0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy10cmltJykuc3RhcnQ7XG52YXIgZm9yY2VkU3RyaW5nVHJpbU1ldGhvZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mb3JjZWQtc3RyaW5nLXRyaW0tbWV0aG9kJyk7XG5cbnZhciBGT1JDRUQgPSBmb3JjZWRTdHJpbmdUcmltTWV0aG9kKCd0cmltU3RhcnQnKTtcblxudmFyIHRyaW1TdGFydCA9IEZPUkNFRCA/IGZ1bmN0aW9uIHRyaW1TdGFydCgpIHtcbiAgcmV0dXJuICR0cmltU3RhcnQodGhpcyk7XG59IDogJycudHJpbVN0YXJ0O1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS57IHRyaW1TdGFydCwgdHJpbUxlZnQgfWAgbWV0aG9kc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3RjMzkvZWNtYXNjcmlwdC1zdHJpbmctbGVmdC1yaWdodC10cmltXG4kKHsgdGFyZ2V0OiAnU3RyaW5nJywgcHJvdG86IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgdHJpbVN0YXJ0OiB0cmltU3RhcnQsXG4gIHRyaW1MZWZ0OiB0cmltU3RhcnRcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgJHRyaW0gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3RyaW5nLXRyaW0nKS50cmltO1xudmFyIGZvcmNlZFN0cmluZ1RyaW1NZXRob2QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZm9yY2VkLXN0cmluZy10cmltLW1ldGhvZCcpO1xuXG4vLyBgU3RyaW5nLnByb3RvdHlwZS50cmltYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN0cmluZy5wcm90b3R5cGUudHJpbVxuJCh7IHRhcmdldDogJ1N0cmluZycsIHByb3RvOiB0cnVlLCBmb3JjZWQ6IGZvcmNlZFN0cmluZ1RyaW1NZXRob2QoJ3RyaW0nKSB9LCB7XG4gIHRyaW06IGZ1bmN0aW9uIHRyaW0oKSB7XG4gICAgcmV0dXJuICR0cmltKHRoaXMpO1xuICB9XG59KTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wuYXN5bmNJdGVyYXRvcmAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5hc3luY2l0ZXJhdG9yXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ2FzeW5jSXRlcmF0b3InKTtcbiIsIi8vIGBTeW1ib2wucHJvdG90eXBlLmRlc2NyaXB0aW9uYCBnZXR0ZXJcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUuZGVzY3JpcHRpb25cbid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtZGVmaW5lLXByb3BlcnR5JykuZjtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvcHktY29uc3RydWN0b3ItcHJvcGVydGllcycpO1xuXG52YXIgTmF0aXZlU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcblxuaWYgKERFU0NSSVBUT1JTICYmIHR5cGVvZiBOYXRpdmVTeW1ib2wgPT0gJ2Z1bmN0aW9uJyAmJiAoISgnZGVzY3JpcHRpb24nIGluIE5hdGl2ZVN5bWJvbC5wcm90b3R5cGUpIHx8XG4gIC8vIFNhZmFyaSAxMiBidWdcbiAgTmF0aXZlU3ltYm9sKCkuZGVzY3JpcHRpb24gIT09IHVuZGVmaW5lZFxuKSkge1xuICB2YXIgRW1wdHlTdHJpbmdEZXNjcmlwdGlvblN0b3JlID0ge307XG4gIC8vIHdyYXAgU3ltYm9sIGNvbnN0cnVjdG9yIGZvciBjb3JyZWN0IHdvcmsgd2l0aCB1bmRlZmluZWQgZGVzY3JpcHRpb25cbiAgdmFyIFN5bWJvbFdyYXBwZXIgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgdmFyIGRlc2NyaXB0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8IDEgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBTdHJpbmcoYXJndW1lbnRzWzBdKTtcbiAgICB2YXIgcmVzdWx0ID0gdGhpcyBpbnN0YW5jZW9mIFN5bWJvbFdyYXBwZXJcbiAgICAgID8gbmV3IE5hdGl2ZVN5bWJvbChkZXNjcmlwdGlvbilcbiAgICAgIC8vIGluIEVkZ2UgMTMsIFN0cmluZyhTeW1ib2wodW5kZWZpbmVkKSkgPT09ICdTeW1ib2wodW5kZWZpbmVkKSdcbiAgICAgIDogZGVzY3JpcHRpb24gPT09IHVuZGVmaW5lZCA/IE5hdGl2ZVN5bWJvbCgpIDogTmF0aXZlU3ltYm9sKGRlc2NyaXB0aW9uKTtcbiAgICBpZiAoZGVzY3JpcHRpb24gPT09ICcnKSBFbXB0eVN0cmluZ0Rlc2NyaXB0aW9uU3RvcmVbcmVzdWx0XSA9IHRydWU7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcbiAgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyhTeW1ib2xXcmFwcGVyLCBOYXRpdmVTeW1ib2wpO1xuICB2YXIgc3ltYm9sUHJvdG90eXBlID0gU3ltYm9sV3JhcHBlci5wcm90b3R5cGUgPSBOYXRpdmVTeW1ib2wucHJvdG90eXBlO1xuICBzeW1ib2xQcm90b3R5cGUuY29uc3RydWN0b3IgPSBTeW1ib2xXcmFwcGVyO1xuXG4gIHZhciBzeW1ib2xUb1N0cmluZyA9IHN5bWJvbFByb3RvdHlwZS50b1N0cmluZztcbiAgdmFyIG5hdGl2ZSA9IFN0cmluZyhOYXRpdmVTeW1ib2woJ3Rlc3QnKSkgPT0gJ1N5bWJvbCh0ZXN0KSc7XG4gIHZhciByZWdleHAgPSAvXlN5bWJvbFxcKCguKilcXClbXildKyQvO1xuICBkZWZpbmVQcm9wZXJ0eShzeW1ib2xQcm90b3R5cGUsICdkZXNjcmlwdGlvbicsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiBkZXNjcmlwdGlvbigpIHtcbiAgICAgIHZhciBzeW1ib2wgPSBpc09iamVjdCh0aGlzKSA/IHRoaXMudmFsdWVPZigpIDogdGhpcztcbiAgICAgIHZhciBzdHJpbmcgPSBzeW1ib2xUb1N0cmluZy5jYWxsKHN5bWJvbCk7XG4gICAgICBpZiAoaGFzKEVtcHR5U3RyaW5nRGVzY3JpcHRpb25TdG9yZSwgc3ltYm9sKSkgcmV0dXJuICcnO1xuICAgICAgdmFyIGRlc2MgPSBuYXRpdmUgPyBzdHJpbmcuc2xpY2UoNywgLTEpIDogc3RyaW5nLnJlcGxhY2UocmVnZXhwLCAnJDEnKTtcbiAgICAgIHJldHVybiBkZXNjID09PSAnJyA/IHVuZGVmaW5lZCA6IGRlc2M7XG4gICAgfVxuICB9KTtcblxuICAkKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6IHRydWUgfSwge1xuICAgIFN5bWJvbDogU3ltYm9sV3JhcHBlclxuICB9KTtcbn1cbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wuaGFzSW5zdGFuY2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuaGFzaW5zdGFuY2VcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaGFzSW5zdGFuY2UnKTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLmlzY29uY2F0c3ByZWFkYWJsZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdpc0NvbmNhdFNwcmVhZGFibGUnKTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wuaXRlcmF0b3JgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuaXRlcmF0b3JcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBJU19QVVJFID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLXB1cmUnKTtcbnZhciBERVNDUklQVE9SUyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9kZXNjcmlwdG9ycycpO1xudmFyIE5BVElWRV9TWU1CT0wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXN5bWJvbCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG52YXIgaGFzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hhcycpO1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaXMtYXJyYXknKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBhbk9iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1vYmplY3QnKTtcbnZhciB0b09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1vYmplY3QnKTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdG8taW5kZXhlZC1vYmplY3QnKTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1wcmltaXRpdmUnKTtcbnZhciBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY3JlYXRlLXByb3BlcnR5LWRlc2NyaXB0b3InKTtcbnZhciBuYXRpdmVPYmplY3RDcmVhdGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWNyZWF0ZScpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWtleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzJyk7XG52YXIgZ2V0T3duUHJvcGVydHlOYW1lc0V4dGVybmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LW5hbWVzLWV4dGVybmFsJyk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1nZXQtb3duLXByb3BlcnR5LXN5bWJvbHMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWdldC1vd24tcHJvcGVydHktZGVzY3JpcHRvcicpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydHknKTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9vYmplY3QtcHJvcGVydHktaXMtZW51bWVyYWJsZScpO1xudmFyIGhpZGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaGlkZScpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgc2hhcmVkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NoYXJlZCcpO1xudmFyIHNoYXJlZEtleSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zaGFyZWQta2V5Jyk7XG52YXIgaGlkZGVuS2V5cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oaWRkZW4ta2V5cycpO1xudmFyIHVpZCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91aWQnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciB3cmFwcGVkV2VsbEtub3duU3ltYm9sTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3dyYXBwZWQtd2VsbC1rbm93bi1zeW1ib2wnKTtcbnZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG52YXIgc2V0VG9TdHJpbmdUYWcgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc2V0LXRvLXN0cmluZy10YWcnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcblxudmFyIEhJRERFTiA9IHNoYXJlZEtleSgnaGlkZGVuJyk7XG52YXIgU1lNQk9MID0gJ1N5bWJvbCc7XG52YXIgUFJPVE9UWVBFID0gJ3Byb3RvdHlwZSc7XG52YXIgVE9fUFJJTUlUSVZFID0gd2VsbEtub3duU3ltYm9sKCd0b1ByaW1pdGl2ZScpO1xudmFyIHNldEludGVybmFsU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLnNldDtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoU1lNQk9MKTtcbnZhciBPYmplY3RQcm90b3R5cGUgPSBPYmplY3RbUFJPVE9UWVBFXTtcbnZhciAkU3ltYm9sID0gZ2xvYmFsLlN5bWJvbDtcbnZhciBKU09OID0gZ2xvYmFsLkpTT047XG52YXIgbmF0aXZlSlNPTlN0cmluZ2lmeSA9IEpTT04gJiYgSlNPTi5zdHJpbmdpZnk7XG52YXIgbmF0aXZlR2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG52YXIgbmF0aXZlRGVmaW5lUHJvcGVydHkgPSBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mO1xudmFyIG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzRXh0ZXJuYWwuZjtcbnZhciBuYXRpdmVQcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHByb3BlcnR5SXNFbnVtZXJhYmxlTW9kdWxlLmY7XG52YXIgQWxsU3ltYm9scyA9IHNoYXJlZCgnc3ltYm9scycpO1xudmFyIE9iamVjdFByb3RvdHlwZVN5bWJvbHMgPSBzaGFyZWQoJ29wLXN5bWJvbHMnKTtcbnZhciBTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5ID0gc2hhcmVkKCdzdHJpbmctdG8tc3ltYm9sLXJlZ2lzdHJ5Jyk7XG52YXIgU3ltYm9sVG9TdHJpbmdSZWdpc3RyeSA9IHNoYXJlZCgnc3ltYm9sLXRvLXN0cmluZy1yZWdpc3RyeScpO1xudmFyIFdlbGxLbm93blN5bWJvbHNTdG9yZSA9IHNoYXJlZCgnd2tzJyk7XG52YXIgUU9iamVjdCA9IGdsb2JhbC5RT2JqZWN0O1xuLy8gRG9uJ3QgdXNlIHNldHRlcnMgaW4gUXQgU2NyaXB0LCBodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9pc3N1ZXMvMTczXG52YXIgVVNFX1NFVFRFUiA9ICFRT2JqZWN0IHx8ICFRT2JqZWN0W1BST1RPVFlQRV0gfHwgIVFPYmplY3RbUFJPVE9UWVBFXS5maW5kQ2hpbGQ7XG5cbi8vIGZhbGxiYWNrIGZvciBvbGQgQW5kcm9pZCwgaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTY4N1xudmFyIHNldFN5bWJvbERlc2NyaXB0b3IgPSBERVNDUklQVE9SUyAmJiBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuYXRpdmVPYmplY3RDcmVhdGUobmF0aXZlRGVmaW5lUHJvcGVydHkoe30sICdhJywge1xuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmF0aXZlRGVmaW5lUHJvcGVydHkodGhpcywgJ2EnLCB7IHZhbHVlOiA3IH0pLmE7IH1cbiAgfSkpLmEgIT0gNztcbn0pID8gZnVuY3Rpb24gKE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiAgdmFyIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoT2JqZWN0UHJvdG90eXBlLCBQKTtcbiAgaWYgKE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpIGRlbGV0ZSBPYmplY3RQcm90b3R5cGVbUF07XG4gIG5hdGl2ZURlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICBpZiAoT2JqZWN0UHJvdG90eXBlRGVzY3JpcHRvciAmJiBPICE9PSBPYmplY3RQcm90b3R5cGUpIHtcbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPYmplY3RQcm90b3R5cGUsIFAsIE9iamVjdFByb3RvdHlwZURlc2NyaXB0b3IpO1xuICB9XG59IDogbmF0aXZlRGVmaW5lUHJvcGVydHk7XG5cbnZhciB3cmFwID0gZnVuY3Rpb24gKHRhZywgZGVzY3JpcHRpb24pIHtcbiAgdmFyIHN5bWJvbCA9IEFsbFN5bWJvbHNbdGFnXSA9IG5hdGl2ZU9iamVjdENyZWF0ZSgkU3ltYm9sW1BST1RPVFlQRV0pO1xuICBzZXRJbnRlcm5hbFN0YXRlKHN5bWJvbCwge1xuICAgIHR5cGU6IFNZTUJPTCxcbiAgICB0YWc6IHRhZyxcbiAgICBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb25cbiAgfSk7XG4gIGlmICghREVTQ1JJUFRPUlMpIHN5bWJvbC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICByZXR1cm4gc3ltYm9sO1xufTtcblxudmFyIGlzU3ltYm9sID0gTkFUSVZFX1NZTUJPTCAmJiB0eXBlb2YgJFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJyA/IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gT2JqZWN0KGl0KSBpbnN0YW5jZW9mICRTeW1ib2w7XG59O1xuXG52YXIgJGRlZmluZVByb3BlcnR5ID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydHkoTywgUCwgQXR0cmlidXRlcykge1xuICBpZiAoTyA9PT0gT2JqZWN0UHJvdG90eXBlKSAkZGVmaW5lUHJvcGVydHkoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgUCwgQXR0cmlidXRlcyk7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIga2V5ID0gdG9QcmltaXRpdmUoUCwgdHJ1ZSk7XG4gIGFuT2JqZWN0KEF0dHJpYnV0ZXMpO1xuICBpZiAoaGFzKEFsbFN5bWJvbHMsIGtleSkpIHtcbiAgICBpZiAoIUF0dHJpYnV0ZXMuZW51bWVyYWJsZSkge1xuICAgICAgaWYgKCFoYXMoTywgSElEREVOKSkgbmF0aXZlRGVmaW5lUHJvcGVydHkoTywgSElEREVOLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwge30pKTtcbiAgICAgIE9bSElEREVOXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGhhcyhPLCBISURERU4pICYmIE9bSElEREVOXVtrZXldKSBPW0hJRERFTl1ba2V5XSA9IGZhbHNlO1xuICAgICAgQXR0cmlidXRlcyA9IG5hdGl2ZU9iamVjdENyZWF0ZShBdHRyaWJ1dGVzLCB7IGVudW1lcmFibGU6IGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcigwLCBmYWxzZSkgfSk7XG4gICAgfSByZXR1cm4gc2V0U3ltYm9sRGVzY3JpcHRvcihPLCBrZXksIEF0dHJpYnV0ZXMpO1xuICB9IHJldHVybiBuYXRpdmVEZWZpbmVQcm9wZXJ0eShPLCBrZXksIEF0dHJpYnV0ZXMpO1xufTtcblxudmFyICRkZWZpbmVQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyhPLCBQcm9wZXJ0aWVzKSB7XG4gIGFuT2JqZWN0KE8pO1xuICB2YXIgcHJvcGVydGllcyA9IHRvSW5kZXhlZE9iamVjdChQcm9wZXJ0aWVzKTtcbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKHByb3BlcnRpZXMpLmNvbmNhdCgkZ2V0T3duUHJvcGVydHlTeW1ib2xzKHByb3BlcnRpZXMpKTtcbiAgJGZvckVhY2goa2V5cywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghREVTQ1JJUFRPUlMgfHwgJHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocHJvcGVydGllcywga2V5KSkgJGRlZmluZVByb3BlcnR5KE8sIGtleSwgcHJvcGVydGllc1trZXldKTtcbiAgfSk7XG4gIHJldHVybiBPO1xufTtcblxudmFyICRjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoTywgUHJvcGVydGllcykge1xuICByZXR1cm4gUHJvcGVydGllcyA9PT0gdW5kZWZpbmVkID8gbmF0aXZlT2JqZWN0Q3JlYXRlKE8pIDogJGRlZmluZVByb3BlcnRpZXMobmF0aXZlT2JqZWN0Q3JlYXRlKE8pLCBQcm9wZXJ0aWVzKTtcbn07XG5cbnZhciAkcHJvcGVydHlJc0VudW1lcmFibGUgPSBmdW5jdGlvbiBwcm9wZXJ0eUlzRW51bWVyYWJsZShWKSB7XG4gIHZhciBQID0gdG9QcmltaXRpdmUoViwgdHJ1ZSk7XG4gIHZhciBlbnVtZXJhYmxlID0gbmF0aXZlUHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0aGlzLCBQKTtcbiAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywgUCkgJiYgIWhhcyhPYmplY3RQcm90b3R5cGVTeW1ib2xzLCBQKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gZW51bWVyYWJsZSB8fCAhaGFzKHRoaXMsIFApIHx8ICFoYXMoQWxsU3ltYm9scywgUCkgfHwgaGFzKHRoaXMsIEhJRERFTikgJiYgdGhpc1tISURERU5dW1BdID8gZW51bWVyYWJsZSA6IHRydWU7XG59O1xuXG52YXIgJGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IGZ1bmN0aW9uIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKSB7XG4gIHZhciBpdCA9IHRvSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKFAsIHRydWUpO1xuICBpZiAoaXQgPT09IE9iamVjdFByb3RvdHlwZSAmJiBoYXMoQWxsU3ltYm9scywga2V5KSAmJiAhaGFzKE9iamVjdFByb3RvdHlwZVN5bWJvbHMsIGtleSkpIHJldHVybjtcbiAgdmFyIGRlc2NyaXB0b3IgPSBuYXRpdmVHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoaXQsIGtleSk7XG4gIGlmIChkZXNjcmlwdG9yICYmIGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICEoaGFzKGl0LCBISURERU4pICYmIGl0W0hJRERFTl1ba2V5XSkpIHtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBkZXNjcmlwdG9yO1xufTtcblxudmFyICRnZXRPd25Qcm9wZXJ0eU5hbWVzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXModG9JbmRleGVkT2JqZWN0KE8pKTtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICAkZm9yRWFjaChuYW1lcywgZnVuY3Rpb24gKGtleSkge1xuICAgIGlmICghaGFzKEFsbFN5bWJvbHMsIGtleSkgJiYgIWhhcyhoaWRkZW5LZXlzLCBrZXkpKSByZXN1bHQucHVzaChrZXkpO1xuICB9KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciAkZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKE8pIHtcbiAgdmFyIElTX09CSkVDVF9QUk9UT1RZUEUgPSBPID09PSBPYmplY3RQcm90b3R5cGU7XG4gIHZhciBuYW1lcyA9IG5hdGl2ZUdldE93blByb3BlcnR5TmFtZXMoSVNfT0JKRUNUX1BST1RPVFlQRSA/IE9iamVjdFByb3RvdHlwZVN5bWJvbHMgOiB0b0luZGV4ZWRPYmplY3QoTykpO1xuICB2YXIgcmVzdWx0ID0gW107XG4gICRmb3JFYWNoKG5hbWVzLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKGhhcyhBbGxTeW1ib2xzLCBrZXkpICYmICghSVNfT0JKRUNUX1BST1RPVFlQRSB8fCBoYXMoT2JqZWN0UHJvdG90eXBlLCBrZXkpKSkge1xuICAgICAgcmVzdWx0LnB1c2goQWxsU3ltYm9sc1trZXldKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuLy8gYFN5bWJvbGAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC1jb25zdHJ1Y3RvclxuaWYgKCFOQVRJVkVfU1lNQk9MKSB7XG4gICRTeW1ib2wgPSBmdW5jdGlvbiBTeW1ib2woKSB7XG4gICAgaWYgKHRoaXMgaW5zdGFuY2VvZiAkU3ltYm9sKSB0aHJvdyBUeXBlRXJyb3IoJ1N5bWJvbCBpcyBub3QgYSBjb25zdHJ1Y3RvcicpO1xuICAgIHZhciBkZXNjcmlwdGlvbiA9ICFhcmd1bWVudHMubGVuZ3RoIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogU3RyaW5nKGFyZ3VtZW50c1swXSk7XG4gICAgdmFyIHRhZyA9IHVpZChkZXNjcmlwdGlvbik7XG4gICAgdmFyIHNldHRlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgaWYgKHRoaXMgPT09IE9iamVjdFByb3RvdHlwZSkgc2V0dGVyLmNhbGwoT2JqZWN0UHJvdG90eXBlU3ltYm9scywgdmFsdWUpO1xuICAgICAgaWYgKGhhcyh0aGlzLCBISURERU4pICYmIGhhcyh0aGlzW0hJRERFTl0sIHRhZykpIHRoaXNbSElEREVOXVt0YWddID0gZmFsc2U7XG4gICAgICBzZXRTeW1ib2xEZXNjcmlwdG9yKHRoaXMsIHRhZywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIHZhbHVlKSk7XG4gICAgfTtcbiAgICBpZiAoREVTQ1JJUFRPUlMgJiYgVVNFX1NFVFRFUikgc2V0U3ltYm9sRGVzY3JpcHRvcihPYmplY3RQcm90b3R5cGUsIHRhZywgeyBjb25maWd1cmFibGU6IHRydWUsIHNldDogc2V0dGVyIH0pO1xuICAgIHJldHVybiB3cmFwKHRhZywgZGVzY3JpcHRpb24pO1xuICB9O1xuXG4gIHJlZGVmaW5lKCRTeW1ib2xbUFJPVE9UWVBFXSwgJ3RvU3RyaW5nJywgZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGdldEludGVybmFsU3RhdGUodGhpcykudGFnO1xuICB9KTtcblxuICBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mID0gJHByb3BlcnR5SXNFbnVtZXJhYmxlO1xuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mID0gJGRlZmluZVByb3BlcnR5O1xuICBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JNb2R1bGUuZiA9ICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gIGdldE93blByb3BlcnR5TmFtZXNNb2R1bGUuZiA9IGdldE93blByb3BlcnR5TmFtZXNFeHRlcm5hbC5mID0gJGdldE93blByb3BlcnR5TmFtZXM7XG4gIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mID0gJGdldE93blByb3BlcnR5U3ltYm9scztcblxuICBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vdGMzOS9wcm9wb3NhbC1TeW1ib2wtZGVzY3JpcHRpb25cbiAgICBuYXRpdmVEZWZpbmVQcm9wZXJ0eSgkU3ltYm9sW1BST1RPVFlQRV0sICdkZXNjcmlwdGlvbicsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogZnVuY3Rpb24gZGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiBnZXRJbnRlcm5hbFN0YXRlKHRoaXMpLmRlc2NyaXB0aW9uO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghSVNfUFVSRSkge1xuICAgICAgcmVkZWZpbmUoT2JqZWN0UHJvdG90eXBlLCAncHJvcGVydHlJc0VudW1lcmFibGUnLCAkcHJvcGVydHlJc0VudW1lcmFibGUsIHsgdW5zYWZlOiB0cnVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIHdyYXBwZWRXZWxsS25vd25TeW1ib2xNb2R1bGUuZiA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgcmV0dXJuIHdyYXAod2VsbEtub3duU3ltYm9sKG5hbWUpLCBuYW1lKTtcbiAgfTtcbn1cblxuJCh7IGdsb2JhbDogdHJ1ZSwgd3JhcDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCwgc2hhbTogIU5BVElWRV9TWU1CT0wgfSwge1xuICBTeW1ib2w6ICRTeW1ib2xcbn0pO1xuXG4kZm9yRWFjaChvYmplY3RLZXlzKFdlbGxLbm93blN5bWJvbHNTdG9yZSksIGZ1bmN0aW9uIChuYW1lKSB7XG4gIGRlZmluZVdlbGxLbm93blN5bWJvbChuYW1lKTtcbn0pO1xuXG4kKHsgdGFyZ2V0OiBTWU1CT0wsIHN0YXQ6IHRydWUsIGZvcmNlZDogIU5BVElWRV9TWU1CT0wgfSwge1xuICAvLyBgU3ltYm9sLmZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5mb3JcbiAgJ2Zvcic6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICB2YXIgc3RyaW5nID0gU3RyaW5nKGtleSk7XG4gICAgaWYgKGhhcyhTdHJpbmdUb1N5bWJvbFJlZ2lzdHJ5LCBzdHJpbmcpKSByZXR1cm4gU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddO1xuICAgIHZhciBzeW1ib2wgPSAkU3ltYm9sKHN0cmluZyk7XG4gICAgU3RyaW5nVG9TeW1ib2xSZWdpc3RyeVtzdHJpbmddID0gc3ltYm9sO1xuICAgIFN5bWJvbFRvU3RyaW5nUmVnaXN0cnlbc3ltYm9sXSA9IHN0cmluZztcbiAgICByZXR1cm4gc3ltYm9sO1xuICB9LFxuICAvLyBgU3ltYm9sLmtleUZvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5rZXlmb3JcbiAga2V5Rm9yOiBmdW5jdGlvbiBrZXlGb3Ioc3ltKSB7XG4gICAgaWYgKCFpc1N5bWJvbChzeW0pKSB0aHJvdyBUeXBlRXJyb3Ioc3ltICsgJyBpcyBub3QgYSBzeW1ib2wnKTtcbiAgICBpZiAoaGFzKFN5bWJvbFRvU3RyaW5nUmVnaXN0cnksIHN5bSkpIHJldHVybiBTeW1ib2xUb1N0cmluZ1JlZ2lzdHJ5W3N5bV07XG4gIH0sXG4gIHVzZVNldHRlcjogZnVuY3Rpb24gKCkgeyBVU0VfU0VUVEVSID0gdHJ1ZTsgfSxcbiAgdXNlU2ltcGxlOiBmdW5jdGlvbiAoKSB7IFVTRV9TRVRURVIgPSBmYWxzZTsgfVxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MLCBzaGFtOiAhREVTQ1JJUFRPUlMgfSwge1xuICAvLyBgT2JqZWN0LmNyZWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5jcmVhdGVcbiAgY3JlYXRlOiAkY3JlYXRlLFxuICAvLyBgT2JqZWN0LmRlZmluZVByb3BlcnR5YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmRlZmluZXByb3BlcnR5XG4gIGRlZmluZVByb3BlcnR5OiAkZGVmaW5lUHJvcGVydHksXG4gIC8vIGBPYmplY3QuZGVmaW5lUHJvcGVydGllc2AgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5kZWZpbmVwcm9wZXJ0aWVzXG4gIGRlZmluZVByb3BlcnRpZXM6ICRkZWZpbmVQcm9wZXJ0aWVzLFxuICAvLyBgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcmAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLW9iamVjdC5nZXRvd25wcm9wZXJ0eWRlc2NyaXB0b3JzXG4gIGdldE93blByb3BlcnR5RGVzY3JpcHRvcjogJGdldE93blByb3BlcnR5RGVzY3JpcHRvclxufSk7XG5cbiQoeyB0YXJnZXQ6ICdPYmplY3QnLCBzdGF0OiB0cnVlLCBmb3JjZWQ6ICFOQVRJVkVfU1lNQk9MIH0sIHtcbiAgLy8gYE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5bmFtZXNcbiAgZ2V0T3duUHJvcGVydHlOYW1lczogJGdldE93blByb3BlcnR5TmFtZXMsXG4gIC8vIGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtb2JqZWN0LmdldG93bnByb3BlcnR5c3ltYm9sc1xuICBnZXRPd25Qcm9wZXJ0eVN5bWJvbHM6ICRnZXRPd25Qcm9wZXJ0eVN5bWJvbHNcbn0pO1xuXG4vLyBDaHJvbWUgMzggYW5kIDM5IGBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzYCBmYWlscyBvbiBwcmltaXRpdmVzXG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zNDQzXG4kKHsgdGFyZ2V0OiAnT2JqZWN0Jywgc3RhdDogdHJ1ZSwgZm9yY2VkOiBmYWlscyhmdW5jdGlvbiAoKSB7IGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mKDEpOyB9KSB9LCB7XG4gIGdldE93blByb3BlcnR5U3ltYm9sczogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGl0KSB7XG4gICAgcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9sc01vZHVsZS5mKHRvT2JqZWN0KGl0KSk7XG4gIH1cbn0pO1xuXG4vLyBgSlNPTi5zdHJpbmdpZnlgIG1ldGhvZCBiZWhhdmlvciB3aXRoIHN5bWJvbHNcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLWpzb24uc3RyaW5naWZ5XG5KU09OICYmICQoeyB0YXJnZXQ6ICdKU09OJywgc3RhdDogdHJ1ZSwgZm9yY2VkOiAhTkFUSVZFX1NZTUJPTCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciBzeW1ib2wgPSAkU3ltYm9sKCk7XG4gIC8vIE1TIEVkZ2UgY29udmVydHMgc3ltYm9sIHZhbHVlcyB0byBKU09OIGFzIHt9XG4gIHJldHVybiBuYXRpdmVKU09OU3RyaW5naWZ5KFtzeW1ib2xdKSAhPSAnW251bGxdJ1xuICAgIC8vIFdlYktpdCBjb252ZXJ0cyBzeW1ib2wgdmFsdWVzIHRvIEpTT04gYXMgbnVsbFxuICAgIHx8IG5hdGl2ZUpTT05TdHJpbmdpZnkoeyBhOiBzeW1ib2wgfSkgIT0gJ3t9J1xuICAgIC8vIFY4IHRocm93cyBvbiBib3hlZCBzeW1ib2xzXG4gICAgfHwgbmF0aXZlSlNPTlN0cmluZ2lmeShPYmplY3Qoc3ltYm9sKSkgIT0gJ3t9Jztcbn0pIH0sIHtcbiAgc3RyaW5naWZ5OiBmdW5jdGlvbiBzdHJpbmdpZnkoaXQpIHtcbiAgICB2YXIgYXJncyA9IFtpdF07XG4gICAgdmFyIGluZGV4ID0gMTtcbiAgICB2YXIgcmVwbGFjZXIsICRyZXBsYWNlcjtcbiAgICB3aGlsZSAoYXJndW1lbnRzLmxlbmd0aCA+IGluZGV4KSBhcmdzLnB1c2goYXJndW1lbnRzW2luZGV4KytdKTtcbiAgICAkcmVwbGFjZXIgPSByZXBsYWNlciA9IGFyZ3NbMV07XG4gICAgaWYgKCFpc09iamVjdChyZXBsYWNlcikgJiYgaXQgPT09IHVuZGVmaW5lZCB8fCBpc1N5bWJvbChpdCkpIHJldHVybjsgLy8gSUU4IHJldHVybnMgc3RyaW5nIG9uIHVuZGVmaW5lZFxuICAgIGlmICghaXNBcnJheShyZXBsYWNlcikpIHJlcGxhY2VyID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgJHJlcGxhY2VyID09ICdmdW5jdGlvbicpIHZhbHVlID0gJHJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSk7XG4gICAgICBpZiAoIWlzU3ltYm9sKHZhbHVlKSkgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gICAgYXJnc1sxXSA9IHJlcGxhY2VyO1xuICAgIHJldHVybiBuYXRpdmVKU09OU3RyaW5naWZ5LmFwcGx5KEpTT04sIGFyZ3MpO1xuICB9XG59KTtcblxuLy8gYFN5bWJvbC5wcm90b3R5cGVbQEB0b1ByaW1pdGl2ZV1gIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnByb3RvdHlwZS1AQHRvcHJpbWl0aXZlXG5pZiAoISRTeW1ib2xbUFJPVE9UWVBFXVtUT19QUklNSVRJVkVdKSBoaWRlKCRTeW1ib2xbUFJPVE9UWVBFXSwgVE9fUFJJTUlUSVZFLCAkU3ltYm9sW1BST1RPVFlQRV0udmFsdWVPZik7XG4vLyBgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXWAgcHJvcGVydHlcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5wcm90b3R5cGUtQEB0b3N0cmluZ3RhZ1xuc2V0VG9TdHJpbmdUYWcoJFN5bWJvbCwgU1lNQk9MKTtcblxuaGlkZGVuS2V5c1tISURERU5dID0gdHJ1ZTtcbiIsInZhciBkZWZpbmVXZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZGVmaW5lLXdlbGwta25vd24tc3ltYm9sJyk7XG5cbi8vIGBTeW1ib2wubWF0Y2hBbGxgIHdlbGwta25vd24gc3ltYm9sXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoQWxsJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLm1hdGNoYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLm1hdGNoXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ21hdGNoJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnJlcGxhY2VgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wucmVwbGFjZVxuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdyZXBsYWNlJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnNlYXJjaGAgd2VsbC1rbm93biBzeW1ib2xcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXN5bWJvbC5zZWFyY2hcbmRlZmluZVdlbGxLbm93blN5bWJvbCgnc2VhcmNoJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnNwZWNpZXNgIHdlbGwta25vd24gc3ltYm9sXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy1zeW1ib2wuc3BlY2llc1xuZGVmaW5lV2VsbEtub3duU3ltYm9sKCdzcGVjaWVzJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnNwbGl0YCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnNwbGl0XG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3NwbGl0Jyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnRvUHJpbWl0aXZlYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnRvcHJpbWl0aXZlXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnRvc3RyaW5ndGFnXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG4iLCJ2YXIgZGVmaW5lV2VsbEtub3duU3ltYm9sID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RlZmluZS13ZWxsLWtub3duLXN5bWJvbCcpO1xuXG4vLyBgU3ltYm9sLnVuc2NvcGFibGVzYCB3ZWxsLWtub3duIHN5bWJvbFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtc3ltYm9sLnVuc2NvcGFibGVzXG5kZWZpbmVXZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGNvcHlXaXRoaW4gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktY29weS13aXRoaW4nKTtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuY29weVdpdGhpbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmNvcHl3aXRoaW5cbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2NvcHlXaXRoaW4nLCBmdW5jdGlvbiBjb3B5V2l0aGluKHRhcmdldCwgc3RhcnQgLyogLCBlbmQgKi8pIHtcbiAgcmV0dXJuICRjb3B5V2l0aGluLmNhbGwoYVR5cGVkQXJyYXkodGhpcyksIHRhcmdldCwgc3RhcnQsIGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRldmVyeSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5ldmVyeTtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZXZlcnlgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5ldmVyeVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZXZlcnknLCBmdW5jdGlvbiBldmVyeShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJGV2ZXJ5KGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkZmlsbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1maWxsJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbGxgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5maWxsXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZpbGwnLCBmdW5jdGlvbiBmaWxsKHZhbHVlIC8qICwgc3RhcnQsIGVuZCAqLykge1xuICByZXR1cm4gJGZpbGwuYXBwbHkoYVR5cGVkQXJyYXkodGhpcyksIGFyZ3VtZW50cyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkZmlsdGVyID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLmZpbHRlcjtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbHRlcmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbHRlclxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZmlsdGVyJywgZnVuY3Rpb24gZmlsdGVyKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gIHZhciBsaXN0ID0gJGZpbHRlcihhVHlwZWRBcnJheSh0aGlzKSwgY2FsbGJhY2tmbiwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xuICB2YXIgQyA9IHNwZWNpZXNDb25zdHJ1Y3Rvcih0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKEMpKShsZW5ndGgpO1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBsaXN0W2luZGV4KytdO1xuICByZXR1cm4gcmVzdWx0O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGZpbmRJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pdGVyYXRpb24nKS5maW5kSW5kZXg7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmZpbmRJbmRleGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbmRpbmRleFxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnZmluZEluZGV4JywgZnVuY3Rpb24gZmluZEluZGV4KHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmaW5kSW5kZXgoYVR5cGVkQXJyYXkodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGZpbmQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZmluZDtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZmluZGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZpbmRcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZpbmQnLCBmdW5jdGlvbiBmaW5kKHByZWRpY2F0ZSAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgcmV0dXJuICRmaW5kKGFUeXBlZEFycmF5KHRoaXMpLCBwcmVkaWNhdGUsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwidmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgRmxvYXQzMkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG50eXBlZEFycmF5Q29uc3RydWN0b3IoJ0Zsb2F0MzInLCA0LCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gRmxvYXQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInZhciB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3InKTtcblxuLy8gYEZsb2F0NjRBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdGbG9hdDY0JywgOCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEZsb2F0NjRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktaXRlcmF0aW9uJykuZm9yRWFjaDtcblxudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuZm9yRWFjaGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmZvcmVhY2hcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2ZvckVhY2gnLCBmdW5jdGlvbiBmb3JFYWNoKGNhbGxiYWNrZm4gLyogLCB0aGlzQXJnICovKSB7XG4gICRmb3JFYWNoKGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5cy1jb25zdHJ1Y3RvcnMtcmVxdWlyZXMtd3JhcHBlcnMnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciB0eXBlZEFycmF5RnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1mcm9tJyk7XG5cbi8vIGAlVHlwZWRBcnJheSUuZnJvbWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUuZnJvbVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRTdGF0aWMoJ2Zyb20nLCB0eXBlZEFycmF5RnJvbSwgVFlQRURfQVJSQVlTX0NPTlNUUlVDVE9SU19SRVFVSVJFU19XUkFQUEVSUyk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgJGluY2x1ZGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWluY2x1ZGVzJykuaW5jbHVkZXM7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluY2x1ZGVzYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuaW5jbHVkZXNcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ2luY2x1ZGVzJywgZnVuY3Rpb24gaW5jbHVkZXMoc2VhcmNoRWxlbWVudCAvKiAsIGZyb21JbmRleCAqLykge1xuICByZXR1cm4gJGluY2x1ZGVzKGFUeXBlZEFycmF5KHRoaXMpLCBzZWFyY2hFbGVtZW50LCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkaW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1pbmNsdWRlcycpLmluZGV4T2Y7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmluZGV4T2ZgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5pbmRleG9mXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdpbmRleE9mJywgZnVuY3Rpb24gaW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiAkaW5kZXhPZihhVHlwZWRBcnJheSh0aGlzKSwgc2VhcmNoRWxlbWVudCwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG4iLCJ2YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJyk7XG5cbi8vIGBJbnQxNkFycmF5YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtdHlwZWRhcnJheS1vYmplY3RzXG50eXBlZEFycmF5Q29uc3RydWN0b3IoJ0ludDE2JywgMiwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwidmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgSW50MzJBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdJbnQzMicsIDQsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBJbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInZhciB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3InKTtcblxuLy8gYEludDhBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdJbnQ4JywgMSwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIEludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIEFycmF5SXRlcmF0b3JzID0gcmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5hcnJheS5pdGVyYXRvcicpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy93ZWxsLWtub3duLXN5bWJvbCcpO1xuXG52YXIgSVRFUkFUT1IgPSB3ZWxsS25vd25TeW1ib2woJ2l0ZXJhdG9yJyk7XG52YXIgVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5O1xudmFyIGFycmF5VmFsdWVzID0gQXJyYXlJdGVyYXRvcnMudmFsdWVzO1xudmFyIGFycmF5S2V5cyA9IEFycmF5SXRlcmF0b3JzLmtleXM7XG52YXIgYXJyYXlFbnRyaWVzID0gQXJyYXlJdGVyYXRvcnMuZW50cmllcztcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0UHJvdG8gPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvO1xudmFyIG5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvciA9IFVpbnQ4QXJyYXkgJiYgVWludDhBcnJheS5wcm90b3R5cGVbSVRFUkFUT1JdO1xuXG52YXIgQ09SUkVDVF9JVEVSX05BTUUgPSAhIW5hdGl2ZVR5cGVkQXJyYXlJdGVyYXRvclxuICAmJiAobmF0aXZlVHlwZWRBcnJheUl0ZXJhdG9yLm5hbWUgPT0gJ3ZhbHVlcycgfHwgbmF0aXZlVHlwZWRBcnJheUl0ZXJhdG9yLm5hbWUgPT0gdW5kZWZpbmVkKTtcblxudmFyIHR5cGVkQXJyYXlWYWx1ZXMgPSBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gIHJldHVybiBhcnJheVZhbHVlcy5jYWxsKGFUeXBlZEFycmF5KHRoaXMpKTtcbn07XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5lbnRyaWVzXG5leHBvcnRQcm90bygnZW50cmllcycsIGZ1bmN0aW9uIGVudHJpZXMoKSB7XG4gIHJldHVybiBhcnJheUVudHJpZXMuY2FsbChhVHlwZWRBcnJheSh0aGlzKSk7XG59KTtcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5rZXlzXG5leHBvcnRQcm90bygna2V5cycsIGZ1bmN0aW9uIGtleXMoKSB7XG4gIHJldHVybiBhcnJheUtleXMuY2FsbChhVHlwZWRBcnJheSh0aGlzKSk7XG59KTtcbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnZhbHVlc2AgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnZhbHVlc1xuZXhwb3J0UHJvdG8oJ3ZhbHVlcycsIHR5cGVkQXJyYXlWYWx1ZXMsICFDT1JSRUNUX0lURVJfTkFNRSk7XG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLUBAaXRlcmF0b3JcbmV4cG9ydFByb3RvKElURVJBVE9SLCB0eXBlZEFycmF5VmFsdWVzLCAhQ09SUkVDVF9JVEVSX05BTUUpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyICRqb2luID0gW10uam9pbjtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuam9pbmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLmpvaW5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnam9pbicsIGZ1bmN0aW9uIGpvaW4oc2VwYXJhdG9yKSB7XG4gIHJldHVybiAkam9pbi5hcHBseShhVHlwZWRBcnJheSh0aGlzKSwgYXJndW1lbnRzKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRsYXN0SW5kZXhPZiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1sYXN0LWluZGV4LW9mJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLmxhc3RJbmRleE9mYCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUubGFzdGluZGV4b2Zcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnbGFzdEluZGV4T2YnLCBmdW5jdGlvbiBsYXN0SW5kZXhPZihzZWFyY2hFbGVtZW50IC8qICwgZnJvbUluZGV4ICovKSB7XG4gIHJldHVybiAkbGFzdEluZGV4T2YuYXBwbHkoYVR5cGVkQXJyYXkodGhpcyksIGFyZ3VtZW50cyk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkbWFwID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLm1hcDtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGFUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5Q29uc3RydWN0b3I7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLm1hcGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLm1hcFxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygnbWFwJywgZnVuY3Rpb24gbWFwKG1hcGZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJG1hcChhVHlwZWRBcnJheSh0aGlzKSwgbWFwZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyAoYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcihzcGVjaWVzQ29uc3RydWN0b3IoTywgTy5jb25zdHJ1Y3RvcikpKShsZW5ndGgpO1xuICB9KTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIFRZUEVEX0FSUkFZU19DT05TVFJVQ1RPUlNfUkVRVUlSRVNfV1JBUFBFUlMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXlzLWNvbnN0cnVjdG9ycy1yZXF1aXJlcy13cmFwcGVycycpO1xuXG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcblxuLy8gYCVUeXBlZEFycmF5JS5vZmAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUub2ZcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0U3RhdGljKCdvZicsIGZ1bmN0aW9uIG9mKC8qIC4uLml0ZW1zICovKSB7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgcmVzdWx0ID0gbmV3IChhVHlwZWRBcnJheUNvbnN0cnVjdG9yKHRoaXMpKShsZW5ndGgpO1xuICB3aGlsZSAobGVuZ3RoID4gaW5kZXgpIHJlc3VsdFtpbmRleF0gPSBhcmd1bWVudHNbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59LCBUWVBFRF9BUlJBWVNfQ09OU1RSVUNUT1JTX1JFUVVJUkVTX1dSQVBQRVJTKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkcmVkdWNlUmlnaHQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktcmVkdWNlJykucmlnaHQ7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnJlZHVjZVJpY2h0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUucmVkdWNlcmlnaHRcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JlZHVjZVJpZ2h0JywgZnVuY3Rpb24gcmVkdWNlUmlnaHQoY2FsbGJhY2tmbiAvKiAsIGluaXRpYWxWYWx1ZSAqLykge1xuICByZXR1cm4gJHJlZHVjZVJpZ2h0KGFUeXBlZEFycmF5KHRoaXMpLCBjYWxsYmFja2ZuLCBhcmd1bWVudHMubGVuZ3RoLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciAkcmVkdWNlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LXJlZHVjZScpLmxlZnQ7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnJlZHVjZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJlZHVjZVxuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygncmVkdWNlJywgZnVuY3Rpb24gcmVkdWNlKGNhbGxiYWNrZm4gLyogLCBpbml0aWFsVmFsdWUgKi8pIHtcbiAgcmV0dXJuICRyZWR1Y2UoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGZsb29yID0gTWF0aC5mbG9vcjtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUucmV2ZXJzZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnJldmVyc2VcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3JldmVyc2UnLCBmdW5jdGlvbiByZXZlcnNlKCkge1xuICB2YXIgdGhhdCA9IHRoaXM7XG4gIHZhciBsZW5ndGggPSBhVHlwZWRBcnJheSh0aGF0KS5sZW5ndGg7XG4gIHZhciBtaWRkbGUgPSBmbG9vcihsZW5ndGggLyAyKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHZhbHVlO1xuICB3aGlsZSAoaW5kZXggPCBtaWRkbGUpIHtcbiAgICB2YWx1ZSA9IHRoYXRbaW5kZXhdO1xuICAgIHRoYXRbaW5kZXgrK10gPSB0aGF0Wy0tbGVuZ3RoXTtcbiAgICB0aGF0W2xlbmd0aF0gPSB2YWx1ZTtcbiAgfSByZXR1cm4gdGhhdDtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvT2Zmc2V0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9mZnNldCcpO1xudmFyIHRvT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLW9iamVjdCcpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbnZhciBGT1JDRUQgPSBmYWlscyhmdW5jdGlvbiAoKSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICBuZXcgSW50OEFycmF5KDEpLnNldCh7fSk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc2V0YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc2V0XG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzZXQnLCBmdW5jdGlvbiBzZXQoYXJyYXlMaWtlIC8qICwgb2Zmc2V0ICovKSB7XG4gIGFUeXBlZEFycmF5KHRoaXMpO1xuICB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDEpO1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGg7XG4gIHZhciBzcmMgPSB0b09iamVjdChhcnJheUxpa2UpO1xuICB2YXIgbGVuID0gdG9MZW5ndGgoc3JjLmxlbmd0aCk7XG4gIHZhciBpbmRleCA9IDA7XG4gIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCcpO1xuICB3aGlsZSAoaW5kZXggPCBsZW4pIHRoaXNbb2Zmc2V0ICsgaW5kZXhdID0gc3JjW2luZGV4KytdO1xufSwgRk9SQ0VEKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBzcGVjaWVzQ29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvc3BlY2llcy1jb25zdHJ1Y3RvcicpO1xudmFyIGZhaWxzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ZhaWxzJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciAkc2xpY2UgPSBbXS5zbGljZTtcblxudmFyIEZPUkNFRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG4gIG5ldyBJbnQ4QXJyYXkoMSkuc2xpY2UoKTtcbn0pO1xuXG4vLyBgJVR5cGVkQXJyYXklLnByb3RvdHlwZS5zbGljZWAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNsaWNlXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzbGljZScsIGZ1bmN0aW9uIHNsaWNlKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxpc3QgPSAkc2xpY2UuY2FsbChhVHlwZWRBcnJheSh0aGlzKSwgc3RhcnQsIGVuZCk7XG4gIHZhciBDID0gc3BlY2llc0NvbnN0cnVjdG9yKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHZhciByZXN1bHQgPSBuZXcgKGFUeXBlZEFycmF5Q29uc3RydWN0b3IoQykpKGxlbmd0aCk7XG4gIHdoaWxlIChsZW5ndGggPiBpbmRleCkgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gIHJldHVybiByZXN1bHQ7XG59LCBGT1JDRUQpO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyICRzb21lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWl0ZXJhdGlvbicpLnNvbWU7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnNvbWVgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS5zb21lXG5BcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFByb3RvKCdzb21lJywgZnVuY3Rpb24gc29tZShjYWxsYmFja2ZuIC8qICwgdGhpc0FyZyAqLykge1xuICByZXR1cm4gJHNvbWUoYVR5cGVkQXJyYXkodGhpcyksIGNhbGxiYWNrZm4sIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xuXG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyICRzb3J0ID0gW10uc29ydDtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUuc29ydGAgbWV0aG9kXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy0ldHlwZWRhcnJheSUucHJvdG90eXBlLnNvcnRcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3NvcnQnLCBmdW5jdGlvbiBzb3J0KGNvbXBhcmVmbikge1xuICByZXR1cm4gJHNvcnQuY2FsbChhVHlwZWRBcnJheSh0aGlzKSwgY29tcGFyZWZuKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktYnVmZmVyLXZpZXctY29yZScpO1xudmFyIHRvTGVuZ3RoID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3RvLWxlbmd0aCcpO1xudmFyIHRvQWJzb2x1dGVJbmRleCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90by1hYnNvbHV0ZS1pbmRleCcpO1xudmFyIHNwZWNpZXNDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9zcGVjaWVzLWNvbnN0cnVjdG9yJyk7XG5cbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG5cbi8vIGAlVHlwZWRBcnJheSUucHJvdG90eXBlLnN1YmFycmF5YCBtZXRob2Rcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLSV0eXBlZGFycmF5JS5wcm90b3R5cGUuc3ViYXJyYXlcbkFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0UHJvdG8oJ3N1YmFycmF5JywgZnVuY3Rpb24gc3ViYXJyYXkoYmVnaW4sIGVuZCkge1xuICB2YXIgTyA9IGFUeXBlZEFycmF5KHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gTy5sZW5ndGg7XG4gIHZhciBiZWdpbkluZGV4ID0gdG9BYnNvbHV0ZUluZGV4KGJlZ2luLCBsZW5ndGgpO1xuICByZXR1cm4gbmV3IChzcGVjaWVzQ29uc3RydWN0b3IoTywgTy5jb25zdHJ1Y3RvcikpKFxuICAgIE8uYnVmZmVyLFxuICAgIE8uYnl0ZU9mZnNldCArIGJlZ2luSW5kZXggKiBPLkJZVEVTX1BFUl9FTEVNRU5ULFxuICAgIHRvTGVuZ3RoKChlbmQgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHRvQWJzb2x1dGVJbmRleChlbmQsIGxlbmd0aCkpIC0gYmVnaW5JbmRleClcbiAgKTtcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBBcnJheUJ1ZmZlclZpZXdDb3JlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FycmF5LWJ1ZmZlci12aWV3LWNvcmUnKTtcbnZhciBmYWlscyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9mYWlscycpO1xuXG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgJHRvTG9jYWxlU3RyaW5nID0gW10udG9Mb2NhbGVTdHJpbmc7XG52YXIgJHNsaWNlID0gW10uc2xpY2U7XG5cbi8vIGlPUyBTYWZhcmkgNi54IGZhaWxzIGhlcmVcbnZhciBUT19MT0NBTEVfU1RSSU5HX0JVRyA9ICEhSW50OEFycmF5ICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgJHRvTG9jYWxlU3RyaW5nLmNhbGwobmV3IEludDhBcnJheSgxKSk7XG59KTtcblxudmFyIEZPUkNFRCA9IGZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIFsxLCAyXS50b0xvY2FsZVN0cmluZygpICE9IG5ldyBJbnQ4QXJyYXkoWzEsIDJdKS50b0xvY2FsZVN0cmluZygpO1xufSkgfHwgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiAgSW50OEFycmF5LnByb3RvdHlwZS50b0xvY2FsZVN0cmluZy5jYWxsKFsxLCAyXSk7XG59KTtcblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b2xvY2FsZXN0cmluZ1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygndG9Mb2NhbGVTdHJpbmcnLCBmdW5jdGlvbiB0b0xvY2FsZVN0cmluZygpIHtcbiAgcmV0dXJuICR0b0xvY2FsZVN0cmluZy5hcHBseShUT19MT0NBTEVfU1RSSU5HX0JVRyA/ICRzbGljZS5jYWxsKGFUeXBlZEFycmF5KHRoaXMpKSA6IGFUeXBlZEFycmF5KHRoaXMpLCBhcmd1bWVudHMpO1xufSwgRk9SQ0VEKTtcbiIsIid1c2Ugc3RyaWN0JztcbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1idWZmZXItdmlldy1jb3JlJyk7XG52YXIgZmFpbHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZmFpbHMnKTtcblxudmFyIFVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheTtcbnZhciBVaW50OEFycmF5UHJvdG90eXBlID0gVWludDhBcnJheSAmJiBVaW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBhcnJheVRvU3RyaW5nID0gW10udG9TdHJpbmc7XG52YXIgYXJyYXlKb2luID0gW10uam9pbjtcblxuaWYgKGZhaWxzKGZ1bmN0aW9uICgpIHsgYXJyYXlUb1N0cmluZy5jYWxsKHt9KTsgfSkpIHtcbiAgYXJyYXlUb1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiBhcnJheUpvaW4uY2FsbCh0aGlzKTtcbiAgfTtcbn1cblxuLy8gYCVUeXBlZEFycmF5JS5wcm90b3R5cGUudG9TdHJpbmdgIG1ldGhvZFxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtJXR5cGVkYXJyYXklLnByb3RvdHlwZS50b3N0cmluZ1xuQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRQcm90bygndG9TdHJpbmcnLCBhcnJheVRvU3RyaW5nLCAoVWludDhBcnJheVByb3RvdHlwZSB8fCB7fSkudG9TdHJpbmcgIT0gYXJyYXlUb1N0cmluZyk7XG4iLCJ2YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJyk7XG5cbi8vIGBVaW50MTZBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50MTYnLCAyLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDE2QXJyYXkoZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIGluaXQodGhpcywgZGF0YSwgYnl0ZU9mZnNldCwgbGVuZ3RoKTtcbiAgfTtcbn0pO1xuIiwidmFyIHR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90eXBlZC1hcnJheS1jb25zdHJ1Y3RvcicpO1xuXG4vLyBgVWludDMyQXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnR5cGVkQXJyYXlDb25zdHJ1Y3RvcignVWludDMyJywgNCwgZnVuY3Rpb24gKGluaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFVpbnQzMkFycmF5KGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICAgIHJldHVybiBpbml0KHRoaXMsIGRhdGEsIGJ5dGVPZmZzZXQsIGxlbmd0aCk7XG4gIH07XG59KTtcbiIsInZhciB0eXBlZEFycmF5Q29uc3RydWN0b3IgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvdHlwZWQtYXJyYXktY29uc3RydWN0b3InKTtcblxuLy8gYFVpbnQ4QXJyYXlgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy10eXBlZGFycmF5LW9iamVjdHNcbnR5cGVkQXJyYXlDb25zdHJ1Y3RvcignVWludDgnLCAxLCBmdW5jdGlvbiAoaW5pdCkge1xuICByZXR1cm4gZnVuY3Rpb24gVWludDhBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSk7XG4iLCJ2YXIgdHlwZWRBcnJheUNvbnN0cnVjdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3R5cGVkLWFycmF5LWNvbnN0cnVjdG9yJyk7XG5cbi8vIGBVaW50OENsYW1wZWRBcnJheWAgY29uc3RydWN0b3Jcbi8vIGh0dHBzOi8vdGMzOS5naXRodWIuaW8vZWNtYTI2Mi8jc2VjLXR5cGVkYXJyYXktb2JqZWN0c1xudHlwZWRBcnJheUNvbnN0cnVjdG9yKCdVaW50OCcsIDEsIGZ1bmN0aW9uIChpbml0KSB7XG4gIHJldHVybiBmdW5jdGlvbiBVaW50OENsYW1wZWRBcnJheShkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgICByZXR1cm4gaW5pdCh0aGlzLCBkYXRhLCBieXRlT2Zmc2V0LCBsZW5ndGgpO1xuICB9O1xufSwgdHJ1ZSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIEludGVybmFsTWV0YWRhdGFNb2R1bGUgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvaW50ZXJuYWwtbWV0YWRhdGEnKTtcbnZhciBjb2xsZWN0aW9uID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NvbGxlY3Rpb24nKTtcbnZhciBjb2xsZWN0aW9uV2VhayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uLXdlYWsnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9pcy1vYmplY3QnKTtcbnZhciBlbmZvcmNlSXRlcm5hbFN0YXRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJykuZW5mb3JjZTtcbnZhciBOQVRJVkVfV0VBS19NQVAgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXdlYWstbWFwJyk7XG5cbnZhciBJU19JRTExID0gIWdsb2JhbC5BY3RpdmVYT2JqZWN0ICYmICdBY3RpdmVYT2JqZWN0JyBpbiBnbG9iYWw7XG52YXIgaXNFeHRlbnNpYmxlID0gT2JqZWN0LmlzRXh0ZW5zaWJsZTtcbnZhciBJbnRlcm5hbFdlYWtNYXA7XG5cbnZhciB3cmFwcGVyID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gZnVuY3Rpb24gV2Vha01hcCgpIHtcbiAgICByZXR1cm4gZ2V0KHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQpO1xuICB9O1xufTtcblxuLy8gYFdlYWtNYXBgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3RjMzkuZ2l0aHViLmlvL2VjbWEyNjIvI3NlYy13ZWFrbWFwLWNvbnN0cnVjdG9yXG52YXIgJFdlYWtNYXAgPSBtb2R1bGUuZXhwb3J0cyA9IGNvbGxlY3Rpb24oJ1dlYWtNYXAnLCB3cmFwcGVyLCBjb2xsZWN0aW9uV2VhaywgdHJ1ZSwgdHJ1ZSk7XG5cbi8vIElFMTEgV2Vha01hcCBmcm96ZW4ga2V5cyBmaXhcbi8vIFdlIGNhbid0IHVzZSBmZWF0dXJlIGRldGVjdGlvbiBiZWNhdXNlIGl0IGNyYXNoIHNvbWUgb2xkIElFIGJ1aWxkc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvaXNzdWVzLzQ4NVxuaWYgKE5BVElWRV9XRUFLX01BUCAmJiBJU19JRTExKSB7XG4gIEludGVybmFsV2Vha01hcCA9IGNvbGxlY3Rpb25XZWFrLmdldENvbnN0cnVjdG9yKHdyYXBwZXIsICdXZWFrTWFwJywgdHJ1ZSk7XG4gIEludGVybmFsTWV0YWRhdGFNb2R1bGUuUkVRVUlSRUQgPSB0cnVlO1xuICB2YXIgV2Vha01hcFByb3RvdHlwZSA9ICRXZWFrTWFwLnByb3RvdHlwZTtcbiAgdmFyIG5hdGl2ZURlbGV0ZSA9IFdlYWtNYXBQcm90b3R5cGVbJ2RlbGV0ZSddO1xuICB2YXIgbmF0aXZlSGFzID0gV2Vha01hcFByb3RvdHlwZS5oYXM7XG4gIHZhciBuYXRpdmVHZXQgPSBXZWFrTWFwUHJvdG90eXBlLmdldDtcbiAgdmFyIG5hdGl2ZVNldCA9IFdlYWtNYXBQcm90b3R5cGUuc2V0O1xuICByZWRlZmluZUFsbChXZWFrTWFwUHJvdG90eXBlLCB7XG4gICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIGlmIChpc09iamVjdChrZXkpICYmICFpc0V4dGVuc2libGUoa2V5KSkge1xuICAgICAgICB2YXIgc3RhdGUgPSBlbmZvcmNlSXRlcm5hbFN0YXRlKHRoaXMpO1xuICAgICAgICBpZiAoIXN0YXRlLmZyb3plbikgc3RhdGUuZnJvemVuID0gbmV3IEludGVybmFsV2Vha01hcCgpO1xuICAgICAgICByZXR1cm4gbmF0aXZlRGVsZXRlLmNhbGwodGhpcywga2V5KSB8fCBzdGF0ZS5mcm96ZW5bJ2RlbGV0ZSddKGtleSk7XG4gICAgICB9IHJldHVybiBuYXRpdmVEZWxldGUuY2FsbCh0aGlzLCBrZXkpO1xuICAgIH0sXG4gICAgaGFzOiBmdW5jdGlvbiBoYXMoa2V5KSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZUhhcy5jYWxsKHRoaXMsIGtleSkgfHwgc3RhdGUuZnJvemVuLmhhcyhrZXkpO1xuICAgICAgfSByZXR1cm4gbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KTtcbiAgICB9LFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KGtleSkge1xuICAgICAgaWYgKGlzT2JqZWN0KGtleSkgJiYgIWlzRXh0ZW5zaWJsZShrZXkpKSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IGVuZm9yY2VJdGVybmFsU3RhdGUodGhpcyk7XG4gICAgICAgIGlmICghc3RhdGUuZnJvemVuKSBzdGF0ZS5mcm96ZW4gPSBuZXcgSW50ZXJuYWxXZWFrTWFwKCk7XG4gICAgICAgIHJldHVybiBuYXRpdmVIYXMuY2FsbCh0aGlzLCBrZXkpID8gbmF0aXZlR2V0LmNhbGwodGhpcywga2V5KSA6IHN0YXRlLmZyb3plbi5nZXQoa2V5KTtcbiAgICAgIH0gcmV0dXJuIG5hdGl2ZUdldC5jYWxsKHRoaXMsIGtleSk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3Qoa2V5KSAmJiAhaXNFeHRlbnNpYmxlKGtleSkpIHtcbiAgICAgICAgdmFyIHN0YXRlID0gZW5mb3JjZUl0ZXJuYWxTdGF0ZSh0aGlzKTtcbiAgICAgICAgaWYgKCFzdGF0ZS5mcm96ZW4pIHN0YXRlLmZyb3plbiA9IG5ldyBJbnRlcm5hbFdlYWtNYXAoKTtcbiAgICAgICAgbmF0aXZlSGFzLmNhbGwodGhpcywga2V5KSA/IG5hdGl2ZVNldC5jYWxsKHRoaXMsIGtleSwgdmFsdWUpIDogc3RhdGUuZnJvemVuLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBuYXRpdmVTZXQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG52YXIgY29sbGVjdGlvbiA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jb2xsZWN0aW9uJyk7XG52YXIgY29sbGVjdGlvbldlYWsgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvY29sbGVjdGlvbi13ZWFrJyk7XG5cbi8vIGBXZWFrU2V0YCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtd2Vha3NldC1jb25zdHJ1Y3RvclxuY29sbGVjdGlvbignV2Vha1NldCcsIGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIFdlYWtTZXQoKSB7IHJldHVybiBnZXQodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCk7IH07XG59LCBjb2xsZWN0aW9uV2VhaywgZmFsc2UsIHRydWUpO1xuIiwidmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBET01JdGVyYWJsZXMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZG9tLWl0ZXJhYmxlcycpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvYXJyYXktZm9yLWVhY2gnKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcblxuZm9yICh2YXIgQ09MTEVDVElPTl9OQU1FIGluIERPTUl0ZXJhYmxlcykge1xuICB2YXIgQ29sbGVjdGlvbiA9IGdsb2JhbFtDT0xMRUNUSU9OX05BTUVdO1xuICB2YXIgQ29sbGVjdGlvblByb3RvdHlwZSA9IENvbGxlY3Rpb24gJiYgQ29sbGVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSAmJiBDb2xsZWN0aW9uUHJvdG90eXBlLmZvckVhY2ggIT09IGZvckVhY2gpIHRyeSB7XG4gICAgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCAnZm9yRWFjaCcsIGZvckVhY2gpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIENvbGxlY3Rpb25Qcm90b3R5cGUuZm9yRWFjaCA9IGZvckVhY2g7XG4gIH1cbn1cbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgRE9NSXRlcmFibGVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2RvbS1pdGVyYWJsZXMnKTtcbnZhciBBcnJheUl0ZXJhdG9yTWV0aG9kcyA9IHJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciBoaWRlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2hpZGUnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgQXJyYXlWYWx1ZXMgPSBBcnJheUl0ZXJhdG9yTWV0aG9kcy52YWx1ZXM7XG5cbmZvciAodmFyIENPTExFQ1RJT05fTkFNRSBpbiBET01JdGVyYWJsZXMpIHtcbiAgdmFyIENvbGxlY3Rpb24gPSBnbG9iYWxbQ09MTEVDVElPTl9OQU1FXTtcbiAgdmFyIENvbGxlY3Rpb25Qcm90b3R5cGUgPSBDb2xsZWN0aW9uICYmIENvbGxlY3Rpb24ucHJvdG90eXBlO1xuICBpZiAoQ29sbGVjdGlvblByb3RvdHlwZSkge1xuICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgIGlmIChDb2xsZWN0aW9uUHJvdG90eXBlW0lURVJBVE9SXSAhPT0gQXJyYXlWYWx1ZXMpIHRyeSB7XG4gICAgICBoaWRlKENvbGxlY3Rpb25Qcm90b3R5cGUsIElURVJBVE9SLCBBcnJheVZhbHVlcyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIENvbGxlY3Rpb25Qcm90b3R5cGVbSVRFUkFUT1JdID0gQXJyYXlWYWx1ZXM7XG4gICAgfVxuICAgIGlmICghQ29sbGVjdGlvblByb3RvdHlwZVtUT19TVFJJTkdfVEFHXSkgaGlkZShDb2xsZWN0aW9uUHJvdG90eXBlLCBUT19TVFJJTkdfVEFHLCBDT0xMRUNUSU9OX05BTUUpO1xuICAgIGlmIChET01JdGVyYWJsZXNbQ09MTEVDVElPTl9OQU1FXSkgZm9yICh2YXIgTUVUSE9EX05BTUUgaW4gQXJyYXlJdGVyYXRvck1ldGhvZHMpIHtcbiAgICAgIC8vIHNvbWUgQ2hyb21lIHZlcnNpb25zIGhhdmUgbm9uLWNvbmZpZ3VyYWJsZSBtZXRob2RzIG9uIERPTVRva2VuTGlzdFxuICAgICAgaWYgKENvbGxlY3Rpb25Qcm90b3R5cGVbTUVUSE9EX05BTUVdICE9PSBBcnJheUl0ZXJhdG9yTWV0aG9kc1tNRVRIT0RfTkFNRV0pIHRyeSB7XG4gICAgICAgIGhpZGUoQ29sbGVjdGlvblByb3RvdHlwZSwgTUVUSE9EX05BTUUsIEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBDb2xsZWN0aW9uUHJvdG90eXBlW01FVEhPRF9OQU1FXSA9IEFycmF5SXRlcmF0b3JNZXRob2RzW01FVEhPRF9OQU1FXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsInZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZ2xvYmFsJyk7XG52YXIgdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy90YXNrJyk7XG5cbnZhciBGT1JDRUQgPSAhZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCAhZ2xvYmFsLmNsZWFySW1tZWRpYXRlO1xuXG4vLyBodHRwOi8vdzNjLmdpdGh1Yi5pby9zZXRJbW1lZGlhdGUvXG5yZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0JykoeyBnbG9iYWw6IHRydWUsIGJpbmQ6IHRydWUsIGVudW1lcmFibGU6IHRydWUsIGZvcmNlZDogRk9SQ0VEIH0sIHtcbiAgLy8gYHNldEltbWVkaWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHA6Ly93M2MuZ2l0aHViLmlvL3NldEltbWVkaWF0ZS8jc2ktc2V0SW1tZWRpYXRlXG4gIHNldEltbWVkaWF0ZTogdGFzay5zZXQsXG4gIC8vIGBjbGVhckltbWVkaWF0ZWAgbWV0aG9kXG4gIC8vIGh0dHA6Ly93M2MuZ2l0aHViLmlvL3NldEltbWVkaWF0ZS8jc2ktY2xlYXJJbW1lZGlhdGVcbiAgY2xlYXJJbW1lZGlhdGU6IHRhc2suY2xlYXJcbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIG1pY3JvdGFzayA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9taWNyb3Rhc2snKTtcbnZhciBjbGFzc29mID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2NsYXNzb2YtcmF3Jyk7XG5cbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgaXNOb2RlID0gY2xhc3NvZihwcm9jZXNzKSA9PSAncHJvY2Vzcyc7XG5cbi8vIGBxdWV1ZU1pY3JvdGFza2AgbWV0aG9kXG4vLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS90aW1lcnMtYW5kLXVzZXItcHJvbXB0cy5odG1sI2RvbS1xdWV1ZW1pY3JvdGFza1xuJCh7IGdsb2JhbDogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgbm9UYXJnZXRHZXQ6IHRydWUgfSwge1xuICBxdWV1ZU1pY3JvdGFzazogZnVuY3Rpb24gcXVldWVNaWNyb3Rhc2soZm4pIHtcbiAgICB2YXIgZG9tYWluID0gaXNOb2RlICYmIHByb2Nlc3MuZG9tYWluO1xuICAgIG1pY3JvdGFzayhkb21haW4gPyBkb21haW4uYmluZChmbikgOiBmbik7XG4gIH1cbn0pO1xuIiwidmFyICQgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvZXhwb3J0Jyk7XG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dsb2JhbCcpO1xudmFyIHVzZXJBZ2VudCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy91c2VyLWFnZW50Jyk7XG5cbnZhciBzbGljZSA9IFtdLnNsaWNlO1xudmFyIE1TSUUgPSAvTVNJRSAuXFwuLy50ZXN0KHVzZXJBZ2VudCk7IC8vIDwtIGRpcnR5IGllOS0gY2hlY2tcblxudmFyIHdyYXAgPSBmdW5jdGlvbiAoc2NoZWR1bGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoaGFuZGxlciwgdGltZW91dCAvKiAsIC4uLmFyZ3VtZW50cyAqLykge1xuICAgIHZhciBib3VuZEFyZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMjtcbiAgICB2YXIgYXJncyA9IGJvdW5kQXJncyA/IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gc2NoZWR1bGVyKGJvdW5kQXJncyA/IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1uZXctZnVuY1xuICAgICAgKHR5cGVvZiBoYW5kbGVyID09ICdmdW5jdGlvbicgPyBoYW5kbGVyIDogRnVuY3Rpb24oaGFuZGxlcikpLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH0gOiBoYW5kbGVyLCB0aW1lb3V0KTtcbiAgfTtcbn07XG5cbi8vIGllOS0gc2V0VGltZW91dCAmIHNldEludGVydmFsIGFkZGl0aW9uYWwgcGFyYW1ldGVycyBmaXhcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjdGltZXJzXG4kKHsgZ2xvYmFsOiB0cnVlLCBiaW5kOiB0cnVlLCBmb3JjZWQ6IE1TSUUgfSwge1xuICAvLyBgc2V0VGltZW91dGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldHRpbWVvdXRcbiAgc2V0VGltZW91dDogd3JhcChnbG9iYWwuc2V0VGltZW91dCksXG4gIC8vIGBzZXRJbnRlcnZhbGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3RpbWVycy1hbmQtdXNlci1wcm9tcHRzLmh0bWwjZG9tLXNldGludGVydmFsXG4gIHNldEludGVydmFsOiB3cmFwKGdsb2JhbC5zZXRJbnRlcnZhbClcbn0pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuLy8gVE9ETzogaW4gY29yZS1qc0A0LCBtb3ZlIC9tb2R1bGVzLyBkZXBlbmRlbmNpZXMgdG8gcHVibGljIGVudHJpZXMgZm9yIGJldHRlciBvcHRpbWl6YXRpb24gYnkgdG9vbHMgbGlrZSBgcHJlc2V0LWVudmBcbnJlcXVpcmUoJy4uL21vZHVsZXMvZXMuYXJyYXkuaXRlcmF0b3InKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIFVTRV9OQVRJVkVfVVJMID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL25hdGl2ZS11cmwnKTtcbnZhciByZWRlZmluZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9yZWRlZmluZScpO1xudmFyIHJlZGVmaW5lQWxsID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lLWFsbCcpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9jcmVhdGUtaXRlcmF0b3ItY29uc3RydWN0b3InKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGhhc093biA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2JpbmQtY29udGV4dCcpO1xudmFyIGFuT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2FuLW9iamVjdCcpO1xudmFyIGlzT2JqZWN0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2lzLW9iamVjdCcpO1xudmFyIGdldEl0ZXJhdG9yID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvcicpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2dldC1pdGVyYXRvci1tZXRob2QnKTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvd2VsbC1rbm93bi1zeW1ib2wnKTtcblxudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIFVSTF9TRUFSQ0hfUEFSQU1TID0gJ1VSTFNlYXJjaFBhcmFtcyc7XG52YXIgVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IgPSBVUkxfU0VBUkNIX1BBUkFNUyArICdJdGVyYXRvcic7XG52YXIgc2V0SW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuc2V0O1xudmFyIGdldEludGVybmFsUGFyYW1zU3RhdGUgPSBJbnRlcm5hbFN0YXRlTW9kdWxlLmdldHRlckZvcihVUkxfU0VBUkNIX1BBUkFNUyk7XG52YXIgZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXR0ZXJGb3IoVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IpO1xuXG52YXIgcGx1cyA9IC9cXCsvZztcbnZhciBzZXF1ZW5jZXMgPSBBcnJheSg0KTtcblxudmFyIHBlcmNlbnRTZXF1ZW5jZSA9IGZ1bmN0aW9uIChieXRlcykge1xuICByZXR1cm4gc2VxdWVuY2VzW2J5dGVzIC0gMV0gfHwgKHNlcXVlbmNlc1tieXRlcyAtIDFdID0gUmVnRXhwKCcoKD86JVtcXFxcZGEtZl17Mn0peycgKyBieXRlcyArICd9KScsICdnaScpKTtcbn07XG5cbnZhciBwZXJjZW50RGVjb2RlID0gZnVuY3Rpb24gKHNlcXVlbmNlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChzZXF1ZW5jZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHNlcXVlbmNlO1xuICB9XG59O1xuXG52YXIgZGVzZXJpYWxpemUgPSBmdW5jdGlvbiAoaXQpIHtcbiAgdmFyIHJlc3VsdCA9IGl0LnJlcGxhY2UocGx1cywgJyAnKTtcbiAgdmFyIGJ5dGVzID0gNDtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgd2hpbGUgKGJ5dGVzKSB7XG4gICAgICByZXN1bHQgPSByZXN1bHQucmVwbGFjZShwZXJjZW50U2VxdWVuY2UoYnl0ZXMtLSksIHBlcmNlbnREZWNvZGUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgZmluZCA9IC9bIScoKX5dfCUyMC9nO1xuXG52YXIgcmVwbGFjZSA9IHtcbiAgJyEnOiAnJTIxJyxcbiAgXCInXCI6ICclMjcnLFxuICAnKCc6ICclMjgnLFxuICAnKSc6ICclMjknLFxuICAnfic6ICclN0UnLFxuICAnJTIwJzogJysnXG59O1xuXG52YXIgcmVwbGFjZXIgPSBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgcmV0dXJuIHJlcGxhY2VbbWF0Y2hdO1xufTtcblxudmFyIHNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChpdCkge1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KGl0KS5yZXBsYWNlKGZpbmQsIHJlcGxhY2VyKTtcbn07XG5cbnZhciBwYXJzZVNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uIChyZXN1bHQsIHF1ZXJ5KSB7XG4gIGlmIChxdWVyeSkge1xuICAgIHZhciBhdHRyaWJ1dGVzID0gcXVlcnkuc3BsaXQoJyYnKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBhdHRyaWJ1dGUsIGVudHJ5O1xuICAgIHdoaWxlIChpbmRleCA8IGF0dHJpYnV0ZXMubGVuZ3RoKSB7XG4gICAgICBhdHRyaWJ1dGUgPSBhdHRyaWJ1dGVzW2luZGV4KytdO1xuICAgICAgaWYgKGF0dHJpYnV0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW50cnkgPSBhdHRyaWJ1dGUuc3BsaXQoJz0nKTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIGtleTogZGVzZXJpYWxpemUoZW50cnkuc2hpZnQoKSksXG4gICAgICAgICAgdmFsdWU6IGRlc2VyaWFsaXplKGVudHJ5LmpvaW4oJz0nKSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgdXBkYXRlU2VhcmNoUGFyYW1zID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XG4gIHRoaXMuZW50cmllcy5sZW5ndGggPSAwO1xuICBwYXJzZVNlYXJjaFBhcmFtcyh0aGlzLmVudHJpZXMsIHF1ZXJ5KTtcbn07XG5cbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gIGlmIChwYXNzZWQgPCByZXF1aXJlZCkgdGhyb3cgVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xufTtcblxudmFyIFVSTFNlYXJjaFBhcmFtc0l0ZXJhdG9yID0gY3JlYXRlSXRlcmF0b3JDb25zdHJ1Y3RvcihmdW5jdGlvbiBJdGVyYXRvcihwYXJhbXMsIGtpbmQpIHtcbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGlzLCB7XG4gICAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVNfSVRFUkFUT1IsXG4gICAgaXRlcmF0b3I6IGdldEl0ZXJhdG9yKGdldEludGVybmFsUGFyYW1zU3RhdGUocGFyYW1zKS5lbnRyaWVzKSxcbiAgICBraW5kOiBraW5kXG4gIH0pO1xufSwgJ0l0ZXJhdG9yJywgZnVuY3Rpb24gbmV4dCgpIHtcbiAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxJdGVyYXRvclN0YXRlKHRoaXMpO1xuICB2YXIga2luZCA9IHN0YXRlLmtpbmQ7XG4gIHZhciBzdGVwID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICBpZiAoIXN0ZXAuZG9uZSkge1xuICAgIHN0ZXAudmFsdWUgPSBraW5kID09PSAna2V5cycgPyBlbnRyeS5rZXkgOiBraW5kID09PSAndmFsdWVzJyA/IGVudHJ5LnZhbHVlIDogW2VudHJ5LmtleSwgZW50cnkudmFsdWVdO1xuICB9IHJldHVybiBzdGVwO1xufSk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXNgIGNvbnN0cnVjdG9yXG4vLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2ludGVyZmFjZS11cmxzZWFyY2hwYXJhbXNcbnZhciBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTFNlYXJjaFBhcmFtcygvKiBpbml0ICovKSB7XG4gIGFuSW5zdGFuY2UodGhpcywgVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3IsIFVSTF9TRUFSQ0hfUEFSQU1TKTtcbiAgdmFyIGluaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZDtcbiAgdmFyIHRoYXQgPSB0aGlzO1xuICB2YXIgZW50cmllcyA9IFtdO1xuICB2YXIgaXRlcmF0b3JNZXRob2QsIGl0ZXJhdG9yLCBzdGVwLCBlbnRyeUl0ZXJhdG9yLCBmaXJzdCwgc2Vjb25kLCBrZXk7XG5cbiAgc2V0SW50ZXJuYWxTdGF0ZSh0aGF0LCB7XG4gICAgdHlwZTogVVJMX1NFQVJDSF9QQVJBTVMsXG4gICAgZW50cmllczogZW50cmllcyxcbiAgICB1cGRhdGVVUkw6IGZ1bmN0aW9uICgpIHsgLyogZW1wdHkgKi8gfSxcbiAgICB1cGRhdGVTZWFyY2hQYXJhbXM6IHVwZGF0ZVNlYXJjaFBhcmFtc1xuICB9KTtcblxuICBpZiAoaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGlzT2JqZWN0KGluaXQpKSB7XG4gICAgICBpdGVyYXRvck1ldGhvZCA9IGdldEl0ZXJhdG9yTWV0aG9kKGluaXQpO1xuICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvck1ldGhvZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpdGVyYXRvciA9IGl0ZXJhdG9yTWV0aG9kLmNhbGwoaW5pdCk7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBlbnRyeUl0ZXJhdG9yID0gZ2V0SXRlcmF0b3IoYW5PYmplY3Qoc3RlcC52YWx1ZSkpO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIChmaXJzdCA9IGVudHJ5SXRlcmF0b3IubmV4dCgpKS5kb25lIHx8XG4gICAgICAgICAgICAoc2Vjb25kID0gZW50cnlJdGVyYXRvci5uZXh0KCkpLmRvbmUgfHxcbiAgICAgICAgICAgICFlbnRyeUl0ZXJhdG9yLm5leHQoKS5kb25lXG4gICAgICAgICAgKSB0aHJvdyBUeXBlRXJyb3IoJ0V4cGVjdGVkIHNlcXVlbmNlIHdpdGggbGVuZ3RoIDInKTtcbiAgICAgICAgICBlbnRyaWVzLnB1c2goeyBrZXk6IGZpcnN0LnZhbHVlICsgJycsIHZhbHVlOiBzZWNvbmQudmFsdWUgKyAnJyB9KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGZvciAoa2V5IGluIGluaXQpIGlmIChoYXNPd24oaW5pdCwga2V5KSkgZW50cmllcy5wdXNoKHsga2V5OiBrZXksIHZhbHVlOiBpbml0W2tleV0gKyAnJyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyc2VTZWFyY2hQYXJhbXMoZW50cmllcywgdHlwZW9mIGluaXQgPT09ICdzdHJpbmcnID8gaW5pdC5jaGFyQXQoMCkgPT09ICc/JyA/IGluaXQuc2xpY2UoMSkgOiBpbml0IDogaW5pdCArICcnKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnJlZGVmaW5lQWxsKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSwge1xuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5hcHBlbnRgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtYXBwZW5kXG4gIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKG5hbWUsIHZhbHVlKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMik7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICBzdGF0ZS5lbnRyaWVzLnB1c2goeyBrZXk6IG5hbWUgKyAnJywgdmFsdWU6IHZhbHVlICsgJycgfSk7XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmRlbGV0ZWAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1kZWxldGVcbiAgJ2RlbGV0ZSc6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKTtcbiAgICB2YXIgZW50cmllcyA9IHN0YXRlLmVudHJpZXM7XG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpIGVudHJpZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIGVsc2UgaW5kZXgrKztcbiAgICB9XG4gICAgc3RhdGUudXBkYXRlVVJMKCk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmdldGAgbWV0aG9kXG4gIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybHNlYXJjaHBhcmFtcy1nZXRcbiAgZ2V0OiBmdW5jdGlvbiBnZXQobmFtZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBlbnRyaWVzID0gZ2V0SW50ZXJuYWxQYXJhbXNTdGF0ZSh0aGlzKS5lbnRyaWVzO1xuICAgIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICBmb3IgKDsgaW5kZXggPCBlbnRyaWVzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGVudHJpZXNbaW5kZXhdLmtleSA9PT0ga2V5KSByZXR1cm4gZW50cmllc1tpbmRleF0udmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5nZXRBbGxgIG1ldGhvZFxuICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmxzZWFyY2hwYXJhbXMtZ2V0YWxsXG4gIGdldEFsbDogZnVuY3Rpb24gZ2V0QWxsKG5hbWUpIHtcbiAgICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKTtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIga2V5ID0gbmFtZSArICcnO1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIGZvciAoOyBpbmRleCA8IGVudHJpZXMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleF0ua2V5ID09PSBrZXkpIHJlc3VsdC5wdXNoKGVudHJpZXNbaW5kZXhdLnZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuaGFzYCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLWhhc1xuICBoYXM6IGZ1bmN0aW9uIGhhcyhuYW1lKSB7XG4gICAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgoYXJndW1lbnRzLmxlbmd0aCwgMSk7XG4gICAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gICAgdmFyIGtleSA9IG5hbWUgKyAnJztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGVudHJpZXMubGVuZ3RoKSB7XG4gICAgICBpZiAoZW50cmllc1tpbmRleCsrXS5rZXkgPT09IGtleSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUuc2V0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNldFxuICBzZXQ6IGZ1bmN0aW9uIHNldChuYW1lLCB2YWx1ZSkge1xuICAgIHZhbGlkYXRlQXJndW1lbnRzTGVuZ3RoKGFyZ3VtZW50cy5sZW5ndGgsIDEpO1xuICAgIHZhciBzdGF0ZSA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcyk7XG4gICAgdmFyIGVudHJpZXMgPSBzdGF0ZS5lbnRyaWVzO1xuICAgIHZhciBmb3VuZCA9IGZhbHNlO1xuICAgIHZhciBrZXkgPSBuYW1lICsgJyc7XG4gICAgdmFyIHZhbCA9IHZhbHVlICsgJyc7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgZW50cnk7XG4gICAgZm9yICg7IGluZGV4IDwgZW50cmllcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICBpZiAoZW50cnkua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGZvdW5kKSBlbnRyaWVzLnNwbGljZShpbmRleC0tLCAxKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgIGVudHJ5LnZhbHVlID0gdmFsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghZm91bmQpIGVudHJpZXMucHVzaCh7IGtleToga2V5LCB2YWx1ZTogdmFsIH0pO1xuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5zb3J0YCBtZXRob2RcbiAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsc2VhcmNocGFyYW1zLXNvcnRcbiAgc29ydDogZnVuY3Rpb24gc29ydCgpIHtcbiAgICB2YXIgc3RhdGUgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpO1xuICAgIHZhciBlbnRyaWVzID0gc3RhdGUuZW50cmllcztcbiAgICAvLyBBcnJheSNzb3J0IGlzIG5vdCBzdGFibGUgaW4gc29tZSBlbmdpbmVzXG4gICAgdmFyIHNsaWNlID0gZW50cmllcy5zbGljZSgpO1xuICAgIHZhciBlbnRyeSwgZW50cmllc0luZGV4LCBzbGljZUluZGV4O1xuICAgIGVudHJpZXMubGVuZ3RoID0gMDtcbiAgICBmb3IgKHNsaWNlSW5kZXggPSAwOyBzbGljZUluZGV4IDwgc2xpY2UubGVuZ3RoOyBzbGljZUluZGV4KyspIHtcbiAgICAgIGVudHJ5ID0gc2xpY2Vbc2xpY2VJbmRleF07XG4gICAgICBmb3IgKGVudHJpZXNJbmRleCA9IDA7IGVudHJpZXNJbmRleCA8IHNsaWNlSW5kZXg7IGVudHJpZXNJbmRleCsrKSB7XG4gICAgICAgIGlmIChlbnRyaWVzW2VudHJpZXNJbmRleF0ua2V5ID4gZW50cnkua2V5KSB7XG4gICAgICAgICAgZW50cmllcy5zcGxpY2UoZW50cmllc0luZGV4LCAwLCBlbnRyeSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbnRyaWVzSW5kZXggPT09IHNsaWNlSW5kZXgpIGVudHJpZXMucHVzaChlbnRyeSk7XG4gICAgfVxuICAgIHN0YXRlLnVwZGF0ZVVSTCgpO1xuICB9LFxuICAvLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZS5mb3JFYWNoYCBtZXRob2RcbiAgZm9yRWFjaDogZnVuY3Rpb24gZm9yRWFjaChjYWxsYmFjayAvKiAsIHRoaXNBcmcgKi8pIHtcbiAgICB2YXIgZW50cmllcyA9IGdldEludGVybmFsUGFyYW1zU3RhdGUodGhpcykuZW50cmllcztcbiAgICB2YXIgYm91bmRGdW5jdGlvbiA9IGJpbmQoY2FsbGJhY2ssIGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkLCAzKTtcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciBlbnRyeTtcbiAgICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgICAgZW50cnkgPSBlbnRyaWVzW2luZGV4KytdO1xuICAgICAgYm91bmRGdW5jdGlvbihlbnRyeS52YWx1ZSwgZW50cnkua2V5LCB0aGlzKTtcbiAgICB9XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmtleXNgIG1ldGhvZFxuICBrZXlzOiBmdW5jdGlvbiBrZXlzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2tleXMnKTtcbiAgfSxcbiAgLy8gYFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGUudmFsdWVzYCBtZXRob2RcbiAgdmFsdWVzOiBmdW5jdGlvbiB2YWx1ZXMoKSB7XG4gICAgcmV0dXJuIG5ldyBVUkxTZWFyY2hQYXJhbXNJdGVyYXRvcih0aGlzLCAndmFsdWVzJyk7XG4gIH0sXG4gIC8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLmVudHJpZXNgIG1ldGhvZFxuICBlbnRyaWVzOiBmdW5jdGlvbiBlbnRyaWVzKCkge1xuICAgIHJldHVybiBuZXcgVVJMU2VhcmNoUGFyYW1zSXRlcmF0b3IodGhpcywgJ2VudHJpZXMnKTtcbiAgfVxufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vLyBgVVJMU2VhcmNoUGFyYW1zLnByb3RvdHlwZVtAQGl0ZXJhdG9yXWAgbWV0aG9kXG5yZWRlZmluZShVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsIElURVJBVE9SLCBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZW50cmllcyk7XG5cbi8vIGBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jdXJsc2VhcmNocGFyYW1zLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxucmVkZWZpbmUoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgdmFyIGVudHJpZXMgPSBnZXRJbnRlcm5hbFBhcmFtc1N0YXRlKHRoaXMpLmVudHJpZXM7XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGVudHJ5O1xuICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzLmxlbmd0aCkge1xuICAgIGVudHJ5ID0gZW50cmllc1tpbmRleCsrXTtcbiAgICByZXN1bHQucHVzaChzZXJpYWxpemUoZW50cnkua2V5KSArICc9JyArIHNlcmlhbGl6ZShlbnRyeS52YWx1ZSkpO1xuICB9IHJldHVybiByZXN1bHQuam9pbignJicpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5zZXRUb1N0cmluZ1RhZyhVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvciwgVVJMX1NFQVJDSF9QQVJBTVMpO1xuXG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCB9LCB7XG4gIFVSTFNlYXJjaFBhcmFtczogVVJMU2VhcmNoUGFyYW1zQ29uc3RydWN0b3Jcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgVVJMU2VhcmNoUGFyYW1zOiBVUkxTZWFyY2hQYXJhbXNDb25zdHJ1Y3RvcixcbiAgZ2V0U3RhdGU6IGdldEludGVybmFsUGFyYW1zU3RhdGVcbn07XG4iLCIndXNlIHN0cmljdCc7XG4vLyBUT0RPOiBpbiBjb3JlLWpzQDQsIG1vdmUgL21vZHVsZXMvIGRlcGVuZGVuY2llcyB0byBwdWJsaWMgZW50cmllcyBmb3IgYmV0dGVyIG9wdGltaXphdGlvbiBieSB0b29scyBsaWtlIGBwcmVzZXQtZW52YFxucmVxdWlyZSgnLi4vbW9kdWxlcy9lcy5zdHJpbmcuaXRlcmF0b3InKTtcbnZhciAkID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2V4cG9ydCcpO1xudmFyIERFU0NSSVBUT1JTID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2Rlc2NyaXB0b3JzJyk7XG52YXIgVVNFX05BVElWRV9VUkwgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvbmF0aXZlLXVybCcpO1xudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9nbG9iYWwnKTtcbnZhciBkZWZpbmVQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL29iamVjdC1kZWZpbmUtcHJvcGVydGllcycpO1xudmFyIHJlZGVmaW5lID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3JlZGVmaW5lJyk7XG52YXIgYW5JbnN0YW5jZSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hbi1pbnN0YW5jZScpO1xudmFyIGhhcyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9oYXMnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvb2JqZWN0LWFzc2lnbicpO1xudmFyIGFycmF5RnJvbSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9hcnJheS1mcm9tJyk7XG52YXIgY29kZUF0ID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3N0cmluZy1tdWx0aWJ5dGUnKS5jb2RlQXQ7XG52YXIgdG9BU0NJSSA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wdW55Y29kZS10by1hc2NpaScpO1xudmFyIHNldFRvU3RyaW5nVGFnID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL3NldC10by1zdHJpbmctdGFnJyk7XG52YXIgVVJMU2VhcmNoUGFyYW1zTW9kdWxlID0gcmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMnKTtcbnZhciBJbnRlcm5hbFN0YXRlTW9kdWxlID0gcmVxdWlyZSgnLi4vaW50ZXJuYWxzL2ludGVybmFsLXN0YXRlJyk7XG5cbnZhciBOYXRpdmVVUkwgPSBnbG9iYWwuVVJMO1xudmFyIFVSTFNlYXJjaFBhcmFtcyA9IFVSTFNlYXJjaFBhcmFtc01vZHVsZS5VUkxTZWFyY2hQYXJhbXM7XG52YXIgZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZSA9IFVSTFNlYXJjaFBhcmFtc01vZHVsZS5nZXRTdGF0ZTtcbnZhciBzZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5zZXQ7XG52YXIgZ2V0SW50ZXJuYWxVUkxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZ2V0dGVyRm9yKCdVUkwnKTtcbnZhciBmbG9vciA9IE1hdGguZmxvb3I7XG52YXIgcG93ID0gTWF0aC5wb3c7XG5cbnZhciBJTlZBTElEX0FVVEhPUklUWSA9ICdJbnZhbGlkIGF1dGhvcml0eSc7XG52YXIgSU5WQUxJRF9TQ0hFTUUgPSAnSW52YWxpZCBzY2hlbWUnO1xudmFyIElOVkFMSURfSE9TVCA9ICdJbnZhbGlkIGhvc3QnO1xudmFyIElOVkFMSURfUE9SVCA9ICdJbnZhbGlkIHBvcnQnO1xuXG52YXIgQUxQSEEgPSAvW0EtWmEtel0vO1xudmFyIEFMUEhBTlVNRVJJQyA9IC9bXFxkK1xcLS5BLVphLXpdLztcbnZhciBESUdJVCA9IC9cXGQvO1xudmFyIEhFWF9TVEFSVCA9IC9eKDB4fDBYKS87XG52YXIgT0NUID0gL15bMC03XSskLztcbnZhciBERUMgPSAvXlxcZCskLztcbnZhciBIRVggPSAvXltcXGRBLUZhLWZdKyQvO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UID0gL1tcXHUwMDAwXFx1MDAwOVxcdTAwMEFcXHUwMDBEICMlLzo/QFtcXFxcXV0vO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRyb2wtcmVnZXhcbnZhciBGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UX0VYQ0xVRElOR19QRVJDRU5UID0gL1tcXHUwMDAwXFx1MDAwOVxcdTAwMEFcXHUwMDBEICMvOj9AW1xcXFxdXS87XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29udHJvbC1yZWdleFxudmFyIExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UgPSAvXltcXHUwMDAwLVxcdTAwMUYgXSt8W1xcdTAwMDAtXFx1MDAxRiBdKyQvZztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XG52YXIgVEFCX0FORF9ORVdfTElORSA9IC9bXFx1MDAwOVxcdTAwMEFcXHUwMDBEXS9nO1xudmFyIEVPRjtcblxudmFyIHBhcnNlSG9zdCA9IGZ1bmN0aW9uICh1cmwsIGlucHV0KSB7XG4gIHZhciByZXN1bHQsIGNvZGVQb2ludHMsIGluZGV4O1xuICBpZiAoaW5wdXQuY2hhckF0KDApID09ICdbJykge1xuICAgIGlmIChpbnB1dC5jaGFyQXQoaW5wdXQubGVuZ3RoIC0gMSkgIT0gJ10nKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgIHJlc3VsdCA9IHBhcnNlSVB2NihpbnB1dC5zbGljZSgxLCAtMSkpO1xuICAgIGlmICghcmVzdWx0KSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgIHVybC5ob3N0ID0gcmVzdWx0O1xuICAvLyBvcGFxdWUgaG9zdFxuICB9IGVsc2UgaWYgKCFpc1NwZWNpYWwodXJsKSkge1xuICAgIGlmIChGT1JCSURERU5fSE9TVF9DT0RFX1BPSU5UX0VYQ0xVRElOR19QRVJDRU5ULnRlc3QoaW5wdXQpKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgIHJlc3VsdCA9ICcnO1xuICAgIGNvZGVQb2ludHMgPSBhcnJheUZyb20oaW5wdXQpO1xuICAgIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGNvZGVQb2ludHMubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHQgKz0gcGVyY2VudEVuY29kZShjb2RlUG9pbnRzW2luZGV4XSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgfVxuICAgIHVybC5ob3N0ID0gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIGlucHV0ID0gdG9BU0NJSShpbnB1dCk7XG4gICAgaWYgKEZPUkJJRERFTl9IT1NUX0NPREVfUE9JTlQudGVzdChpbnB1dCkpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgcmVzdWx0ID0gcGFyc2VJUHY0KGlucHV0KTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgIHVybC5ob3N0ID0gcmVzdWx0O1xuICB9XG59O1xuXG52YXIgcGFyc2VJUHY0ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBwYXJ0cyA9IGlucHV0LnNwbGl0KCcuJyk7XG4gIHZhciBwYXJ0c0xlbmd0aCwgbnVtYmVycywgaW5kZXgsIHBhcnQsIHJhZGl4LCBudW1iZXIsIGlwdjQ7XG4gIGlmIChwYXJ0cy5sZW5ndGggJiYgcGFydHNbcGFydHMubGVuZ3RoIC0gMV0gPT0gJycpIHtcbiAgICBwYXJ0cy5wb3AoKTtcbiAgfVxuICBwYXJ0c0xlbmd0aCA9IHBhcnRzLmxlbmd0aDtcbiAgaWYgKHBhcnRzTGVuZ3RoID4gNCkgcmV0dXJuIGlucHV0O1xuICBudW1iZXJzID0gW107XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IHBhcnRzTGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgcGFydCA9IHBhcnRzW2luZGV4XTtcbiAgICBpZiAocGFydCA9PSAnJykgcmV0dXJuIGlucHV0O1xuICAgIHJhZGl4ID0gMTA7XG4gICAgaWYgKHBhcnQubGVuZ3RoID4gMSAmJiBwYXJ0LmNoYXJBdCgwKSA9PSAnMCcpIHtcbiAgICAgIHJhZGl4ID0gSEVYX1NUQVJULnRlc3QocGFydCkgPyAxNiA6IDg7XG4gICAgICBwYXJ0ID0gcGFydC5zbGljZShyYWRpeCA9PSA4ID8gMSA6IDIpO1xuICAgIH1cbiAgICBpZiAocGFydCA9PT0gJycpIHtcbiAgICAgIG51bWJlciA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKHJhZGl4ID09IDEwID8gREVDIDogcmFkaXggPT0gOCA/IE9DVCA6IEhFWCkudGVzdChwYXJ0KSkgcmV0dXJuIGlucHV0O1xuICAgICAgbnVtYmVyID0gcGFyc2VJbnQocGFydCwgcmFkaXgpO1xuICAgIH1cbiAgICBudW1iZXJzLnB1c2gobnVtYmVyKTtcbiAgfVxuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBwYXJ0c0xlbmd0aDsgaW5kZXgrKykge1xuICAgIG51bWJlciA9IG51bWJlcnNbaW5kZXhdO1xuICAgIGlmIChpbmRleCA9PSBwYXJ0c0xlbmd0aCAtIDEpIHtcbiAgICAgIGlmIChudW1iZXIgPj0gcG93KDI1NiwgNSAtIHBhcnRzTGVuZ3RoKSkgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIGlmIChudW1iZXIgPiAyNTUpIHJldHVybiBudWxsO1xuICB9XG4gIGlwdjQgPSBudW1iZXJzLnBvcCgpO1xuICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCBudW1iZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIGlwdjQgKz0gbnVtYmVyc1tpbmRleF0gKiBwb3coMjU2LCAzIC0gaW5kZXgpO1xuICB9XG4gIHJldHVybiBpcHY0O1xufTtcblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1zdGF0ZW1lbnRzXG52YXIgcGFyc2VJUHY2ID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIHZhciBhZGRyZXNzID0gWzAsIDAsIDAsIDAsIDAsIDAsIDAsIDBdO1xuICB2YXIgcGllY2VJbmRleCA9IDA7XG4gIHZhciBjb21wcmVzcyA9IG51bGw7XG4gIHZhciBwb2ludGVyID0gMDtcbiAgdmFyIHZhbHVlLCBsZW5ndGgsIG51bWJlcnNTZWVuLCBpcHY0UGllY2UsIG51bWJlciwgc3dhcHMsIHN3YXA7XG5cbiAgdmFyIGNoYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGlucHV0LmNoYXJBdChwb2ludGVyKTtcbiAgfTtcblxuICBpZiAoY2hhcigpID09ICc6Jykge1xuICAgIGlmIChpbnB1dC5jaGFyQXQoMSkgIT0gJzonKSByZXR1cm47XG4gICAgcG9pbnRlciArPSAyO1xuICAgIHBpZWNlSW5kZXgrKztcbiAgICBjb21wcmVzcyA9IHBpZWNlSW5kZXg7XG4gIH1cbiAgd2hpbGUgKGNoYXIoKSkge1xuICAgIGlmIChwaWVjZUluZGV4ID09IDgpIHJldHVybjtcbiAgICBpZiAoY2hhcigpID09ICc6Jykge1xuICAgICAgaWYgKGNvbXByZXNzICE9PSBudWxsKSByZXR1cm47XG4gICAgICBwb2ludGVyKys7XG4gICAgICBwaWVjZUluZGV4Kys7XG4gICAgICBjb21wcmVzcyA9IHBpZWNlSW5kZXg7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFsdWUgPSBsZW5ndGggPSAwO1xuICAgIHdoaWxlIChsZW5ndGggPCA0ICYmIEhFWC50ZXN0KGNoYXIoKSkpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgKiAxNiArIHBhcnNlSW50KGNoYXIoKSwgMTYpO1xuICAgICAgcG9pbnRlcisrO1xuICAgICAgbGVuZ3RoKys7XG4gICAgfVxuICAgIGlmIChjaGFyKCkgPT0gJy4nKSB7XG4gICAgICBpZiAobGVuZ3RoID09IDApIHJldHVybjtcbiAgICAgIHBvaW50ZXIgLT0gbGVuZ3RoO1xuICAgICAgaWYgKHBpZWNlSW5kZXggPiA2KSByZXR1cm47XG4gICAgICBudW1iZXJzU2VlbiA9IDA7XG4gICAgICB3aGlsZSAoY2hhcigpKSB7XG4gICAgICAgIGlwdjRQaWVjZSA9IG51bGw7XG4gICAgICAgIGlmIChudW1iZXJzU2VlbiA+IDApIHtcbiAgICAgICAgICBpZiAoY2hhcigpID09ICcuJyAmJiBudW1iZXJzU2VlbiA8IDQpIHBvaW50ZXIrKztcbiAgICAgICAgICBlbHNlIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIURJR0lULnRlc3QoY2hhcigpKSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoRElHSVQudGVzdChjaGFyKCkpKSB7XG4gICAgICAgICAgbnVtYmVyID0gcGFyc2VJbnQoY2hhcigpLCAxMCk7XG4gICAgICAgICAgaWYgKGlwdjRQaWVjZSA9PT0gbnVsbCkgaXB2NFBpZWNlID0gbnVtYmVyO1xuICAgICAgICAgIGVsc2UgaWYgKGlwdjRQaWVjZSA9PSAwKSByZXR1cm47XG4gICAgICAgICAgZWxzZSBpcHY0UGllY2UgPSBpcHY0UGllY2UgKiAxMCArIG51bWJlcjtcbiAgICAgICAgICBpZiAoaXB2NFBpZWNlID4gMjU1KSByZXR1cm47XG4gICAgICAgICAgcG9pbnRlcisrO1xuICAgICAgICB9XG4gICAgICAgIGFkZHJlc3NbcGllY2VJbmRleF0gPSBhZGRyZXNzW3BpZWNlSW5kZXhdICogMjU2ICsgaXB2NFBpZWNlO1xuICAgICAgICBudW1iZXJzU2VlbisrO1xuICAgICAgICBpZiAobnVtYmVyc1NlZW4gPT0gMiB8fCBudW1iZXJzU2VlbiA9PSA0KSBwaWVjZUluZGV4Kys7XG4gICAgICB9XG4gICAgICBpZiAobnVtYmVyc1NlZW4gIT0gNCkgcmV0dXJuO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIGlmIChjaGFyKCkgPT0gJzonKSB7XG4gICAgICBwb2ludGVyKys7XG4gICAgICBpZiAoIWNoYXIoKSkgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoY2hhcigpKSByZXR1cm47XG4gICAgYWRkcmVzc1twaWVjZUluZGV4KytdID0gdmFsdWU7XG4gIH1cbiAgaWYgKGNvbXByZXNzICE9PSBudWxsKSB7XG4gICAgc3dhcHMgPSBwaWVjZUluZGV4IC0gY29tcHJlc3M7XG4gICAgcGllY2VJbmRleCA9IDc7XG4gICAgd2hpbGUgKHBpZWNlSW5kZXggIT0gMCAmJiBzd2FwcyA+IDApIHtcbiAgICAgIHN3YXAgPSBhZGRyZXNzW3BpZWNlSW5kZXhdO1xuICAgICAgYWRkcmVzc1twaWVjZUluZGV4LS1dID0gYWRkcmVzc1tjb21wcmVzcyArIHN3YXBzIC0gMV07XG4gICAgICBhZGRyZXNzW2NvbXByZXNzICsgLS1zd2Fwc10gPSBzd2FwO1xuICAgIH1cbiAgfSBlbHNlIGlmIChwaWVjZUluZGV4ICE9IDgpIHJldHVybjtcbiAgcmV0dXJuIGFkZHJlc3M7XG59O1xuXG52YXIgZmluZExvbmdlc3RaZXJvU2VxdWVuY2UgPSBmdW5jdGlvbiAoaXB2Nikge1xuICB2YXIgbWF4SW5kZXggPSBudWxsO1xuICB2YXIgbWF4TGVuZ3RoID0gMTtcbiAgdmFyIGN1cnJTdGFydCA9IG51bGw7XG4gIHZhciBjdXJyTGVuZ3RoID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcbiAgZm9yICg7IGluZGV4IDwgODsgaW5kZXgrKykge1xuICAgIGlmIChpcHY2W2luZGV4XSAhPT0gMCkge1xuICAgICAgaWYgKGN1cnJMZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgbWF4SW5kZXggPSBjdXJyU3RhcnQ7XG4gICAgICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gICAgICB9XG4gICAgICBjdXJyU3RhcnQgPSBudWxsO1xuICAgICAgY3Vyckxlbmd0aCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjdXJyU3RhcnQgPT09IG51bGwpIGN1cnJTdGFydCA9IGluZGV4O1xuICAgICAgKytjdXJyTGVuZ3RoO1xuICAgIH1cbiAgfVxuICBpZiAoY3Vyckxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgIG1heEluZGV4ID0gY3VyclN0YXJ0O1xuICAgIG1heExlbmd0aCA9IGN1cnJMZW5ndGg7XG4gIH1cbiAgcmV0dXJuIG1heEluZGV4O1xufTtcblxudmFyIHNlcmlhbGl6ZUhvc3QgPSBmdW5jdGlvbiAoaG9zdCkge1xuICB2YXIgcmVzdWx0LCBpbmRleCwgY29tcHJlc3MsIGlnbm9yZTA7XG4gIC8vIGlwdjRcbiAgaWYgKHR5cGVvZiBob3N0ID09ICdudW1iZXInKSB7XG4gICAgcmVzdWx0ID0gW107XG4gICAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgNDsgaW5kZXgrKykge1xuICAgICAgcmVzdWx0LnVuc2hpZnQoaG9zdCAlIDI1Nik7XG4gICAgICBob3N0ID0gZmxvb3IoaG9zdCAvIDI1Nik7XG4gICAgfSByZXR1cm4gcmVzdWx0LmpvaW4oJy4nKTtcbiAgLy8gaXB2NlxuICB9IGVsc2UgaWYgKHR5cGVvZiBob3N0ID09ICdvYmplY3QnKSB7XG4gICAgcmVzdWx0ID0gJyc7XG4gICAgY29tcHJlc3MgPSBmaW5kTG9uZ2VzdFplcm9TZXF1ZW5jZShob3N0KTtcbiAgICBmb3IgKGluZGV4ID0gMDsgaW5kZXggPCA4OyBpbmRleCsrKSB7XG4gICAgICBpZiAoaWdub3JlMCAmJiBob3N0W2luZGV4XSA9PT0gMCkgY29udGludWU7XG4gICAgICBpZiAoaWdub3JlMCkgaWdub3JlMCA9IGZhbHNlO1xuICAgICAgaWYgKGNvbXByZXNzID09PSBpbmRleCkge1xuICAgICAgICByZXN1bHQgKz0gaW5kZXggPyAnOicgOiAnOjonO1xuICAgICAgICBpZ25vcmUwID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCArPSBob3N0W2luZGV4XS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChpbmRleCA8IDcpIHJlc3VsdCArPSAnOic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnWycgKyByZXN1bHQgKyAnXSc7XG4gIH0gcmV0dXJuIGhvc3Q7XG59O1xuXG52YXIgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCA9IHt9O1xudmFyIGZyYWdtZW50UGVyY2VudEVuY29kZVNldCA9IGFzc2lnbih7fSwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCwge1xuICAnICc6IDEsICdcIic6IDEsICc8JzogMSwgJz4nOiAxLCAnYCc6IDFcbn0pO1xudmFyIHBhdGhQZXJjZW50RW5jb2RlU2V0ID0gYXNzaWduKHt9LCBmcmFnbWVudFBlcmNlbnRFbmNvZGVTZXQsIHtcbiAgJyMnOiAxLCAnPyc6IDEsICd7JzogMSwgJ30nOiAxXG59KTtcbnZhciB1c2VyaW5mb1BlcmNlbnRFbmNvZGVTZXQgPSBhc3NpZ24oe30sIHBhdGhQZXJjZW50RW5jb2RlU2V0LCB7XG4gICcvJzogMSwgJzonOiAxLCAnOyc6IDEsICc9JzogMSwgJ0AnOiAxLCAnWyc6IDEsICdcXFxcJzogMSwgJ10nOiAxLCAnXic6IDEsICd8JzogMVxufSk7XG5cbnZhciBwZXJjZW50RW5jb2RlID0gZnVuY3Rpb24gKGNoYXIsIHNldCkge1xuICB2YXIgY29kZSA9IGNvZGVBdChjaGFyLCAwKTtcbiAgcmV0dXJuIGNvZGUgPiAweDIwICYmIGNvZGUgPCAweDdGICYmICFoYXMoc2V0LCBjaGFyKSA/IGNoYXIgOiBlbmNvZGVVUklDb21wb25lbnQoY2hhcik7XG59O1xuXG52YXIgc3BlY2lhbFNjaGVtZXMgPSB7XG4gIGZ0cDogMjEsXG4gIGZpbGU6IG51bGwsXG4gIGdvcGhlcjogNzAsXG4gIGh0dHA6IDgwLFxuICBodHRwczogNDQzLFxuICB3czogODAsXG4gIHdzczogNDQzXG59O1xuXG52YXIgaXNTcGVjaWFsID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gaGFzKHNwZWNpYWxTY2hlbWVzLCB1cmwuc2NoZW1lKTtcbn07XG5cbnZhciBpbmNsdWRlc0NyZWRlbnRpYWxzID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gdXJsLnVzZXJuYW1lICE9ICcnIHx8IHVybC5wYXNzd29yZCAhPSAnJztcbn07XG5cbnZhciBjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQgPSBmdW5jdGlvbiAodXJsKSB7XG4gIHJldHVybiAhdXJsLmhvc3QgfHwgdXJsLmNhbm5vdEJlQUJhc2VVUkwgfHwgdXJsLnNjaGVtZSA9PSAnZmlsZSc7XG59O1xuXG52YXIgaXNXaW5kb3dzRHJpdmVMZXR0ZXIgPSBmdW5jdGlvbiAoc3RyaW5nLCBub3JtYWxpemVkKSB7XG4gIHZhciBzZWNvbmQ7XG4gIHJldHVybiBzdHJpbmcubGVuZ3RoID09IDIgJiYgQUxQSEEudGVzdChzdHJpbmcuY2hhckF0KDApKVxuICAgICYmICgoc2Vjb25kID0gc3RyaW5nLmNoYXJBdCgxKSkgPT0gJzonIHx8ICghbm9ybWFsaXplZCAmJiBzZWNvbmQgPT0gJ3wnKSk7XG59O1xuXG52YXIgc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlciA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgdmFyIHRoaXJkO1xuICByZXR1cm4gc3RyaW5nLmxlbmd0aCA+IDEgJiYgaXNXaW5kb3dzRHJpdmVMZXR0ZXIoc3RyaW5nLnNsaWNlKDAsIDIpKSAmJiAoXG4gICAgc3RyaW5nLmxlbmd0aCA9PSAyIHx8XG4gICAgKCh0aGlyZCA9IHN0cmluZy5jaGFyQXQoMikpID09PSAnLycgfHwgdGhpcmQgPT09ICdcXFxcJyB8fCB0aGlyZCA9PT0gJz8nIHx8IHRoaXJkID09PSAnIycpXG4gICk7XG59O1xuXG52YXIgc2hvcnRlblVSTHNQYXRoID0gZnVuY3Rpb24gKHVybCkge1xuICB2YXIgcGF0aCA9IHVybC5wYXRoO1xuICB2YXIgcGF0aFNpemUgPSBwYXRoLmxlbmd0aDtcbiAgaWYgKHBhdGhTaXplICYmICh1cmwuc2NoZW1lICE9ICdmaWxlJyB8fCBwYXRoU2l6ZSAhPSAxIHx8ICFpc1dpbmRvd3NEcml2ZUxldHRlcihwYXRoWzBdLCB0cnVlKSkpIHtcbiAgICBwYXRoLnBvcCgpO1xuICB9XG59O1xuXG52YXIgaXNTaW5nbGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4nIHx8IHNlZ21lbnQudG9Mb3dlckNhc2UoKSA9PT0gJyUyZSc7XG59O1xuXG52YXIgaXNEb3VibGVEb3QgPSBmdW5jdGlvbiAoc2VnbWVudCkge1xuICBzZWdtZW50ID0gc2VnbWVudC50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gc2VnbWVudCA9PT0gJy4uJyB8fCBzZWdtZW50ID09PSAnJTJlLicgfHwgc2VnbWVudCA9PT0gJy4lMmUnIHx8IHNlZ21lbnQgPT09ICclMmUlMmUnO1xufTtcblxuLy8gU3RhdGVzOlxudmFyIFNDSEVNRV9TVEFSVCA9IHt9O1xudmFyIFNDSEVNRSA9IHt9O1xudmFyIE5PX1NDSEVNRSA9IHt9O1xudmFyIFNQRUNJQUxfUkVMQVRJVkVfT1JfQVVUSE9SSVRZID0ge307XG52YXIgUEFUSF9PUl9BVVRIT1JJVFkgPSB7fTtcbnZhciBSRUxBVElWRSA9IHt9O1xudmFyIFJFTEFUSVZFX1NMQVNIID0ge307XG52YXIgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUyA9IHt9O1xudmFyIFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTID0ge307XG52YXIgQVVUSE9SSVRZID0ge307XG52YXIgSE9TVCA9IHt9O1xudmFyIEhPU1ROQU1FID0ge307XG52YXIgUE9SVCA9IHt9O1xudmFyIEZJTEUgPSB7fTtcbnZhciBGSUxFX1NMQVNIID0ge307XG52YXIgRklMRV9IT1NUID0ge307XG52YXIgUEFUSF9TVEFSVCA9IHt9O1xudmFyIFBBVEggPSB7fTtcbnZhciBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIID0ge307XG52YXIgUVVFUlkgPSB7fTtcbnZhciBGUkFHTUVOVCA9IHt9O1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbnZhciBwYXJzZVVSTCA9IGZ1bmN0aW9uICh1cmwsIGlucHV0LCBzdGF0ZU92ZXJyaWRlLCBiYXNlKSB7XG4gIHZhciBzdGF0ZSA9IHN0YXRlT3ZlcnJpZGUgfHwgU0NIRU1FX1NUQVJUO1xuICB2YXIgcG9pbnRlciA9IDA7XG4gIHZhciBidWZmZXIgPSAnJztcbiAgdmFyIHNlZW5BdCA9IGZhbHNlO1xuICB2YXIgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgdmFyIHNlZW5QYXNzd29yZFRva2VuID0gZmFsc2U7XG4gIHZhciBjb2RlUG9pbnRzLCBjaGFyLCBidWZmZXJDb2RlUG9pbnRzLCBmYWlsdXJlO1xuXG4gIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgIHVybC5zY2hlbWUgPSAnJztcbiAgICB1cmwudXNlcm5hbWUgPSAnJztcbiAgICB1cmwucGFzc3dvcmQgPSAnJztcbiAgICB1cmwuaG9zdCA9IG51bGw7XG4gICAgdXJsLnBvcnQgPSBudWxsO1xuICAgIHVybC5wYXRoID0gW107XG4gICAgdXJsLnF1ZXJ5ID0gbnVsbDtcbiAgICB1cmwuZnJhZ21lbnQgPSBudWxsO1xuICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gZmFsc2U7XG4gICAgaW5wdXQgPSBpbnB1dC5yZXBsYWNlKExFQURJTkdfQU5EX1RSQUlMSU5HX0MwX0NPTlRST0xfT1JfU1BBQ0UsICcnKTtcbiAgfVxuXG4gIGlucHV0ID0gaW5wdXQucmVwbGFjZShUQUJfQU5EX05FV19MSU5FLCAnJyk7XG5cbiAgY29kZVBvaW50cyA9IGFycmF5RnJvbShpbnB1dCk7XG5cbiAgd2hpbGUgKHBvaW50ZXIgPD0gY29kZVBvaW50cy5sZW5ndGgpIHtcbiAgICBjaGFyID0gY29kZVBvaW50c1twb2ludGVyXTtcbiAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICBjYXNlIFNDSEVNRV9TVEFSVDpcbiAgICAgICAgaWYgKGNoYXIgJiYgQUxQSEEudGVzdChjaGFyKSkge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgc3RhdGUgPSBTQ0hFTUU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICBzdGF0ZSA9IE5PX1NDSEVNRTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHJldHVybiBJTlZBTElEX1NDSEVNRTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU0NIRU1FOlxuICAgICAgICBpZiAoY2hhciAmJiAoQUxQSEFOVU1FUklDLnRlc3QoY2hhcikgfHwgY2hhciA9PSAnKycgfHwgY2hhciA9PSAnLScgfHwgY2hhciA9PSAnLicpKSB7XG4gICAgICAgICAgYnVmZmVyICs9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc6Jykge1xuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIChcbiAgICAgICAgICAgIChpc1NwZWNpYWwodXJsKSAhPSBoYXMoc3BlY2lhbFNjaGVtZXMsIGJ1ZmZlcikpIHx8XG4gICAgICAgICAgICAoYnVmZmVyID09ICdmaWxlJyAmJiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgfHxcbiAgICAgICAgICAgICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAhdXJsLmhvc3QpXG4gICAgICAgICAgKSkgcmV0dXJuO1xuICAgICAgICAgIHVybC5zY2hlbWUgPSBidWZmZXI7XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHtcbiAgICAgICAgICAgIGlmIChpc1NwZWNpYWwodXJsKSAmJiBzcGVjaWFsU2NoZW1lc1t1cmwuc2NoZW1lXSA9PSB1cmwucG9ydCkgdXJsLnBvcnQgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICAgIHN0YXRlID0gRklMRTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpICYmIGJhc2UgJiYgYmFzZS5zY2hlbWUgPT0gdXJsLnNjaGVtZSkge1xuICAgICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX1JFTEFUSVZFX09SX0FVVEhPUklUWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzU3BlY2lhbCh1cmwpKSB7XG4gICAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX1NMQVNIRVM7XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSF9PUl9BVVRIT1JJVFk7XG4gICAgICAgICAgICBwb2ludGVyKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVybC5jYW5ub3RCZUFCYXNlVVJMID0gdHJ1ZTtcbiAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgc3RhdGUgPSBDQU5OT1RfQkVfQV9CQVNFX1VSTF9QQVRIO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghc3RhdGVPdmVycmlkZSkge1xuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gTk9fU0NIRU1FO1xuICAgICAgICAgIHBvaW50ZXIgPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBOT19TQ0hFTUU6XG4gICAgICAgIGlmICghYmFzZSB8fCAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNoYXIgIT0gJyMnKSkgcmV0dXJuIElOVkFMSURfU0NIRU1FO1xuICAgICAgICBpZiAoYmFzZS5jYW5ub3RCZUFCYXNlVVJMICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gYmFzZS5xdWVyeTtcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICB1cmwuY2Fubm90QmVBQmFzZVVSTCA9IHRydWU7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IGJhc2Uuc2NoZW1lID09ICdmaWxlJyA/IEZJTEUgOiBSRUxBVElWRTtcbiAgICAgICAgY29udGludWU7XG5cbiAgICAgIGNhc2UgU1BFQ0lBTF9SRUxBVElWRV9PUl9BVVRIT1JJVFk6XG4gICAgICAgIGlmIChjaGFyID09ICcvJyAmJiBjb2RlUG9pbnRzW3BvaW50ZXIgKyAxXSA9PSAnLycpIHtcbiAgICAgICAgICBzdGF0ZSA9IFNQRUNJQUxfQVVUSE9SSVRZX0lHTk9SRV9TTEFTSEVTO1xuICAgICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFBBVEhfT1JfQVVUSE9SSVRZOlxuICAgICAgICBpZiAoY2hhciA9PSAnLycpIHtcbiAgICAgICAgICBzdGF0ZSA9IEFVVEhPUklUWTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUxBVElWRTpcbiAgICAgICAgdXJsLnNjaGVtZSA9IGJhc2Uuc2NoZW1lO1xuICAgICAgICBpZiAoY2hhciA9PSBFT0YpIHtcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICB1cmwucXVlcnkgPSBiYXNlLnF1ZXJ5O1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJy8nIHx8IChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkpIHtcbiAgICAgICAgICBzdGF0ZSA9IFJFTEFUSVZFX1NMQVNIO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgdXJsLnVzZXJuYW1lID0gYmFzZS51c2VybmFtZTtcbiAgICAgICAgICB1cmwucGFzc3dvcmQgPSBiYXNlLnBhc3N3b3JkO1xuICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgIHVybC5wb3J0ID0gYmFzZS5wb3J0O1xuICAgICAgICAgIHVybC5wYXRoID0gYmFzZS5wYXRoLnNsaWNlKCk7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cmwudXNlcm5hbWUgPSBiYXNlLnVzZXJuYW1lO1xuICAgICAgICAgIHVybC5wYXNzd29yZCA9IGJhc2UucGFzc3dvcmQ7XG4gICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgdXJsLnBvcnQgPSBiYXNlLnBvcnQ7XG4gICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICB1cmwucGF0aC5wb3AoKTtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgUkVMQVRJVkVfU0xBU0g6XG4gICAgICAgIGlmIChpc1NwZWNpYWwodXJsKSAmJiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpKSB7XG4gICAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcvJykge1xuICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybC51c2VybmFtZSA9IGJhc2UudXNlcm5hbWU7XG4gICAgICAgICAgdXJsLnBhc3N3b3JkID0gYmFzZS5wYXNzd29yZDtcbiAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICB1cmwucG9ydCA9IGJhc2UucG9ydDtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfU0xBU0hFUzpcbiAgICAgICAgc3RhdGUgPSBTUEVDSUFMX0FVVEhPUklUWV9JR05PUkVfU0xBU0hFUztcbiAgICAgICAgaWYgKGNoYXIgIT0gJy8nIHx8IGJ1ZmZlci5jaGFyQXQocG9pbnRlciArIDEpICE9ICcvJykgY29udGludWU7XG4gICAgICAgIHBvaW50ZXIrKztcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgU1BFQ0lBTF9BVVRIT1JJVFlfSUdOT1JFX1NMQVNIRVM6XG4gICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiBjaGFyICE9ICdcXFxcJykge1xuICAgICAgICAgIHN0YXRlID0gQVVUSE9SSVRZO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIEFVVEhPUklUWTpcbiAgICAgICAgaWYgKGNoYXIgPT0gJ0AnKSB7XG4gICAgICAgICAgaWYgKHNlZW5BdCkgYnVmZmVyID0gJyU0MCcgKyBidWZmZXI7XG4gICAgICAgICAgc2VlbkF0ID0gdHJ1ZTtcbiAgICAgICAgICBidWZmZXJDb2RlUG9pbnRzID0gYXJyYXlGcm9tKGJ1ZmZlcik7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXJDb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gYnVmZmVyQ29kZVBvaW50c1tpXTtcbiAgICAgICAgICAgIGlmIChjb2RlUG9pbnQgPT0gJzonICYmICFzZWVuUGFzc3dvcmRUb2tlbikge1xuICAgICAgICAgICAgICBzZWVuUGFzc3dvcmRUb2tlbiA9IHRydWU7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVuY29kZWRDb2RlUG9pbnRzID0gcGVyY2VudEVuY29kZShjb2RlUG9pbnQsIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgICAgICBpZiAoc2VlblBhc3N3b3JkVG9rZW4pIHVybC5wYXNzd29yZCArPSBlbmNvZGVkQ29kZVBvaW50cztcbiAgICAgICAgICAgIGVsc2UgdXJsLnVzZXJuYW1lICs9IGVuY29kZWRDb2RlUG9pbnRzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fCBjaGFyID09ICc/JyB8fCBjaGFyID09ICcjJyB8fFxuICAgICAgICAgIChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHNlZW5BdCAmJiBidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0FVVEhPUklUWTtcbiAgICAgICAgICBwb2ludGVyIC09IGFycmF5RnJvbShidWZmZXIpLmxlbmd0aCArIDE7XG4gICAgICAgICAgYnVmZmVyID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBIT1NUO1xuICAgICAgICB9IGVsc2UgYnVmZmVyICs9IGNoYXI7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhPU1Q6XG4gICAgICBjYXNlIEhPU1ROQU1FOlxuICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSAmJiB1cmwuc2NoZW1lID09ICdmaWxlJykge1xuICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgPT0gJzonICYmICFzZWVuQnJhY2tldCkge1xuICAgICAgICAgIGlmIChidWZmZXIgPT0gJycpIHJldHVybiBJTlZBTElEX0hPU1Q7XG4gICAgICAgICAgZmFpbHVyZSA9IHBhcnNlSG9zdCh1cmwsIGJ1ZmZlcik7XG4gICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gUE9SVDtcbiAgICAgICAgICBpZiAoc3RhdGVPdmVycmlkZSA9PSBIT1NUTkFNRSkgcmV0dXJuO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnIHx8XG4gICAgICAgICAgKGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpKVxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAoaXNTcGVjaWFsKHVybCkgJiYgYnVmZmVyID09ICcnKSByZXR1cm4gSU5WQUxJRF9IT1NUO1xuICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlICYmIGJ1ZmZlciA9PSAnJyAmJiAoaW5jbHVkZXNDcmVkZW50aWFscyh1cmwpIHx8IHVybC5wb3J0ICE9PSBudWxsKSkgcmV0dXJuO1xuICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICAgICAgIGlmIChmYWlsdXJlKSByZXR1cm4gZmFpbHVyZTtcbiAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY2hhciA9PSAnWycpIHNlZW5CcmFja2V0ID0gdHJ1ZTtcbiAgICAgICAgICBlbHNlIGlmIChjaGFyID09ICddJykgc2VlbkJyYWNrZXQgPSBmYWxzZTtcbiAgICAgICAgICBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgfSBicmVhaztcblxuICAgICAgY2FzZSBQT1JUOlxuICAgICAgICBpZiAoRElHSVQudGVzdChjaGFyKSkge1xuICAgICAgICAgIGJ1ZmZlciArPSBjaGFyO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnIHx8XG4gICAgICAgICAgKGNoYXIgPT0gJ1xcXFwnICYmIGlzU3BlY2lhbCh1cmwpKSB8fFxuICAgICAgICAgIHN0YXRlT3ZlcnJpZGVcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGJ1ZmZlciAhPSAnJykge1xuICAgICAgICAgICAgdmFyIHBvcnQgPSBwYXJzZUludChidWZmZXIsIDEwKTtcbiAgICAgICAgICAgIGlmIChwb3J0ID4gMHhGRkZGKSByZXR1cm4gSU5WQUxJRF9QT1JUO1xuICAgICAgICAgICAgdXJsLnBvcnQgPSAoaXNTcGVjaWFsKHVybCkgJiYgcG9ydCA9PT0gc3BlY2lhbFNjaGVtZXNbdXJsLnNjaGVtZV0pID8gbnVsbCA6IHBvcnQ7XG4gICAgICAgICAgICBidWZmZXIgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSByZXR1cm4gSU5WQUxJRF9QT1JUO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGSUxFOlxuICAgICAgICB1cmwuc2NoZW1lID0gJ2ZpbGUnO1xuICAgICAgICBpZiAoY2hhciA9PSAnLycgfHwgY2hhciA9PSAnXFxcXCcpIHN0YXRlID0gRklMRV9TTEFTSDtcbiAgICAgICAgZWxzZSBpZiAoYmFzZSAmJiBiYXNlLnNjaGVtZSA9PSAnZmlsZScpIHtcbiAgICAgICAgICBpZiAoY2hhciA9PSBFT0YpIHtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICc/Jykge1xuICAgICAgICAgICAgdXJsLmhvc3QgPSBiYXNlLmhvc3Q7XG4gICAgICAgICAgICB1cmwucGF0aCA9IGJhc2UucGF0aC5zbGljZSgpO1xuICAgICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhciA9PSAnIycpIHtcbiAgICAgICAgICAgIHVybC5ob3N0ID0gYmFzZS5ob3N0O1xuICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgIHVybC5xdWVyeSA9IGJhc2UucXVlcnk7XG4gICAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgICAgICAgICAgICB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgICAgICAgdXJsLnBhdGggPSBiYXNlLnBhdGguc2xpY2UoKTtcbiAgICAgICAgICAgICAgc2hvcnRlblVSTHNQYXRoKHVybCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIEZJTEVfU0xBU0g6XG4gICAgICAgIGlmIChjaGFyID09ICcvJyB8fCBjaGFyID09ICdcXFxcJykge1xuICAgICAgICAgIHN0YXRlID0gRklMRV9IT1NUO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiYXNlICYmIGJhc2Uuc2NoZW1lID09ICdmaWxlJyAmJiAhc3RhcnRzV2l0aFdpbmRvd3NEcml2ZUxldHRlcihjb2RlUG9pbnRzLnNsaWNlKHBvaW50ZXIpLmpvaW4oJycpKSkge1xuICAgICAgICAgIGlmIChpc1dpbmRvd3NEcml2ZUxldHRlcihiYXNlLnBhdGhbMF0sIHRydWUpKSB1cmwucGF0aC5wdXNoKGJhc2UucGF0aFswXSk7XG4gICAgICAgICAgZWxzZSB1cmwuaG9zdCA9IGJhc2UuaG9zdDtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZSA9IFBBVEg7XG4gICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICBjYXNlIEZJTEVfSE9TVDpcbiAgICAgICAgaWYgKGNoYXIgPT0gRU9GIHx8IGNoYXIgPT0gJy8nIHx8IGNoYXIgPT0gJ1xcXFwnIHx8IGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGlzV2luZG93c0RyaXZlTGV0dGVyKGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGJ1ZmZlciA9PSAnJykge1xuICAgICAgICAgICAgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgIGlmIChzdGF0ZU92ZXJyaWRlKSByZXR1cm47XG4gICAgICAgICAgICBzdGF0ZSA9IFBBVEhfU1RBUlQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZhaWx1cmUgPSBwYXJzZUhvc3QodXJsLCBidWZmZXIpO1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHJldHVybiBmYWlsdXJlO1xuICAgICAgICAgICAgaWYgKHVybC5ob3N0ID09ICdsb2NhbGhvc3QnKSB1cmwuaG9zdCA9ICcnO1xuICAgICAgICAgICAgaWYgKHN0YXRlT3ZlcnJpZGUpIHJldHVybjtcbiAgICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgICAgc3RhdGUgPSBQQVRIX1NUQVJUO1xuICAgICAgICAgIH0gY29udGludWU7XG4gICAgICAgIH0gZWxzZSBidWZmZXIgKz0gY2hhcjtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgUEFUSF9TVEFSVDpcbiAgICAgICAgaWYgKGlzU3BlY2lhbCh1cmwpKSB7XG4gICAgICAgICAgc3RhdGUgPSBQQVRIO1xuICAgICAgICAgIGlmIChjaGFyICE9ICcvJyAmJiBjaGFyICE9ICdcXFxcJykgY29udGludWU7XG4gICAgICAgIH0gZWxzZSBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnPycpIHtcbiAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IFFVRVJZO1xuICAgICAgICB9IGVsc2UgaWYgKCFzdGF0ZU92ZXJyaWRlICYmIGNoYXIgPT0gJyMnKSB7XG4gICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBGUkFHTUVOVDtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyICE9IEVPRikge1xuICAgICAgICAgIHN0YXRlID0gUEFUSDtcbiAgICAgICAgICBpZiAoY2hhciAhPSAnLycpIGNvbnRpbnVlO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFBBVEg6XG4gICAgICAgIGlmIChcbiAgICAgICAgICBjaGFyID09IEVPRiB8fCBjaGFyID09ICcvJyB8fFxuICAgICAgICAgIChjaGFyID09ICdcXFxcJyAmJiBpc1NwZWNpYWwodXJsKSkgfHxcbiAgICAgICAgICAoIXN0YXRlT3ZlcnJpZGUgJiYgKGNoYXIgPT0gJz8nIHx8IGNoYXIgPT0gJyMnKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKGlzRG91YmxlRG90KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHNob3J0ZW5VUkxzUGF0aCh1cmwpO1xuICAgICAgICAgICAgaWYgKGNoYXIgIT0gJy8nICYmICEoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAoaXNTaW5nbGVEb3QoYnVmZmVyKSkge1xuICAgICAgICAgICAgaWYgKGNoYXIgIT0gJy8nICYmICEoY2hhciA9PSAnXFxcXCcgJiYgaXNTcGVjaWFsKHVybCkpKSB7XG4gICAgICAgICAgICAgIHVybC5wYXRoLnB1c2goJycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodXJsLnNjaGVtZSA9PSAnZmlsZScgJiYgIXVybC5wYXRoLmxlbmd0aCAmJiBpc1dpbmRvd3NEcml2ZUxldHRlcihidWZmZXIpKSB7XG4gICAgICAgICAgICAgIGlmICh1cmwuaG9zdCkgdXJsLmhvc3QgPSAnJztcbiAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmNoYXJBdCgwKSArICc6JzsgLy8gbm9ybWFsaXplIHdpbmRvd3MgZHJpdmUgbGV0dGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cmwucGF0aC5wdXNoKGJ1ZmZlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJ1ZmZlciA9ICcnO1xuICAgICAgICAgIGlmICh1cmwuc2NoZW1lID09ICdmaWxlJyAmJiAoY2hhciA9PSBFT0YgfHwgY2hhciA9PSAnPycgfHwgY2hhciA9PSAnIycpKSB7XG4gICAgICAgICAgICB3aGlsZSAodXJsLnBhdGgubGVuZ3RoID4gMSAmJiB1cmwucGF0aFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgdXJsLnBhdGguc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgICB1cmwucXVlcnkgPSAnJztcbiAgICAgICAgICAgIHN0YXRlID0gUVVFUlk7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xuICAgICAgICAgICAgdXJsLmZyYWdtZW50ID0gJyc7XG4gICAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWZmZXIgKz0gcGVyY2VudEVuY29kZShjaGFyLCBwYXRoUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgQ0FOTk9UX0JFX0FfQkFTRV9VUkxfUEFUSDpcbiAgICAgICAgaWYgKGNoYXIgPT0gJz8nKSB7XG4gICAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgICAgc3RhdGUgPSBRVUVSWTtcbiAgICAgICAgfSBlbHNlIGlmIChjaGFyID09ICcjJykge1xuICAgICAgICAgIHVybC5mcmFnbWVudCA9ICcnO1xuICAgICAgICAgIHN0YXRlID0gRlJBR01FTlQ7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhciAhPSBFT0YpIHtcbiAgICAgICAgICB1cmwucGF0aFswXSArPSBwZXJjZW50RW5jb2RlKGNoYXIsIEMwQ29udHJvbFBlcmNlbnRFbmNvZGVTZXQpO1xuICAgICAgICB9IGJyZWFrO1xuXG4gICAgICBjYXNlIFFVRVJZOlxuICAgICAgICBpZiAoIXN0YXRlT3ZlcnJpZGUgJiYgY2hhciA9PSAnIycpIHtcbiAgICAgICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgICAgICBzdGF0ZSA9IEZSQUdNRU5UO1xuICAgICAgICB9IGVsc2UgaWYgKGNoYXIgIT0gRU9GKSB7XG4gICAgICAgICAgaWYgKGNoYXIgPT0gXCInXCIgJiYgaXNTcGVjaWFsKHVybCkpIHVybC5xdWVyeSArPSAnJTI3JztcbiAgICAgICAgICBlbHNlIGlmIChjaGFyID09ICcjJykgdXJsLnF1ZXJ5ICs9ICclMjMnO1xuICAgICAgICAgIGVsc2UgdXJsLnF1ZXJ5ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgQzBDb250cm9sUGVyY2VudEVuY29kZVNldCk7XG4gICAgICAgIH0gYnJlYWs7XG5cbiAgICAgIGNhc2UgRlJBR01FTlQ6XG4gICAgICAgIGlmIChjaGFyICE9IEVPRikgdXJsLmZyYWdtZW50ICs9IHBlcmNlbnRFbmNvZGUoY2hhciwgZnJhZ21lbnRQZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcG9pbnRlcisrO1xuICB9XG59O1xuXG4vLyBgVVJMYCBjb25zdHJ1Y3RvclxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmwtY2xhc3NcbnZhciBVUkxDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIFVSTCh1cmwgLyogLCBiYXNlICovKSB7XG4gIHZhciB0aGF0ID0gYW5JbnN0YW5jZSh0aGlzLCBVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuICB2YXIgYmFzZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICB2YXIgdXJsU3RyaW5nID0gU3RyaW5nKHVybCk7XG4gIHZhciBzdGF0ZSA9IHNldEludGVybmFsU3RhdGUodGhhdCwgeyB0eXBlOiAnVVJMJyB9KTtcbiAgdmFyIGJhc2VTdGF0ZSwgZmFpbHVyZTtcbiAgaWYgKGJhc2UgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmIChiYXNlIGluc3RhbmNlb2YgVVJMQ29uc3RydWN0b3IpIGJhc2VTdGF0ZSA9IGdldEludGVybmFsVVJMU3RhdGUoYmFzZSk7XG4gICAgZWxzZSB7XG4gICAgICBmYWlsdXJlID0gcGFyc2VVUkwoYmFzZVN0YXRlID0ge30sIFN0cmluZyhiYXNlKSk7XG4gICAgICBpZiAoZmFpbHVyZSkgdGhyb3cgVHlwZUVycm9yKGZhaWx1cmUpO1xuICAgIH1cbiAgfVxuICBmYWlsdXJlID0gcGFyc2VVUkwoc3RhdGUsIHVybFN0cmluZywgbnVsbCwgYmFzZVN0YXRlKTtcbiAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvcihmYWlsdXJlKTtcbiAgdmFyIHNlYXJjaFBhcmFtcyA9IHN0YXRlLnNlYXJjaFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoKTtcbiAgdmFyIHNlYXJjaFBhcmFtc1N0YXRlID0gZ2V0SW50ZXJuYWxTZWFyY2hQYXJhbXNTdGF0ZShzZWFyY2hQYXJhbXMpO1xuICBzZWFyY2hQYXJhbXNTdGF0ZS51cGRhdGVTZWFyY2hQYXJhbXMoc3RhdGUucXVlcnkpO1xuICBzZWFyY2hQYXJhbXNTdGF0ZS51cGRhdGVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3RhdGUucXVlcnkgPSBTdHJpbmcoc2VhcmNoUGFyYW1zKSB8fCBudWxsO1xuICB9O1xuICBpZiAoIURFU0NSSVBUT1JTKSB7XG4gICAgdGhhdC5ocmVmID0gc2VyaWFsaXplVVJMLmNhbGwodGhhdCk7XG4gICAgdGhhdC5vcmlnaW4gPSBnZXRPcmlnaW4uY2FsbCh0aGF0KTtcbiAgICB0aGF0LnByb3RvY29sID0gZ2V0UHJvdG9jb2wuY2FsbCh0aGF0KTtcbiAgICB0aGF0LnVzZXJuYW1lID0gZ2V0VXNlcm5hbWUuY2FsbCh0aGF0KTtcbiAgICB0aGF0LnBhc3N3b3JkID0gZ2V0UGFzc3dvcmQuY2FsbCh0aGF0KTtcbiAgICB0aGF0Lmhvc3QgPSBnZXRIb3N0LmNhbGwodGhhdCk7XG4gICAgdGhhdC5ob3N0bmFtZSA9IGdldEhvc3RuYW1lLmNhbGwodGhhdCk7XG4gICAgdGhhdC5wb3J0ID0gZ2V0UG9ydC5jYWxsKHRoYXQpO1xuICAgIHRoYXQucGF0aG5hbWUgPSBnZXRQYXRobmFtZS5jYWxsKHRoYXQpO1xuICAgIHRoYXQuc2VhcmNoID0gZ2V0U2VhcmNoLmNhbGwodGhhdCk7XG4gICAgdGhhdC5zZWFyY2hQYXJhbXMgPSBnZXRTZWFyY2hQYXJhbXMuY2FsbCh0aGF0KTtcbiAgICB0aGF0Lmhhc2ggPSBnZXRIYXNoLmNhbGwodGhhdCk7XG4gIH1cbn07XG5cbnZhciBVUkxQcm90b3R5cGUgPSBVUkxDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG5cbnZhciBzZXJpYWxpemVVUkwgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgc2NoZW1lID0gdXJsLnNjaGVtZTtcbiAgdmFyIHVzZXJuYW1lID0gdXJsLnVzZXJuYW1lO1xuICB2YXIgcGFzc3dvcmQgPSB1cmwucGFzc3dvcmQ7XG4gIHZhciBob3N0ID0gdXJsLmhvc3Q7XG4gIHZhciBwb3J0ID0gdXJsLnBvcnQ7XG4gIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gIHZhciBxdWVyeSA9IHVybC5xdWVyeTtcbiAgdmFyIGZyYWdtZW50ID0gdXJsLmZyYWdtZW50O1xuICB2YXIgb3V0cHV0ID0gc2NoZW1lICsgJzonO1xuICBpZiAoaG9zdCAhPT0gbnVsbCkge1xuICAgIG91dHB1dCArPSAnLy8nO1xuICAgIGlmIChpbmNsdWRlc0NyZWRlbnRpYWxzKHVybCkpIHtcbiAgICAgIG91dHB1dCArPSB1c2VybmFtZSArIChwYXNzd29yZCA/ICc6JyArIHBhc3N3b3JkIDogJycpICsgJ0AnO1xuICAgIH1cbiAgICBvdXRwdXQgKz0gc2VyaWFsaXplSG9zdChob3N0KTtcbiAgICBpZiAocG9ydCAhPT0gbnVsbCkgb3V0cHV0ICs9ICc6JyArIHBvcnQ7XG4gIH0gZWxzZSBpZiAoc2NoZW1lID09ICdmaWxlJykgb3V0cHV0ICs9ICcvLyc7XG4gIG91dHB1dCArPSB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIHBhdGguam9pbignLycpIDogJyc7XG4gIGlmIChxdWVyeSAhPT0gbnVsbCkgb3V0cHV0ICs9ICc/JyArIHF1ZXJ5O1xuICBpZiAoZnJhZ21lbnQgIT09IG51bGwpIG91dHB1dCArPSAnIycgKyBmcmFnbWVudDtcbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbnZhciBnZXRPcmlnaW4gPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgc2NoZW1lID0gdXJsLnNjaGVtZTtcbiAgdmFyIHBvcnQgPSB1cmwucG9ydDtcbiAgaWYgKHNjaGVtZSA9PSAnYmxvYicpIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwoc2NoZW1lLnBhdGhbMF0pLm9yaWdpbjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9XG4gIGlmIChzY2hlbWUgPT0gJ2ZpbGUnIHx8ICFpc1NwZWNpYWwodXJsKSkgcmV0dXJuICdudWxsJztcbiAgcmV0dXJuIHNjaGVtZSArICc6Ly8nICsgc2VyaWFsaXplSG9zdCh1cmwuaG9zdCkgKyAocG9ydCAhPT0gbnVsbCA/ICc6JyArIHBvcnQgOiAnJyk7XG59O1xuXG52YXIgZ2V0UHJvdG9jb2wgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnNjaGVtZSArICc6Jztcbn07XG5cbnZhciBnZXRVc2VybmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykudXNlcm5hbWU7XG59O1xuXG52YXIgZ2V0UGFzc3dvcmQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnBhc3N3b3JkO1xufTtcblxudmFyIGdldEhvc3QgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICB2YXIgaG9zdCA9IHVybC5ob3N0O1xuICB2YXIgcG9ydCA9IHVybC5wb3J0O1xuICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnXG4gICAgOiBwb3J0ID09PSBudWxsID8gc2VyaWFsaXplSG9zdChob3N0KVxuICAgIDogc2VyaWFsaXplSG9zdChob3N0KSArICc6JyArIHBvcnQ7XG59O1xuXG52YXIgZ2V0SG9zdG5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBob3N0ID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKS5ob3N0O1xuICByZXR1cm4gaG9zdCA9PT0gbnVsbCA/ICcnIDogc2VyaWFsaXplSG9zdChob3N0KTtcbn07XG5cbnZhciBnZXRQb3J0ID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcG9ydCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykucG9ydDtcbiAgcmV0dXJuIHBvcnQgPT09IG51bGwgPyAnJyA6IFN0cmluZyhwb3J0KTtcbn07XG5cbnZhciBnZXRQYXRobmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gIHZhciBwYXRoID0gdXJsLnBhdGg7XG4gIHJldHVybiB1cmwuY2Fubm90QmVBQmFzZVVSTCA/IHBhdGhbMF0gOiBwYXRoLmxlbmd0aCA/ICcvJyArIHBhdGguam9pbignLycpIDogJyc7XG59O1xuXG52YXIgZ2V0U2VhcmNoID0gZnVuY3Rpb24gKCkge1xuICB2YXIgcXVlcnkgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpLnF1ZXJ5O1xuICByZXR1cm4gcXVlcnkgPyAnPycgKyBxdWVyeSA6ICcnO1xufTtcblxudmFyIGdldFNlYXJjaFBhcmFtcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGdldEludGVybmFsVVJMU3RhdGUodGhpcykuc2VhcmNoUGFyYW1zO1xufTtcblxudmFyIGdldEhhc2ggPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBmcmFnbWVudCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcykuZnJhZ21lbnQ7XG4gIHJldHVybiBmcmFnbWVudCA/ICcjJyArIGZyYWdtZW50IDogJyc7XG59O1xuXG52YXIgYWNjZXNzb3JEZXNjcmlwdG9yID0gZnVuY3Rpb24gKGdldHRlciwgc2V0dGVyKSB7XG4gIHJldHVybiB7IGdldDogZ2V0dGVyLCBzZXQ6IHNldHRlciwgY29uZmlndXJhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiB0cnVlIH07XG59O1xuXG5pZiAoREVTQ1JJUFRPUlMpIHtcbiAgZGVmaW5lUHJvcGVydGllcyhVUkxQcm90b3R5cGUsIHtcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ocmVmYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1ocmVmXG4gICAgaHJlZjogYWNjZXNzb3JEZXNjcmlwdG9yKHNlcmlhbGl6ZVVSTCwgZnVuY3Rpb24gKGhyZWYpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgdmFyIHVybFN0cmluZyA9IFN0cmluZyhocmVmKTtcbiAgICAgIHZhciBmYWlsdXJlID0gcGFyc2VVUkwodXJsLCB1cmxTdHJpbmcpO1xuICAgICAgaWYgKGZhaWx1cmUpIHRocm93IFR5cGVFcnJvcihmYWlsdXJlKTtcbiAgICAgIGdldEludGVybmFsU2VhcmNoUGFyYW1zU3RhdGUodXJsLnNlYXJjaFBhcmFtcykudXBkYXRlU2VhcmNoUGFyYW1zKHVybC5xdWVyeSk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUub3JpZ2luYCBnZXR0ZXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtb3JpZ2luXG4gICAgb3JpZ2luOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0T3JpZ2luKSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wcm90b2NvbGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcHJvdG9jb2xcbiAgICBwcm90b2NvbDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFByb3RvY29sLCBmdW5jdGlvbiAocHJvdG9jb2wpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgcGFyc2VVUkwodXJsLCBTdHJpbmcocHJvdG9jb2wpICsgJzonLCBTQ0hFTUVfU1RBUlQpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnVzZXJuYW1lYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC11c2VybmFtZVxuICAgIHVzZXJuYW1lOiBhY2Nlc3NvckRlc2NyaXB0b3IoZ2V0VXNlcm5hbWUsIGZ1bmN0aW9uICh1c2VybmFtZSkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICB2YXIgY29kZVBvaW50cyA9IGFycmF5RnJvbShTdHJpbmcodXNlcm5hbWUpKTtcbiAgICAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSkgcmV0dXJuO1xuICAgICAgdXJsLnVzZXJuYW1lID0gJyc7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvZGVQb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdXJsLnVzZXJuYW1lICs9IHBlcmNlbnRFbmNvZGUoY29kZVBvaW50c1tpXSwgdXNlcmluZm9QZXJjZW50RW5jb2RlU2V0KTtcbiAgICAgIH1cbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wYXNzd29yZGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtcGFzc3dvcmRcbiAgICBwYXNzd29yZDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBhc3N3b3JkLCBmdW5jdGlvbiAocGFzc3dvcmQpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgdmFyIGNvZGVQb2ludHMgPSBhcnJheUZyb20oU3RyaW5nKHBhc3N3b3JkKSk7XG4gICAgICBpZiAoY2Fubm90SGF2ZVVzZXJuYW1lUGFzc3dvcmRQb3J0KHVybCkpIHJldHVybjtcbiAgICAgIHVybC5wYXNzd29yZCA9ICcnO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2RlUG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHVybC5wYXNzd29yZCArPSBwZXJjZW50RW5jb2RlKGNvZGVQb2ludHNbaV0sIHVzZXJpbmZvUGVyY2VudEVuY29kZVNldCk7XG4gICAgICB9XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaG9zdGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdFxuICAgIGhvc3Q6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRIb3N0LCBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICBpZiAodXJsLmNhbm5vdEJlQUJhc2VVUkwpIHJldHVybjtcbiAgICAgIHBhcnNlVVJMKHVybCwgU3RyaW5nKGhvc3QpLCBIT1NUKTtcbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5ob3N0bmFtZWAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaG9zdG5hbWVcbiAgICBob3N0bmFtZTogYWNjZXNzb3JEZXNjcmlwdG9yKGdldEhvc3RuYW1lLCBmdW5jdGlvbiAoaG9zdG5hbWUpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgaWYgKHVybC5jYW5ub3RCZUFCYXNlVVJMKSByZXR1cm47XG4gICAgICBwYXJzZVVSTCh1cmwsIFN0cmluZyhob3N0bmFtZSksIEhPU1ROQU1FKTtcbiAgICB9KSxcbiAgICAvLyBgVVJMLnByb3RvdHlwZS5wb3J0YCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1wb3J0XG4gICAgcG9ydDogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFBvcnQsIGZ1bmN0aW9uIChwb3J0KSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIGlmIChjYW5ub3RIYXZlVXNlcm5hbWVQYXNzd29yZFBvcnQodXJsKSkgcmV0dXJuO1xuICAgICAgcG9ydCA9IFN0cmluZyhwb3J0KTtcbiAgICAgIGlmIChwb3J0ID09ICcnKSB1cmwucG9ydCA9IG51bGw7XG4gICAgICBlbHNlIHBhcnNlVVJMKHVybCwgcG9ydCwgUE9SVCk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUucGF0aG5hbWVgIGFjY2Vzc29ycyBwYWlyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXBhdGhuYW1lXG4gICAgcGF0aG5hbWU6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRQYXRobmFtZSwgZnVuY3Rpb24gKHBhdGhuYW1lKSB7XG4gICAgICB2YXIgdXJsID0gZ2V0SW50ZXJuYWxVUkxTdGF0ZSh0aGlzKTtcbiAgICAgIGlmICh1cmwuY2Fubm90QmVBQmFzZVVSTCkgcmV0dXJuO1xuICAgICAgdXJsLnBhdGggPSBbXTtcbiAgICAgIHBhcnNlVVJMKHVybCwgcGF0aG5hbWUgKyAnJywgUEFUSF9TVEFSVCk7XG4gICAgfSksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuc2VhcmNoYCBhY2Nlc3NvcnMgcGFpclxuICAgIC8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC1zZWFyY2hcbiAgICBzZWFyY2g6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRTZWFyY2gsIGZ1bmN0aW9uIChzZWFyY2gpIHtcbiAgICAgIHZhciB1cmwgPSBnZXRJbnRlcm5hbFVSTFN0YXRlKHRoaXMpO1xuICAgICAgc2VhcmNoID0gU3RyaW5nKHNlYXJjaCk7XG4gICAgICBpZiAoc2VhcmNoID09ICcnKSB7XG4gICAgICAgIHVybC5xdWVyeSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJz8nID09IHNlYXJjaC5jaGFyQXQoMCkpIHNlYXJjaCA9IHNlYXJjaC5zbGljZSgxKTtcbiAgICAgICAgdXJsLnF1ZXJ5ID0gJyc7XG4gICAgICAgIHBhcnNlVVJMKHVybCwgc2VhcmNoLCBRVUVSWSk7XG4gICAgICB9XG4gICAgICBnZXRJbnRlcm5hbFNlYXJjaFBhcmFtc1N0YXRlKHVybC5zZWFyY2hQYXJhbXMpLnVwZGF0ZVNlYXJjaFBhcmFtcyh1cmwucXVlcnkpO1xuICAgIH0pLFxuICAgIC8vIGBVUkwucHJvdG90eXBlLnNlYXJjaFBhcmFtc2AgZ2V0dGVyXG4gICAgLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXNlYXJjaHBhcmFtc1xuICAgIHNlYXJjaFBhcmFtczogYWNjZXNzb3JEZXNjcmlwdG9yKGdldFNlYXJjaFBhcmFtcyksXG4gICAgLy8gYFVSTC5wcm90b3R5cGUuaGFzaGAgYWNjZXNzb3JzIHBhaXJcbiAgICAvLyBodHRwczovL3VybC5zcGVjLndoYXR3Zy5vcmcvI2RvbS11cmwtaGFzaFxuICAgIGhhc2g6IGFjY2Vzc29yRGVzY3JpcHRvcihnZXRIYXNoLCBmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgdmFyIHVybCA9IGdldEludGVybmFsVVJMU3RhdGUodGhpcyk7XG4gICAgICBoYXNoID0gU3RyaW5nKGhhc2gpO1xuICAgICAgaWYgKGhhc2ggPT0gJycpIHtcbiAgICAgICAgdXJsLmZyYWdtZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCcjJyA9PSBoYXNoLmNoYXJBdCgwKSkgaGFzaCA9IGhhc2guc2xpY2UoMSk7XG4gICAgICB1cmwuZnJhZ21lbnQgPSAnJztcbiAgICAgIHBhcnNlVVJMKHVybCwgaGFzaCwgRlJBR01FTlQpO1xuICAgIH0pXG4gIH0pO1xufVxuXG4vLyBgVVJMLnByb3RvdHlwZS50b0pTT05gIG1ldGhvZFxuLy8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNkb20tdXJsLXRvanNvblxucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9KU09OJywgZnVuY3Rpb24gdG9KU09OKCkge1xuICByZXR1cm4gc2VyaWFsaXplVVJMLmNhbGwodGhpcyk7XG59LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8vIGBVUkwucHJvdG90eXBlLnRvU3RyaW5nYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jVVJMLXN0cmluZ2lmaWNhdGlvbi1iZWhhdmlvclxucmVkZWZpbmUoVVJMUHJvdG90eXBlLCAndG9TdHJpbmcnLCBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuIHNlcmlhbGl6ZVVSTC5jYWxsKHRoaXMpO1xufSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG5pZiAoTmF0aXZlVVJMKSB7XG4gIHZhciBuYXRpdmVDcmVhdGVPYmplY3RVUkwgPSBOYXRpdmVVUkwuY3JlYXRlT2JqZWN0VVJMO1xuICB2YXIgbmF0aXZlUmV2b2tlT2JqZWN0VVJMID0gTmF0aXZlVVJMLnJldm9rZU9iamVjdFVSTDtcbiAgLy8gYFVSTC5jcmVhdGVPYmplY3RVUkxgIG1ldGhvZFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML2NyZWF0ZU9iamVjdFVSTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgaWYgKG5hdGl2ZUNyZWF0ZU9iamVjdFVSTCkgcmVkZWZpbmUoVVJMQ29uc3RydWN0b3IsICdjcmVhdGVPYmplY3RVUkwnLCBmdW5jdGlvbiBjcmVhdGVPYmplY3RVUkwoYmxvYikge1xuICAgIHJldHVybiBuYXRpdmVDcmVhdGVPYmplY3RVUkwuYXBwbHkoTmF0aXZlVVJMLCBhcmd1bWVudHMpO1xuICB9KTtcbiAgLy8gYFVSTC5yZXZva2VPYmplY3RVUkxgIG1ldGhvZFxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVVJML3Jldm9rZU9iamVjdFVSTFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgaWYgKG5hdGl2ZVJldm9rZU9iamVjdFVSTCkgcmVkZWZpbmUoVVJMQ29uc3RydWN0b3IsICdyZXZva2VPYmplY3RVUkwnLCBmdW5jdGlvbiByZXZva2VPYmplY3RVUkwodXJsKSB7XG4gICAgcmV0dXJuIG5hdGl2ZVJldm9rZU9iamVjdFVSTC5hcHBseShOYXRpdmVVUkwsIGFyZ3VtZW50cyk7XG4gIH0pO1xufVxuXG5zZXRUb1N0cmluZ1RhZyhVUkxDb25zdHJ1Y3RvciwgJ1VSTCcpO1xuXG4kKHsgZ2xvYmFsOiB0cnVlLCBmb3JjZWQ6ICFVU0VfTkFUSVZFX1VSTCwgc2hhbTogIURFU0NSSVBUT1JTIH0sIHtcbiAgVVJMOiBVUkxDb25zdHJ1Y3RvclxufSk7XG4iLCIndXNlIHN0cmljdCc7XG52YXIgJCA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9leHBvcnQnKTtcblxuLy8gYFVSTC5wcm90b3R5cGUudG9KU09OYCBtZXRob2Rcbi8vIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZG9tLXVybC10b2pzb25cbiQoeyB0YXJnZXQ6ICdVUkwnLCBwcm90bzogdHJ1ZSwgZW51bWVyYWJsZTogdHJ1ZSB9LCB7XG4gIHRvSlNPTjogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgIHJldHVybiBVUkwucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodGhpcyk7XG4gIH1cbn0pO1xuIiwicmVxdWlyZSgnLi4vZXMnKTtcbnJlcXVpcmUoJy4uL3dlYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4uL2ludGVybmFscy9wYXRoJyk7XG4iLCJyZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuZm9yLWVhY2gnKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLmRvbS1jb2xsZWN0aW9ucy5pdGVyYXRvcicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIuaW1tZWRpYXRlJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi5xdWV1ZS1taWNyb3Rhc2snKTtcbnJlcXVpcmUoJy4uL21vZHVsZXMvd2ViLnRpbWVycycpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsJyk7XG5yZXF1aXJlKCcuLi9tb2R1bGVzL3dlYi51cmwudG8tanNvbicpO1xucmVxdWlyZSgnLi4vbW9kdWxlcy93ZWIudXJsLXNlYXJjaC1wYXJhbXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi9pbnRlcm5hbHMvcGF0aCcpO1xuIiwiKGZ1bmN0aW9uKCkge1xuICB2YXIgYmFzZTY0bWFwXG4gICAgICA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJyxcblxuICBjcnlwdCA9IHtcbiAgICAvLyBCaXQtd2lzZSByb3RhdGlvbiBsZWZ0XG4gICAgcm90bDogZnVuY3Rpb24obiwgYikge1xuICAgICAgcmV0dXJuIChuIDw8IGIpIHwgKG4gPj4+ICgzMiAtIGIpKTtcbiAgICB9LFxuXG4gICAgLy8gQml0LXdpc2Ugcm90YXRpb24gcmlnaHRcbiAgICByb3RyOiBmdW5jdGlvbihuLCBiKSB7XG4gICAgICByZXR1cm4gKG4gPDwgKDMyIC0gYikpIHwgKG4gPj4+IGIpO1xuICAgIH0sXG5cbiAgICAvLyBTd2FwIGJpZy1lbmRpYW4gdG8gbGl0dGxlLWVuZGlhbiBhbmQgdmljZSB2ZXJzYVxuICAgIGVuZGlhbjogZnVuY3Rpb24obikge1xuICAgICAgLy8gSWYgbnVtYmVyIGdpdmVuLCBzd2FwIGVuZGlhblxuICAgICAgaWYgKG4uY29uc3RydWN0b3IgPT0gTnVtYmVyKSB7XG4gICAgICAgIHJldHVybiBjcnlwdC5yb3RsKG4sIDgpICYgMHgwMEZGMDBGRiB8IGNyeXB0LnJvdGwobiwgMjQpICYgMHhGRjAwRkYwMDtcbiAgICAgIH1cblxuICAgICAgLy8gRWxzZSwgYXNzdW1lIGFycmF5IGFuZCBzd2FwIGFsbCBpdGVtc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuLmxlbmd0aDsgaSsrKVxuICAgICAgICBuW2ldID0gY3J5cHQuZW5kaWFuKG5baV0pO1xuICAgICAgcmV0dXJuIG47XG4gICAgfSxcblxuICAgIC8vIEdlbmVyYXRlIGFuIGFycmF5IG9mIGFueSBsZW5ndGggb2YgcmFuZG9tIGJ5dGVzXG4gICAgcmFuZG9tQnl0ZXM6IGZ1bmN0aW9uKG4pIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW107IG4gPiAwOyBuLS0pXG4gICAgICAgIGJ5dGVzLnB1c2goTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMjU2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGJpZy1lbmRpYW4gMzItYml0IHdvcmRzXG4gICAgYnl0ZXNUb1dvcmRzOiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgd29yZHMgPSBbXSwgaSA9IDAsIGIgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyssIGIgKz0gOClcbiAgICAgICAgd29yZHNbYiA+Pj4gNV0gfD0gYnl0ZXNbaV0gPDwgKDI0IC0gYiAlIDMyKTtcbiAgICAgIHJldHVybiB3b3JkcztcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBiaWctZW5kaWFuIDMyLWJpdCB3b3JkcyB0byBhIGJ5dGUgYXJyYXlcbiAgICB3b3Jkc1RvQnl0ZXM6IGZ1bmN0aW9uKHdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBieXRlcyA9IFtdLCBiID0gMDsgYiA8IHdvcmRzLmxlbmd0aCAqIDMyOyBiICs9IDgpXG4gICAgICAgIGJ5dGVzLnB1c2goKHdvcmRzW2IgPj4+IDVdID4+PiAoMjQgLSBiICUgMzIpKSAmIDB4RkYpO1xuICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgYnl0ZSBhcnJheSB0byBhIGhleCBzdHJpbmdcbiAgICBieXRlc1RvSGV4OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgaGV4ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4LnB1c2goKGJ5dGVzW2ldID4+PiA0KS50b1N0cmluZygxNikpO1xuICAgICAgICBoZXgucHVzaCgoYnl0ZXNbaV0gJiAweEYpLnRvU3RyaW5nKDE2KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGV4LmpvaW4oJycpO1xuICAgIH0sXG5cbiAgICAvLyBDb252ZXJ0IGEgaGV4IHN0cmluZyB0byBhIGJ5dGUgYXJyYXlcbiAgICBoZXhUb0J5dGVzOiBmdW5jdGlvbihoZXgpIHtcbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGMgPSAwOyBjIDwgaGV4Lmxlbmd0aDsgYyArPSAyKVxuICAgICAgICBieXRlcy5wdXNoKHBhcnNlSW50KGhleC5zdWJzdHIoYywgMiksIDE2KSk7XG4gICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfSxcblxuICAgIC8vIENvbnZlcnQgYSBieXRlIGFycmF5IHRvIGEgYmFzZS02NCBzdHJpbmdcbiAgICBieXRlc1RvQmFzZTY0OiBmdW5jdGlvbihieXRlcykge1xuICAgICAgZm9yICh2YXIgYmFzZTY0ID0gW10sIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCA0OyBqKyspXG4gICAgICAgICAgaWYgKGkgKiA4ICsgaiAqIDYgPD0gYnl0ZXMubGVuZ3RoICogOClcbiAgICAgICAgICAgIGJhc2U2NC5wdXNoKGJhc2U2NG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+IDYgKiAoMyAtIGopKSAmIDB4M0YpKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiYXNlNjQucHVzaCgnPScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2U2NC5qb2luKCcnKTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVydCBhIGJhc2UtNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheVxuICAgIGJhc2U2NFRvQnl0ZXM6IGZ1bmN0aW9uKGJhc2U2NCkge1xuICAgICAgLy8gUmVtb3ZlIG5vbi1iYXNlLTY0IGNoYXJhY3RlcnNcbiAgICAgIGJhc2U2NCA9IGJhc2U2NC5yZXBsYWNlKC9bXkEtWjAtOStcXC9dL2lnLCAnJyk7XG5cbiAgICAgIGZvciAodmFyIGJ5dGVzID0gW10sIGkgPSAwLCBpbW9kNCA9IDA7IGkgPCBiYXNlNjQubGVuZ3RoO1xuICAgICAgICAgIGltb2Q0ID0gKytpICUgNCkge1xuICAgICAgICBpZiAoaW1vZDQgPT0gMCkgY29udGludWU7XG4gICAgICAgIGJ5dGVzLnB1c2goKChiYXNlNjRtYXAuaW5kZXhPZihiYXNlNjQuY2hhckF0KGkgLSAxKSlcbiAgICAgICAgICAgICYgKE1hdGgucG93KDIsIC0yICogaW1vZDQgKyA4KSAtIDEpKSA8PCAoaW1vZDQgKiAyKSlcbiAgICAgICAgICAgIHwgKGJhc2U2NG1hcC5pbmRleE9mKGJhc2U2NC5jaGFyQXQoaSkpID4+PiAoNiAtIGltb2Q0ICogMikpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBieXRlcztcbiAgICB9XG4gIH07XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBjcnlwdDtcbn0pKCk7XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL2hlIHYxLjIuMCBieSBAbWF0aGlhcyB8IE1JVCBsaWNlbnNlICovXG47KGZ1bmN0aW9uKHJvb3QpIHtcblxuXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgLlxuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBtb2R1bGVgLlxuXHR2YXIgZnJlZU1vZHVsZSA9IHR5cGVvZiBtb2R1bGUgPT0gJ29iamVjdCcgJiYgbW9kdWxlICYmXG5cdFx0bW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMgJiYgbW9kdWxlO1xuXG5cdC8vIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgLCBmcm9tIE5vZGUuanMgb3IgQnJvd3NlcmlmaWVkIGNvZGUsXG5cdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgLlxuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHwgZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdC8vIEFsbCBhc3RyYWwgc3ltYm9scy5cblx0dmFyIHJlZ2V4QXN0cmFsU3ltYm9scyA9IC9bXFx1RDgwMC1cXHVEQkZGXVtcXHVEQzAwLVxcdURGRkZdL2c7XG5cdC8vIEFsbCBBU0NJSSBzeW1ib2xzIChub3QganVzdCBwcmludGFibGUgQVNDSUkpIGV4Y2VwdCB0aG9zZSBsaXN0ZWQgaW4gdGhlXG5cdC8vIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlLlxuXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCN0YWJsZS1jaGFycmVmLW92ZXJyaWRlc1xuXHR2YXIgcmVnZXhBc2NpaVdoaXRlbGlzdCA9IC9bXFx4MDEtXFx4N0ZdL2c7XG5cdC8vIEFsbCBCTVAgc3ltYm9scyB0aGF0IGFyZSBub3QgQVNDSUkgbmV3bGluZXMsIHByaW50YWJsZSBBU0NJSSBzeW1ib2xzLCBvclxuXHQvLyBjb2RlIHBvaW50cyBsaXN0ZWQgaW4gdGhlIGZpcnN0IGNvbHVtbiBvZiB0aGUgb3ZlcnJpZGVzIHRhYmxlIG9uXG5cdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3RhYmxlLWNoYXJyZWYtb3ZlcnJpZGVzLlxuXHR2YXIgcmVnZXhCbXBXaGl0ZWxpc3QgPSAvW1xceDAxLVxcdFxceDBCXFxmXFx4MEUtXFx4MUZcXHg3RlxceDgxXFx4OERcXHg4RlxceDkwXFx4OURcXHhBMC1cXHVGRkZGXS9nO1xuXG5cdHZhciByZWdleEVuY29kZU5vbkFzY2lpID0gLzxcXHUyMEQyfD1cXHUyMEU1fD5cXHUyMEQyfFxcdTIwNUZcXHUyMDBBfFxcdTIxOURcXHUwMzM4fFxcdTIyMDJcXHUwMzM4fFxcdTIyMjBcXHUyMEQyfFxcdTIyMjlcXHVGRTAwfFxcdTIyMkFcXHVGRTAwfFxcdTIyM0NcXHUyMEQyfFxcdTIyM0RcXHUwMzMxfFxcdTIyM0VcXHUwMzMzfFxcdTIyNDJcXHUwMzM4fFxcdTIyNEJcXHUwMzM4fFxcdTIyNERcXHUyMEQyfFxcdTIyNEVcXHUwMzM4fFxcdTIyNEZcXHUwMzM4fFxcdTIyNTBcXHUwMzM4fFxcdTIyNjFcXHUyMEU1fFxcdTIyNjRcXHUyMEQyfFxcdTIyNjVcXHUyMEQyfFxcdTIyNjZcXHUwMzM4fFxcdTIyNjdcXHUwMzM4fFxcdTIyNjhcXHVGRTAwfFxcdTIyNjlcXHVGRTAwfFxcdTIyNkFcXHUwMzM4fFxcdTIyNkFcXHUyMEQyfFxcdTIyNkJcXHUwMzM4fFxcdTIyNkJcXHUyMEQyfFxcdTIyN0ZcXHUwMzM4fFxcdTIyODJcXHUyMEQyfFxcdTIyODNcXHUyMEQyfFxcdTIyOEFcXHVGRTAwfFxcdTIyOEJcXHVGRTAwfFxcdTIyOEZcXHUwMzM4fFxcdTIyOTBcXHUwMzM4fFxcdTIyOTNcXHVGRTAwfFxcdTIyOTRcXHVGRTAwfFxcdTIyQjRcXHUyMEQyfFxcdTIyQjVcXHUyMEQyfFxcdTIyRDhcXHUwMzM4fFxcdTIyRDlcXHUwMzM4fFxcdTIyREFcXHVGRTAwfFxcdTIyREJcXHVGRTAwfFxcdTIyRjVcXHUwMzM4fFxcdTIyRjlcXHUwMzM4fFxcdTI5MzNcXHUwMzM4fFxcdTI5Q0ZcXHUwMzM4fFxcdTI5RDBcXHUwMzM4fFxcdTJBNkRcXHUwMzM4fFxcdTJBNzBcXHUwMzM4fFxcdTJBN0RcXHUwMzM4fFxcdTJBN0VcXHUwMzM4fFxcdTJBQTFcXHUwMzM4fFxcdTJBQTJcXHUwMzM4fFxcdTJBQUNcXHVGRTAwfFxcdTJBQURcXHVGRTAwfFxcdTJBQUZcXHUwMzM4fFxcdTJBQjBcXHUwMzM4fFxcdTJBQzVcXHUwMzM4fFxcdTJBQzZcXHUwMzM4fFxcdTJBQ0JcXHVGRTAwfFxcdTJBQ0NcXHVGRTAwfFxcdTJBRkRcXHUyMEU1fFtcXHhBMC1cXHUwMTEzXFx1MDExNi1cXHUwMTIyXFx1MDEyNC1cXHUwMTJCXFx1MDEyRS1cXHUwMTREXFx1MDE1MC1cXHUwMTdFXFx1MDE5MlxcdTAxQjVcXHUwMUY1XFx1MDIzN1xcdTAyQzZcXHUwMkM3XFx1MDJEOC1cXHUwMkREXFx1MDMxMVxcdTAzOTEtXFx1MDNBMVxcdTAzQTMtXFx1MDNBOVxcdTAzQjEtXFx1MDNDOVxcdTAzRDFcXHUwM0QyXFx1MDNENVxcdTAzRDZcXHUwM0RDXFx1MDNERFxcdTAzRjBcXHUwM0YxXFx1MDNGNVxcdTAzRjZcXHUwNDAxLVxcdTA0MENcXHUwNDBFLVxcdTA0NEZcXHUwNDUxLVxcdTA0NUNcXHUwNDVFXFx1MDQ1RlxcdTIwMDItXFx1MjAwNVxcdTIwMDctXFx1MjAxMFxcdTIwMTMtXFx1MjAxNlxcdTIwMTgtXFx1MjAxQVxcdTIwMUMtXFx1MjAxRVxcdTIwMjAtXFx1MjAyMlxcdTIwMjVcXHUyMDI2XFx1MjAzMC1cXHUyMDM1XFx1MjAzOVxcdTIwM0FcXHUyMDNFXFx1MjA0MVxcdTIwNDNcXHUyMDQ0XFx1MjA0RlxcdTIwNTdcXHUyMDVGLVxcdTIwNjNcXHUyMEFDXFx1MjBEQlxcdTIwRENcXHUyMTAyXFx1MjEwNVxcdTIxMEEtXFx1MjExM1xcdTIxMTUtXFx1MjExRVxcdTIxMjJcXHUyMTI0XFx1MjEyNy1cXHUyMTI5XFx1MjEyQ1xcdTIxMkRcXHUyMTJGLVxcdTIxMzFcXHUyMTMzLVxcdTIxMzhcXHUyMTQ1LVxcdTIxNDhcXHUyMTUzLVxcdTIxNUVcXHUyMTkwLVxcdTIxOUJcXHUyMTlELVxcdTIxQTdcXHUyMUE5LVxcdTIxQUVcXHUyMUIwLVxcdTIxQjNcXHUyMUI1LVxcdTIxQjdcXHUyMUJBLVxcdTIxREJcXHUyMUREXFx1MjFFNFxcdTIxRTVcXHUyMUY1XFx1MjFGRC1cXHUyMjA1XFx1MjIwNy1cXHUyMjA5XFx1MjIwQlxcdTIyMENcXHUyMjBGLVxcdTIyMTRcXHUyMjE2LVxcdTIyMThcXHUyMjFBXFx1MjIxRC1cXHUyMjM4XFx1MjIzQS1cXHUyMjU3XFx1MjI1OVxcdTIyNUFcXHUyMjVDXFx1MjI1Ri1cXHUyMjYyXFx1MjI2NC1cXHUyMjhCXFx1MjI4RC1cXHUyMjlCXFx1MjI5RC1cXHUyMkE1XFx1MjJBNy1cXHUyMkIwXFx1MjJCMi1cXHUyMkJCXFx1MjJCRC1cXHUyMkRCXFx1MjJERS1cXHUyMkUzXFx1MjJFNi1cXHUyMkY3XFx1MjJGOS1cXHUyMkZFXFx1MjMwNVxcdTIzMDZcXHUyMzA4LVxcdTIzMTBcXHUyMzEyXFx1MjMxM1xcdTIzMTVcXHUyMzE2XFx1MjMxQy1cXHUyMzFGXFx1MjMyMlxcdTIzMjNcXHUyMzJEXFx1MjMyRVxcdTIzMzZcXHUyMzNEXFx1MjMzRlxcdTIzN0NcXHUyM0IwXFx1MjNCMVxcdTIzQjQtXFx1MjNCNlxcdTIzREMtXFx1MjNERlxcdTIzRTJcXHUyM0U3XFx1MjQyM1xcdTI0QzhcXHUyNTAwXFx1MjUwMlxcdTI1MENcXHUyNTEwXFx1MjUxNFxcdTI1MThcXHUyNTFDXFx1MjUyNFxcdTI1MkNcXHUyNTM0XFx1MjUzQ1xcdTI1NTAtXFx1MjU2Q1xcdTI1ODBcXHUyNTg0XFx1MjU4OFxcdTI1OTEtXFx1MjU5M1xcdTI1QTFcXHUyNUFBXFx1MjVBQlxcdTI1QURcXHUyNUFFXFx1MjVCMVxcdTI1QjMtXFx1MjVCNVxcdTI1QjhcXHUyNUI5XFx1MjVCRC1cXHUyNUJGXFx1MjVDMlxcdTI1QzNcXHUyNUNBXFx1MjVDQlxcdTI1RUNcXHUyNUVGXFx1MjVGOC1cXHUyNUZDXFx1MjYwNVxcdTI2MDZcXHUyNjBFXFx1MjY0MFxcdTI2NDJcXHUyNjYwXFx1MjY2M1xcdTI2NjVcXHUyNjY2XFx1MjY2QVxcdTI2NkQtXFx1MjY2RlxcdTI3MTNcXHUyNzE3XFx1MjcyMFxcdTI3MzZcXHUyNzU4XFx1Mjc3MlxcdTI3NzNcXHUyN0M4XFx1MjdDOVxcdTI3RTYtXFx1MjdFRFxcdTI3RjUtXFx1MjdGQVxcdTI3RkNcXHUyN0ZGXFx1MjkwMi1cXHUyOTA1XFx1MjkwQy1cXHUyOTEzXFx1MjkxNlxcdTI5MTktXFx1MjkyMFxcdTI5MjMtXFx1MjkyQVxcdTI5MzNcXHUyOTM1LVxcdTI5MzlcXHUyOTNDXFx1MjkzRFxcdTI5NDVcXHUyOTQ4LVxcdTI5NEJcXHUyOTRFLVxcdTI5NzZcXHUyOTc4XFx1Mjk3OVxcdTI5N0ItXFx1Mjk3RlxcdTI5ODVcXHUyOTg2XFx1Mjk4Qi1cXHUyOTk2XFx1Mjk5QVxcdTI5OUNcXHUyOTlEXFx1MjlBNC1cXHUyOUI3XFx1MjlCOVxcdTI5QkJcXHUyOUJDXFx1MjlCRS1cXHUyOUM1XFx1MjlDOVxcdTI5Q0QtXFx1MjlEMFxcdTI5REMtXFx1MjlERVxcdTI5RTMtXFx1MjlFNVxcdTI5RUJcXHUyOUY0XFx1MjlGNlxcdTJBMDAtXFx1MkEwMlxcdTJBMDRcXHUyQTA2XFx1MkEwQ1xcdTJBMERcXHUyQTEwLVxcdTJBMTdcXHUyQTIyLVxcdTJBMjdcXHUyQTI5XFx1MkEyQVxcdTJBMkQtXFx1MkEzMVxcdTJBMzMtXFx1MkEzQ1xcdTJBM0ZcXHUyQTQwXFx1MkE0Mi1cXHUyQTREXFx1MkE1MFxcdTJBNTMtXFx1MkE1OFxcdTJBNUEtXFx1MkE1RFxcdTJBNUZcXHUyQTY2XFx1MkE2QVxcdTJBNkQtXFx1MkE3NVxcdTJBNzctXFx1MkE5QVxcdTJBOUQtXFx1MkFBMlxcdTJBQTQtXFx1MkFCMFxcdTJBQjMtXFx1MkFDOFxcdTJBQ0JcXHUyQUNDXFx1MkFDRi1cXHUyQURCXFx1MkFFNFxcdTJBRTYtXFx1MkFFOVxcdTJBRUItXFx1MkFGM1xcdTJBRkRcXHVGQjAwLVxcdUZCMDRdfFxcdUQ4MzVbXFx1REM5Q1xcdURDOUVcXHVEQzlGXFx1RENBMlxcdURDQTVcXHVEQ0E2XFx1RENBOS1cXHVEQ0FDXFx1RENBRS1cXHVEQ0I5XFx1RENCQlxcdURDQkQtXFx1RENDM1xcdURDQzUtXFx1RENDRlxcdUREMDRcXHVERDA1XFx1REQwNy1cXHVERDBBXFx1REQwRC1cXHVERDE0XFx1REQxNi1cXHVERDFDXFx1REQxRS1cXHVERDM5XFx1REQzQi1cXHVERDNFXFx1REQ0MC1cXHVERDQ0XFx1REQ0NlxcdURENEEtXFx1REQ1MFxcdURENTItXFx1REQ2Ql0vZztcblx0dmFyIGVuY29kZU1hcCA9IHsnXFx4QUQnOidzaHknLCdcXHUyMDBDJzonenduaicsJ1xcdTIwMEQnOid6d2onLCdcXHUyMDBFJzonbHJtJywnXFx1MjA2Myc6J2ljJywnXFx1MjA2Mic6J2l0JywnXFx1MjA2MSc6J2FmJywnXFx1MjAwRic6J3JsbScsJ1xcdTIwMEInOidaZXJvV2lkdGhTcGFjZScsJ1xcdTIwNjAnOidOb0JyZWFrJywnXFx1MDMxMSc6J0Rvd25CcmV2ZScsJ1xcdTIwREInOid0ZG90JywnXFx1MjBEQyc6J0RvdERvdCcsJ1xcdCc6J1RhYicsJ1xcbic6J05ld0xpbmUnLCdcXHUyMDA4JzoncHVuY3NwJywnXFx1MjA1Ric6J01lZGl1bVNwYWNlJywnXFx1MjAwOSc6J3RoaW5zcCcsJ1xcdTIwMEEnOidoYWlyc3AnLCdcXHUyMDA0JzonZW1zcDEzJywnXFx1MjAwMic6J2Vuc3AnLCdcXHUyMDA1JzonZW1zcDE0JywnXFx1MjAwMyc6J2Vtc3AnLCdcXHUyMDA3JzonbnVtc3AnLCdcXHhBMCc6J25ic3AnLCdcXHUyMDVGXFx1MjAwQSc6J1RoaWNrU3BhY2UnLCdcXHUyMDNFJzonb2xpbmUnLCdfJzonbG93YmFyJywnXFx1MjAxMCc6J2Rhc2gnLCdcXHUyMDEzJzonbmRhc2gnLCdcXHUyMDE0JzonbWRhc2gnLCdcXHUyMDE1JzonaG9yYmFyJywnLCc6J2NvbW1hJywnOyc6J3NlbWknLCdcXHUyMDRGJzonYnNlbWknLCc6JzonY29sb24nLCdcXHUyQTc0JzonQ29sb25lJywnISc6J2V4Y2wnLCdcXHhBMSc6J2lleGNsJywnPyc6J3F1ZXN0JywnXFx4QkYnOidpcXVlc3QnLCcuJzoncGVyaW9kJywnXFx1MjAyNSc6J25sZHInLCdcXHUyMDI2JzonbWxkcicsJ1xceEI3JzonbWlkZG90JywnXFwnJzonYXBvcycsJ1xcdTIwMTgnOidsc3F1bycsJ1xcdTIwMTknOidyc3F1bycsJ1xcdTIwMUEnOidzYnF1bycsJ1xcdTIwMzknOidsc2FxdW8nLCdcXHUyMDNBJzoncnNhcXVvJywnXCInOidxdW90JywnXFx1MjAxQyc6J2xkcXVvJywnXFx1MjAxRCc6J3JkcXVvJywnXFx1MjAxRSc6J2JkcXVvJywnXFx4QUInOidsYXF1bycsJ1xceEJCJzoncmFxdW8nLCcoJzonbHBhcicsJyknOidycGFyJywnWyc6J2xzcWInLCddJzoncnNxYicsJ3snOidsY3ViJywnfSc6J3JjdWInLCdcXHUyMzA4JzonbGNlaWwnLCdcXHUyMzA5JzoncmNlaWwnLCdcXHUyMzBBJzonbGZsb29yJywnXFx1MjMwQic6J3JmbG9vcicsJ1xcdTI5ODUnOidsb3BhcicsJ1xcdTI5ODYnOidyb3BhcicsJ1xcdTI5OEInOidsYnJrZScsJ1xcdTI5OEMnOidyYnJrZScsJ1xcdTI5OEQnOidsYnJrc2x1JywnXFx1Mjk4RSc6J3JicmtzbGQnLCdcXHUyOThGJzonbGJya3NsZCcsJ1xcdTI5OTAnOidyYnJrc2x1JywnXFx1Mjk5MSc6J2xhbmdkJywnXFx1Mjk5Mic6J3JhbmdkJywnXFx1Mjk5Myc6J2xwYXJsdCcsJ1xcdTI5OTQnOidycGFyZ3QnLCdcXHUyOTk1JzonZ3RsUGFyJywnXFx1Mjk5Nic6J2x0clBhcicsJ1xcdTI3RTYnOidsb2JyaycsJ1xcdTI3RTcnOidyb2JyaycsJ1xcdTI3RTgnOidsYW5nJywnXFx1MjdFOSc6J3JhbmcnLCdcXHUyN0VBJzonTGFuZycsJ1xcdTI3RUInOidSYW5nJywnXFx1MjdFQyc6J2xvYW5nJywnXFx1MjdFRCc6J3JvYW5nJywnXFx1Mjc3Mic6J2xiYnJrJywnXFx1Mjc3Myc6J3JiYnJrJywnXFx1MjAxNic6J1ZlcnQnLCdcXHhBNyc6J3NlY3QnLCdcXHhCNic6J3BhcmEnLCdAJzonY29tbWF0JywnKic6J2FzdCcsJy8nOidzb2wnLCd1bmRlZmluZWQnOm51bGwsJyYnOidhbXAnLCcjJzonbnVtJywnJSc6J3BlcmNudCcsJ1xcdTIwMzAnOidwZXJtaWwnLCdcXHUyMDMxJzoncGVydGVuaycsJ1xcdTIwMjAnOidkYWdnZXInLCdcXHUyMDIxJzonRGFnZ2VyJywnXFx1MjAyMic6J2J1bGwnLCdcXHUyMDQzJzonaHlidWxsJywnXFx1MjAzMic6J3ByaW1lJywnXFx1MjAzMyc6J1ByaW1lJywnXFx1MjAzNCc6J3RwcmltZScsJ1xcdTIwNTcnOidxcHJpbWUnLCdcXHUyMDM1JzonYnByaW1lJywnXFx1MjA0MSc6J2NhcmV0JywnYCc6J2dyYXZlJywnXFx4QjQnOidhY3V0ZScsJ1xcdTAyREMnOid0aWxkZScsJ14nOidIYXQnLCdcXHhBRic6J21hY3InLCdcXHUwMkQ4JzonYnJldmUnLCdcXHUwMkQ5JzonZG90JywnXFx4QTgnOidkaWUnLCdcXHUwMkRBJzoncmluZycsJ1xcdTAyREQnOidkYmxhYycsJ1xceEI4JzonY2VkaWwnLCdcXHUwMkRCJzonb2dvbicsJ1xcdTAyQzYnOidjaXJjJywnXFx1MDJDNyc6J2Nhcm9uJywnXFx4QjAnOidkZWcnLCdcXHhBOSc6J2NvcHknLCdcXHhBRSc6J3JlZycsJ1xcdTIxMTcnOidjb3B5c3InLCdcXHUyMTE4Jzond3AnLCdcXHUyMTFFJzoncngnLCdcXHUyMTI3JzonbWhvJywnXFx1MjEyOSc6J2lpb3RhJywnXFx1MjE5MCc6J2xhcnInLCdcXHUyMTlBJzonbmxhcnInLCdcXHUyMTkyJzoncmFycicsJ1xcdTIxOUInOiducmFycicsJ1xcdTIxOTEnOid1YXJyJywnXFx1MjE5Myc6J2RhcnInLCdcXHUyMTk0JzonaGFycicsJ1xcdTIxQUUnOiduaGFycicsJ1xcdTIxOTUnOid2YXJyJywnXFx1MjE5Nic6J253YXJyJywnXFx1MjE5Nyc6J25lYXJyJywnXFx1MjE5OCc6J3NlYXJyJywnXFx1MjE5OSc6J3N3YXJyJywnXFx1MjE5RCc6J3JhcnJ3JywnXFx1MjE5RFxcdTAzMzgnOiducmFycncnLCdcXHUyMTlFJzonTGFycicsJ1xcdTIxOUYnOidVYXJyJywnXFx1MjFBMCc6J1JhcnInLCdcXHUyMUExJzonRGFycicsJ1xcdTIxQTInOidsYXJydGwnLCdcXHUyMUEzJzoncmFycnRsJywnXFx1MjFBNCc6J21hcHN0b2xlZnQnLCdcXHUyMUE1JzonbWFwc3RvdXAnLCdcXHUyMUE2JzonbWFwJywnXFx1MjFBNyc6J21hcHN0b2Rvd24nLCdcXHUyMUE5JzonbGFycmhrJywnXFx1MjFBQSc6J3JhcnJoaycsJ1xcdTIxQUInOidsYXJybHAnLCdcXHUyMUFDJzoncmFycmxwJywnXFx1MjFBRCc6J2hhcnJ3JywnXFx1MjFCMCc6J2xzaCcsJ1xcdTIxQjEnOidyc2gnLCdcXHUyMUIyJzonbGRzaCcsJ1xcdTIxQjMnOidyZHNoJywnXFx1MjFCNSc6J2NyYXJyJywnXFx1MjFCNic6J2N1bGFycicsJ1xcdTIxQjcnOidjdXJhcnInLCdcXHUyMUJBJzonb2xhcnInLCdcXHUyMUJCJzonb3JhcnInLCdcXHUyMUJDJzonbGhhcnUnLCdcXHUyMUJEJzonbGhhcmQnLCdcXHUyMUJFJzondWhhcnInLCdcXHUyMUJGJzondWhhcmwnLCdcXHUyMUMwJzoncmhhcnUnLCdcXHUyMUMxJzoncmhhcmQnLCdcXHUyMUMyJzonZGhhcnInLCdcXHUyMUMzJzonZGhhcmwnLCdcXHUyMUM0JzoncmxhcnInLCdcXHUyMUM1JzondWRhcnInLCdcXHUyMUM2JzonbHJhcnInLCdcXHUyMUM3JzonbGxhcnInLCdcXHUyMUM4JzondXVhcnInLCdcXHUyMUM5JzoncnJhcnInLCdcXHUyMUNBJzonZGRhcnInLCdcXHUyMUNCJzonbHJoYXInLCdcXHUyMUNDJzoncmxoYXInLCdcXHUyMUQwJzonbEFycicsJ1xcdTIxQ0QnOidubEFycicsJ1xcdTIxRDEnOid1QXJyJywnXFx1MjFEMic6J3JBcnInLCdcXHUyMUNGJzonbnJBcnInLCdcXHUyMUQzJzonZEFycicsJ1xcdTIxRDQnOidpZmYnLCdcXHUyMUNFJzonbmhBcnInLCdcXHUyMUQ1JzondkFycicsJ1xcdTIxRDYnOidud0FycicsJ1xcdTIxRDcnOiduZUFycicsJ1xcdTIxRDgnOidzZUFycicsJ1xcdTIxRDknOidzd0FycicsJ1xcdTIxREEnOidsQWFycicsJ1xcdTIxREInOidyQWFycicsJ1xcdTIxREQnOid6aWdyYXJyJywnXFx1MjFFNCc6J2xhcnJiJywnXFx1MjFFNSc6J3JhcnJiJywnXFx1MjFGNSc6J2R1YXJyJywnXFx1MjFGRCc6J2xvYXJyJywnXFx1MjFGRSc6J3JvYXJyJywnXFx1MjFGRic6J2hvYXJyJywnXFx1MjIwMCc6J2ZvcmFsbCcsJ1xcdTIyMDEnOidjb21wJywnXFx1MjIwMic6J3BhcnQnLCdcXHUyMjAyXFx1MDMzOCc6J25wYXJ0JywnXFx1MjIwMyc6J2V4aXN0JywnXFx1MjIwNCc6J25leGlzdCcsJ1xcdTIyMDUnOidlbXB0eScsJ1xcdTIyMDcnOidEZWwnLCdcXHUyMjA4JzonaW4nLCdcXHUyMjA5Jzonbm90aW4nLCdcXHUyMjBCJzonbmknLCdcXHUyMjBDJzonbm90bmknLCdcXHUwM0Y2JzonYmVwc2knLCdcXHUyMjBGJzoncHJvZCcsJ1xcdTIyMTAnOidjb3Byb2QnLCdcXHUyMjExJzonc3VtJywnKyc6J3BsdXMnLCdcXHhCMSc6J3BtJywnXFx4RjcnOidkaXYnLCdcXHhENyc6J3RpbWVzJywnPCc6J2x0JywnXFx1MjI2RSc6J25sdCcsJzxcXHUyMEQyJzonbnZsdCcsJz0nOidlcXVhbHMnLCdcXHUyMjYwJzonbmUnLCc9XFx1MjBFNSc6J2JuZScsJ1xcdTJBNzUnOidFcXVhbCcsJz4nOidndCcsJ1xcdTIyNkYnOiduZ3QnLCc+XFx1MjBEMic6J252Z3QnLCdcXHhBQyc6J25vdCcsJ3wnOid2ZXJ0JywnXFx4QTYnOidicnZiYXInLCdcXHUyMjEyJzonbWludXMnLCdcXHUyMjEzJzonbXAnLCdcXHUyMjE0JzoncGx1c2RvJywnXFx1MjA0NCc6J2ZyYXNsJywnXFx1MjIxNic6J3NldG1uJywnXFx1MjIxNyc6J2xvd2FzdCcsJ1xcdTIyMTgnOidjb21wZm4nLCdcXHUyMjFBJzonU3FydCcsJ1xcdTIyMUQnOidwcm9wJywnXFx1MjIxRSc6J2luZmluJywnXFx1MjIxRic6J2FuZ3J0JywnXFx1MjIyMCc6J2FuZycsJ1xcdTIyMjBcXHUyMEQyJzonbmFuZycsJ1xcdTIyMjEnOidhbmdtc2QnLCdcXHUyMjIyJzonYW5nc3BoJywnXFx1MjIyMyc6J21pZCcsJ1xcdTIyMjQnOidubWlkJywnXFx1MjIyNSc6J3BhcicsJ1xcdTIyMjYnOiducGFyJywnXFx1MjIyNyc6J2FuZCcsJ1xcdTIyMjgnOidvcicsJ1xcdTIyMjknOidjYXAnLCdcXHUyMjI5XFx1RkUwMCc6J2NhcHMnLCdcXHUyMjJBJzonY3VwJywnXFx1MjIyQVxcdUZFMDAnOidjdXBzJywnXFx1MjIyQic6J2ludCcsJ1xcdTIyMkMnOidJbnQnLCdcXHUyMjJEJzondGludCcsJ1xcdTJBMEMnOidxaW50JywnXFx1MjIyRSc6J29pbnQnLCdcXHUyMjJGJzonQ29uaW50JywnXFx1MjIzMCc6J0Njb25pbnQnLCdcXHUyMjMxJzonY3dpbnQnLCdcXHUyMjMyJzonY3djb25pbnQnLCdcXHUyMjMzJzonYXdjb25pbnQnLCdcXHUyMjM0JzondGhlcmU0JywnXFx1MjIzNSc6J2JlY2F1cycsJ1xcdTIyMzYnOidyYXRpbycsJ1xcdTIyMzcnOidDb2xvbicsJ1xcdTIyMzgnOidtaW51c2QnLCdcXHUyMjNBJzonbUREb3QnLCdcXHUyMjNCJzonaG9tdGh0JywnXFx1MjIzQyc6J3NpbScsJ1xcdTIyNDEnOiduc2ltJywnXFx1MjIzQ1xcdTIwRDInOidudnNpbScsJ1xcdTIyM0QnOidic2ltJywnXFx1MjIzRFxcdTAzMzEnOidyYWNlJywnXFx1MjIzRSc6J2FjJywnXFx1MjIzRVxcdTAzMzMnOidhY0UnLCdcXHUyMjNGJzonYWNkJywnXFx1MjI0MCc6J3dyJywnXFx1MjI0Mic6J2VzaW0nLCdcXHUyMjQyXFx1MDMzOCc6J25lc2ltJywnXFx1MjI0Myc6J3NpbWUnLCdcXHUyMjQ0JzonbnNpbWUnLCdcXHUyMjQ1JzonY29uZycsJ1xcdTIyNDcnOiduY29uZycsJ1xcdTIyNDYnOidzaW1uZScsJ1xcdTIyNDgnOidhcCcsJ1xcdTIyNDknOiduYXAnLCdcXHUyMjRBJzonYXBlJywnXFx1MjI0Qic6J2FwaWQnLCdcXHUyMjRCXFx1MDMzOCc6J25hcGlkJywnXFx1MjI0Qyc6J2Jjb25nJywnXFx1MjI0RCc6J0N1cENhcCcsJ1xcdTIyNkQnOidOb3RDdXBDYXAnLCdcXHUyMjREXFx1MjBEMic6J252YXAnLCdcXHUyMjRFJzonYnVtcCcsJ1xcdTIyNEVcXHUwMzM4JzonbmJ1bXAnLCdcXHUyMjRGJzonYnVtcGUnLCdcXHUyMjRGXFx1MDMzOCc6J25idW1wZScsJ1xcdTIyNTAnOidkb3RlcScsJ1xcdTIyNTBcXHUwMzM4JzonbmVkb3QnLCdcXHUyMjUxJzonZURvdCcsJ1xcdTIyNTInOidlZkRvdCcsJ1xcdTIyNTMnOidlckRvdCcsJ1xcdTIyNTQnOidjb2xvbmUnLCdcXHUyMjU1JzonZWNvbG9uJywnXFx1MjI1Nic6J2VjaXInLCdcXHUyMjU3JzonY2lyZScsJ1xcdTIyNTknOid3ZWRnZXEnLCdcXHUyMjVBJzondmVlZXEnLCdcXHUyMjVDJzondHJpZScsJ1xcdTIyNUYnOidlcXVlc3QnLCdcXHUyMjYxJzonZXF1aXYnLCdcXHUyMjYyJzonbmVxdWl2JywnXFx1MjI2MVxcdTIwRTUnOidibmVxdWl2JywnXFx1MjI2NCc6J2xlJywnXFx1MjI3MCc6J25sZScsJ1xcdTIyNjRcXHUyMEQyJzonbnZsZScsJ1xcdTIyNjUnOidnZScsJ1xcdTIyNzEnOiduZ2UnLCdcXHUyMjY1XFx1MjBEMic6J252Z2UnLCdcXHUyMjY2JzonbEUnLCdcXHUyMjY2XFx1MDMzOCc6J25sRScsJ1xcdTIyNjcnOidnRScsJ1xcdTIyNjdcXHUwMzM4JzonbmdFJywnXFx1MjI2OFxcdUZFMDAnOidsdm5FJywnXFx1MjI2OCc6J2xuRScsJ1xcdTIyNjknOidnbkUnLCdcXHUyMjY5XFx1RkUwMCc6J2d2bkUnLCdcXHUyMjZBJzonbGwnLCdcXHUyMjZBXFx1MDMzOCc6J25MdHYnLCdcXHUyMjZBXFx1MjBEMic6J25MdCcsJ1xcdTIyNkInOidnZycsJ1xcdTIyNkJcXHUwMzM4Jzonbkd0dicsJ1xcdTIyNkJcXHUyMEQyJzonbkd0JywnXFx1MjI2Qyc6J3R3aXh0JywnXFx1MjI3Mic6J2xzaW0nLCdcXHUyMjc0JzonbmxzaW0nLCdcXHUyMjczJzonZ3NpbScsJ1xcdTIyNzUnOiduZ3NpbScsJ1xcdTIyNzYnOidsZycsJ1xcdTIyNzgnOidudGxnJywnXFx1MjI3Nyc6J2dsJywnXFx1MjI3OSc6J250Z2wnLCdcXHUyMjdBJzoncHInLCdcXHUyMjgwJzonbnByJywnXFx1MjI3Qic6J3NjJywnXFx1MjI4MSc6J25zYycsJ1xcdTIyN0MnOidwcmN1ZScsJ1xcdTIyRTAnOiducHJjdWUnLCdcXHUyMjdEJzonc2NjdWUnLCdcXHUyMkUxJzonbnNjY3VlJywnXFx1MjI3RSc6J3Byc2ltJywnXFx1MjI3Ric6J3Njc2ltJywnXFx1MjI3RlxcdTAzMzgnOidOb3RTdWNjZWVkc1RpbGRlJywnXFx1MjI4Mic6J3N1YicsJ1xcdTIyODQnOiduc3ViJywnXFx1MjI4MlxcdTIwRDInOid2bnN1YicsJ1xcdTIyODMnOidzdXAnLCdcXHUyMjg1JzonbnN1cCcsJ1xcdTIyODNcXHUyMEQyJzondm5zdXAnLCdcXHUyMjg2Jzonc3ViZScsJ1xcdTIyODgnOiduc3ViZScsJ1xcdTIyODcnOidzdXBlJywnXFx1MjI4OSc6J25zdXBlJywnXFx1MjI4QVxcdUZFMDAnOid2c3VibmUnLCdcXHUyMjhBJzonc3VibmUnLCdcXHUyMjhCXFx1RkUwMCc6J3ZzdXBuZScsJ1xcdTIyOEInOidzdXBuZScsJ1xcdTIyOEQnOidjdXBkb3QnLCdcXHUyMjhFJzondXBsdXMnLCdcXHUyMjhGJzonc3FzdWInLCdcXHUyMjhGXFx1MDMzOCc6J05vdFNxdWFyZVN1YnNldCcsJ1xcdTIyOTAnOidzcXN1cCcsJ1xcdTIyOTBcXHUwMzM4JzonTm90U3F1YXJlU3VwZXJzZXQnLCdcXHUyMjkxJzonc3FzdWJlJywnXFx1MjJFMic6J25zcXN1YmUnLCdcXHUyMjkyJzonc3FzdXBlJywnXFx1MjJFMyc6J25zcXN1cGUnLCdcXHUyMjkzJzonc3FjYXAnLCdcXHUyMjkzXFx1RkUwMCc6J3NxY2FwcycsJ1xcdTIyOTQnOidzcWN1cCcsJ1xcdTIyOTRcXHVGRTAwJzonc3FjdXBzJywnXFx1MjI5NSc6J29wbHVzJywnXFx1MjI5Nic6J29taW51cycsJ1xcdTIyOTcnOidvdGltZXMnLCdcXHUyMjk4Jzonb3NvbCcsJ1xcdTIyOTknOidvZG90JywnXFx1MjI5QSc6J29jaXInLCdcXHUyMjlCJzonb2FzdCcsJ1xcdTIyOUQnOidvZGFzaCcsJ1xcdTIyOUUnOidwbHVzYicsJ1xcdTIyOUYnOidtaW51c2InLCdcXHUyMkEwJzondGltZXNiJywnXFx1MjJBMSc6J3Nkb3RiJywnXFx1MjJBMic6J3ZkYXNoJywnXFx1MjJBQyc6J252ZGFzaCcsJ1xcdTIyQTMnOidkYXNodicsJ1xcdTIyQTQnOid0b3AnLCdcXHUyMkE1JzonYm90JywnXFx1MjJBNyc6J21vZGVscycsJ1xcdTIyQTgnOid2RGFzaCcsJ1xcdTIyQUQnOidudkRhc2gnLCdcXHUyMkE5JzonVmRhc2gnLCdcXHUyMkFFJzonblZkYXNoJywnXFx1MjJBQSc6J1Z2ZGFzaCcsJ1xcdTIyQUInOidWRGFzaCcsJ1xcdTIyQUYnOiduVkRhc2gnLCdcXHUyMkIwJzoncHJ1cmVsJywnXFx1MjJCMic6J3ZsdHJpJywnXFx1MjJFQSc6J25sdHJpJywnXFx1MjJCMyc6J3ZydHJpJywnXFx1MjJFQic6J25ydHJpJywnXFx1MjJCNCc6J2x0cmllJywnXFx1MjJFQyc6J25sdHJpZScsJ1xcdTIyQjRcXHUyMEQyJzonbnZsdHJpZScsJ1xcdTIyQjUnOidydHJpZScsJ1xcdTIyRUQnOiducnRyaWUnLCdcXHUyMkI1XFx1MjBEMic6J252cnRyaWUnLCdcXHUyMkI2Jzonb3JpZ29mJywnXFx1MjJCNyc6J2ltb2YnLCdcXHUyMkI4JzonbXVtYXAnLCdcXHUyMkI5JzonaGVyY29uJywnXFx1MjJCQSc6J2ludGNhbCcsJ1xcdTIyQkInOid2ZWViYXInLCdcXHUyMkJEJzonYmFydmVlJywnXFx1MjJCRSc6J2FuZ3J0dmInLCdcXHUyMkJGJzonbHJ0cmknLCdcXHUyMkMwJzonV2VkZ2UnLCdcXHUyMkMxJzonVmVlJywnXFx1MjJDMic6J3hjYXAnLCdcXHUyMkMzJzoneGN1cCcsJ1xcdTIyQzQnOidkaWFtJywnXFx1MjJDNSc6J3Nkb3QnLCdcXHUyMkM2JzonU3RhcicsJ1xcdTIyQzcnOidkaXZvbngnLCdcXHUyMkM4JzonYm93dGllJywnXFx1MjJDOSc6J2x0aW1lcycsJ1xcdTIyQ0EnOidydGltZXMnLCdcXHUyMkNCJzonbHRocmVlJywnXFx1MjJDQyc6J3J0aHJlZScsJ1xcdTIyQ0QnOidic2ltZScsJ1xcdTIyQ0UnOidjdXZlZScsJ1xcdTIyQ0YnOidjdXdlZCcsJ1xcdTIyRDAnOidTdWInLCdcXHUyMkQxJzonU3VwJywnXFx1MjJEMic6J0NhcCcsJ1xcdTIyRDMnOidDdXAnLCdcXHUyMkQ0JzonZm9yaycsJ1xcdTIyRDUnOidlcGFyJywnXFx1MjJENic6J2x0ZG90JywnXFx1MjJENyc6J2d0ZG90JywnXFx1MjJEOCc6J0xsJywnXFx1MjJEOFxcdTAzMzgnOiduTGwnLCdcXHUyMkQ5JzonR2cnLCdcXHUyMkQ5XFx1MDMzOCc6J25HZycsJ1xcdTIyREFcXHVGRTAwJzonbGVzZycsJ1xcdTIyREEnOidsZWcnLCdcXHUyMkRCJzonZ2VsJywnXFx1MjJEQlxcdUZFMDAnOidnZXNsJywnXFx1MjJERSc6J2N1ZXByJywnXFx1MjJERic6J2N1ZXNjJywnXFx1MjJFNic6J2xuc2ltJywnXFx1MjJFNyc6J2duc2ltJywnXFx1MjJFOCc6J3BybnNpbScsJ1xcdTIyRTknOidzY25zaW0nLCdcXHUyMkVFJzondmVsbGlwJywnXFx1MjJFRic6J2N0ZG90JywnXFx1MjJGMCc6J3V0ZG90JywnXFx1MjJGMSc6J2R0ZG90JywnXFx1MjJGMic6J2Rpc2luJywnXFx1MjJGMyc6J2lzaW5zdicsJ1xcdTIyRjQnOidpc2lucycsJ1xcdTIyRjUnOidpc2luZG90JywnXFx1MjJGNVxcdTAzMzgnOidub3RpbmRvdCcsJ1xcdTIyRjYnOidub3RpbnZjJywnXFx1MjJGNyc6J25vdGludmInLCdcXHUyMkY5JzonaXNpbkUnLCdcXHUyMkY5XFx1MDMzOCc6J25vdGluRScsJ1xcdTIyRkEnOiduaXNkJywnXFx1MjJGQic6J3huaXMnLCdcXHUyMkZDJzonbmlzJywnXFx1MjJGRCc6J25vdG5pdmMnLCdcXHUyMkZFJzonbm90bml2YicsJ1xcdTIzMDUnOidiYXJ3ZWQnLCdcXHUyMzA2JzonQmFyd2VkJywnXFx1MjMwQyc6J2RyY3JvcCcsJ1xcdTIzMEQnOidkbGNyb3AnLCdcXHUyMzBFJzondXJjcm9wJywnXFx1MjMwRic6J3VsY3JvcCcsJ1xcdTIzMTAnOidibm90JywnXFx1MjMxMic6J3Byb2ZsaW5lJywnXFx1MjMxMyc6J3Byb2ZzdXJmJywnXFx1MjMxNSc6J3RlbHJlYycsJ1xcdTIzMTYnOid0YXJnZXQnLCdcXHUyMzFDJzondWxjb3JuJywnXFx1MjMxRCc6J3VyY29ybicsJ1xcdTIzMUUnOidkbGNvcm4nLCdcXHUyMzFGJzonZHJjb3JuJywnXFx1MjMyMic6J2Zyb3duJywnXFx1MjMyMyc6J3NtaWxlJywnXFx1MjMyRCc6J2N5bGN0eScsJ1xcdTIzMkUnOidwcm9mYWxhcicsJ1xcdTIzMzYnOid0b3Bib3QnLCdcXHUyMzNEJzonb3ZiYXInLCdcXHUyMzNGJzonc29sYmFyJywnXFx1MjM3Qyc6J2FuZ3phcnInLCdcXHUyM0IwJzonbG1vdXN0JywnXFx1MjNCMSc6J3Jtb3VzdCcsJ1xcdTIzQjQnOid0YnJrJywnXFx1MjNCNSc6J2JicmsnLCdcXHUyM0I2JzonYmJya3RicmsnLCdcXHUyM0RDJzonT3ZlclBhcmVudGhlc2lzJywnXFx1MjNERCc6J1VuZGVyUGFyZW50aGVzaXMnLCdcXHUyM0RFJzonT3ZlckJyYWNlJywnXFx1MjNERic6J1VuZGVyQnJhY2UnLCdcXHUyM0UyJzondHJwZXppdW0nLCdcXHUyM0U3JzonZWxpbnRlcnMnLCdcXHUyNDIzJzonYmxhbmsnLCdcXHUyNTAwJzonYm94aCcsJ1xcdTI1MDInOidib3h2JywnXFx1MjUwQyc6J2JveGRyJywnXFx1MjUxMCc6J2JveGRsJywnXFx1MjUxNCc6J2JveHVyJywnXFx1MjUxOCc6J2JveHVsJywnXFx1MjUxQyc6J2JveHZyJywnXFx1MjUyNCc6J2JveHZsJywnXFx1MjUyQyc6J2JveGhkJywnXFx1MjUzNCc6J2JveGh1JywnXFx1MjUzQyc6J2JveHZoJywnXFx1MjU1MCc6J2JveEgnLCdcXHUyNTUxJzonYm94VicsJ1xcdTI1NTInOidib3hkUicsJ1xcdTI1NTMnOidib3hEcicsJ1xcdTI1NTQnOidib3hEUicsJ1xcdTI1NTUnOidib3hkTCcsJ1xcdTI1NTYnOidib3hEbCcsJ1xcdTI1NTcnOidib3hETCcsJ1xcdTI1NTgnOidib3h1UicsJ1xcdTI1NTknOidib3hVcicsJ1xcdTI1NUEnOidib3hVUicsJ1xcdTI1NUInOidib3h1TCcsJ1xcdTI1NUMnOidib3hVbCcsJ1xcdTI1NUQnOidib3hVTCcsJ1xcdTI1NUUnOidib3h2UicsJ1xcdTI1NUYnOidib3hWcicsJ1xcdTI1NjAnOidib3hWUicsJ1xcdTI1NjEnOidib3h2TCcsJ1xcdTI1NjInOidib3hWbCcsJ1xcdTI1NjMnOidib3hWTCcsJ1xcdTI1NjQnOidib3hIZCcsJ1xcdTI1NjUnOidib3hoRCcsJ1xcdTI1NjYnOidib3hIRCcsJ1xcdTI1NjcnOidib3hIdScsJ1xcdTI1NjgnOidib3hoVScsJ1xcdTI1NjknOidib3hIVScsJ1xcdTI1NkEnOidib3h2SCcsJ1xcdTI1NkInOidib3hWaCcsJ1xcdTI1NkMnOidib3hWSCcsJ1xcdTI1ODAnOid1aGJsaycsJ1xcdTI1ODQnOidsaGJsaycsJ1xcdTI1ODgnOidibG9jaycsJ1xcdTI1OTEnOidibGsxNCcsJ1xcdTI1OTInOidibGsxMicsJ1xcdTI1OTMnOidibGszNCcsJ1xcdTI1QTEnOidzcXUnLCdcXHUyNUFBJzonc3F1ZicsJ1xcdTI1QUInOidFbXB0eVZlcnlTbWFsbFNxdWFyZScsJ1xcdTI1QUQnOidyZWN0JywnXFx1MjVBRSc6J21hcmtlcicsJ1xcdTI1QjEnOidmbHRucycsJ1xcdTI1QjMnOid4dXRyaScsJ1xcdTI1QjQnOid1dHJpZicsJ1xcdTI1QjUnOid1dHJpJywnXFx1MjVCOCc6J3J0cmlmJywnXFx1MjVCOSc6J3J0cmknLCdcXHUyNUJEJzoneGR0cmknLCdcXHUyNUJFJzonZHRyaWYnLCdcXHUyNUJGJzonZHRyaScsJ1xcdTI1QzInOidsdHJpZicsJ1xcdTI1QzMnOidsdHJpJywnXFx1MjVDQSc6J2xveicsJ1xcdTI1Q0InOidjaXInLCdcXHUyNUVDJzondHJpZG90JywnXFx1MjVFRic6J3hjaXJjJywnXFx1MjVGOCc6J3VsdHJpJywnXFx1MjVGOSc6J3VydHJpJywnXFx1MjVGQSc6J2xsdHJpJywnXFx1MjVGQic6J0VtcHR5U21hbGxTcXVhcmUnLCdcXHUyNUZDJzonRmlsbGVkU21hbGxTcXVhcmUnLCdcXHUyNjA1Jzonc3RhcmYnLCdcXHUyNjA2Jzonc3RhcicsJ1xcdTI2MEUnOidwaG9uZScsJ1xcdTI2NDAnOidmZW1hbGUnLCdcXHUyNjQyJzonbWFsZScsJ1xcdTI2NjAnOidzcGFkZXMnLCdcXHUyNjYzJzonY2x1YnMnLCdcXHUyNjY1JzonaGVhcnRzJywnXFx1MjY2Nic6J2RpYW1zJywnXFx1MjY2QSc6J3N1bmcnLCdcXHUyNzEzJzonY2hlY2snLCdcXHUyNzE3JzonY3Jvc3MnLCdcXHUyNzIwJzonbWFsdCcsJ1xcdTI3MzYnOidzZXh0JywnXFx1Mjc1OCc6J1ZlcnRpY2FsU2VwYXJhdG9yJywnXFx1MjdDOCc6J2Jzb2xoc3ViJywnXFx1MjdDOSc6J3N1cGhzb2wnLCdcXHUyN0Y1JzoneGxhcnInLCdcXHUyN0Y2JzoneHJhcnInLCdcXHUyN0Y3JzoneGhhcnInLCdcXHUyN0Y4JzoneGxBcnInLCdcXHUyN0Y5JzoneHJBcnInLCdcXHUyN0ZBJzoneGhBcnInLCdcXHUyN0ZDJzoneG1hcCcsJ1xcdTI3RkYnOidkemlncmFycicsJ1xcdTI5MDInOidudmxBcnInLCdcXHUyOTAzJzonbnZyQXJyJywnXFx1MjkwNCc6J252SGFycicsJ1xcdTI5MDUnOidNYXAnLCdcXHUyOTBDJzonbGJhcnInLCdcXHUyOTBEJzoncmJhcnInLCdcXHUyOTBFJzonbEJhcnInLCdcXHUyOTBGJzonckJhcnInLCdcXHUyOTEwJzonUkJhcnInLCdcXHUyOTExJzonRERvdHJhaGQnLCdcXHUyOTEyJzonVXBBcnJvd0JhcicsJ1xcdTI5MTMnOidEb3duQXJyb3dCYXInLCdcXHUyOTE2JzonUmFycnRsJywnXFx1MjkxOSc6J2xhdGFpbCcsJ1xcdTI5MUEnOidyYXRhaWwnLCdcXHUyOTFCJzonbEF0YWlsJywnXFx1MjkxQyc6J3JBdGFpbCcsJ1xcdTI5MUQnOidsYXJyZnMnLCdcXHUyOTFFJzoncmFycmZzJywnXFx1MjkxRic6J2xhcnJiZnMnLCdcXHUyOTIwJzoncmFycmJmcycsJ1xcdTI5MjMnOidud2FyaGsnLCdcXHUyOTI0JzonbmVhcmhrJywnXFx1MjkyNSc6J3NlYXJoaycsJ1xcdTI5MjYnOidzd2FyaGsnLCdcXHUyOTI3JzonbnduZWFyJywnXFx1MjkyOCc6J3RvZWEnLCdcXHUyOTI5JzondG9zYScsJ1xcdTI5MkEnOidzd253YXInLCdcXHUyOTMzJzoncmFycmMnLCdcXHUyOTMzXFx1MDMzOCc6J25yYXJyYycsJ1xcdTI5MzUnOidjdWRhcnJyJywnXFx1MjkzNic6J2xkY2EnLCdcXHUyOTM3JzoncmRjYScsJ1xcdTI5MzgnOidjdWRhcnJsJywnXFx1MjkzOSc6J2xhcnJwbCcsJ1xcdTI5M0MnOidjdXJhcnJtJywnXFx1MjkzRCc6J2N1bGFycnAnLCdcXHUyOTQ1JzoncmFycnBsJywnXFx1Mjk0OCc6J2hhcnJjaXInLCdcXHUyOTQ5JzonVWFycm9jaXInLCdcXHUyOTRBJzonbHVyZHNoYXInLCdcXHUyOTRCJzonbGRydXNoYXInLCdcXHUyOTRFJzonTGVmdFJpZ2h0VmVjdG9yJywnXFx1Mjk0Ric6J1JpZ2h0VXBEb3duVmVjdG9yJywnXFx1Mjk1MCc6J0Rvd25MZWZ0UmlnaHRWZWN0b3InLCdcXHUyOTUxJzonTGVmdFVwRG93blZlY3RvcicsJ1xcdTI5NTInOidMZWZ0VmVjdG9yQmFyJywnXFx1Mjk1Myc6J1JpZ2h0VmVjdG9yQmFyJywnXFx1Mjk1NCc6J1JpZ2h0VXBWZWN0b3JCYXInLCdcXHUyOTU1JzonUmlnaHREb3duVmVjdG9yQmFyJywnXFx1Mjk1Nic6J0Rvd25MZWZ0VmVjdG9yQmFyJywnXFx1Mjk1Nyc6J0Rvd25SaWdodFZlY3RvckJhcicsJ1xcdTI5NTgnOidMZWZ0VXBWZWN0b3JCYXInLCdcXHUyOTU5JzonTGVmdERvd25WZWN0b3JCYXInLCdcXHUyOTVBJzonTGVmdFRlZVZlY3RvcicsJ1xcdTI5NUInOidSaWdodFRlZVZlY3RvcicsJ1xcdTI5NUMnOidSaWdodFVwVGVlVmVjdG9yJywnXFx1Mjk1RCc6J1JpZ2h0RG93blRlZVZlY3RvcicsJ1xcdTI5NUUnOidEb3duTGVmdFRlZVZlY3RvcicsJ1xcdTI5NUYnOidEb3duUmlnaHRUZWVWZWN0b3InLCdcXHUyOTYwJzonTGVmdFVwVGVlVmVjdG9yJywnXFx1Mjk2MSc6J0xlZnREb3duVGVlVmVjdG9yJywnXFx1Mjk2Mic6J2xIYXInLCdcXHUyOTYzJzondUhhcicsJ1xcdTI5NjQnOidySGFyJywnXFx1Mjk2NSc6J2RIYXInLCdcXHUyOTY2JzonbHVydWhhcicsJ1xcdTI5NjcnOidsZHJkaGFyJywnXFx1Mjk2OCc6J3J1bHVoYXInLCdcXHUyOTY5JzoncmRsZGhhcicsJ1xcdTI5NkEnOidsaGFydWwnLCdcXHUyOTZCJzonbGxoYXJkJywnXFx1Mjk2Qyc6J3JoYXJ1bCcsJ1xcdTI5NkQnOidscmhhcmQnLCdcXHUyOTZFJzondWRoYXInLCdcXHUyOTZGJzonZHVoYXInLCdcXHUyOTcwJzonUm91bmRJbXBsaWVzJywnXFx1Mjk3MSc6J2VyYXJyJywnXFx1Mjk3Mic6J3NpbXJhcnInLCdcXHUyOTczJzonbGFycnNpbScsJ1xcdTI5NzQnOidyYXJyc2ltJywnXFx1Mjk3NSc6J3JhcnJhcCcsJ1xcdTI5NzYnOidsdGxhcnInLCdcXHUyOTc4JzonZ3RyYXJyJywnXFx1Mjk3OSc6J3N1YnJhcnInLCdcXHUyOTdCJzonc3VwbGFycicsJ1xcdTI5N0MnOidsZmlzaHQnLCdcXHUyOTdEJzoncmZpc2h0JywnXFx1Mjk3RSc6J3VmaXNodCcsJ1xcdTI5N0YnOidkZmlzaHQnLCdcXHUyOTlBJzondnppZ3phZycsJ1xcdTI5OUMnOid2YW5ncnQnLCdcXHUyOTlEJzonYW5ncnR2YmQnLCdcXHUyOUE0JzonYW5nZScsJ1xcdTI5QTUnOidyYW5nZScsJ1xcdTI5QTYnOidkd2FuZ2xlJywnXFx1MjlBNyc6J3V3YW5nbGUnLCdcXHUyOUE4JzonYW5nbXNkYWEnLCdcXHUyOUE5JzonYW5nbXNkYWInLCdcXHUyOUFBJzonYW5nbXNkYWMnLCdcXHUyOUFCJzonYW5nbXNkYWQnLCdcXHUyOUFDJzonYW5nbXNkYWUnLCdcXHUyOUFEJzonYW5nbXNkYWYnLCdcXHUyOUFFJzonYW5nbXNkYWcnLCdcXHUyOUFGJzonYW5nbXNkYWgnLCdcXHUyOUIwJzonYmVtcHR5dicsJ1xcdTI5QjEnOidkZW1wdHl2JywnXFx1MjlCMic6J2NlbXB0eXYnLCdcXHUyOUIzJzoncmFlbXB0eXYnLCdcXHUyOUI0JzonbGFlbXB0eXYnLCdcXHUyOUI1Jzonb2hiYXInLCdcXHUyOUI2Jzonb21pZCcsJ1xcdTI5QjcnOidvcGFyJywnXFx1MjlCOSc6J29wZXJwJywnXFx1MjlCQic6J29sY3Jvc3MnLCdcXHUyOUJDJzonb2Rzb2xkJywnXFx1MjlCRSc6J29sY2lyJywnXFx1MjlCRic6J29mY2lyJywnXFx1MjlDMCc6J29sdCcsJ1xcdTI5QzEnOidvZ3QnLCdcXHUyOUMyJzonY2lyc2NpcicsJ1xcdTI5QzMnOidjaXJFJywnXFx1MjlDNCc6J3NvbGInLCdcXHUyOUM1JzonYnNvbGInLCdcXHUyOUM5JzonYm94Ym94JywnXFx1MjlDRCc6J3RyaXNiJywnXFx1MjlDRSc6J3J0cmlsdHJpJywnXFx1MjlDRic6J0xlZnRUcmlhbmdsZUJhcicsJ1xcdTI5Q0ZcXHUwMzM4JzonTm90TGVmdFRyaWFuZ2xlQmFyJywnXFx1MjlEMCc6J1JpZ2h0VHJpYW5nbGVCYXInLCdcXHUyOUQwXFx1MDMzOCc6J05vdFJpZ2h0VHJpYW5nbGVCYXInLCdcXHUyOURDJzonaWluZmluJywnXFx1MjlERCc6J2luZmludGllJywnXFx1MjlERSc6J252aW5maW4nLCdcXHUyOUUzJzonZXBhcnNsJywnXFx1MjlFNCc6J3NtZXBhcnNsJywnXFx1MjlFNSc6J2VxdnBhcnNsJywnXFx1MjlFQic6J2xvemYnLCdcXHUyOUY0JzonUnVsZURlbGF5ZWQnLCdcXHUyOUY2JzonZHNvbCcsJ1xcdTJBMDAnOid4b2RvdCcsJ1xcdTJBMDEnOid4b3BsdXMnLCdcXHUyQTAyJzoneG90aW1lJywnXFx1MkEwNCc6J3h1cGx1cycsJ1xcdTJBMDYnOid4c3FjdXAnLCdcXHUyQTBEJzonZnBhcnRpbnQnLCdcXHUyQTEwJzonY2lyZm5pbnQnLCdcXHUyQTExJzonYXdpbnQnLCdcXHUyQTEyJzoncnBwb2xpbnQnLCdcXHUyQTEzJzonc2Nwb2xpbnQnLCdcXHUyQTE0JzonbnBvbGludCcsJ1xcdTJBMTUnOidwb2ludGludCcsJ1xcdTJBMTYnOidxdWF0aW50JywnXFx1MkExNyc6J2ludGxhcmhrJywnXFx1MkEyMic6J3BsdXNjaXInLCdcXHUyQTIzJzoncGx1c2FjaXInLCdcXHUyQTI0Jzonc2ltcGx1cycsJ1xcdTJBMjUnOidwbHVzZHUnLCdcXHUyQTI2JzoncGx1c3NpbScsJ1xcdTJBMjcnOidwbHVzdHdvJywnXFx1MkEyOSc6J21jb21tYScsJ1xcdTJBMkEnOidtaW51c2R1JywnXFx1MkEyRCc6J2xvcGx1cycsJ1xcdTJBMkUnOidyb3BsdXMnLCdcXHUyQTJGJzonQ3Jvc3MnLCdcXHUyQTMwJzondGltZXNkJywnXFx1MkEzMSc6J3RpbWVzYmFyJywnXFx1MkEzMyc6J3NtYXNocCcsJ1xcdTJBMzQnOidsb3RpbWVzJywnXFx1MkEzNSc6J3JvdGltZXMnLCdcXHUyQTM2Jzonb3RpbWVzYXMnLCdcXHUyQTM3JzonT3RpbWVzJywnXFx1MkEzOCc6J29kaXYnLCdcXHUyQTM5JzondHJpcGx1cycsJ1xcdTJBM0EnOid0cmltaW51cycsJ1xcdTJBM0InOid0cml0aW1lJywnXFx1MkEzQyc6J2lwcm9kJywnXFx1MkEzRic6J2FtYWxnJywnXFx1MkE0MCc6J2NhcGRvdCcsJ1xcdTJBNDInOiduY3VwJywnXFx1MkE0Myc6J25jYXAnLCdcXHUyQTQ0JzonY2FwYW5kJywnXFx1MkE0NSc6J2N1cG9yJywnXFx1MkE0Nic6J2N1cGNhcCcsJ1xcdTJBNDcnOidjYXBjdXAnLCdcXHUyQTQ4JzonY3VwYnJjYXAnLCdcXHUyQTQ5JzonY2FwYnJjdXAnLCdcXHUyQTRBJzonY3VwY3VwJywnXFx1MkE0Qic6J2NhcGNhcCcsJ1xcdTJBNEMnOidjY3VwcycsJ1xcdTJBNEQnOidjY2FwcycsJ1xcdTJBNTAnOidjY3Vwc3NtJywnXFx1MkE1Myc6J0FuZCcsJ1xcdTJBNTQnOidPcicsJ1xcdTJBNTUnOidhbmRhbmQnLCdcXHUyQTU2Jzonb3JvcicsJ1xcdTJBNTcnOidvcnNsb3BlJywnXFx1MkE1OCc6J2FuZHNsb3BlJywnXFx1MkE1QSc6J2FuZHYnLCdcXHUyQTVCJzonb3J2JywnXFx1MkE1Qyc6J2FuZGQnLCdcXHUyQTVEJzonb3JkJywnXFx1MkE1Ric6J3dlZGJhcicsJ1xcdTJBNjYnOidzZG90ZScsJ1xcdTJBNkEnOidzaW1kb3QnLCdcXHUyQTZEJzonY29uZ2RvdCcsJ1xcdTJBNkRcXHUwMzM4JzonbmNvbmdkb3QnLCdcXHUyQTZFJzonZWFzdGVyJywnXFx1MkE2Ric6J2FwYWNpcicsJ1xcdTJBNzAnOidhcEUnLCdcXHUyQTcwXFx1MDMzOCc6J25hcEUnLCdcXHUyQTcxJzonZXBsdXMnLCdcXHUyQTcyJzoncGx1c2UnLCdcXHUyQTczJzonRXNpbScsJ1xcdTJBNzcnOidlRERvdCcsJ1xcdTJBNzgnOidlcXVpdkREJywnXFx1MkE3OSc6J2x0Y2lyJywnXFx1MkE3QSc6J2d0Y2lyJywnXFx1MkE3Qic6J2x0cXVlc3QnLCdcXHUyQTdDJzonZ3RxdWVzdCcsJ1xcdTJBN0QnOidsZXMnLCdcXHUyQTdEXFx1MDMzOCc6J25sZXMnLCdcXHUyQTdFJzonZ2VzJywnXFx1MkE3RVxcdTAzMzgnOiduZ2VzJywnXFx1MkE3Ric6J2xlc2RvdCcsJ1xcdTJBODAnOidnZXNkb3QnLCdcXHUyQTgxJzonbGVzZG90bycsJ1xcdTJBODInOidnZXNkb3RvJywnXFx1MkE4Myc6J2xlc2RvdG9yJywnXFx1MkE4NCc6J2dlc2RvdG9sJywnXFx1MkE4NSc6J2xhcCcsJ1xcdTJBODYnOidnYXAnLCdcXHUyQTg3JzonbG5lJywnXFx1MkE4OCc6J2duZScsJ1xcdTJBODknOidsbmFwJywnXFx1MkE4QSc6J2duYXAnLCdcXHUyQThCJzonbEVnJywnXFx1MkE4Qyc6J2dFbCcsJ1xcdTJBOEQnOidsc2ltZScsJ1xcdTJBOEUnOidnc2ltZScsJ1xcdTJBOEYnOidsc2ltZycsJ1xcdTJBOTAnOidnc2ltbCcsJ1xcdTJBOTEnOidsZ0UnLCdcXHUyQTkyJzonZ2xFJywnXFx1MkE5Myc6J2xlc2dlcycsJ1xcdTJBOTQnOidnZXNsZXMnLCdcXHUyQTk1JzonZWxzJywnXFx1MkE5Nic6J2VncycsJ1xcdTJBOTcnOidlbHNkb3QnLCdcXHUyQTk4JzonZWdzZG90JywnXFx1MkE5OSc6J2VsJywnXFx1MkE5QSc6J2VnJywnXFx1MkE5RCc6J3NpbWwnLCdcXHUyQTlFJzonc2ltZycsJ1xcdTJBOUYnOidzaW1sRScsJ1xcdTJBQTAnOidzaW1nRScsJ1xcdTJBQTEnOidMZXNzTGVzcycsJ1xcdTJBQTFcXHUwMzM4JzonTm90TmVzdGVkTGVzc0xlc3MnLCdcXHUyQUEyJzonR3JlYXRlckdyZWF0ZXInLCdcXHUyQUEyXFx1MDMzOCc6J05vdE5lc3RlZEdyZWF0ZXJHcmVhdGVyJywnXFx1MkFBNCc6J2dsaicsJ1xcdTJBQTUnOidnbGEnLCdcXHUyQUE2JzonbHRjYycsJ1xcdTJBQTcnOidndGNjJywnXFx1MkFBOCc6J2xlc2NjJywnXFx1MkFBOSc6J2dlc2NjJywnXFx1MkFBQSc6J3NtdCcsJ1xcdTJBQUInOidsYXQnLCdcXHUyQUFDJzonc210ZScsJ1xcdTJBQUNcXHVGRTAwJzonc210ZXMnLCdcXHUyQUFEJzonbGF0ZScsJ1xcdTJBQURcXHVGRTAwJzonbGF0ZXMnLCdcXHUyQUFFJzonYnVtcEUnLCdcXHUyQUFGJzoncHJlJywnXFx1MkFBRlxcdTAzMzgnOiducHJlJywnXFx1MkFCMCc6J3NjZScsJ1xcdTJBQjBcXHUwMzM4JzonbnNjZScsJ1xcdTJBQjMnOidwckUnLCdcXHUyQUI0Jzonc2NFJywnXFx1MkFCNSc6J3BybkUnLCdcXHUyQUI2Jzonc2NuRScsJ1xcdTJBQjcnOidwcmFwJywnXFx1MkFCOCc6J3NjYXAnLCdcXHUyQUI5JzoncHJuYXAnLCdcXHUyQUJBJzonc2NuYXAnLCdcXHUyQUJCJzonUHInLCdcXHUyQUJDJzonU2MnLCdcXHUyQUJEJzonc3ViZG90JywnXFx1MkFCRSc6J3N1cGRvdCcsJ1xcdTJBQkYnOidzdWJwbHVzJywnXFx1MkFDMCc6J3N1cHBsdXMnLCdcXHUyQUMxJzonc3VibXVsdCcsJ1xcdTJBQzInOidzdXBtdWx0JywnXFx1MkFDMyc6J3N1YmVkb3QnLCdcXHUyQUM0Jzonc3VwZWRvdCcsJ1xcdTJBQzUnOidzdWJFJywnXFx1MkFDNVxcdTAzMzgnOiduc3ViRScsJ1xcdTJBQzYnOidzdXBFJywnXFx1MkFDNlxcdTAzMzgnOiduc3VwRScsJ1xcdTJBQzcnOidzdWJzaW0nLCdcXHUyQUM4Jzonc3Vwc2ltJywnXFx1MkFDQlxcdUZFMDAnOid2c3VibkUnLCdcXHUyQUNCJzonc3VibkUnLCdcXHUyQUNDXFx1RkUwMCc6J3ZzdXBuRScsJ1xcdTJBQ0MnOidzdXBuRScsJ1xcdTJBQ0YnOidjc3ViJywnXFx1MkFEMCc6J2NzdXAnLCdcXHUyQUQxJzonY3N1YmUnLCdcXHUyQUQyJzonY3N1cGUnLCdcXHUyQUQzJzonc3Vic3VwJywnXFx1MkFENCc6J3N1cHN1YicsJ1xcdTJBRDUnOidzdWJzdWInLCdcXHUyQUQ2Jzonc3Vwc3VwJywnXFx1MkFENyc6J3N1cGhzdWInLCdcXHUyQUQ4Jzonc3VwZHN1YicsJ1xcdTJBRDknOidmb3JrdicsJ1xcdTJBREEnOid0b3Bmb3JrJywnXFx1MkFEQic6J21sY3AnLCdcXHUyQUU0JzonRGFzaHYnLCdcXHUyQUU2JzonVmRhc2hsJywnXFx1MkFFNyc6J0JhcnYnLCdcXHUyQUU4JzondkJhcicsJ1xcdTJBRTknOid2QmFydicsJ1xcdTJBRUInOidWYmFyJywnXFx1MkFFQyc6J05vdCcsJ1xcdTJBRUQnOidiTm90JywnXFx1MkFFRSc6J3JubWlkJywnXFx1MkFFRic6J2Npcm1pZCcsJ1xcdTJBRjAnOidtaWRjaXInLCdcXHUyQUYxJzondG9wY2lyJywnXFx1MkFGMic6J25ocGFyJywnXFx1MkFGMyc6J3BhcnNpbScsJ1xcdTJBRkQnOidwYXJzbCcsJ1xcdTJBRkRcXHUyMEU1JzonbnBhcnNsJywnXFx1MjY2RCc6J2ZsYXQnLCdcXHUyNjZFJzonbmF0dXInLCdcXHUyNjZGJzonc2hhcnAnLCdcXHhBNCc6J2N1cnJlbicsJ1xceEEyJzonY2VudCcsJyQnOidkb2xsYXInLCdcXHhBMyc6J3BvdW5kJywnXFx4QTUnOid5ZW4nLCdcXHUyMEFDJzonZXVybycsJ1xceEI5Jzonc3VwMScsJ1xceEJEJzonaGFsZicsJ1xcdTIxNTMnOidmcmFjMTMnLCdcXHhCQyc6J2ZyYWMxNCcsJ1xcdTIxNTUnOidmcmFjMTUnLCdcXHUyMTU5JzonZnJhYzE2JywnXFx1MjE1Qic6J2ZyYWMxOCcsJ1xceEIyJzonc3VwMicsJ1xcdTIxNTQnOidmcmFjMjMnLCdcXHUyMTU2JzonZnJhYzI1JywnXFx4QjMnOidzdXAzJywnXFx4QkUnOidmcmFjMzQnLCdcXHUyMTU3JzonZnJhYzM1JywnXFx1MjE1Qyc6J2ZyYWMzOCcsJ1xcdTIxNTgnOidmcmFjNDUnLCdcXHUyMTVBJzonZnJhYzU2JywnXFx1MjE1RCc6J2ZyYWM1OCcsJ1xcdTIxNUUnOidmcmFjNzgnLCdcXHVEODM1XFx1RENCNic6J2FzY3InLCdcXHVEODM1XFx1REQ1Mic6J2FvcGYnLCdcXHVEODM1XFx1REQxRSc6J2FmcicsJ1xcdUQ4MzVcXHVERDM4JzonQW9wZicsJ1xcdUQ4MzVcXHVERDA0JzonQWZyJywnXFx1RDgzNVxcdURDOUMnOidBc2NyJywnXFx4QUEnOidvcmRmJywnXFx4RTEnOidhYWN1dGUnLCdcXHhDMSc6J0FhY3V0ZScsJ1xceEUwJzonYWdyYXZlJywnXFx4QzAnOidBZ3JhdmUnLCdcXHUwMTAzJzonYWJyZXZlJywnXFx1MDEwMic6J0FicmV2ZScsJ1xceEUyJzonYWNpcmMnLCdcXHhDMic6J0FjaXJjJywnXFx4RTUnOidhcmluZycsJ1xceEM1JzonYW5nc3QnLCdcXHhFNCc6J2F1bWwnLCdcXHhDNCc6J0F1bWwnLCdcXHhFMyc6J2F0aWxkZScsJ1xceEMzJzonQXRpbGRlJywnXFx1MDEwNSc6J2FvZ29uJywnXFx1MDEwNCc6J0FvZ29uJywnXFx1MDEwMSc6J2FtYWNyJywnXFx1MDEwMCc6J0FtYWNyJywnXFx4RTYnOidhZWxpZycsJ1xceEM2JzonQUVsaWcnLCdcXHVEODM1XFx1RENCNyc6J2JzY3InLCdcXHVEODM1XFx1REQ1Myc6J2JvcGYnLCdcXHVEODM1XFx1REQxRic6J2JmcicsJ1xcdUQ4MzVcXHVERDM5JzonQm9wZicsJ1xcdTIxMkMnOidCc2NyJywnXFx1RDgzNVxcdUREMDUnOidCZnInLCdcXHVEODM1XFx1REQyMCc6J2NmcicsJ1xcdUQ4MzVcXHVEQ0I4JzonY3NjcicsJ1xcdUQ4MzVcXHVERDU0JzonY29wZicsJ1xcdTIxMkQnOidDZnInLCdcXHVEODM1XFx1REM5RSc6J0NzY3InLCdcXHUyMTAyJzonQ29wZicsJ1xcdTAxMDcnOidjYWN1dGUnLCdcXHUwMTA2JzonQ2FjdXRlJywnXFx1MDEwOSc6J2NjaXJjJywnXFx1MDEwOCc6J0NjaXJjJywnXFx1MDEwRCc6J2NjYXJvbicsJ1xcdTAxMEMnOidDY2Fyb24nLCdcXHUwMTBCJzonY2RvdCcsJ1xcdTAxMEEnOidDZG90JywnXFx4RTcnOidjY2VkaWwnLCdcXHhDNyc6J0NjZWRpbCcsJ1xcdTIxMDUnOidpbmNhcmUnLCdcXHVEODM1XFx1REQyMSc6J2RmcicsJ1xcdTIxNDYnOidkZCcsJ1xcdUQ4MzVcXHVERDU1JzonZG9wZicsJ1xcdUQ4MzVcXHVEQ0I5JzonZHNjcicsJ1xcdUQ4MzVcXHVEQzlGJzonRHNjcicsJ1xcdUQ4MzVcXHVERDA3JzonRGZyJywnXFx1MjE0NSc6J0REJywnXFx1RDgzNVxcdUREM0InOidEb3BmJywnXFx1MDEwRic6J2RjYXJvbicsJ1xcdTAxMEUnOidEY2Fyb24nLCdcXHUwMTExJzonZHN0cm9rJywnXFx1MDExMCc6J0RzdHJvaycsJ1xceEYwJzonZXRoJywnXFx4RDAnOidFVEgnLCdcXHUyMTQ3JzonZWUnLCdcXHUyMTJGJzonZXNjcicsJ1xcdUQ4MzVcXHVERDIyJzonZWZyJywnXFx1RDgzNVxcdURENTYnOidlb3BmJywnXFx1MjEzMCc6J0VzY3InLCdcXHVEODM1XFx1REQwOCc6J0VmcicsJ1xcdUQ4MzVcXHVERDNDJzonRW9wZicsJ1xceEU5JzonZWFjdXRlJywnXFx4QzknOidFYWN1dGUnLCdcXHhFOCc6J2VncmF2ZScsJ1xceEM4JzonRWdyYXZlJywnXFx4RUEnOidlY2lyYycsJ1xceENBJzonRWNpcmMnLCdcXHUwMTFCJzonZWNhcm9uJywnXFx1MDExQSc6J0VjYXJvbicsJ1xceEVCJzonZXVtbCcsJ1xceENCJzonRXVtbCcsJ1xcdTAxMTcnOidlZG90JywnXFx1MDExNic6J0Vkb3QnLCdcXHUwMTE5JzonZW9nb24nLCdcXHUwMTE4JzonRW9nb24nLCdcXHUwMTEzJzonZW1hY3InLCdcXHUwMTEyJzonRW1hY3InLCdcXHVEODM1XFx1REQyMyc6J2ZmcicsJ1xcdUQ4MzVcXHVERDU3JzonZm9wZicsJ1xcdUQ4MzVcXHVEQ0JCJzonZnNjcicsJ1xcdUQ4MzVcXHVERDA5JzonRmZyJywnXFx1RDgzNVxcdUREM0QnOidGb3BmJywnXFx1MjEzMSc6J0ZzY3InLCdcXHVGQjAwJzonZmZsaWcnLCdcXHVGQjAzJzonZmZpbGlnJywnXFx1RkIwNCc6J2ZmbGxpZycsJ1xcdUZCMDEnOidmaWxpZycsJ2ZqJzonZmpsaWcnLCdcXHVGQjAyJzonZmxsaWcnLCdcXHUwMTkyJzonZm5vZicsJ1xcdTIxMEEnOidnc2NyJywnXFx1RDgzNVxcdURENTgnOidnb3BmJywnXFx1RDgzNVxcdUREMjQnOidnZnInLCdcXHVEODM1XFx1RENBMic6J0dzY3InLCdcXHVEODM1XFx1REQzRSc6J0dvcGYnLCdcXHVEODM1XFx1REQwQSc6J0dmcicsJ1xcdTAxRjUnOidnYWN1dGUnLCdcXHUwMTFGJzonZ2JyZXZlJywnXFx1MDExRSc6J0dicmV2ZScsJ1xcdTAxMUQnOidnY2lyYycsJ1xcdTAxMUMnOidHY2lyYycsJ1xcdTAxMjEnOidnZG90JywnXFx1MDEyMCc6J0dkb3QnLCdcXHUwMTIyJzonR2NlZGlsJywnXFx1RDgzNVxcdUREMjUnOidoZnInLCdcXHUyMTBFJzoncGxhbmNraCcsJ1xcdUQ4MzVcXHVEQ0JEJzonaHNjcicsJ1xcdUQ4MzVcXHVERDU5JzonaG9wZicsJ1xcdTIxMEInOidIc2NyJywnXFx1MjEwQyc6J0hmcicsJ1xcdTIxMEQnOidIb3BmJywnXFx1MDEyNSc6J2hjaXJjJywnXFx1MDEyNCc6J0hjaXJjJywnXFx1MjEwRic6J2hiYXInLCdcXHUwMTI3JzonaHN0cm9rJywnXFx1MDEyNic6J0hzdHJvaycsJ1xcdUQ4MzVcXHVERDVBJzonaW9wZicsJ1xcdUQ4MzVcXHVERDI2JzonaWZyJywnXFx1RDgzNVxcdURDQkUnOidpc2NyJywnXFx1MjE0OCc6J2lpJywnXFx1RDgzNVxcdURENDAnOidJb3BmJywnXFx1MjExMCc6J0lzY3InLCdcXHUyMTExJzonSW0nLCdcXHhFRCc6J2lhY3V0ZScsJ1xceENEJzonSWFjdXRlJywnXFx4RUMnOidpZ3JhdmUnLCdcXHhDQyc6J0lncmF2ZScsJ1xceEVFJzonaWNpcmMnLCdcXHhDRSc6J0ljaXJjJywnXFx4RUYnOidpdW1sJywnXFx4Q0YnOidJdW1sJywnXFx1MDEyOSc6J2l0aWxkZScsJ1xcdTAxMjgnOidJdGlsZGUnLCdcXHUwMTMwJzonSWRvdCcsJ1xcdTAxMkYnOidpb2dvbicsJ1xcdTAxMkUnOidJb2dvbicsJ1xcdTAxMkInOidpbWFjcicsJ1xcdTAxMkEnOidJbWFjcicsJ1xcdTAxMzMnOidpamxpZycsJ1xcdTAxMzInOidJSmxpZycsJ1xcdTAxMzEnOidpbWF0aCcsJ1xcdUQ4MzVcXHVEQ0JGJzonanNjcicsJ1xcdUQ4MzVcXHVERDVCJzonam9wZicsJ1xcdUQ4MzVcXHVERDI3JzonamZyJywnXFx1RDgzNVxcdURDQTUnOidKc2NyJywnXFx1RDgzNVxcdUREMEQnOidKZnInLCdcXHVEODM1XFx1REQ0MSc6J0pvcGYnLCdcXHUwMTM1JzonamNpcmMnLCdcXHUwMTM0JzonSmNpcmMnLCdcXHUwMjM3Jzonam1hdGgnLCdcXHVEODM1XFx1REQ1Qyc6J2tvcGYnLCdcXHVEODM1XFx1RENDMCc6J2tzY3InLCdcXHVEODM1XFx1REQyOCc6J2tmcicsJ1xcdUQ4MzVcXHVEQ0E2JzonS3NjcicsJ1xcdUQ4MzVcXHVERDQyJzonS29wZicsJ1xcdUQ4MzVcXHVERDBFJzonS2ZyJywnXFx1MDEzNyc6J2tjZWRpbCcsJ1xcdTAxMzYnOidLY2VkaWwnLCdcXHVEODM1XFx1REQyOSc6J2xmcicsJ1xcdUQ4MzVcXHVEQ0MxJzonbHNjcicsJ1xcdTIxMTMnOidlbGwnLCdcXHVEODM1XFx1REQ1RCc6J2xvcGYnLCdcXHUyMTEyJzonTHNjcicsJ1xcdUQ4MzVcXHVERDBGJzonTGZyJywnXFx1RDgzNVxcdURENDMnOidMb3BmJywnXFx1MDEzQSc6J2xhY3V0ZScsJ1xcdTAxMzknOidMYWN1dGUnLCdcXHUwMTNFJzonbGNhcm9uJywnXFx1MDEzRCc6J0xjYXJvbicsJ1xcdTAxM0MnOidsY2VkaWwnLCdcXHUwMTNCJzonTGNlZGlsJywnXFx1MDE0Mic6J2xzdHJvaycsJ1xcdTAxNDEnOidMc3Ryb2snLCdcXHUwMTQwJzonbG1pZG90JywnXFx1MDEzRic6J0xtaWRvdCcsJ1xcdUQ4MzVcXHVERDJBJzonbWZyJywnXFx1RDgzNVxcdURENUUnOidtb3BmJywnXFx1RDgzNVxcdURDQzInOidtc2NyJywnXFx1RDgzNVxcdUREMTAnOidNZnInLCdcXHVEODM1XFx1REQ0NCc6J01vcGYnLCdcXHUyMTMzJzonTXNjcicsJ1xcdUQ4MzVcXHVERDJCJzonbmZyJywnXFx1RDgzNVxcdURENUYnOidub3BmJywnXFx1RDgzNVxcdURDQzMnOiduc2NyJywnXFx1MjExNSc6J05vcGYnLCdcXHVEODM1XFx1RENBOSc6J05zY3InLCdcXHVEODM1XFx1REQxMSc6J05mcicsJ1xcdTAxNDQnOiduYWN1dGUnLCdcXHUwMTQzJzonTmFjdXRlJywnXFx1MDE0OCc6J25jYXJvbicsJ1xcdTAxNDcnOidOY2Fyb24nLCdcXHhGMSc6J250aWxkZScsJ1xceEQxJzonTnRpbGRlJywnXFx1MDE0Nic6J25jZWRpbCcsJ1xcdTAxNDUnOidOY2VkaWwnLCdcXHUyMTE2JzonbnVtZXJvJywnXFx1MDE0Qic6J2VuZycsJ1xcdTAxNEEnOidFTkcnLCdcXHVEODM1XFx1REQ2MCc6J29vcGYnLCdcXHVEODM1XFx1REQyQyc6J29mcicsJ1xcdTIxMzQnOidvc2NyJywnXFx1RDgzNVxcdURDQUEnOidPc2NyJywnXFx1RDgzNVxcdUREMTInOidPZnInLCdcXHVEODM1XFx1REQ0Nic6J09vcGYnLCdcXHhCQSc6J29yZG0nLCdcXHhGMyc6J29hY3V0ZScsJ1xceEQzJzonT2FjdXRlJywnXFx4RjInOidvZ3JhdmUnLCdcXHhEMic6J09ncmF2ZScsJ1xceEY0Jzonb2NpcmMnLCdcXHhENCc6J09jaXJjJywnXFx4RjYnOidvdW1sJywnXFx4RDYnOidPdW1sJywnXFx1MDE1MSc6J29kYmxhYycsJ1xcdTAxNTAnOidPZGJsYWMnLCdcXHhGNSc6J290aWxkZScsJ1xceEQ1JzonT3RpbGRlJywnXFx4RjgnOidvc2xhc2gnLCdcXHhEOCc6J09zbGFzaCcsJ1xcdTAxNEQnOidvbWFjcicsJ1xcdTAxNEMnOidPbWFjcicsJ1xcdTAxNTMnOidvZWxpZycsJ1xcdTAxNTInOidPRWxpZycsJ1xcdUQ4MzVcXHVERDJEJzoncGZyJywnXFx1RDgzNVxcdURDQzUnOidwc2NyJywnXFx1RDgzNVxcdURENjEnOidwb3BmJywnXFx1MjExOSc6J1BvcGYnLCdcXHVEODM1XFx1REQxMyc6J1BmcicsJ1xcdUQ4MzVcXHVEQ0FCJzonUHNjcicsJ1xcdUQ4MzVcXHVERDYyJzoncW9wZicsJ1xcdUQ4MzVcXHVERDJFJzoncWZyJywnXFx1RDgzNVxcdURDQzYnOidxc2NyJywnXFx1RDgzNVxcdURDQUMnOidRc2NyJywnXFx1RDgzNVxcdUREMTQnOidRZnInLCdcXHUyMTFBJzonUW9wZicsJ1xcdTAxMzgnOidrZ3JlZW4nLCdcXHVEODM1XFx1REQyRic6J3JmcicsJ1xcdUQ4MzVcXHVERDYzJzoncm9wZicsJ1xcdUQ4MzVcXHVEQ0M3JzoncnNjcicsJ1xcdTIxMUInOidSc2NyJywnXFx1MjExQyc6J1JlJywnXFx1MjExRCc6J1JvcGYnLCdcXHUwMTU1JzoncmFjdXRlJywnXFx1MDE1NCc6J1JhY3V0ZScsJ1xcdTAxNTknOidyY2Fyb24nLCdcXHUwMTU4JzonUmNhcm9uJywnXFx1MDE1Nyc6J3JjZWRpbCcsJ1xcdTAxNTYnOidSY2VkaWwnLCdcXHVEODM1XFx1REQ2NCc6J3NvcGYnLCdcXHVEODM1XFx1RENDOCc6J3NzY3InLCdcXHVEODM1XFx1REQzMCc6J3NmcicsJ1xcdUQ4MzVcXHVERDRBJzonU29wZicsJ1xcdUQ4MzVcXHVERDE2JzonU2ZyJywnXFx1RDgzNVxcdURDQUUnOidTc2NyJywnXFx1MjRDOCc6J29TJywnXFx1MDE1Qic6J3NhY3V0ZScsJ1xcdTAxNUEnOidTYWN1dGUnLCdcXHUwMTVEJzonc2NpcmMnLCdcXHUwMTVDJzonU2NpcmMnLCdcXHUwMTYxJzonc2Nhcm9uJywnXFx1MDE2MCc6J1NjYXJvbicsJ1xcdTAxNUYnOidzY2VkaWwnLCdcXHUwMTVFJzonU2NlZGlsJywnXFx4REYnOidzemxpZycsJ1xcdUQ4MzVcXHVERDMxJzondGZyJywnXFx1RDgzNVxcdURDQzknOid0c2NyJywnXFx1RDgzNVxcdURENjUnOid0b3BmJywnXFx1RDgzNVxcdURDQUYnOidUc2NyJywnXFx1RDgzNVxcdUREMTcnOidUZnInLCdcXHVEODM1XFx1REQ0Qic6J1RvcGYnLCdcXHUwMTY1JzondGNhcm9uJywnXFx1MDE2NCc6J1RjYXJvbicsJ1xcdTAxNjMnOid0Y2VkaWwnLCdcXHUwMTYyJzonVGNlZGlsJywnXFx1MjEyMic6J3RyYWRlJywnXFx1MDE2Nyc6J3RzdHJvaycsJ1xcdTAxNjYnOidUc3Ryb2snLCdcXHVEODM1XFx1RENDQSc6J3VzY3InLCdcXHVEODM1XFx1REQ2Nic6J3VvcGYnLCdcXHVEODM1XFx1REQzMic6J3VmcicsJ1xcdUQ4MzVcXHVERDRDJzonVW9wZicsJ1xcdUQ4MzVcXHVERDE4JzonVWZyJywnXFx1RDgzNVxcdURDQjAnOidVc2NyJywnXFx4RkEnOid1YWN1dGUnLCdcXHhEQSc6J1VhY3V0ZScsJ1xceEY5JzondWdyYXZlJywnXFx4RDknOidVZ3JhdmUnLCdcXHUwMTZEJzondWJyZXZlJywnXFx1MDE2Qyc6J1VicmV2ZScsJ1xceEZCJzondWNpcmMnLCdcXHhEQic6J1VjaXJjJywnXFx1MDE2Ric6J3VyaW5nJywnXFx1MDE2RSc6J1VyaW5nJywnXFx4RkMnOid1dW1sJywnXFx4REMnOidVdW1sJywnXFx1MDE3MSc6J3VkYmxhYycsJ1xcdTAxNzAnOidVZGJsYWMnLCdcXHUwMTY5JzondXRpbGRlJywnXFx1MDE2OCc6J1V0aWxkZScsJ1xcdTAxNzMnOid1b2dvbicsJ1xcdTAxNzInOidVb2dvbicsJ1xcdTAxNkInOid1bWFjcicsJ1xcdTAxNkEnOidVbWFjcicsJ1xcdUQ4MzVcXHVERDMzJzondmZyJywnXFx1RDgzNVxcdURENjcnOid2b3BmJywnXFx1RDgzNVxcdURDQ0InOid2c2NyJywnXFx1RDgzNVxcdUREMTknOidWZnInLCdcXHVEODM1XFx1REQ0RCc6J1ZvcGYnLCdcXHVEODM1XFx1RENCMSc6J1ZzY3InLCdcXHVEODM1XFx1REQ2OCc6J3dvcGYnLCdcXHVEODM1XFx1RENDQyc6J3dzY3InLCdcXHVEODM1XFx1REQzNCc6J3dmcicsJ1xcdUQ4MzVcXHVEQ0IyJzonV3NjcicsJ1xcdUQ4MzVcXHVERDRFJzonV29wZicsJ1xcdUQ4MzVcXHVERDFBJzonV2ZyJywnXFx1MDE3NSc6J3djaXJjJywnXFx1MDE3NCc6J1djaXJjJywnXFx1RDgzNVxcdUREMzUnOid4ZnInLCdcXHVEODM1XFx1RENDRCc6J3hzY3InLCdcXHVEODM1XFx1REQ2OSc6J3hvcGYnLCdcXHVEODM1XFx1REQ0Ric6J1hvcGYnLCdcXHVEODM1XFx1REQxQic6J1hmcicsJ1xcdUQ4MzVcXHVEQ0IzJzonWHNjcicsJ1xcdUQ4MzVcXHVERDM2JzoneWZyJywnXFx1RDgzNVxcdURDQ0UnOid5c2NyJywnXFx1RDgzNVxcdURENkEnOid5b3BmJywnXFx1RDgzNVxcdURDQjQnOidZc2NyJywnXFx1RDgzNVxcdUREMUMnOidZZnInLCdcXHVEODM1XFx1REQ1MCc6J1lvcGYnLCdcXHhGRCc6J3lhY3V0ZScsJ1xceEREJzonWWFjdXRlJywnXFx1MDE3Nyc6J3ljaXJjJywnXFx1MDE3Nic6J1ljaXJjJywnXFx4RkYnOid5dW1sJywnXFx1MDE3OCc6J1l1bWwnLCdcXHVEODM1XFx1RENDRic6J3pzY3InLCdcXHVEODM1XFx1REQzNyc6J3pmcicsJ1xcdUQ4MzVcXHVERDZCJzonem9wZicsJ1xcdTIxMjgnOidaZnInLCdcXHUyMTI0JzonWm9wZicsJ1xcdUQ4MzVcXHVEQ0I1JzonWnNjcicsJ1xcdTAxN0EnOid6YWN1dGUnLCdcXHUwMTc5JzonWmFjdXRlJywnXFx1MDE3RSc6J3pjYXJvbicsJ1xcdTAxN0QnOidaY2Fyb24nLCdcXHUwMTdDJzonemRvdCcsJ1xcdTAxN0InOidaZG90JywnXFx1MDFCNSc6J2ltcGVkJywnXFx4RkUnOid0aG9ybicsJ1xceERFJzonVEhPUk4nLCdcXHUwMTQ5JzonbmFwb3MnLCdcXHUwM0IxJzonYWxwaGEnLCdcXHUwMzkxJzonQWxwaGEnLCdcXHUwM0IyJzonYmV0YScsJ1xcdTAzOTInOidCZXRhJywnXFx1MDNCMyc6J2dhbW1hJywnXFx1MDM5Myc6J0dhbW1hJywnXFx1MDNCNCc6J2RlbHRhJywnXFx1MDM5NCc6J0RlbHRhJywnXFx1MDNCNSc6J2Vwc2knLCdcXHUwM0Y1JzonZXBzaXYnLCdcXHUwMzk1JzonRXBzaWxvbicsJ1xcdTAzREQnOidnYW1tYWQnLCdcXHUwM0RDJzonR2FtbWFkJywnXFx1MDNCNic6J3pldGEnLCdcXHUwMzk2JzonWmV0YScsJ1xcdTAzQjcnOidldGEnLCdcXHUwMzk3JzonRXRhJywnXFx1MDNCOCc6J3RoZXRhJywnXFx1MDNEMSc6J3RoZXRhdicsJ1xcdTAzOTgnOidUaGV0YScsJ1xcdTAzQjknOidpb3RhJywnXFx1MDM5OSc6J0lvdGEnLCdcXHUwM0JBJzona2FwcGEnLCdcXHUwM0YwJzona2FwcGF2JywnXFx1MDM5QSc6J0thcHBhJywnXFx1MDNCQic6J2xhbWJkYScsJ1xcdTAzOUInOidMYW1iZGEnLCdcXHUwM0JDJzonbXUnLCdcXHhCNSc6J21pY3JvJywnXFx1MDM5Qyc6J011JywnXFx1MDNCRCc6J251JywnXFx1MDM5RCc6J051JywnXFx1MDNCRSc6J3hpJywnXFx1MDM5RSc6J1hpJywnXFx1MDNCRic6J29taWNyb24nLCdcXHUwMzlGJzonT21pY3JvbicsJ1xcdTAzQzAnOidwaScsJ1xcdTAzRDYnOidwaXYnLCdcXHUwM0EwJzonUGknLCdcXHUwM0MxJzoncmhvJywnXFx1MDNGMSc6J3Job3YnLCdcXHUwM0ExJzonUmhvJywnXFx1MDNDMyc6J3NpZ21hJywnXFx1MDNBMyc6J1NpZ21hJywnXFx1MDNDMic6J3NpZ21hZicsJ1xcdTAzQzQnOid0YXUnLCdcXHUwM0E0JzonVGF1JywnXFx1MDNDNSc6J3Vwc2knLCdcXHUwM0E1JzonVXBzaWxvbicsJ1xcdTAzRDInOidVcHNpJywnXFx1MDNDNic6J3BoaScsJ1xcdTAzRDUnOidwaGl2JywnXFx1MDNBNic6J1BoaScsJ1xcdTAzQzcnOidjaGknLCdcXHUwM0E3JzonQ2hpJywnXFx1MDNDOCc6J3BzaScsJ1xcdTAzQTgnOidQc2knLCdcXHUwM0M5Jzonb21lZ2EnLCdcXHUwM0E5Jzonb2htJywnXFx1MDQzMCc6J2FjeScsJ1xcdTA0MTAnOidBY3knLCdcXHUwNDMxJzonYmN5JywnXFx1MDQxMSc6J0JjeScsJ1xcdTA0MzInOid2Y3knLCdcXHUwNDEyJzonVmN5JywnXFx1MDQzMyc6J2djeScsJ1xcdTA0MTMnOidHY3knLCdcXHUwNDUzJzonZ2pjeScsJ1xcdTA0MDMnOidHSmN5JywnXFx1MDQzNCc6J2RjeScsJ1xcdTA0MTQnOidEY3knLCdcXHUwNDUyJzonZGpjeScsJ1xcdTA0MDInOidESmN5JywnXFx1MDQzNSc6J2llY3knLCdcXHUwNDE1JzonSUVjeScsJ1xcdTA0NTEnOidpb2N5JywnXFx1MDQwMSc6J0lPY3knLCdcXHUwNDU0JzonanVrY3knLCdcXHUwNDA0JzonSnVrY3knLCdcXHUwNDM2JzonemhjeScsJ1xcdTA0MTYnOidaSGN5JywnXFx1MDQzNyc6J3pjeScsJ1xcdTA0MTcnOidaY3knLCdcXHUwNDU1JzonZHNjeScsJ1xcdTA0MDUnOidEU2N5JywnXFx1MDQzOCc6J2ljeScsJ1xcdTA0MTgnOidJY3knLCdcXHUwNDU2JzonaXVrY3knLCdcXHUwNDA2JzonSXVrY3knLCdcXHUwNDU3JzoneWljeScsJ1xcdTA0MDcnOidZSWN5JywnXFx1MDQzOSc6J2pjeScsJ1xcdTA0MTknOidKY3knLCdcXHUwNDU4JzonanNlcmN5JywnXFx1MDQwOCc6J0pzZXJjeScsJ1xcdTA0M0EnOidrY3knLCdcXHUwNDFBJzonS2N5JywnXFx1MDQ1Qyc6J2tqY3knLCdcXHUwNDBDJzonS0pjeScsJ1xcdTA0M0InOidsY3knLCdcXHUwNDFCJzonTGN5JywnXFx1MDQ1OSc6J2xqY3knLCdcXHUwNDA5JzonTEpjeScsJ1xcdTA0M0MnOidtY3knLCdcXHUwNDFDJzonTWN5JywnXFx1MDQzRCc6J25jeScsJ1xcdTA0MUQnOidOY3knLCdcXHUwNDVBJzonbmpjeScsJ1xcdTA0MEEnOidOSmN5JywnXFx1MDQzRSc6J29jeScsJ1xcdTA0MUUnOidPY3knLCdcXHUwNDNGJzoncGN5JywnXFx1MDQxRic6J1BjeScsJ1xcdTA0NDAnOidyY3knLCdcXHUwNDIwJzonUmN5JywnXFx1MDQ0MSc6J3NjeScsJ1xcdTA0MjEnOidTY3knLCdcXHUwNDQyJzondGN5JywnXFx1MDQyMic6J1RjeScsJ1xcdTA0NUInOid0c2hjeScsJ1xcdTA0MEInOidUU0hjeScsJ1xcdTA0NDMnOid1Y3knLCdcXHUwNDIzJzonVWN5JywnXFx1MDQ1RSc6J3VicmN5JywnXFx1MDQwRSc6J1VicmN5JywnXFx1MDQ0NCc6J2ZjeScsJ1xcdTA0MjQnOidGY3knLCdcXHUwNDQ1Jzona2hjeScsJ1xcdTA0MjUnOidLSGN5JywnXFx1MDQ0Nic6J3RzY3knLCdcXHUwNDI2JzonVFNjeScsJ1xcdTA0NDcnOidjaGN5JywnXFx1MDQyNyc6J0NIY3knLCdcXHUwNDVGJzonZHpjeScsJ1xcdTA0MEYnOidEWmN5JywnXFx1MDQ0OCc6J3NoY3knLCdcXHUwNDI4JzonU0hjeScsJ1xcdTA0NDknOidzaGNoY3knLCdcXHUwNDI5JzonU0hDSGN5JywnXFx1MDQ0QSc6J2hhcmRjeScsJ1xcdTA0MkEnOidIQVJEY3knLCdcXHUwNDRCJzoneWN5JywnXFx1MDQyQic6J1ljeScsJ1xcdTA0NEMnOidzb2Z0Y3knLCdcXHUwNDJDJzonU09GVGN5JywnXFx1MDQ0RCc6J2VjeScsJ1xcdTA0MkQnOidFY3knLCdcXHUwNDRFJzoneXVjeScsJ1xcdTA0MkUnOidZVWN5JywnXFx1MDQ0Ric6J3lhY3knLCdcXHUwNDJGJzonWUFjeScsJ1xcdTIxMzUnOidhbGVwaCcsJ1xcdTIxMzYnOidiZXRoJywnXFx1MjEzNyc6J2dpbWVsJywnXFx1MjEzOCc6J2RhbGV0aCd9O1xuXG5cdHZhciByZWdleEVzY2FwZSA9IC9bXCImJzw+YF0vZztcblx0dmFyIGVzY2FwZU1hcCA9IHtcblx0XHQnXCInOiAnJnF1b3Q7Jyxcblx0XHQnJic6ICcmYW1wOycsXG5cdFx0J1xcJyc6ICcmI3gyNzsnLFxuXHRcdCc8JzogJyZsdDsnLFxuXHRcdC8vIFNlZSBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHM6IGluIEhUTUwsIHRoZVxuXHRcdC8vIGZvbGxvd2luZyBpcyBub3Qgc3RyaWN0bHkgbmVjZXNzYXJ5IHVubGVzcyBpdOKAmXMgcGFydCBvZiBhIHRhZyBvciBhblxuXHRcdC8vIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS4gV2XigJlyZSBvbmx5IGVzY2FwaW5nIGl0IHRvIHN1cHBvcnQgdGhvc2Vcblx0XHQvLyBzaXR1YXRpb25zLCBhbmQgZm9yIFhNTCBzdXBwb3J0LlxuXHRcdCc+JzogJyZndDsnLFxuXHRcdC8vIEluIEludGVybmV0IEV4cGxvcmVyIOKJpCA4LCB0aGUgYmFja3RpY2sgY2hhcmFjdGVyIGNhbiBiZSB1c2VkXG5cdFx0Ly8gdG8gYnJlYWsgb3V0IG9mICh1bilxdW90ZWQgYXR0cmlidXRlIHZhbHVlcyBvciBIVE1MIGNvbW1lbnRzLlxuXHRcdC8vIFNlZSBodHRwOi8vaHRtbDVzZWMub3JnLyMxMDIsIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwOCwgYW5kXG5cdFx0Ly8gaHR0cDovL2h0bWw1c2VjLm9yZy8jMTMzLlxuXHRcdCdgJzogJyYjeDYwOydcblx0fTtcblxuXHR2YXIgcmVnZXhJbnZhbGlkRW50aXR5ID0gLyYjKD86W3hYXVteYS1mQS1GMC05XXxbXjAtOXhYXSkvO1xuXHR2YXIgcmVnZXhJbnZhbGlkUmF3Q29kZVBvaW50ID0gL1tcXDAtXFx4MDhcXHgwQlxceDBFLVxceDFGXFx4N0YtXFx4OUZcXHVGREQwLVxcdUZERUZcXHVGRkZFXFx1RkZGRl18W1xcdUQ4M0ZcXHVEODdGXFx1RDhCRlxcdUQ4RkZcXHVEOTNGXFx1RDk3RlxcdUQ5QkZcXHVEOUZGXFx1REEzRlxcdURBN0ZcXHVEQUJGXFx1REFGRlxcdURCM0ZcXHVEQjdGXFx1REJCRlxcdURCRkZdW1xcdURGRkVcXHVERkZGXXxbXFx1RDgwMC1cXHVEQkZGXSg/IVtcXHVEQzAwLVxcdURGRkZdKXwoPzpbXlxcdUQ4MDAtXFx1REJGRl18XilbXFx1REMwMC1cXHVERkZGXS87XG5cdHZhciByZWdleERlY29kZSA9IC8mKENvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWx8RG91YmxlTG9uZ0xlZnRSaWdodEFycm93fENsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbHxOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcnxOb3RTcXVhcmVTdXBlcnNldEVxdWFsfERpYWNyaXRpY2FsRG91YmxlQWN1dGV8Tm90UmlnaHRUcmlhbmdsZUVxdWFsfE5vdFN1Y2NlZWRzU2xhbnRFcXVhbHxOb3RQcmVjZWRlc1NsYW50RXF1YWx8Q2xvc2VDdXJseURvdWJsZVF1b3RlfE5lZ2F0aXZlVmVyeVRoaW5TcGFjZXxEb3VibGVDb250b3VySW50ZWdyYWx8RmlsbGVkVmVyeVNtYWxsU3F1YXJlfENhcGl0YWxEaWZmZXJlbnRpYWxEfE9wZW5DdXJseURvdWJsZVF1b3RlfEVtcHR5VmVyeVNtYWxsU3F1YXJlfE5lc3RlZEdyZWF0ZXJHcmVhdGVyfERvdWJsZUxvbmdSaWdodEFycm93fE5vdExlZnRUcmlhbmdsZUVxdWFsfE5vdEdyZWF0ZXJTbGFudEVxdWFsfFJldmVyc2VVcEVxdWlsaWJyaXVtfERvdWJsZUxlZnRSaWdodEFycm93fE5vdFNxdWFyZVN1YnNldEVxdWFsfE5vdERvdWJsZVZlcnRpY2FsQmFyfFJpZ2h0QXJyb3dMZWZ0QXJyb3d8Tm90R3JlYXRlckZ1bGxFcXVhbHxOb3RSaWdodFRyaWFuZ2xlQmFyfFNxdWFyZVN1cGVyc2V0RXF1YWx8RG93bkxlZnRSaWdodFZlY3RvcnxEb3VibGVMb25nTGVmdEFycm93fGxlZnRyaWdodHNxdWlnYXJyb3d8TGVmdEFycm93UmlnaHRBcnJvd3xOZWdhdGl2ZU1lZGl1bVNwYWNlfGJsYWNrdHJpYW5nbGVyaWdodHxSaWdodERvd25WZWN0b3JCYXJ8UHJlY2VkZXNTbGFudEVxdWFsfFJpZ2h0RG91YmxlQnJhY2tldHxTdWNjZWVkc1NsYW50RXF1YWx8Tm90TGVmdFRyaWFuZ2xlQmFyfFJpZ2h0VHJpYW5nbGVFcXVhbHxTcXVhcmVJbnRlcnNlY3Rpb258UmlnaHREb3duVGVlVmVjdG9yfFJldmVyc2VFcXVpbGlicml1bXxOZWdhdGl2ZVRoaWNrU3BhY2V8bG9uZ2xlZnRyaWdodGFycm93fExvbmdsZWZ0cmlnaHRhcnJvd3xMb25nTGVmdFJpZ2h0QXJyb3d8RG93blJpZ2h0VGVlVmVjdG9yfERvd25SaWdodFZlY3RvckJhcnxHcmVhdGVyU2xhbnRFcXVhbHxTcXVhcmVTdWJzZXRFcXVhbHxMZWZ0RG93blZlY3RvckJhcnxMZWZ0RG91YmxlQnJhY2tldHxWZXJ0aWNhbFNlcGFyYXRvcnxyaWdodGxlZnRoYXJwb29uc3xOb3RHcmVhdGVyR3JlYXRlcnxOb3RTcXVhcmVTdXBlcnNldHxibGFja3RyaWFuZ2xlbGVmdHxibGFja3RyaWFuZ2xlZG93bnxOZWdhdGl2ZVRoaW5TcGFjZXxMZWZ0RG93blRlZVZlY3RvcnxOb3RMZXNzU2xhbnRFcXVhbHxsZWZ0cmlnaHRoYXJwb29uc3xEb3VibGVVcERvd25BcnJvd3xEb3VibGVWZXJ0aWNhbEJhcnxMZWZ0VHJpYW5nbGVFcXVhbHxGaWxsZWRTbWFsbFNxdWFyZXx0d29oZWFkcmlnaHRhcnJvd3xOb3ROZXN0ZWRMZXNzTGVzc3xEb3duTGVmdFRlZVZlY3RvcnxEb3duTGVmdFZlY3RvckJhcnxSaWdodEFuZ2xlQnJhY2tldHxOb3RUaWxkZUZ1bGxFcXVhbHxOb3RSZXZlcnNlRWxlbWVudHxSaWdodFVwRG93blZlY3RvcnxEaWFjcml0aWNhbFRpbGRlfE5vdFN1Y2NlZWRzVGlsZGV8Y2lyY2xlYXJyb3dyaWdodHxOb3RQcmVjZWRlc0VxdWFsfHJpZ2h0aGFycG9vbmRvd258RG91YmxlUmlnaHRBcnJvd3xOb3RTdWNjZWVkc0VxdWFsfE5vbkJyZWFraW5nU3BhY2V8Tm90UmlnaHRUcmlhbmdsZXxMZXNzRXF1YWxHcmVhdGVyfFJpZ2h0VXBUZWVWZWN0b3J8TGVmdEFuZ2xlQnJhY2tldHxHcmVhdGVyRnVsbEVxdWFsfERvd25BcnJvd1VwQXJyb3d8UmlnaHRVcFZlY3RvckJhcnx0d29oZWFkbGVmdGFycm93fEdyZWF0ZXJFcXVhbExlc3N8ZG93bmhhcnBvb25yaWdodHxSaWdodFRyaWFuZ2xlQmFyfG50cmlhbmdsZXJpZ2h0ZXF8Tm90U3VwZXJzZXRFcXVhbHxMZWZ0VXBEb3duVmVjdG9yfERpYWNyaXRpY2FsQWN1dGV8cmlnaHRyaWdodGFycm93c3x2YXJ0cmlhbmdsZXJpZ2h0fFVwQXJyb3dEb3duQXJyb3d8RGlhY3JpdGljYWxHcmF2ZXxVbmRlclBhcmVudGhlc2lzfEVtcHR5U21hbGxTcXVhcmV8TGVmdFVwVmVjdG9yQmFyfGxlZnRyaWdodGFycm93c3xEb3duUmlnaHRWZWN0b3J8ZG93bmhhcnBvb25sZWZ0fHRyaWFuZ2xlcmlnaHRlcXxTaG9ydFJpZ2h0QXJyb3d8T3ZlclBhcmVudGhlc2lzfERvdWJsZUxlZnRBcnJvd3xEb3VibGVEb3duQXJyb3d8Tm90U3F1YXJlU3Vic2V0fGJpZ3RyaWFuZ2xlZG93bnxudHJpYW5nbGVsZWZ0ZXF8VXBwZXJSaWdodEFycm93fGN1cnZlYXJyb3dyaWdodHx2YXJ0cmlhbmdsZWxlZnR8Tm90TGVmdFRyaWFuZ2xlfG5sZWZ0cmlnaHRhcnJvd3xMb3dlclJpZ2h0QXJyb3d8Tm90SHVtcERvd25IdW1wfE5vdEdyZWF0ZXJUaWxkZXxyaWdodHRocmVldGltZXN8TGVmdFVwVGVlVmVjdG9yfE5vdEdyZWF0ZXJFcXVhbHxzdHJhaWdodGVwc2lsb258TGVmdFRyaWFuZ2xlQmFyfHJpZ2h0c3F1aWdhcnJvd3xDb250b3VySW50ZWdyYWx8cmlnaHRsZWZ0YXJyb3dzfENsb3NlQ3VybHlRdW90ZXxSaWdodERvd25WZWN0b3J8TGVmdFJpZ2h0VmVjdG9yfG5MZWZ0cmlnaHRhcnJvd3xsZWZ0aGFycG9vbmRvd258Y2lyY2xlYXJyb3dsZWZ0fFNxdWFyZVN1cGVyc2V0fE9wZW5DdXJseVF1b3RlfGhvb2tyaWdodGFycm93fEhvcml6b250YWxMaW5lfERpYWNyaXRpY2FsRG90fE5vdExlc3NHcmVhdGVyfG50cmlhbmdsZXJpZ2h0fERvdWJsZVJpZ2h0VGVlfEludmlzaWJsZUNvbW1hfEludmlzaWJsZVRpbWVzfExvd2VyTGVmdEFycm93fERvd25MZWZ0VmVjdG9yfE5vdFN1YnNldEVxdWFsfGN1cnZlYXJyb3dsZWZ0fHRyaWFuZ2xlbGVmdGVxfE5vdFZlcnRpY2FsQmFyfFRpbGRlRnVsbEVxdWFsfGRvd25kb3duYXJyb3dzfE5vdEdyZWF0ZXJMZXNzfFJpZ2h0VGVlVmVjdG9yfFplcm9XaWR0aFNwYWNlfGxvb3BhcnJvd3JpZ2h0fExvbmdSaWdodEFycm93fGRvdWJsZWJhcndlZGdlfFNob3J0TGVmdEFycm93fFNob3J0RG93bkFycm93fFJpZ2h0VmVjdG9yQmFyfEdyZWF0ZXJHcmVhdGVyfFJldmVyc2VFbGVtZW50fHJpZ2h0aGFycG9vbnVwfExlc3NTbGFudEVxdWFsfGxlZnR0aHJlZXRpbWVzfHVwaGFycG9vbnJpZ2h0fHJpZ2h0YXJyb3d0YWlsfExlZnREb3duVmVjdG9yfExvbmdyaWdodGFycm93fE5lc3RlZExlc3NMZXNzfFVwcGVyTGVmdEFycm93fG5zaG9ydHBhcmFsbGVsfGxlZnRsZWZ0YXJyb3dzfGxlZnRyaWdodGFycm93fExlZnRyaWdodGFycm93fExlZnRSaWdodEFycm93fGxvbmdyaWdodGFycm93fHVwaGFycG9vbmxlZnR8UmlnaHRBcnJvd0JhcnxBcHBseUZ1bmN0aW9ufExlZnRUZWVWZWN0b3J8bGVmdGFycm93dGFpbHxOb3RFcXVhbFRpbGRlfHZhcnN1YnNldG5lcXF8dmFyc3Vwc2V0bmVxcXxSaWdodFRlZUFycm93fFN1Y2NlZWRzRXF1YWx8U3VjY2VlZHNUaWxkZXxMZWZ0VmVjdG9yQmFyfFN1cGVyc2V0RXF1YWx8aG9va2xlZnRhcnJvd3xEaWZmZXJlbnRpYWxEfFZlcnRpY2FsVGlsZGV8VmVyeVRoaW5TcGFjZXxibGFja3RyaWFuZ2xlfGJpZ3RyaWFuZ2xldXB8TGVzc0Z1bGxFcXVhbHxkaXZpZGVvbnRpbWVzfGxlZnRoYXJwb29udXB8VXBFcXVpbGlicml1bXxudHJpYW5nbGVsZWZ0fFJpZ2h0VHJpYW5nbGV8bWVhc3VyZWRhbmdsZXxzaG9ydHBhcmFsbGVsfGxvbmdsZWZ0YXJyb3d8TG9uZ2xlZnRhcnJvd3xMb25nTGVmdEFycm93fERvdWJsZUxlZnRUZWV8UG9pbmNhcmVwbGFuZXxQcmVjZWRlc0VxdWFsfHRyaWFuZ2xlcmlnaHR8RG91YmxlVXBBcnJvd3xSaWdodFVwVmVjdG9yfGZhbGxpbmdkb3RzZXF8bG9vcGFycm93bGVmdHxQcmVjZWRlc1RpbGRlfE5vdFRpbGRlRXF1YWx8Tm90VGlsZGVUaWxkZXxzbWFsbHNldG1pbnVzfFByb3BvcnRpb25hbHx0cmlhbmdsZWxlZnR8dHJpYW5nbGVkb3dufFVuZGVyQnJhY2tldHxOb3RIdW1wRXF1YWx8ZXhwb25lbnRpYWxlfEV4cG9uZW50aWFsRXxOb3RMZXNzVGlsZGV8SGlsYmVydFNwYWNlfFJpZ2h0Q2VpbGluZ3xibGFja2xvemVuZ2V8dmFyc3Vwc2V0bmVxfEh1bXBEb3duSHVtcHxHcmVhdGVyRXF1YWx8VmVydGljYWxMaW5lfExlZnRUZWVBcnJvd3xOb3RMZXNzRXF1YWx8RG93blRlZUFycm93fExlZnRUcmlhbmdsZXx2YXJzdWJzZXRuZXF8SW50ZXJzZWN0aW9ufE5vdENvbmdydWVudHxEb3duQXJyb3dCYXJ8TGVmdFVwVmVjdG9yfExlZnRBcnJvd0JhcnxyaXNpbmdkb3RzZXF8R3JlYXRlclRpbGRlfFJvdW5kSW1wbGllc3xTcXVhcmVTdWJzZXR8U2hvcnRVcEFycm93fE5vdFN1cGVyc2V0fHF1YXRlcm5pb25zfHByZWNuYXBwcm94fGJhY2tlcHNpbG9ufHByZWNjdXJseWVxfE92ZXJCcmFja2V0fGJsYWNrc3F1YXJlfE1lZGl1bVNwYWNlfFZlcnRpY2FsQmFyfGNpcmNsZWRjaXJjfGNpcmNsZWRkYXNofENpcmNsZU1pbnVzfENpcmNsZVRpbWVzfExlc3NHcmVhdGVyfGN1cmx5ZXFwcmVjfGN1cmx5ZXFzdWNjfGRpYW1vbmRzdWl0fFVwRG93bkFycm93fFVwZG93bmFycm93fFJ1bGVEZWxheWVkfFJyaWdodGFycm93fHVwZG93bmFycm93fFJpZ2h0VmVjdG9yfG5SaWdodGFycm93fG5yaWdodGFycm93fGVxc2xhbnRsZXNzfExlZnRDZWlsaW5nfEVxdWlsaWJyaXVtfFNtYWxsQ2lyY2xlfGV4cGVjdGF0aW9ufE5vdFN1Y2NlZWRzfHRoaWNrYXBwcm94fEdyZWF0ZXJMZXNzfFNxdWFyZVVuaW9ufE5vdFByZWNlZGVzfE5vdExlc3NMZXNzfHN0cmFpZ2h0cGhpfHN1Y2NuYXBwcm94fHN1Y2NjdXJseWVxfFN1YnNldEVxdWFsfHNxc3Vwc2V0ZXF8UHJvcG9ydGlvbnxMYXBsYWNldHJmfEltYWdpbmFyeUl8c3Vwc2V0bmVxcXxOb3RHcmVhdGVyfGd0cmVxcWxlc3N8Tm90RWxlbWVudHxUaGlja1NwYWNlfFRpbGRlRXF1YWx8VGlsZGVUaWxkZXxGb3VyaWVydHJmfHJtb3VzdGFjaGV8RXF1YWxUaWxkZXxlcXNsYW50Z3RyfFVuZGVyQnJhY2V8TGVmdFZlY3RvcnxVcEFycm93QmFyfG5MZWZ0YXJyb3d8bnN1YnNldGVxcXxzdWJzZXRuZXFxfG5zdXBzZXRlcXF8bmxlZnRhcnJvd3xzdWNjYXBwcm94fGxlc3NhcHByb3h8VXBUZWVBcnJvd3x1cHVwYXJyb3dzfGN1cmx5d2VkZ2V8bGVzc2VxcWd0cnx2YXJlcHNpbG9ufHZhcm5vdGhpbmd8UmlnaHRGbG9vcnxjb21wbGVtZW50fENpcmNsZVBsdXN8c3FzdWJzZXRlcXxMbGVmdGFycm93fGNpcmNsZWRhc3R8UmlnaHRBcnJvd3xSaWdodGFycm93fHJpZ2h0YXJyb3d8bG1vdXN0YWNoZXxCZXJub3VsbGlzfHByZWNhcHByb3h8bWFwc3RvbGVmdHxtYXBzdG9kb3dufGxvbmdtYXBzdG98ZG90c3F1YXJlfGRvd25hcnJvd3xEb3VibGVEb3R8bnN1YnNldGVxfHN1cHNldG5lcXxsZWZ0YXJyb3d8bnN1cHNldGVxfHN1YnNldG5lcXxUaGluU3BhY2V8bmdlcXNsYW50fHN1YnNldGVxcXxIdW1wRXF1YWx8Tm90U3Vic2V0fHRyaWFuZ2xlcXxOb3RDdXBDYXB8bGVzc2VxZ3RyfGhlYXJ0c3VpdHxUcmlwbGVEb3R8TGVmdGFycm93fENvcHJvZHVjdHxDb25ncnVlbnR8dmFycHJvcHRvfGNvbXBsZXhlc3xndmVydG5lcXF8TGVmdEFycm93fExlc3NUaWxkZXxzdXBzZXRlcXF8TWludXNQbHVzfENpcmNsZURvdHxubGVxc2xhbnR8Tm90RXhpc3RzfGd0cmVxbGVzc3xucGFyYWxsZWx8VW5pb25QbHVzfExlZnRGbG9vcnxjaGVja21hcmt8Q2VudGVyRG90fGNlbnRlcmRvdHxNZWxsaW50cmZ8Z3RyYXBwcm94fGJpZ290aW1lc3xPdmVyQnJhY2V8c3BhZGVzdWl0fHRoZXJlZm9yZXxwaXRjaGZvcmt8cmF0aW9uYWxzfFBsdXNNaW51c3xCYWNrc2xhc2h8VGhlcmVmb3JlfERvd25CcmV2ZXxiYWNrc2ltZXF8YmFja3ByaW1lfERvd25BcnJvd3xuc2hvcnRtaWR8RG93bmFycm93fGx2ZXJ0bmVxcXxlcXZwYXJzbHxpbWFnbGluZXxpbWFncGFydHxpbmZpbnRpZXxpbnRlZ2Vyc3xJbnRlZ3JhbHxpbnRlcmNhbHxMZXNzTGVzc3xVYXJyb2NpcnxpbnRsYXJoa3xzcXN1cHNldHxhbmdtc2RhZnxzcXN1YnNldHxsbGNvcm5lcnx2YXJ0aGV0YXxjdXBicmNhcHxsbmFwcHJveHxTdXBlcnNldHxTdWNoVGhhdHxzdWNjbnNpbXxzdWNjbmVxcXxhbmdtc2RhZ3xiaWd1cGx1c3xjdXJseXZlZXx0cnBleml1bXxTdWNjZWVkc3xOb3RUaWxkZXxiaWd3ZWRnZXxhbmdtc2RhaHxhbmdydHZiZHx0cmltaW51c3xjd2NvbmludHxmcGFydGludHxscmNvcm5lcnxzbWVwYXJzbHxzdWJzZXRlcXx1cmNvcm5lcnxsdXJkc2hhcnxsYWVtcHR5dnxERG90cmFoZHxhcHByb3hlcXxsZHJ1c2hhcnxhd2NvbmludHxtYXBzdG91cHxiYWNrY29uZ3xzaG9ydG1pZHx0cmlhbmdsZXxnZXFzbGFudHxnZXNkb3RvbHx0aW1lc2JhcnxjaXJjbGVkUnxjaXJjbGVkU3xzZXRtaW51c3xtdWx0aW1hcHxuYXR1cmFsc3xzY3BvbGludHxuY29uZ2RvdHxSaWdodFRlZXxib3htaW51c3xnbmFwcHJveHxib3h0aW1lc3xhbmRzbG9wZXx0aGlja3NpbXxhbmdtc2RhYXx2YXJzaWdtYXxjaXJmbmludHxydHJpbHRyaXxhbmdtc2RhYnxycHBvbGludHxhbmdtc2RhY3xiYXJ3ZWRnZXxkcmJrYXJvd3xjbHVic3VpdHx0aGV0YXN5bXxic29saHN1YnxjYXBicmN1cHxkemlncmFycnxkb3RlcWRvdHxEb3RFcXVhbHxkb3RtaW51c3xVbmRlckJhcnxOb3RFcXVhbHxyZWFscGFydHxvdGltZXNhc3x1bGNvcm5lcnxoa3NlYXJvd3xoa3N3YXJvd3xwYXJhbGxlbHxQYXJ0aWFsRHxlbGludGVyc3xlbXB0eXNldHxwbHVzYWNpcnxiYnJrdGJya3xhbmdtc2RhZHxwb2ludGludHxiaWdvcGx1c3xhbmdtc2RhZXxQcmVjZWRlc3xiaWdzcWN1cHx2YXJrYXBwYXxub3RpbmRvdHxzdXBzZXRlcXxwcmVjbmVxcXxwcmVjbnNpbXxwcm9mYWxhcnxwcm9mbGluZXxwcm9mc3VyZnxsZXFzbGFudHxsZXNkb3RvcnxyYWVtcHR5dnxzdWJwbHVzfG5vdG5pdmJ8bm90bml2Y3xzdWJyYXJyfHppZ3JhcnJ8dnppZ3phZ3xzdWJtdWx0fHN1YmVkb3R8RWxlbWVudHxiZXR3ZWVufGNpcnNjaXJ8bGFycmJmc3xsYXJyc2ltfGxvdGltZXN8bGJya3NsZHxsYnJrc2x1fGxvemVuZ2V8bGRyZGhhcnxkYmthcm93fGJpZ2NpcmN8ZXBzaWxvbnxzaW1yYXJyfHNpbXBsdXN8bHRxdWVzdHxFcHNpbG9ufGx1cnVoYXJ8Z3RxdWVzdHxtYWx0ZXNlfG5wb2xpbnR8ZXFjb2xvbnxucHJlY2VxfGJpZ29kb3R8ZGRhZ2dlcnxndHJsZXNzfGJuZXF1aXZ8aGFycmNpcnxkZG90c2VxfGVxdWl2RER8YmFja3NpbXxkZW1wdHl2fG5zcXN1YmV8bnNxc3VwZXxVcHNpbG9ufG5zdWJzZXR8dXBzaWxvbnxtaW51c2R1fG5zdWNjZXF8c3dhcnJvd3xuc3Vwc2V0fGNvbG9uZXF8c2VhcnJvd3xib3hwbHVzfG5hcHByb3h8bmF0dXJhbHxhc3ltcGVxfGFsZWZzeW18Y29uZ2RvdHxuZWFycm93fGJpZ3N0YXJ8ZGlhbW9uZHxzdXBwbHVzfHRyaXRpbWV8TGVmdFRlZXxudmluZmlufHRyaXBsdXN8TmV3TGluZXxudmx0cmllfG52cnRyaWV8bndhcnJvd3xuZXhpc3RzfERpYW1vbmR8cnVsdWhhcnxJbXBsaWVzfHN1cG11bHR8YW5nemFycnxzdXBsYXJyfHN1cGhzdWJ8cXVlc3RlcXxiZWNhdXNlfGRpZ2FtbWF8QmVjYXVzZXxvbGNyb3NzfGJlbXB0eXZ8b21pY3JvbnxPbWljcm9ufHJvdGltZXN8Tm9CcmVha3xpbnRwcm9kfGFuZ3J0dmJ8b3JkZXJvZnx1d2FuZ2xlfHN1cGhzb2x8bGVzZG90b3xvcnNsb3BlfERvd25UZWV8cmVhbGluZXxjdWRhcnJsfHJkbGRoYXJ8T3ZlckJhcnxzdXBlZG90fGxlc3Nkb3R8c3VwZHN1Ynx0b3Bmb3JrfHN1Y2NzaW18cmJya3NsdXxyYnJrc2xkfHBlcnRlbmt8Y3VkYXJycnxpc2luZG90fHBsYW5ja2h8bGVzc2d0cnxwbHVzY2lyfGdlc2RvdG98cGx1c3NpbXxwbHVzdHdvfGxlc3NzaW18Y3VsYXJycHxyYXJyc2ltfENheWxleXN8bm90aW52YXxub3RpbnZifG5vdGludmN8VXBBcnJvd3xVcGFycm93fHVwYXJyb3d8Tm90TGVzc3xkd2FuZ2xlfHByZWNzaW18UHJvZHVjdHxjdXJhcnJtfENjb25pbnR8ZG90cGx1c3xyYXJyYmZzfGNjdXBzc218Q2VkaWxsYXxjZW1wdHl2fG5vdG5pdmF8cXVhdGludHxmcmFjMzV8ZnJhYzM4fGZyYWM0NXxmcmFjNTZ8ZnJhYzU4fGZyYWM3OHx0cmlkb3R8eG9wbHVzfGdhY3V0ZXxnYW1tYWR8R2FtbWFkfGxmaXNodHxsZmxvb3J8YmlnY3VwfHNxc3VwZXxnYnJldmV8R2JyZXZlfGxoYXJ1bHxzcXN1YmV8c3FjdXBzfEdjZWRpbHxhcGFjaXJ8bGxoYXJkfGxtaWRvdHxMbWlkb3R8bG1vdXN0fGFuZGFuZHxzcWNhcHN8YXBwcm94fEFicmV2ZXxzcGFkZXN8Y2lyY2VxfHRwcmltZXxkaXZpZGV8dG9wY2lyfEFzc2lnbnx0b3Bib3R8Z2VzZG90fGRpdm9ueHx4dXBsdXN8dGltZXNkfGdlc2xlc3xhdGlsZGV8c29sYmFyfFNPRlRjeXxsb3BsdXN8dGltZXNifGxvd2FzdHxsb3diYXJ8ZGxjb3JufGRsY3JvcHxzb2Z0Y3l8ZG9sbGFyfGxwYXJsdHx0aGtzaW18bHJoYXJkfEF0aWxkZXxsc2FxdW98c21hc2hwfGJpZ3ZlZXx0aGluc3B8d3JlYXRofGJrYXJvd3xsc3F1b3J8bHN0cm9rfExzdHJva3xsdGhyZWV8bHRpbWVzfGx0bGFycnxEb3REb3R8c2ltZG90fGx0clBhcnx3ZWllcnB8eHNxY3VwfGFuZ21zZHxzaWdtYXZ8c2lnbWFmfHplZXRyZnxaY2Fyb258emNhcm9ufG1hcHN0b3x2c3VwbmV8dGhldGF2fGNpcm1pZHxtYXJrZXJ8bWNvbW1hfFphY3V0ZXx2c3VibkV8dGhlcmU0fGd0bFBhcnx2c3VibmV8Ym90dG9tfGd0cmFycnxTSENIY3l8c2hjaGN5fG1pZGFzdHxtaWRjaXJ8bWlkZG90fG1pbnVzYnxtaW51c2R8Z3RyZG90fGJvd3RpZXxzZnJvd258bW5wbHVzfG1vZGVsc3xjb2xvbmV8c2Vzd2FyfENvbG9uZXxtc3Rwb3N8c2VhcmhrfGd0cnNpbXxuYWN1dGV8TmFjdXRlfGJveGJveHx0ZWxyZWN8aGFpcnNwfFRjZWRpbHxuYnVtcGV8c2Nuc2ltfG5jYXJvbnxOY2Fyb258bmNlZGlsfE5jZWRpbHxoYW1pbHR8U2NlZGlsfG5lYXJoa3xoYXJkY3l8SEFSRGN5fHRjZWRpbHxUY2Fyb258Y29tbWF0fG5lcXVpdnxuZXNlYXJ8dGNhcm9ufHRhcmdldHxoZWFydHN8bmV4aXN0fHZhcnJob3xzY2VkaWx8U2Nhcm9ufHNjYXJvbnxoZWxsaXB8U2FjdXRlfHNhY3V0ZXxoZXJjb258c3dud2FyfGNvbXBmbnxydGltZXN8cnRocmVlfHJzcXVvcnxyc2FxdW98emFjdXRlfHdlZGdlcXxob210aHR8YmFydmVlfGJhcndlZHxCYXJ3ZWR8cnBhcmd0fGhvcmJhcnxjb25pbnR8c3dhcmhrfHJvcGx1c3xubHRyaWV8aHNsYXNofGhzdHJva3xIc3Ryb2t8cm1vdXN0fENvbmludHxicHJpbWV8aHlidWxsfGh5cGhlbnxpYWN1dGV8SWFjdXRlfHN1cHN1cHxzdXBzdWJ8c3Vwc2ltfHZhcnBoaXxjb3Byb2R8YnJ2YmFyfGFncmF2ZXxTdXBzZXR8c3Vwc2V0fGlncmF2ZXxJZ3JhdmV8bm90aW5FfEFncmF2ZXxpaWlpbnR8aWluZmlufGNvcHlzcnx3ZWRiYXJ8VmVyYmFyfHZhbmdydHxiZWNhdXN8aW5jYXJlfHZlcmJhcnxpbm9kb3R8YnVsbGV0fGRyY29ybnxpbnRjYWx8ZHJjcm9wfGN1bGFycnx2ZWxsaXB8VXRpbGRlfGJ1bXBlcXxjdXBjYXB8ZHN0cm9rfERzdHJva3xDdXBDYXB8Y3VwY3VwfGN1cGRvdHxlYWN1dGV8RWFjdXRlfHN1cGRvdHxpcXVlc3R8ZWFzdGVyfGVjYXJvbnxFY2Fyb258ZWNvbG9ufGlzaW5zdnx1dGlsZGV8aXRpbGRlfEl0aWxkZXxjdXJhcnJ8c3VjY2VxfEJ1bXBlcXxjYWN1dGV8dWxjcm9wfG5wYXJzbHxDYWN1dGV8bnByY3VlfGVncmF2ZXxFZ3JhdmV8bnJhcnJjfG5yYXJyd3xzdWJzdXB8c3Vic3VifG5ydHJpZXxqc2VyY3l8bnNjY3VlfEpzZXJjeXxrYXBwYXZ8a2NlZGlsfEtjZWRpbHxzdWJzaW18dWxjb3JufG5zaW1lcXxlZ3Nkb3R8dmVlYmFyfGtncmVlbnxjYXBhbmR8ZWxzZG90fFN1YnNldHxzdWJzZXR8Y3VycmVufGFhY3V0ZXxsYWN1dGV8TGFjdXRlfGVtcHR5dnxudGlsZGV8TnRpbGRlfGxhZ3JhbnxsYW1iZGF8TGFtYmRhfGNhcGNhcHxVZ3JhdmV8bGFuZ2xlfHN1YmRvdHxlbXNwMTN8bnVtZXJvfGVtc3AxNHxudmRhc2h8bnZEYXNofG5WZGFzaHxuVkRhc2h8dWdyYXZlfHVmaXNodHxudkhhcnJ8bGFycmZzfG52bEFycnxsYXJyaGt8bGFycmxwfGxhcnJwbHxudnJBcnJ8VWRibGFjfG53YXJoa3xsYXJydGx8bnduZWFyfG9hY3V0ZXxPYWN1dGV8bGF0YWlsfGxBdGFpbHxzc3RhcmZ8bGJyYWNlfG9kYmxhY3xPZGJsYWN8bGJyYWNrfHVkYmxhY3xvZHNvbGR8ZXBhcnNsfGxjYXJvbnxMY2Fyb258b2dyYXZlfE9ncmF2ZXxsY2VkaWx8TGNlZGlsfEFhY3V0ZXxzc21pbGV8c3NldG1ufHNxdWFyZnxsZHF1b3J8Y2FwY3VwfG9taW51c3xjeWxjdHl8cmhhcnVsfGVxY2lyY3xkYWdnZXJ8cmZsb29yfHJmaXNodHxEYWdnZXJ8ZGFsZXRofGVxdWFsc3xvcmlnb2Z8Y2FwZG90fGVxdWVzdHxkY2Fyb258RGNhcm9ufHJkcXVvcnxvc2xhc2h8T3NsYXNofG90aWxkZXxPdGlsZGV8b3RpbWVzfE90aW1lc3x1cmNyb3B8VWJyZXZlfHVicmV2ZXxZYWN1dGV8VWFjdXRlfHVhY3V0ZXxSY2VkaWx8cmNlZGlsfHVyY29ybnxwYXJzaW18UmNhcm9ufFZkYXNobHxyY2Fyb258VHN0cm9rfHBlcmNudHxwZXJpb2R8cGVybWlsfEV4aXN0c3x5YWN1dGV8cmJyYWNrfHJicmFjZXxwaG1tYXR8Y2Nhcm9ufENjYXJvbnxwbGFuY2t8Y2NlZGlsfHBsYW5rdnx0c3Ryb2t8ZmVtYWxlfHBsdXNkb3xwbHVzZHV8ZmZpbGlnfHBsdXNtbnxmZmxsaWd8Q2NlZGlsfHJBdGFpbHxkZmlzaHR8YmVybm91fHJhdGFpbHxSYXJydGx8cmFycnRsfGFuZ3NwaHxyYXJycGx8cmFycmxwfHJhcnJoa3x4d2VkZ2V8eG90aW1lfGZvcmFsbHxGb3JBbGx8VnZkYXNofHZzdXBuRXxwcmVjZXF8YmlnY2FwfGZyYWMxMnxmcmFjMTN8ZnJhYzE0fHByaW1lc3xyYXJyZnN8cHJuc2ltfGZyYWMxNXxTcXVhcmV8ZnJhYzE2fHNxdWFyZXxsZXNkb3R8ZnJhYzE4fGZyYWMyM3xwcm9wdG98cHJ1cmVsfHJhcnJhcHxyYW5nbGV8cHVuY3NwfGZyYWMyNXxSYWN1dGV8cXByaW1lfHJhY3V0ZXxsZXNnZXN8ZnJhYzM0fGFicmV2ZXxBRWxpZ3xlcXNpbXx1dGRvdHxzZXRtbnx1cnRyaXxFcXVhbHxVcmluZ3xzZUFycnx1cmluZ3xzZWFycnxkYXNodnxEYXNodnxtdW1hcHxuYWJsYXxpb2dvbnxJb2dvbnxzZG90ZXxzZG90YnxzY3NpbXxuYXBpZHxuYXBvc3xlcXVpdnxuYXR1cnxBY2lyY3xkYmxhY3xlcmFycnxuYnVtcHxpcHJvZHxlckRvdHx1Y2lyY3xhd2ludHxlc2RvdHxhbmdydHxuY29uZ3xpc2luRXxzY25hcHxTY2lyY3xzY2lyY3xuZGFzaHxpc2luc3xVYnJjeXxuZWFycnxuZUFycnxpc2ludnxuZWRvdHx1YnJjeXxhY3V0ZXxZY2lyY3xpdWtjeXxJdWtjeXx4dXRyaXxuZXNpbXxjYXJldHxqY2lyY3xKY2lyY3xjYXJvbnx0d2l4dHxkZGFycnxzY2N1ZXxleGlzdHxqbWF0aHxzYnF1b3xuZ2VxcXxhbmdzdHxjY2Fwc3xsY2VpbHxuZ3NpbXxVcFRlZXxkZWx0YXxEZWx0YXxydHJpZnxuaGFycnxuaEFycnxuaHBhcnxydHJpZXxqdWtjeXxKdWtjeXxrYXBwYXxyc3F1b3xLYXBwYXxubGFycnxubEFycnxUU0hjeXxycmFycnxhb2dvbnxBb2dvbnxmZmxpZ3x4cmFycnx0c2hjeXxjY2lyY3xubGVxcXxmaWxpZ3x1cHNpaHxubGVzc3xkaGFybHxubHNpbXxmamxpZ3xyb3BhcnxubHRyaXxkaGFycnxyb2Jya3xyb2FycnxmbGxpZ3xmbHRuc3xyb2FuZ3xybm1pZHxzdWJuRXxzdWJuZXxsQWFycnx0cmlzYnxDY2lyY3xhY2lyY3xjY3Vwc3xibGFua3xWRGFzaHxmb3JrdnxWZGFzaHxsYW5nZHxjZWRpbHxibGsxMnxibGsxNHxsYXF1b3xzdHJuc3xkaWFtc3xub3Rpbnx2RGFzaHxsYXJyYnxibGszNHxibG9ja3xkaXNpbnx1cGx1c3x2ZGFzaHx2QmFydnxhZWxpZ3xzdGFyZnxXZWRnZXxjaGVja3x4ckFycnxsYXRlc3xsYmFycnxsQmFycnxub3RuaXxsYmJya3xiY29uZ3xmcmFzbHxsYnJrZXxmcm93bnx2cnRyaXx2cHJvcHx2bnN1cHxnYW1tYXxHYW1tYXx3ZWRnZXx4b2RvdHxiZHF1b3xzcmFycnxkb3RlcXxsZHF1b3xib3hkbHxib3hkTHxnY2lyY3xHY2lyY3xib3hEbHxib3hETHxib3hkcnxib3hkUnxib3hEcnxUUkFERXx0cmFkZXxybGhhcnxib3hEUnx2bnN1YnxucGFydHx2bHRyaXxybGFycnxib3hoZHxib3hoRHxucHJlY3xnZXNjY3xucmFycnxuckFycnxib3hIZHxib3hIRHxib3hodXxib3hoVXxucnRyaXxib3hIdXxjbHVic3xib3hIVXx0aW1lc3xjb2xvbnxDb2xvbnxnaW1lbHx4bEFycnxUaWxkZXxuc2ltZXx0aWxkZXxuc21pZHxuc3BhcnxUSE9STnx0aG9ybnx4bGFycnxuc3ViZXxuc3ViRXx0aGthcHx4aEFycnxjb21tYXxuc3VjY3xib3h1bHxib3h1THxuc3VwZXxuc3VwRXxnbmVxcXxnbnNpbXxib3hVbHxib3hVTHxncmF2ZXxib3h1cnxib3h1Unxib3hVcnxib3hVUnxsZXNjY3xhbmdsZXxiZXBzaXxib3h2aHx2YXJwaXxib3h2SHxudW1zcHxUaGV0YXxnc2ltZXxnc2ltbHx0aGV0YXxib3hWaHxib3hWSHxib3h2bHxndGNpcnxndGRvdHxib3h2THxib3hWbHxib3hWTHxjcmFycnxjcm9zc3xDcm9zc3xudnNpbXxib3h2cnxud2Fycnxud0FycnxzcXN1cHxkdGRvdHxVb2dvbnxsaGFyZHxsaGFydXxkdHJpZnxvY2lyY3xPY2lyY3xsaGJsa3xkdWFycnxvZGFzaHxzcXN1YnxIYWNla3xzcWN1cHxsbGFycnxkdWhhcnxvZWxpZ3xPRWxpZ3xvZmNpcnxib3h2Unx1b2dvbnxsbHRyaXxib3hWcnxjc3ViZXx1dWFycnxvaGJhcnxjc3VwZXxjdGRvdHxvbGFycnxvbGNpcnxoYXJyd3xvbGluZXxzcWNhcHxvbWFjcnxPbWFjcnxvbWVnYXxPbWVnYXxib3hWUnxhbGVwaHxsbmVxcXxsbnNpbXxsb2FuZ3xsb2FycnxyaGFydXxsb2Jya3xoY2lyY3xvcGVycHxvcGx1c3xyaGFyZHxIY2lyY3xvcmFycnxVbmlvbnxvcmRlcnxlY2lyY3xFY2lyY3xjdWVwcnxzemxpZ3xjdWVzY3xicmV2ZXxyZWFsc3xlRERvdHxCcmV2ZXxob2Fycnxsb3Bhcnx1dHJpZnxyZHF1b3xVbWFjcnx1bWFjcnxlZkRvdHxzd0Fycnx1bHRyaXxhbHBoYXxyY2VpbHxvdmJhcnxzd2FycnxXY2lyY3x3Y2lyY3xzbXRlc3xzbWlsZXxic2VtaXxscmFycnxhcmluZ3xwYXJzbHxscmhhcnxic2ltZXx1aGJsa3xscnRyaXxjdXBvcnxBcmluZ3x1aGFycnx1aGFybHxzbGFycnxyYnJrZXxic29sYnxsc2ltZXxyYmJya3xSQmFycnxsc2ltZ3xwaG9uZXxyQmFycnxyYmFycnxpY2lyY3xsc3F1b3xJY2lyY3xlbWFjcnxFbWFjcnxyYXRpb3xzaW1uZXxwbHVzYnxzaW1sRXxzaW1nRXxzaW1lcXxwbHVzZXxsdGNpcnxsdGRvdHxlbXB0eXx4aGFycnx4ZHRyaXxpZXhjbHxBbHBoYXxsdHJpZXxyYXJyd3xwb3VuZHxsdHJpZnx4Y2lyY3xidW1wZXxwcmN1ZXxidW1wRXxhc3ltcHxhbWFjcnxjdXZlZXxTaWdtYXxzaWdtYXxpaWludHx1ZGhhcnxpaW90YXxpamxpZ3xJSmxpZ3xzdXBuRXxpbWFjcnxJbWFjcnxwcmltZXxQcmltZXxpbWFnZXxwcm5hcHxlb2dvbnxFb2dvbnxyYXJyY3xtZGFzaHxtRERvdHxjdXdlZHxpbWF0aHxzdXBuZXxpbXBlZHxBbWFjcnx1ZGFycnxwcnNpbXxtaWNyb3xyYXJyYnxjd2ludHxyYXF1b3xpbmZpbnxlcGx1c3xyYW5nZXxyYW5nZHxVY2lyY3xyYWRpY3xtaW51c3xhbWFsZ3x2ZWVlcXxyQWFycnxlcHNpdnx5Y2lyY3xxdWVzdHxzaGFycHxxdW90fHp3bmp8UXNjcnxyYWNlfHFzY3J8UW9wZnxxb3BmfHFpbnR8cmFuZ3xSYW5nfFpzY3J8enNjcnxab3BmfHpvcGZ8cmFycnxyQXJyfFJhcnJ8UHNjcnxwc2NyfHByb3B8cHJvZHxwcm5FfHByZWN8WkhjeXx6aGN5fHByYXB8WmV0YXx6ZXRhfFBvcGZ8cG9wZnxaZG90fHBsdXN8emRvdHxZdW1sfHl1bWx8cGhpdnxZVWN5fHl1Y3l8WXNjcnx5c2NyfHBlcnB8WW9wZnx5b3BmfHBhcnR8cGFyYXxZSWN5fE91bWx8cmN1Ynx5aWN5fFlBY3l8cmRjYXxvdW1sfG9zb2x8T3NjcnxyZHNofHlhY3l8cmVhbHxvc2NyfHh2ZWV8YW5kZHxyZWN0fGFuZHZ8WHNjcnxvcm9yfG9yZG18b3JkZnx4c2NyfGFuZ2V8YW9wZnxBb3BmfHJIYXJ8WG9wZnxvcGFyfE9vcGZ8eG9wZnx4bmlzfHJob3Z8b29wZnxvbWlkfHhtYXB8b2ludHxhcGlkfGFwb3N8b2dvbnxhc2NyfEFzY3J8b2RvdHxvZGl2fHhjdXB8eGNhcHxvY2lyfG9hc3R8bnZsdHxudmxlfG52Z3R8bnZnZXxudmFwfFdzY3J8d3NjcnxhdW1sfG50bGd8bnRnbHxuc3VwfG5zdWJ8bnNpbXxOc2NyfG5zY3J8bnNjZXxXb3BmfHJpbmd8bnByZXx3b3BmfG5wYXJ8QXVtbHxCYXJ2fGJicmt8Tm9wZnxub3BmfG5taWR8bkx0dnxiZXRhfHJvcGZ8Um9wZnxCZXRhfGJldGh8bmxlc3xycGFyfG5sZXF8Ym5vdHxiTm90fG5sZHJ8TkpjeXxyc2NyfFJzY3J8VnNjcnx2c2NyfHJzcWJ8bmpjeXxib3BmfG5pc2R8Qm9wZnxydHJpfFZvcGZ8bkd0dnxuZ3RyfHZvcGZ8Ym94aHxib3hIfGJveHZ8bmdlc3xuZ2VxfGJveFZ8YnNjcnxzY2FwfEJzY3J8YnNpbXxWZXJ0fHZlcnR8YnNvbHxidWxsfGJ1bXB8Y2Fwc3xjZG90fG5jdXB8c2NuRXxuY2FwfG5ic3B8bmFwRXxDZG90fGNlbnR8c2RvdHxWYmFyfG5hbmd8dkJhcnxjaGN5fE1zY3J8bXNjcnxzZWN0fHNlbWl8Q0hjeXxNb3BmfG1vcGZ8c2V4dHxjaXJjfGNpcmV8bWxkcnxtbGNwfGNpckV8Y29tcHxzaGN5fFNIY3l8dkFycnx2YXJyfGNvbmd8Y29wZnxDb3BmfGNvcHl8Q09QWXxtYWx0fG1hbGV8bWFjcnxsdm5FfGNzY3J8bHRyaXxzaW1lfGx0Y2N8c2ltZ3xDc2NyfHNpbWx8Y3N1YnxVdW1sfGxzcWJ8bHNpbXx1dW1sfGNzdXB8THNjcnxsc2NyfHV0cml8c21pZHxscGFyfGN1cHN8c210ZXxsb3pmfGRhcnJ8TG9wZnxVc2NyfHNvbGJ8bG9wZnxzb3BmfFNvcGZ8bG5lcXx1c2NyfHNwYXJ8ZEFycnxsbmFwfERhcnJ8ZGFzaHxTcXJ0fExKY3l8bGpjeXxsSGFyfGRIYXJ8VXBzaXx1cHNpfGRpYW18bGVzZ3xkamN5fERKY3l8bGVxcXxkb3BmfERvcGZ8ZHNjcnxEc2NyfGRzY3l8bGRzaHxsZGNhfHNxdWZ8RFNjeXxzc2NyfFNzY3J8ZHNvbHxsY3VifGxhdGV8c3RhcnxTdGFyfFVvcGZ8TGFycnxsQXJyfGxhcnJ8dW9wZnxkdHJpfGR6Y3l8c3ViZXxzdWJFfExhbmd8bGFuZ3xLc2NyfGtzY3J8S29wZnxrb3BmfEtKY3l8a2pjeXxLSGN5fGtoY3l8RFpjeXxlY2lyfGVkb3R8ZURvdHxKc2NyfGpzY3J8c3VjY3xKb3BmfGpvcGZ8RWRvdHx1SGFyfGVtc3B8ZW5zcHxJdW1sfGl1bWx8ZW9wZnxpc2lufElzY3J8aXNjcnxFb3BmfGVwYXJ8c3VuZ3xlcHNpfGVzY3J8c3VwMXxzdXAyfHN1cDN8SW90YXxpb3RhfHN1cGV8c3VwRXxJb3BmfGlvcGZ8SU9jeXxpb2N5fEVzY3J8ZXNpbXxFc2ltfGltb2Z8VWFycnxRVU9UfHVBcnJ8dWFycnxldW1sfElFY3l8aWVjeXxJZG90fEV1bWx8ZXVyb3xleGNsfEhzY3J8aHNjcnxIb3BmfGhvcGZ8VFNjeXx0c2N5fFRzY3J8aGJhcnx0c2NyfGZsYXR8dGJya3xmbm9mfGhBcnJ8aGFycnxoYWxmfGZvcGZ8Rm9wZnx0ZG90fGd2bkV8Zm9ya3x0cmllfGd0Y2N8ZnNjcnxGc2NyfGdkb3R8Z3NpbXxHc2NyfGdzY3J8R29wZnxnb3BmfGduZXF8R2RvdHx0b3NhfGduYXB8VG9wZnx0b3BmfGdlcXF8dG9lYXxHSmN5fGdqY3l8dGludHxnZXNsfG1pZHxTZnJ8Z2dnfHRvcHxnZXN8Z2xhfGdsRXxnbGp8Z2VxfGduZXxnRWx8Z2VsfGduRXxHY3l8Z2N5fGdhcHxUZnJ8dGZyfFRjeXx0Y3l8SGF0fFRhdXxGZnJ8dGF1fFRhYnxoZnJ8SGZyfGZmcnxGY3l8ZmN5fGljeXxJY3l8aWZmfEVUSHxldGh8aWZyfElmcnxFdGF8ZXRhfGludHxJbnR8U3VwfHN1cHx1Y3l8VWN5fFN1bXxzdW18amN5fEVOR3x1ZnJ8VWZyfGVuZ3xKY3l8amZyfGVsc3xlbGx8ZWdzfEVmcnxlZnJ8SmZyfHVtbHxrY3l8S2N5fEVjeXxlY3l8a2ZyfEtmcnxsYXB8U3VifHN1YnxsYXR8bGN5fExjeXxsZWd8RG90fGRvdHxsRWd8bGVxfGxlc3xzcXV8ZGl2fGRpZXxsZnJ8TGZyfGxnRXxEZnJ8ZGZyfERlbHxkZWd8RGN5fGRjeXxsbmV8bG5FfHNvbHxsb3p8c210fEN1cHxscm18Y3VwfGxzaHxMc2h8c2ltfHNoeXxtYXB8TWFwfG1jeXxNY3l8bWZyfE1mcnxtaG98Z2ZyfEdmcnxzZnJ8Y2lyfENoaXxjaGl8bmFwfENmcnx2Y3l8VmN5fGNmcnxTY3l8c2N5fG5jeXxOY3l8dmVlfFZlZXxDYXB8Y2FwfG5mcnxzY0V8c2NlfE5mcnxuZ2V8bmdFfG5HZ3x2ZnJ8VmZyfG5ndHxib3R8bkd0fG5pc3xuaXZ8UnNofHJzaHxubGV8bmxFfGJuZXxCZnJ8YmZyfG5MbHxubHR8bkx0fEJjeXxiY3l8bm90fE5vdHxybG18d2ZyfFdmcnxucHJ8bnNjfG51bXxvY3l8YXN0fE9jeXxvZnJ8eGZyfFhmcnxPZnJ8b2d0fG9obXxhcEV8b2x0fFJob3xhcGV8cmhvfFJmcnxyZnJ8b3JkfFJFR3xhbmd8cmVnfG9ydnxBbmR8YW5kfEFNUHxSY3l8YW1wfEFmcnx5Y3l8WWN5fHllbnx5ZnJ8WWZyfHJjeXxwYXJ8cGN5fFBjeXxwZnJ8UGZyfHBoaXxQaGl8YWZyfEFjeXxhY3l8emN5fFpjeXxwaXZ8YWNFfGFjZHx6ZnJ8WmZyfHByZXxwckV8cHNpfFBzaXxxZnJ8UWZyfHp3anxPcnxnZXxHZ3xndHxnZ3xlbHxvU3xsdHxMdHxMVHxSZXxsZ3xnbHxlZ3xuZXxJbXxpdHxsZXxERHx3cHx3cnxudXxOdXxkZHxsRXxTY3xzY3xwaXxQaXxlZXxhZnxsbHxMbHxyeHxnRXx4aXxwbXxYaXxpY3xwcnxQcnxpbnxuaXxtcHxtdXxhY3xNdXxvcnxhcHxHdHxHVHxpaSk7fCYoQWFjdXRlfEFncmF2ZXxBdGlsZGV8Q2NlZGlsfEVhY3V0ZXxFZ3JhdmV8SWFjdXRlfElncmF2ZXxOdGlsZGV8T2FjdXRlfE9ncmF2ZXxPc2xhc2h8T3RpbGRlfFVhY3V0ZXxVZ3JhdmV8WWFjdXRlfGFhY3V0ZXxhZ3JhdmV8YXRpbGRlfGJydmJhcnxjY2VkaWx8Y3VycmVufGRpdmlkZXxlYWN1dGV8ZWdyYXZlfGZyYWMxMnxmcmFjMTR8ZnJhYzM0fGlhY3V0ZXxpZ3JhdmV8aXF1ZXN0fG1pZGRvdHxudGlsZGV8b2FjdXRlfG9ncmF2ZXxvc2xhc2h8b3RpbGRlfHBsdXNtbnx1YWN1dGV8dWdyYXZlfHlhY3V0ZXxBRWxpZ3xBY2lyY3xBcmluZ3xFY2lyY3xJY2lyY3xPY2lyY3xUSE9STnxVY2lyY3xhY2lyY3xhY3V0ZXxhZWxpZ3xhcmluZ3xjZWRpbHxlY2lyY3xpY2lyY3xpZXhjbHxsYXF1b3xtaWNyb3xvY2lyY3xwb3VuZHxyYXF1b3xzemxpZ3x0aG9ybnx0aW1lc3x1Y2lyY3xBdW1sfENPUFl8RXVtbHxJdW1sfE91bWx8UVVPVHxVdW1sfGF1bWx8Y2VudHxjb3B5fGV1bWx8aXVtbHxtYWNyfG5ic3B8b3JkZnxvcmRtfG91bWx8cGFyYXxxdW90fHNlY3R8c3VwMXxzdXAyfHN1cDN8dXVtbHx5dW1sfEFNUHxFVEh8UkVHfGFtcHxkZWd8ZXRofG5vdHxyZWd8c2h5fHVtbHx5ZW58R1R8TFR8Z3R8bHQpKD8hOykoWz1hLXpBLVowLTldPyl8JiMoWzAtOV0rKSg7Pyl8JiNbeFhdKFthLWZBLUYwLTldKykoOz8pfCYoWzAtOWEtekEtWl0rKS9nO1xuXHR2YXIgZGVjb2RlTWFwID0geydhYWN1dGUnOidcXHhFMScsJ0FhY3V0ZSc6J1xceEMxJywnYWJyZXZlJzonXFx1MDEwMycsJ0FicmV2ZSc6J1xcdTAxMDInLCdhYyc6J1xcdTIyM0UnLCdhY2QnOidcXHUyMjNGJywnYWNFJzonXFx1MjIzRVxcdTAzMzMnLCdhY2lyYyc6J1xceEUyJywnQWNpcmMnOidcXHhDMicsJ2FjdXRlJzonXFx4QjQnLCdhY3knOidcXHUwNDMwJywnQWN5JzonXFx1MDQxMCcsJ2FlbGlnJzonXFx4RTYnLCdBRWxpZyc6J1xceEM2JywnYWYnOidcXHUyMDYxJywnYWZyJzonXFx1RDgzNVxcdUREMUUnLCdBZnInOidcXHVEODM1XFx1REQwNCcsJ2FncmF2ZSc6J1xceEUwJywnQWdyYXZlJzonXFx4QzAnLCdhbGVmc3ltJzonXFx1MjEzNScsJ2FsZXBoJzonXFx1MjEzNScsJ2FscGhhJzonXFx1MDNCMScsJ0FscGhhJzonXFx1MDM5MScsJ2FtYWNyJzonXFx1MDEwMScsJ0FtYWNyJzonXFx1MDEwMCcsJ2FtYWxnJzonXFx1MkEzRicsJ2FtcCc6JyYnLCdBTVAnOicmJywnYW5kJzonXFx1MjIyNycsJ0FuZCc6J1xcdTJBNTMnLCdhbmRhbmQnOidcXHUyQTU1JywnYW5kZCc6J1xcdTJBNUMnLCdhbmRzbG9wZSc6J1xcdTJBNTgnLCdhbmR2JzonXFx1MkE1QScsJ2FuZyc6J1xcdTIyMjAnLCdhbmdlJzonXFx1MjlBNCcsJ2FuZ2xlJzonXFx1MjIyMCcsJ2FuZ21zZCc6J1xcdTIyMjEnLCdhbmdtc2RhYSc6J1xcdTI5QTgnLCdhbmdtc2RhYic6J1xcdTI5QTknLCdhbmdtc2RhYyc6J1xcdTI5QUEnLCdhbmdtc2RhZCc6J1xcdTI5QUInLCdhbmdtc2RhZSc6J1xcdTI5QUMnLCdhbmdtc2RhZic6J1xcdTI5QUQnLCdhbmdtc2RhZyc6J1xcdTI5QUUnLCdhbmdtc2RhaCc6J1xcdTI5QUYnLCdhbmdydCc6J1xcdTIyMUYnLCdhbmdydHZiJzonXFx1MjJCRScsJ2FuZ3J0dmJkJzonXFx1Mjk5RCcsJ2FuZ3NwaCc6J1xcdTIyMjInLCdhbmdzdCc6J1xceEM1JywnYW5nemFycic6J1xcdTIzN0MnLCdhb2dvbic6J1xcdTAxMDUnLCdBb2dvbic6J1xcdTAxMDQnLCdhb3BmJzonXFx1RDgzNVxcdURENTInLCdBb3BmJzonXFx1RDgzNVxcdUREMzgnLCdhcCc6J1xcdTIyNDgnLCdhcGFjaXInOidcXHUyQTZGJywnYXBlJzonXFx1MjI0QScsJ2FwRSc6J1xcdTJBNzAnLCdhcGlkJzonXFx1MjI0QicsJ2Fwb3MnOidcXCcnLCdBcHBseUZ1bmN0aW9uJzonXFx1MjA2MScsJ2FwcHJveCc6J1xcdTIyNDgnLCdhcHByb3hlcSc6J1xcdTIyNEEnLCdhcmluZyc6J1xceEU1JywnQXJpbmcnOidcXHhDNScsJ2FzY3InOidcXHVEODM1XFx1RENCNicsJ0FzY3InOidcXHVEODM1XFx1REM5QycsJ0Fzc2lnbic6J1xcdTIyNTQnLCdhc3QnOicqJywnYXN5bXAnOidcXHUyMjQ4JywnYXN5bXBlcSc6J1xcdTIyNEQnLCdhdGlsZGUnOidcXHhFMycsJ0F0aWxkZSc6J1xceEMzJywnYXVtbCc6J1xceEU0JywnQXVtbCc6J1xceEM0JywnYXdjb25pbnQnOidcXHUyMjMzJywnYXdpbnQnOidcXHUyQTExJywnYmFja2NvbmcnOidcXHUyMjRDJywnYmFja2Vwc2lsb24nOidcXHUwM0Y2JywnYmFja3ByaW1lJzonXFx1MjAzNScsJ2JhY2tzaW0nOidcXHUyMjNEJywnYmFja3NpbWVxJzonXFx1MjJDRCcsJ0JhY2tzbGFzaCc6J1xcdTIyMTYnLCdCYXJ2JzonXFx1MkFFNycsJ2JhcnZlZSc6J1xcdTIyQkQnLCdiYXJ3ZWQnOidcXHUyMzA1JywnQmFyd2VkJzonXFx1MjMwNicsJ2JhcndlZGdlJzonXFx1MjMwNScsJ2JicmsnOidcXHUyM0I1JywnYmJya3RicmsnOidcXHUyM0I2JywnYmNvbmcnOidcXHUyMjRDJywnYmN5JzonXFx1MDQzMScsJ0JjeSc6J1xcdTA0MTEnLCdiZHF1byc6J1xcdTIwMUUnLCdiZWNhdXMnOidcXHUyMjM1JywnYmVjYXVzZSc6J1xcdTIyMzUnLCdCZWNhdXNlJzonXFx1MjIzNScsJ2JlbXB0eXYnOidcXHUyOUIwJywnYmVwc2knOidcXHUwM0Y2JywnYmVybm91JzonXFx1MjEyQycsJ0Jlcm5vdWxsaXMnOidcXHUyMTJDJywnYmV0YSc6J1xcdTAzQjInLCdCZXRhJzonXFx1MDM5MicsJ2JldGgnOidcXHUyMTM2JywnYmV0d2Vlbic6J1xcdTIyNkMnLCdiZnInOidcXHVEODM1XFx1REQxRicsJ0Jmcic6J1xcdUQ4MzVcXHVERDA1JywnYmlnY2FwJzonXFx1MjJDMicsJ2JpZ2NpcmMnOidcXHUyNUVGJywnYmlnY3VwJzonXFx1MjJDMycsJ2JpZ29kb3QnOidcXHUyQTAwJywnYmlnb3BsdXMnOidcXHUyQTAxJywnYmlnb3RpbWVzJzonXFx1MkEwMicsJ2JpZ3NxY3VwJzonXFx1MkEwNicsJ2JpZ3N0YXInOidcXHUyNjA1JywnYmlndHJpYW5nbGVkb3duJzonXFx1MjVCRCcsJ2JpZ3RyaWFuZ2xldXAnOidcXHUyNUIzJywnYmlndXBsdXMnOidcXHUyQTA0JywnYmlndmVlJzonXFx1MjJDMScsJ2JpZ3dlZGdlJzonXFx1MjJDMCcsJ2JrYXJvdyc6J1xcdTI5MEQnLCdibGFja2xvemVuZ2UnOidcXHUyOUVCJywnYmxhY2tzcXVhcmUnOidcXHUyNUFBJywnYmxhY2t0cmlhbmdsZSc6J1xcdTI1QjQnLCdibGFja3RyaWFuZ2xlZG93bic6J1xcdTI1QkUnLCdibGFja3RyaWFuZ2xlbGVmdCc6J1xcdTI1QzInLCdibGFja3RyaWFuZ2xlcmlnaHQnOidcXHUyNUI4JywnYmxhbmsnOidcXHUyNDIzJywnYmxrMTInOidcXHUyNTkyJywnYmxrMTQnOidcXHUyNTkxJywnYmxrMzQnOidcXHUyNTkzJywnYmxvY2snOidcXHUyNTg4JywnYm5lJzonPVxcdTIwRTUnLCdibmVxdWl2JzonXFx1MjI2MVxcdTIwRTUnLCdibm90JzonXFx1MjMxMCcsJ2JOb3QnOidcXHUyQUVEJywnYm9wZic6J1xcdUQ4MzVcXHVERDUzJywnQm9wZic6J1xcdUQ4MzVcXHVERDM5JywnYm90JzonXFx1MjJBNScsJ2JvdHRvbSc6J1xcdTIyQTUnLCdib3d0aWUnOidcXHUyMkM4JywnYm94Ym94JzonXFx1MjlDOScsJ2JveGRsJzonXFx1MjUxMCcsJ2JveGRMJzonXFx1MjU1NScsJ2JveERsJzonXFx1MjU1NicsJ2JveERMJzonXFx1MjU1NycsJ2JveGRyJzonXFx1MjUwQycsJ2JveGRSJzonXFx1MjU1MicsJ2JveERyJzonXFx1MjU1MycsJ2JveERSJzonXFx1MjU1NCcsJ2JveGgnOidcXHUyNTAwJywnYm94SCc6J1xcdTI1NTAnLCdib3hoZCc6J1xcdTI1MkMnLCdib3hoRCc6J1xcdTI1NjUnLCdib3hIZCc6J1xcdTI1NjQnLCdib3hIRCc6J1xcdTI1NjYnLCdib3hodSc6J1xcdTI1MzQnLCdib3hoVSc6J1xcdTI1NjgnLCdib3hIdSc6J1xcdTI1NjcnLCdib3hIVSc6J1xcdTI1NjknLCdib3htaW51cyc6J1xcdTIyOUYnLCdib3hwbHVzJzonXFx1MjI5RScsJ2JveHRpbWVzJzonXFx1MjJBMCcsJ2JveHVsJzonXFx1MjUxOCcsJ2JveHVMJzonXFx1MjU1QicsJ2JveFVsJzonXFx1MjU1QycsJ2JveFVMJzonXFx1MjU1RCcsJ2JveHVyJzonXFx1MjUxNCcsJ2JveHVSJzonXFx1MjU1OCcsJ2JveFVyJzonXFx1MjU1OScsJ2JveFVSJzonXFx1MjU1QScsJ2JveHYnOidcXHUyNTAyJywnYm94Vic6J1xcdTI1NTEnLCdib3h2aCc6J1xcdTI1M0MnLCdib3h2SCc6J1xcdTI1NkEnLCdib3hWaCc6J1xcdTI1NkInLCdib3hWSCc6J1xcdTI1NkMnLCdib3h2bCc6J1xcdTI1MjQnLCdib3h2TCc6J1xcdTI1NjEnLCdib3hWbCc6J1xcdTI1NjInLCdib3hWTCc6J1xcdTI1NjMnLCdib3h2cic6J1xcdTI1MUMnLCdib3h2Uic6J1xcdTI1NUUnLCdib3hWcic6J1xcdTI1NUYnLCdib3hWUic6J1xcdTI1NjAnLCdicHJpbWUnOidcXHUyMDM1JywnYnJldmUnOidcXHUwMkQ4JywnQnJldmUnOidcXHUwMkQ4JywnYnJ2YmFyJzonXFx4QTYnLCdic2NyJzonXFx1RDgzNVxcdURDQjcnLCdCc2NyJzonXFx1MjEyQycsJ2JzZW1pJzonXFx1MjA0RicsJ2JzaW0nOidcXHUyMjNEJywnYnNpbWUnOidcXHUyMkNEJywnYnNvbCc6J1xcXFwnLCdic29sYic6J1xcdTI5QzUnLCdic29saHN1Yic6J1xcdTI3QzgnLCdidWxsJzonXFx1MjAyMicsJ2J1bGxldCc6J1xcdTIwMjInLCdidW1wJzonXFx1MjI0RScsJ2J1bXBlJzonXFx1MjI0RicsJ2J1bXBFJzonXFx1MkFBRScsJ2J1bXBlcSc6J1xcdTIyNEYnLCdCdW1wZXEnOidcXHUyMjRFJywnY2FjdXRlJzonXFx1MDEwNycsJ0NhY3V0ZSc6J1xcdTAxMDYnLCdjYXAnOidcXHUyMjI5JywnQ2FwJzonXFx1MjJEMicsJ2NhcGFuZCc6J1xcdTJBNDQnLCdjYXBicmN1cCc6J1xcdTJBNDknLCdjYXBjYXAnOidcXHUyQTRCJywnY2FwY3VwJzonXFx1MkE0NycsJ2NhcGRvdCc6J1xcdTJBNDAnLCdDYXBpdGFsRGlmZmVyZW50aWFsRCc6J1xcdTIxNDUnLCdjYXBzJzonXFx1MjIyOVxcdUZFMDAnLCdjYXJldCc6J1xcdTIwNDEnLCdjYXJvbic6J1xcdTAyQzcnLCdDYXlsZXlzJzonXFx1MjEyRCcsJ2NjYXBzJzonXFx1MkE0RCcsJ2NjYXJvbic6J1xcdTAxMEQnLCdDY2Fyb24nOidcXHUwMTBDJywnY2NlZGlsJzonXFx4RTcnLCdDY2VkaWwnOidcXHhDNycsJ2NjaXJjJzonXFx1MDEwOScsJ0NjaXJjJzonXFx1MDEwOCcsJ0Njb25pbnQnOidcXHUyMjMwJywnY2N1cHMnOidcXHUyQTRDJywnY2N1cHNzbSc6J1xcdTJBNTAnLCdjZG90JzonXFx1MDEwQicsJ0Nkb3QnOidcXHUwMTBBJywnY2VkaWwnOidcXHhCOCcsJ0NlZGlsbGEnOidcXHhCOCcsJ2NlbXB0eXYnOidcXHUyOUIyJywnY2VudCc6J1xceEEyJywnY2VudGVyZG90JzonXFx4QjcnLCdDZW50ZXJEb3QnOidcXHhCNycsJ2Nmcic6J1xcdUQ4MzVcXHVERDIwJywnQ2ZyJzonXFx1MjEyRCcsJ2NoY3knOidcXHUwNDQ3JywnQ0hjeSc6J1xcdTA0MjcnLCdjaGVjayc6J1xcdTI3MTMnLCdjaGVja21hcmsnOidcXHUyNzEzJywnY2hpJzonXFx1MDNDNycsJ0NoaSc6J1xcdTAzQTcnLCdjaXInOidcXHUyNUNCJywnY2lyYyc6J1xcdTAyQzYnLCdjaXJjZXEnOidcXHUyMjU3JywnY2lyY2xlYXJyb3dsZWZ0JzonXFx1MjFCQScsJ2NpcmNsZWFycm93cmlnaHQnOidcXHUyMUJCJywnY2lyY2xlZGFzdCc6J1xcdTIyOUInLCdjaXJjbGVkY2lyYyc6J1xcdTIyOUEnLCdjaXJjbGVkZGFzaCc6J1xcdTIyOUQnLCdDaXJjbGVEb3QnOidcXHUyMjk5JywnY2lyY2xlZFInOidcXHhBRScsJ2NpcmNsZWRTJzonXFx1MjRDOCcsJ0NpcmNsZU1pbnVzJzonXFx1MjI5NicsJ0NpcmNsZVBsdXMnOidcXHUyMjk1JywnQ2lyY2xlVGltZXMnOidcXHUyMjk3JywnY2lyZSc6J1xcdTIyNTcnLCdjaXJFJzonXFx1MjlDMycsJ2NpcmZuaW50JzonXFx1MkExMCcsJ2Npcm1pZCc6J1xcdTJBRUYnLCdjaXJzY2lyJzonXFx1MjlDMicsJ0Nsb2Nrd2lzZUNvbnRvdXJJbnRlZ3JhbCc6J1xcdTIyMzInLCdDbG9zZUN1cmx5RG91YmxlUXVvdGUnOidcXHUyMDFEJywnQ2xvc2VDdXJseVF1b3RlJzonXFx1MjAxOScsJ2NsdWJzJzonXFx1MjY2MycsJ2NsdWJzdWl0JzonXFx1MjY2MycsJ2NvbG9uJzonOicsJ0NvbG9uJzonXFx1MjIzNycsJ2NvbG9uZSc6J1xcdTIyNTQnLCdDb2xvbmUnOidcXHUyQTc0JywnY29sb25lcSc6J1xcdTIyNTQnLCdjb21tYSc6JywnLCdjb21tYXQnOidAJywnY29tcCc6J1xcdTIyMDEnLCdjb21wZm4nOidcXHUyMjE4JywnY29tcGxlbWVudCc6J1xcdTIyMDEnLCdjb21wbGV4ZXMnOidcXHUyMTAyJywnY29uZyc6J1xcdTIyNDUnLCdjb25nZG90JzonXFx1MkE2RCcsJ0NvbmdydWVudCc6J1xcdTIyNjEnLCdjb25pbnQnOidcXHUyMjJFJywnQ29uaW50JzonXFx1MjIyRicsJ0NvbnRvdXJJbnRlZ3JhbCc6J1xcdTIyMkUnLCdjb3BmJzonXFx1RDgzNVxcdURENTQnLCdDb3BmJzonXFx1MjEwMicsJ2NvcHJvZCc6J1xcdTIyMTAnLCdDb3Byb2R1Y3QnOidcXHUyMjEwJywnY29weSc6J1xceEE5JywnQ09QWSc6J1xceEE5JywnY29weXNyJzonXFx1MjExNycsJ0NvdW50ZXJDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOidcXHUyMjMzJywnY3JhcnInOidcXHUyMUI1JywnY3Jvc3MnOidcXHUyNzE3JywnQ3Jvc3MnOidcXHUyQTJGJywnY3Njcic6J1xcdUQ4MzVcXHVEQ0I4JywnQ3Njcic6J1xcdUQ4MzVcXHVEQzlFJywnY3N1Yic6J1xcdTJBQ0YnLCdjc3ViZSc6J1xcdTJBRDEnLCdjc3VwJzonXFx1MkFEMCcsJ2NzdXBlJzonXFx1MkFEMicsJ2N0ZG90JzonXFx1MjJFRicsJ2N1ZGFycmwnOidcXHUyOTM4JywnY3VkYXJycic6J1xcdTI5MzUnLCdjdWVwcic6J1xcdTIyREUnLCdjdWVzYyc6J1xcdTIyREYnLCdjdWxhcnInOidcXHUyMUI2JywnY3VsYXJycCc6J1xcdTI5M0QnLCdjdXAnOidcXHUyMjJBJywnQ3VwJzonXFx1MjJEMycsJ2N1cGJyY2FwJzonXFx1MkE0OCcsJ2N1cGNhcCc6J1xcdTJBNDYnLCdDdXBDYXAnOidcXHUyMjREJywnY3VwY3VwJzonXFx1MkE0QScsJ2N1cGRvdCc6J1xcdTIyOEQnLCdjdXBvcic6J1xcdTJBNDUnLCdjdXBzJzonXFx1MjIyQVxcdUZFMDAnLCdjdXJhcnInOidcXHUyMUI3JywnY3VyYXJybSc6J1xcdTI5M0MnLCdjdXJseWVxcHJlYyc6J1xcdTIyREUnLCdjdXJseWVxc3VjYyc6J1xcdTIyREYnLCdjdXJseXZlZSc6J1xcdTIyQ0UnLCdjdXJseXdlZGdlJzonXFx1MjJDRicsJ2N1cnJlbic6J1xceEE0JywnY3VydmVhcnJvd2xlZnQnOidcXHUyMUI2JywnY3VydmVhcnJvd3JpZ2h0JzonXFx1MjFCNycsJ2N1dmVlJzonXFx1MjJDRScsJ2N1d2VkJzonXFx1MjJDRicsJ2N3Y29uaW50JzonXFx1MjIzMicsJ2N3aW50JzonXFx1MjIzMScsJ2N5bGN0eSc6J1xcdTIzMkQnLCdkYWdnZXInOidcXHUyMDIwJywnRGFnZ2VyJzonXFx1MjAyMScsJ2RhbGV0aCc6J1xcdTIxMzgnLCdkYXJyJzonXFx1MjE5MycsJ2RBcnInOidcXHUyMUQzJywnRGFycic6J1xcdTIxQTEnLCdkYXNoJzonXFx1MjAxMCcsJ2Rhc2h2JzonXFx1MjJBMycsJ0Rhc2h2JzonXFx1MkFFNCcsJ2Ria2Fyb3cnOidcXHUyOTBGJywnZGJsYWMnOidcXHUwMkREJywnZGNhcm9uJzonXFx1MDEwRicsJ0RjYXJvbic6J1xcdTAxMEUnLCdkY3knOidcXHUwNDM0JywnRGN5JzonXFx1MDQxNCcsJ2RkJzonXFx1MjE0NicsJ0REJzonXFx1MjE0NScsJ2RkYWdnZXInOidcXHUyMDIxJywnZGRhcnInOidcXHUyMUNBJywnRERvdHJhaGQnOidcXHUyOTExJywnZGRvdHNlcSc6J1xcdTJBNzcnLCdkZWcnOidcXHhCMCcsJ0RlbCc6J1xcdTIyMDcnLCdkZWx0YSc6J1xcdTAzQjQnLCdEZWx0YSc6J1xcdTAzOTQnLCdkZW1wdHl2JzonXFx1MjlCMScsJ2RmaXNodCc6J1xcdTI5N0YnLCdkZnInOidcXHVEODM1XFx1REQyMScsJ0Rmcic6J1xcdUQ4MzVcXHVERDA3JywnZEhhcic6J1xcdTI5NjUnLCdkaGFybCc6J1xcdTIxQzMnLCdkaGFycic6J1xcdTIxQzInLCdEaWFjcml0aWNhbEFjdXRlJzonXFx4QjQnLCdEaWFjcml0aWNhbERvdCc6J1xcdTAyRDknLCdEaWFjcml0aWNhbERvdWJsZUFjdXRlJzonXFx1MDJERCcsJ0RpYWNyaXRpY2FsR3JhdmUnOidgJywnRGlhY3JpdGljYWxUaWxkZSc6J1xcdTAyREMnLCdkaWFtJzonXFx1MjJDNCcsJ2RpYW1vbmQnOidcXHUyMkM0JywnRGlhbW9uZCc6J1xcdTIyQzQnLCdkaWFtb25kc3VpdCc6J1xcdTI2NjYnLCdkaWFtcyc6J1xcdTI2NjYnLCdkaWUnOidcXHhBOCcsJ0RpZmZlcmVudGlhbEQnOidcXHUyMTQ2JywnZGlnYW1tYSc6J1xcdTAzREQnLCdkaXNpbic6J1xcdTIyRjInLCdkaXYnOidcXHhGNycsJ2RpdmlkZSc6J1xceEY3JywnZGl2aWRlb250aW1lcyc6J1xcdTIyQzcnLCdkaXZvbngnOidcXHUyMkM3JywnZGpjeSc6J1xcdTA0NTInLCdESmN5JzonXFx1MDQwMicsJ2RsY29ybic6J1xcdTIzMUUnLCdkbGNyb3AnOidcXHUyMzBEJywnZG9sbGFyJzonJCcsJ2RvcGYnOidcXHVEODM1XFx1REQ1NScsJ0RvcGYnOidcXHVEODM1XFx1REQzQicsJ2RvdCc6J1xcdTAyRDknLCdEb3QnOidcXHhBOCcsJ0RvdERvdCc6J1xcdTIwREMnLCdkb3RlcSc6J1xcdTIyNTAnLCdkb3RlcWRvdCc6J1xcdTIyNTEnLCdEb3RFcXVhbCc6J1xcdTIyNTAnLCdkb3RtaW51cyc6J1xcdTIyMzgnLCdkb3RwbHVzJzonXFx1MjIxNCcsJ2RvdHNxdWFyZSc6J1xcdTIyQTEnLCdkb3VibGViYXJ3ZWRnZSc6J1xcdTIzMDYnLCdEb3VibGVDb250b3VySW50ZWdyYWwnOidcXHUyMjJGJywnRG91YmxlRG90JzonXFx4QTgnLCdEb3VibGVEb3duQXJyb3cnOidcXHUyMUQzJywnRG91YmxlTGVmdEFycm93JzonXFx1MjFEMCcsJ0RvdWJsZUxlZnRSaWdodEFycm93JzonXFx1MjFENCcsJ0RvdWJsZUxlZnRUZWUnOidcXHUyQUU0JywnRG91YmxlTG9uZ0xlZnRBcnJvdyc6J1xcdTI3RjgnLCdEb3VibGVMb25nTGVmdFJpZ2h0QXJyb3cnOidcXHUyN0ZBJywnRG91YmxlTG9uZ1JpZ2h0QXJyb3cnOidcXHUyN0Y5JywnRG91YmxlUmlnaHRBcnJvdyc6J1xcdTIxRDInLCdEb3VibGVSaWdodFRlZSc6J1xcdTIyQTgnLCdEb3VibGVVcEFycm93JzonXFx1MjFEMScsJ0RvdWJsZVVwRG93bkFycm93JzonXFx1MjFENScsJ0RvdWJsZVZlcnRpY2FsQmFyJzonXFx1MjIyNScsJ2Rvd25hcnJvdyc6J1xcdTIxOTMnLCdEb3duYXJyb3cnOidcXHUyMUQzJywnRG93bkFycm93JzonXFx1MjE5MycsJ0Rvd25BcnJvd0Jhcic6J1xcdTI5MTMnLCdEb3duQXJyb3dVcEFycm93JzonXFx1MjFGNScsJ0Rvd25CcmV2ZSc6J1xcdTAzMTEnLCdkb3duZG93bmFycm93cyc6J1xcdTIxQ0EnLCdkb3duaGFycG9vbmxlZnQnOidcXHUyMUMzJywnZG93bmhhcnBvb25yaWdodCc6J1xcdTIxQzInLCdEb3duTGVmdFJpZ2h0VmVjdG9yJzonXFx1Mjk1MCcsJ0Rvd25MZWZ0VGVlVmVjdG9yJzonXFx1Mjk1RScsJ0Rvd25MZWZ0VmVjdG9yJzonXFx1MjFCRCcsJ0Rvd25MZWZ0VmVjdG9yQmFyJzonXFx1Mjk1NicsJ0Rvd25SaWdodFRlZVZlY3Rvcic6J1xcdTI5NUYnLCdEb3duUmlnaHRWZWN0b3InOidcXHUyMUMxJywnRG93blJpZ2h0VmVjdG9yQmFyJzonXFx1Mjk1NycsJ0Rvd25UZWUnOidcXHUyMkE0JywnRG93blRlZUFycm93JzonXFx1MjFBNycsJ2RyYmthcm93JzonXFx1MjkxMCcsJ2RyY29ybic6J1xcdTIzMUYnLCdkcmNyb3AnOidcXHUyMzBDJywnZHNjcic6J1xcdUQ4MzVcXHVEQ0I5JywnRHNjcic6J1xcdUQ4MzVcXHVEQzlGJywnZHNjeSc6J1xcdTA0NTUnLCdEU2N5JzonXFx1MDQwNScsJ2Rzb2wnOidcXHUyOUY2JywnZHN0cm9rJzonXFx1MDExMScsJ0RzdHJvayc6J1xcdTAxMTAnLCdkdGRvdCc6J1xcdTIyRjEnLCdkdHJpJzonXFx1MjVCRicsJ2R0cmlmJzonXFx1MjVCRScsJ2R1YXJyJzonXFx1MjFGNScsJ2R1aGFyJzonXFx1Mjk2RicsJ2R3YW5nbGUnOidcXHUyOUE2JywnZHpjeSc6J1xcdTA0NUYnLCdEWmN5JzonXFx1MDQwRicsJ2R6aWdyYXJyJzonXFx1MjdGRicsJ2VhY3V0ZSc6J1xceEU5JywnRWFjdXRlJzonXFx4QzknLCdlYXN0ZXInOidcXHUyQTZFJywnZWNhcm9uJzonXFx1MDExQicsJ0VjYXJvbic6J1xcdTAxMUEnLCdlY2lyJzonXFx1MjI1NicsJ2VjaXJjJzonXFx4RUEnLCdFY2lyYyc6J1xceENBJywnZWNvbG9uJzonXFx1MjI1NScsJ2VjeSc6J1xcdTA0NEQnLCdFY3knOidcXHUwNDJEJywnZUREb3QnOidcXHUyQTc3JywnZWRvdCc6J1xcdTAxMTcnLCdlRG90JzonXFx1MjI1MScsJ0Vkb3QnOidcXHUwMTE2JywnZWUnOidcXHUyMTQ3JywnZWZEb3QnOidcXHUyMjUyJywnZWZyJzonXFx1RDgzNVxcdUREMjInLCdFZnInOidcXHVEODM1XFx1REQwOCcsJ2VnJzonXFx1MkE5QScsJ2VncmF2ZSc6J1xceEU4JywnRWdyYXZlJzonXFx4QzgnLCdlZ3MnOidcXHUyQTk2JywnZWdzZG90JzonXFx1MkE5OCcsJ2VsJzonXFx1MkE5OScsJ0VsZW1lbnQnOidcXHUyMjA4JywnZWxpbnRlcnMnOidcXHUyM0U3JywnZWxsJzonXFx1MjExMycsJ2Vscyc6J1xcdTJBOTUnLCdlbHNkb3QnOidcXHUyQTk3JywnZW1hY3InOidcXHUwMTEzJywnRW1hY3InOidcXHUwMTEyJywnZW1wdHknOidcXHUyMjA1JywnZW1wdHlzZXQnOidcXHUyMjA1JywnRW1wdHlTbWFsbFNxdWFyZSc6J1xcdTI1RkInLCdlbXB0eXYnOidcXHUyMjA1JywnRW1wdHlWZXJ5U21hbGxTcXVhcmUnOidcXHUyNUFCJywnZW1zcCc6J1xcdTIwMDMnLCdlbXNwMTMnOidcXHUyMDA0JywnZW1zcDE0JzonXFx1MjAwNScsJ2VuZyc6J1xcdTAxNEInLCdFTkcnOidcXHUwMTRBJywnZW5zcCc6J1xcdTIwMDInLCdlb2dvbic6J1xcdTAxMTknLCdFb2dvbic6J1xcdTAxMTgnLCdlb3BmJzonXFx1RDgzNVxcdURENTYnLCdFb3BmJzonXFx1RDgzNVxcdUREM0MnLCdlcGFyJzonXFx1MjJENScsJ2VwYXJzbCc6J1xcdTI5RTMnLCdlcGx1cyc6J1xcdTJBNzEnLCdlcHNpJzonXFx1MDNCNScsJ2Vwc2lsb24nOidcXHUwM0I1JywnRXBzaWxvbic6J1xcdTAzOTUnLCdlcHNpdic6J1xcdTAzRjUnLCdlcWNpcmMnOidcXHUyMjU2JywnZXFjb2xvbic6J1xcdTIyNTUnLCdlcXNpbSc6J1xcdTIyNDInLCdlcXNsYW50Z3RyJzonXFx1MkE5NicsJ2Vxc2xhbnRsZXNzJzonXFx1MkE5NScsJ0VxdWFsJzonXFx1MkE3NScsJ2VxdWFscyc6Jz0nLCdFcXVhbFRpbGRlJzonXFx1MjI0MicsJ2VxdWVzdCc6J1xcdTIyNUYnLCdFcXVpbGlicml1bSc6J1xcdTIxQ0MnLCdlcXVpdic6J1xcdTIyNjEnLCdlcXVpdkREJzonXFx1MkE3OCcsJ2VxdnBhcnNsJzonXFx1MjlFNScsJ2VyYXJyJzonXFx1Mjk3MScsJ2VyRG90JzonXFx1MjI1MycsJ2VzY3InOidcXHUyMTJGJywnRXNjcic6J1xcdTIxMzAnLCdlc2RvdCc6J1xcdTIyNTAnLCdlc2ltJzonXFx1MjI0MicsJ0VzaW0nOidcXHUyQTczJywnZXRhJzonXFx1MDNCNycsJ0V0YSc6J1xcdTAzOTcnLCdldGgnOidcXHhGMCcsJ0VUSCc6J1xceEQwJywnZXVtbCc6J1xceEVCJywnRXVtbCc6J1xceENCJywnZXVybyc6J1xcdTIwQUMnLCdleGNsJzonIScsJ2V4aXN0JzonXFx1MjIwMycsJ0V4aXN0cyc6J1xcdTIyMDMnLCdleHBlY3RhdGlvbic6J1xcdTIxMzAnLCdleHBvbmVudGlhbGUnOidcXHUyMTQ3JywnRXhwb25lbnRpYWxFJzonXFx1MjE0NycsJ2ZhbGxpbmdkb3RzZXEnOidcXHUyMjUyJywnZmN5JzonXFx1MDQ0NCcsJ0ZjeSc6J1xcdTA0MjQnLCdmZW1hbGUnOidcXHUyNjQwJywnZmZpbGlnJzonXFx1RkIwMycsJ2ZmbGlnJzonXFx1RkIwMCcsJ2ZmbGxpZyc6J1xcdUZCMDQnLCdmZnInOidcXHVEODM1XFx1REQyMycsJ0Zmcic6J1xcdUQ4MzVcXHVERDA5JywnZmlsaWcnOidcXHVGQjAxJywnRmlsbGVkU21hbGxTcXVhcmUnOidcXHUyNUZDJywnRmlsbGVkVmVyeVNtYWxsU3F1YXJlJzonXFx1MjVBQScsJ2ZqbGlnJzonZmonLCdmbGF0JzonXFx1MjY2RCcsJ2ZsbGlnJzonXFx1RkIwMicsJ2ZsdG5zJzonXFx1MjVCMScsJ2Zub2YnOidcXHUwMTkyJywnZm9wZic6J1xcdUQ4MzVcXHVERDU3JywnRm9wZic6J1xcdUQ4MzVcXHVERDNEJywnZm9yYWxsJzonXFx1MjIwMCcsJ0ZvckFsbCc6J1xcdTIyMDAnLCdmb3JrJzonXFx1MjJENCcsJ2Zvcmt2JzonXFx1MkFEOScsJ0ZvdXJpZXJ0cmYnOidcXHUyMTMxJywnZnBhcnRpbnQnOidcXHUyQTBEJywnZnJhYzEyJzonXFx4QkQnLCdmcmFjMTMnOidcXHUyMTUzJywnZnJhYzE0JzonXFx4QkMnLCdmcmFjMTUnOidcXHUyMTU1JywnZnJhYzE2JzonXFx1MjE1OScsJ2ZyYWMxOCc6J1xcdTIxNUInLCdmcmFjMjMnOidcXHUyMTU0JywnZnJhYzI1JzonXFx1MjE1NicsJ2ZyYWMzNCc6J1xceEJFJywnZnJhYzM1JzonXFx1MjE1NycsJ2ZyYWMzOCc6J1xcdTIxNUMnLCdmcmFjNDUnOidcXHUyMTU4JywnZnJhYzU2JzonXFx1MjE1QScsJ2ZyYWM1OCc6J1xcdTIxNUQnLCdmcmFjNzgnOidcXHUyMTVFJywnZnJhc2wnOidcXHUyMDQ0JywnZnJvd24nOidcXHUyMzIyJywnZnNjcic6J1xcdUQ4MzVcXHVEQ0JCJywnRnNjcic6J1xcdTIxMzEnLCdnYWN1dGUnOidcXHUwMUY1JywnZ2FtbWEnOidcXHUwM0IzJywnR2FtbWEnOidcXHUwMzkzJywnZ2FtbWFkJzonXFx1MDNERCcsJ0dhbW1hZCc6J1xcdTAzREMnLCdnYXAnOidcXHUyQTg2JywnZ2JyZXZlJzonXFx1MDExRicsJ0dicmV2ZSc6J1xcdTAxMUUnLCdHY2VkaWwnOidcXHUwMTIyJywnZ2NpcmMnOidcXHUwMTFEJywnR2NpcmMnOidcXHUwMTFDJywnZ2N5JzonXFx1MDQzMycsJ0djeSc6J1xcdTA0MTMnLCdnZG90JzonXFx1MDEyMScsJ0dkb3QnOidcXHUwMTIwJywnZ2UnOidcXHUyMjY1JywnZ0UnOidcXHUyMjY3JywnZ2VsJzonXFx1MjJEQicsJ2dFbCc6J1xcdTJBOEMnLCdnZXEnOidcXHUyMjY1JywnZ2VxcSc6J1xcdTIyNjcnLCdnZXFzbGFudCc6J1xcdTJBN0UnLCdnZXMnOidcXHUyQTdFJywnZ2VzY2MnOidcXHUyQUE5JywnZ2VzZG90JzonXFx1MkE4MCcsJ2dlc2RvdG8nOidcXHUyQTgyJywnZ2VzZG90b2wnOidcXHUyQTg0JywnZ2VzbCc6J1xcdTIyREJcXHVGRTAwJywnZ2VzbGVzJzonXFx1MkE5NCcsJ2dmcic6J1xcdUQ4MzVcXHVERDI0JywnR2ZyJzonXFx1RDgzNVxcdUREMEEnLCdnZyc6J1xcdTIyNkInLCdHZyc6J1xcdTIyRDknLCdnZ2cnOidcXHUyMkQ5JywnZ2ltZWwnOidcXHUyMTM3JywnZ2pjeSc6J1xcdTA0NTMnLCdHSmN5JzonXFx1MDQwMycsJ2dsJzonXFx1MjI3NycsJ2dsYSc6J1xcdTJBQTUnLCdnbEUnOidcXHUyQTkyJywnZ2xqJzonXFx1MkFBNCcsJ2duYXAnOidcXHUyQThBJywnZ25hcHByb3gnOidcXHUyQThBJywnZ25lJzonXFx1MkE4OCcsJ2duRSc6J1xcdTIyNjknLCdnbmVxJzonXFx1MkE4OCcsJ2duZXFxJzonXFx1MjI2OScsJ2duc2ltJzonXFx1MjJFNycsJ2dvcGYnOidcXHVEODM1XFx1REQ1OCcsJ0dvcGYnOidcXHVEODM1XFx1REQzRScsJ2dyYXZlJzonYCcsJ0dyZWF0ZXJFcXVhbCc6J1xcdTIyNjUnLCdHcmVhdGVyRXF1YWxMZXNzJzonXFx1MjJEQicsJ0dyZWF0ZXJGdWxsRXF1YWwnOidcXHUyMjY3JywnR3JlYXRlckdyZWF0ZXInOidcXHUyQUEyJywnR3JlYXRlckxlc3MnOidcXHUyMjc3JywnR3JlYXRlclNsYW50RXF1YWwnOidcXHUyQTdFJywnR3JlYXRlclRpbGRlJzonXFx1MjI3MycsJ2dzY3InOidcXHUyMTBBJywnR3Njcic6J1xcdUQ4MzVcXHVEQ0EyJywnZ3NpbSc6J1xcdTIyNzMnLCdnc2ltZSc6J1xcdTJBOEUnLCdnc2ltbCc6J1xcdTJBOTAnLCdndCc6Jz4nLCdHdCc6J1xcdTIyNkInLCdHVCc6Jz4nLCdndGNjJzonXFx1MkFBNycsJ2d0Y2lyJzonXFx1MkE3QScsJ2d0ZG90JzonXFx1MjJENycsJ2d0bFBhcic6J1xcdTI5OTUnLCdndHF1ZXN0JzonXFx1MkE3QycsJ2d0cmFwcHJveCc6J1xcdTJBODYnLCdndHJhcnInOidcXHUyOTc4JywnZ3RyZG90JzonXFx1MjJENycsJ2d0cmVxbGVzcyc6J1xcdTIyREInLCdndHJlcXFsZXNzJzonXFx1MkE4QycsJ2d0cmxlc3MnOidcXHUyMjc3JywnZ3Ryc2ltJzonXFx1MjI3MycsJ2d2ZXJ0bmVxcSc6J1xcdTIyNjlcXHVGRTAwJywnZ3ZuRSc6J1xcdTIyNjlcXHVGRTAwJywnSGFjZWsnOidcXHUwMkM3JywnaGFpcnNwJzonXFx1MjAwQScsJ2hhbGYnOidcXHhCRCcsJ2hhbWlsdCc6J1xcdTIxMEInLCdoYXJkY3knOidcXHUwNDRBJywnSEFSRGN5JzonXFx1MDQyQScsJ2hhcnInOidcXHUyMTk0JywnaEFycic6J1xcdTIxRDQnLCdoYXJyY2lyJzonXFx1Mjk0OCcsJ2hhcnJ3JzonXFx1MjFBRCcsJ0hhdCc6J14nLCdoYmFyJzonXFx1MjEwRicsJ2hjaXJjJzonXFx1MDEyNScsJ0hjaXJjJzonXFx1MDEyNCcsJ2hlYXJ0cyc6J1xcdTI2NjUnLCdoZWFydHN1aXQnOidcXHUyNjY1JywnaGVsbGlwJzonXFx1MjAyNicsJ2hlcmNvbic6J1xcdTIyQjknLCdoZnInOidcXHVEODM1XFx1REQyNScsJ0hmcic6J1xcdTIxMEMnLCdIaWxiZXJ0U3BhY2UnOidcXHUyMTBCJywnaGtzZWFyb3cnOidcXHUyOTI1JywnaGtzd2Fyb3cnOidcXHUyOTI2JywnaG9hcnInOidcXHUyMUZGJywnaG9tdGh0JzonXFx1MjIzQicsJ2hvb2tsZWZ0YXJyb3cnOidcXHUyMUE5JywnaG9va3JpZ2h0YXJyb3cnOidcXHUyMUFBJywnaG9wZic6J1xcdUQ4MzVcXHVERDU5JywnSG9wZic6J1xcdTIxMEQnLCdob3JiYXInOidcXHUyMDE1JywnSG9yaXpvbnRhbExpbmUnOidcXHUyNTAwJywnaHNjcic6J1xcdUQ4MzVcXHVEQ0JEJywnSHNjcic6J1xcdTIxMEInLCdoc2xhc2gnOidcXHUyMTBGJywnaHN0cm9rJzonXFx1MDEyNycsJ0hzdHJvayc6J1xcdTAxMjYnLCdIdW1wRG93bkh1bXAnOidcXHUyMjRFJywnSHVtcEVxdWFsJzonXFx1MjI0RicsJ2h5YnVsbCc6J1xcdTIwNDMnLCdoeXBoZW4nOidcXHUyMDEwJywnaWFjdXRlJzonXFx4RUQnLCdJYWN1dGUnOidcXHhDRCcsJ2ljJzonXFx1MjA2MycsJ2ljaXJjJzonXFx4RUUnLCdJY2lyYyc6J1xceENFJywnaWN5JzonXFx1MDQzOCcsJ0ljeSc6J1xcdTA0MTgnLCdJZG90JzonXFx1MDEzMCcsJ2llY3knOidcXHUwNDM1JywnSUVjeSc6J1xcdTA0MTUnLCdpZXhjbCc6J1xceEExJywnaWZmJzonXFx1MjFENCcsJ2lmcic6J1xcdUQ4MzVcXHVERDI2JywnSWZyJzonXFx1MjExMScsJ2lncmF2ZSc6J1xceEVDJywnSWdyYXZlJzonXFx4Q0MnLCdpaSc6J1xcdTIxNDgnLCdpaWlpbnQnOidcXHUyQTBDJywnaWlpbnQnOidcXHUyMjJEJywnaWluZmluJzonXFx1MjlEQycsJ2lpb3RhJzonXFx1MjEyOScsJ2lqbGlnJzonXFx1MDEzMycsJ0lKbGlnJzonXFx1MDEzMicsJ0ltJzonXFx1MjExMScsJ2ltYWNyJzonXFx1MDEyQicsJ0ltYWNyJzonXFx1MDEyQScsJ2ltYWdlJzonXFx1MjExMScsJ0ltYWdpbmFyeUknOidcXHUyMTQ4JywnaW1hZ2xpbmUnOidcXHUyMTEwJywnaW1hZ3BhcnQnOidcXHUyMTExJywnaW1hdGgnOidcXHUwMTMxJywnaW1vZic6J1xcdTIyQjcnLCdpbXBlZCc6J1xcdTAxQjUnLCdJbXBsaWVzJzonXFx1MjFEMicsJ2luJzonXFx1MjIwOCcsJ2luY2FyZSc6J1xcdTIxMDUnLCdpbmZpbic6J1xcdTIyMUUnLCdpbmZpbnRpZSc6J1xcdTI5REQnLCdpbm9kb3QnOidcXHUwMTMxJywnaW50JzonXFx1MjIyQicsJ0ludCc6J1xcdTIyMkMnLCdpbnRjYWwnOidcXHUyMkJBJywnaW50ZWdlcnMnOidcXHUyMTI0JywnSW50ZWdyYWwnOidcXHUyMjJCJywnaW50ZXJjYWwnOidcXHUyMkJBJywnSW50ZXJzZWN0aW9uJzonXFx1MjJDMicsJ2ludGxhcmhrJzonXFx1MkExNycsJ2ludHByb2QnOidcXHUyQTNDJywnSW52aXNpYmxlQ29tbWEnOidcXHUyMDYzJywnSW52aXNpYmxlVGltZXMnOidcXHUyMDYyJywnaW9jeSc6J1xcdTA0NTEnLCdJT2N5JzonXFx1MDQwMScsJ2lvZ29uJzonXFx1MDEyRicsJ0lvZ29uJzonXFx1MDEyRScsJ2lvcGYnOidcXHVEODM1XFx1REQ1QScsJ0lvcGYnOidcXHVEODM1XFx1REQ0MCcsJ2lvdGEnOidcXHUwM0I5JywnSW90YSc6J1xcdTAzOTknLCdpcHJvZCc6J1xcdTJBM0MnLCdpcXVlc3QnOidcXHhCRicsJ2lzY3InOidcXHVEODM1XFx1RENCRScsJ0lzY3InOidcXHUyMTEwJywnaXNpbic6J1xcdTIyMDgnLCdpc2luZG90JzonXFx1MjJGNScsJ2lzaW5FJzonXFx1MjJGOScsJ2lzaW5zJzonXFx1MjJGNCcsJ2lzaW5zdic6J1xcdTIyRjMnLCdpc2ludic6J1xcdTIyMDgnLCdpdCc6J1xcdTIwNjInLCdpdGlsZGUnOidcXHUwMTI5JywnSXRpbGRlJzonXFx1MDEyOCcsJ2l1a2N5JzonXFx1MDQ1NicsJ0l1a2N5JzonXFx1MDQwNicsJ2l1bWwnOidcXHhFRicsJ0l1bWwnOidcXHhDRicsJ2pjaXJjJzonXFx1MDEzNScsJ0pjaXJjJzonXFx1MDEzNCcsJ2pjeSc6J1xcdTA0MzknLCdKY3knOidcXHUwNDE5JywnamZyJzonXFx1RDgzNVxcdUREMjcnLCdKZnInOidcXHVEODM1XFx1REQwRCcsJ2ptYXRoJzonXFx1MDIzNycsJ2pvcGYnOidcXHVEODM1XFx1REQ1QicsJ0pvcGYnOidcXHVEODM1XFx1REQ0MScsJ2pzY3InOidcXHVEODM1XFx1RENCRicsJ0pzY3InOidcXHVEODM1XFx1RENBNScsJ2pzZXJjeSc6J1xcdTA0NTgnLCdKc2VyY3knOidcXHUwNDA4JywnanVrY3knOidcXHUwNDU0JywnSnVrY3knOidcXHUwNDA0Jywna2FwcGEnOidcXHUwM0JBJywnS2FwcGEnOidcXHUwMzlBJywna2FwcGF2JzonXFx1MDNGMCcsJ2tjZWRpbCc6J1xcdTAxMzcnLCdLY2VkaWwnOidcXHUwMTM2Jywna2N5JzonXFx1MDQzQScsJ0tjeSc6J1xcdTA0MUEnLCdrZnInOidcXHVEODM1XFx1REQyOCcsJ0tmcic6J1xcdUQ4MzVcXHVERDBFJywna2dyZWVuJzonXFx1MDEzOCcsJ2toY3knOidcXHUwNDQ1JywnS0hjeSc6J1xcdTA0MjUnLCdramN5JzonXFx1MDQ1QycsJ0tKY3knOidcXHUwNDBDJywna29wZic6J1xcdUQ4MzVcXHVERDVDJywnS29wZic6J1xcdUQ4MzVcXHVERDQyJywna3Njcic6J1xcdUQ4MzVcXHVEQ0MwJywnS3Njcic6J1xcdUQ4MzVcXHVEQ0E2JywnbEFhcnInOidcXHUyMURBJywnbGFjdXRlJzonXFx1MDEzQScsJ0xhY3V0ZSc6J1xcdTAxMzknLCdsYWVtcHR5dic6J1xcdTI5QjQnLCdsYWdyYW4nOidcXHUyMTEyJywnbGFtYmRhJzonXFx1MDNCQicsJ0xhbWJkYSc6J1xcdTAzOUInLCdsYW5nJzonXFx1MjdFOCcsJ0xhbmcnOidcXHUyN0VBJywnbGFuZ2QnOidcXHUyOTkxJywnbGFuZ2xlJzonXFx1MjdFOCcsJ2xhcCc6J1xcdTJBODUnLCdMYXBsYWNldHJmJzonXFx1MjExMicsJ2xhcXVvJzonXFx4QUInLCdsYXJyJzonXFx1MjE5MCcsJ2xBcnInOidcXHUyMUQwJywnTGFycic6J1xcdTIxOUUnLCdsYXJyYic6J1xcdTIxRTQnLCdsYXJyYmZzJzonXFx1MjkxRicsJ2xhcnJmcyc6J1xcdTI5MUQnLCdsYXJyaGsnOidcXHUyMUE5JywnbGFycmxwJzonXFx1MjFBQicsJ2xhcnJwbCc6J1xcdTI5MzknLCdsYXJyc2ltJzonXFx1Mjk3MycsJ2xhcnJ0bCc6J1xcdTIxQTInLCdsYXQnOidcXHUyQUFCJywnbGF0YWlsJzonXFx1MjkxOScsJ2xBdGFpbCc6J1xcdTI5MUInLCdsYXRlJzonXFx1MkFBRCcsJ2xhdGVzJzonXFx1MkFBRFxcdUZFMDAnLCdsYmFycic6J1xcdTI5MEMnLCdsQmFycic6J1xcdTI5MEUnLCdsYmJyayc6J1xcdTI3NzInLCdsYnJhY2UnOid7JywnbGJyYWNrJzonWycsJ2xicmtlJzonXFx1Mjk4QicsJ2xicmtzbGQnOidcXHUyOThGJywnbGJya3NsdSc6J1xcdTI5OEQnLCdsY2Fyb24nOidcXHUwMTNFJywnTGNhcm9uJzonXFx1MDEzRCcsJ2xjZWRpbCc6J1xcdTAxM0MnLCdMY2VkaWwnOidcXHUwMTNCJywnbGNlaWwnOidcXHUyMzA4JywnbGN1Yic6J3snLCdsY3knOidcXHUwNDNCJywnTGN5JzonXFx1MDQxQicsJ2xkY2EnOidcXHUyOTM2JywnbGRxdW8nOidcXHUyMDFDJywnbGRxdW9yJzonXFx1MjAxRScsJ2xkcmRoYXInOidcXHUyOTY3JywnbGRydXNoYXInOidcXHUyOTRCJywnbGRzaCc6J1xcdTIxQjInLCdsZSc6J1xcdTIyNjQnLCdsRSc6J1xcdTIyNjYnLCdMZWZ0QW5nbGVCcmFja2V0JzonXFx1MjdFOCcsJ2xlZnRhcnJvdyc6J1xcdTIxOTAnLCdMZWZ0YXJyb3cnOidcXHUyMUQwJywnTGVmdEFycm93JzonXFx1MjE5MCcsJ0xlZnRBcnJvd0Jhcic6J1xcdTIxRTQnLCdMZWZ0QXJyb3dSaWdodEFycm93JzonXFx1MjFDNicsJ2xlZnRhcnJvd3RhaWwnOidcXHUyMUEyJywnTGVmdENlaWxpbmcnOidcXHUyMzA4JywnTGVmdERvdWJsZUJyYWNrZXQnOidcXHUyN0U2JywnTGVmdERvd25UZWVWZWN0b3InOidcXHUyOTYxJywnTGVmdERvd25WZWN0b3InOidcXHUyMUMzJywnTGVmdERvd25WZWN0b3JCYXInOidcXHUyOTU5JywnTGVmdEZsb29yJzonXFx1MjMwQScsJ2xlZnRoYXJwb29uZG93bic6J1xcdTIxQkQnLCdsZWZ0aGFycG9vbnVwJzonXFx1MjFCQycsJ2xlZnRsZWZ0YXJyb3dzJzonXFx1MjFDNycsJ2xlZnRyaWdodGFycm93JzonXFx1MjE5NCcsJ0xlZnRyaWdodGFycm93JzonXFx1MjFENCcsJ0xlZnRSaWdodEFycm93JzonXFx1MjE5NCcsJ2xlZnRyaWdodGFycm93cyc6J1xcdTIxQzYnLCdsZWZ0cmlnaHRoYXJwb29ucyc6J1xcdTIxQ0InLCdsZWZ0cmlnaHRzcXVpZ2Fycm93JzonXFx1MjFBRCcsJ0xlZnRSaWdodFZlY3Rvcic6J1xcdTI5NEUnLCdMZWZ0VGVlJzonXFx1MjJBMycsJ0xlZnRUZWVBcnJvdyc6J1xcdTIxQTQnLCdMZWZ0VGVlVmVjdG9yJzonXFx1Mjk1QScsJ2xlZnR0aHJlZXRpbWVzJzonXFx1MjJDQicsJ0xlZnRUcmlhbmdsZSc6J1xcdTIyQjInLCdMZWZ0VHJpYW5nbGVCYXInOidcXHUyOUNGJywnTGVmdFRyaWFuZ2xlRXF1YWwnOidcXHUyMkI0JywnTGVmdFVwRG93blZlY3Rvcic6J1xcdTI5NTEnLCdMZWZ0VXBUZWVWZWN0b3InOidcXHUyOTYwJywnTGVmdFVwVmVjdG9yJzonXFx1MjFCRicsJ0xlZnRVcFZlY3RvckJhcic6J1xcdTI5NTgnLCdMZWZ0VmVjdG9yJzonXFx1MjFCQycsJ0xlZnRWZWN0b3JCYXInOidcXHUyOTUyJywnbGVnJzonXFx1MjJEQScsJ2xFZyc6J1xcdTJBOEInLCdsZXEnOidcXHUyMjY0JywnbGVxcSc6J1xcdTIyNjYnLCdsZXFzbGFudCc6J1xcdTJBN0QnLCdsZXMnOidcXHUyQTdEJywnbGVzY2MnOidcXHUyQUE4JywnbGVzZG90JzonXFx1MkE3RicsJ2xlc2RvdG8nOidcXHUyQTgxJywnbGVzZG90b3InOidcXHUyQTgzJywnbGVzZyc6J1xcdTIyREFcXHVGRTAwJywnbGVzZ2VzJzonXFx1MkE5MycsJ2xlc3NhcHByb3gnOidcXHUyQTg1JywnbGVzc2RvdCc6J1xcdTIyRDYnLCdsZXNzZXFndHInOidcXHUyMkRBJywnbGVzc2VxcWd0cic6J1xcdTJBOEInLCdMZXNzRXF1YWxHcmVhdGVyJzonXFx1MjJEQScsJ0xlc3NGdWxsRXF1YWwnOidcXHUyMjY2JywnTGVzc0dyZWF0ZXInOidcXHUyMjc2JywnbGVzc2d0cic6J1xcdTIyNzYnLCdMZXNzTGVzcyc6J1xcdTJBQTEnLCdsZXNzc2ltJzonXFx1MjI3MicsJ0xlc3NTbGFudEVxdWFsJzonXFx1MkE3RCcsJ0xlc3NUaWxkZSc6J1xcdTIyNzInLCdsZmlzaHQnOidcXHUyOTdDJywnbGZsb29yJzonXFx1MjMwQScsJ2xmcic6J1xcdUQ4MzVcXHVERDI5JywnTGZyJzonXFx1RDgzNVxcdUREMEYnLCdsZyc6J1xcdTIyNzYnLCdsZ0UnOidcXHUyQTkxJywnbEhhcic6J1xcdTI5NjInLCdsaGFyZCc6J1xcdTIxQkQnLCdsaGFydSc6J1xcdTIxQkMnLCdsaGFydWwnOidcXHUyOTZBJywnbGhibGsnOidcXHUyNTg0JywnbGpjeSc6J1xcdTA0NTknLCdMSmN5JzonXFx1MDQwOScsJ2xsJzonXFx1MjI2QScsJ0xsJzonXFx1MjJEOCcsJ2xsYXJyJzonXFx1MjFDNycsJ2xsY29ybmVyJzonXFx1MjMxRScsJ0xsZWZ0YXJyb3cnOidcXHUyMURBJywnbGxoYXJkJzonXFx1Mjk2QicsJ2xsdHJpJzonXFx1MjVGQScsJ2xtaWRvdCc6J1xcdTAxNDAnLCdMbWlkb3QnOidcXHUwMTNGJywnbG1vdXN0JzonXFx1MjNCMCcsJ2xtb3VzdGFjaGUnOidcXHUyM0IwJywnbG5hcCc6J1xcdTJBODknLCdsbmFwcHJveCc6J1xcdTJBODknLCdsbmUnOidcXHUyQTg3JywnbG5FJzonXFx1MjI2OCcsJ2xuZXEnOidcXHUyQTg3JywnbG5lcXEnOidcXHUyMjY4JywnbG5zaW0nOidcXHUyMkU2JywnbG9hbmcnOidcXHUyN0VDJywnbG9hcnInOidcXHUyMUZEJywnbG9icmsnOidcXHUyN0U2JywnbG9uZ2xlZnRhcnJvdyc6J1xcdTI3RjUnLCdMb25nbGVmdGFycm93JzonXFx1MjdGOCcsJ0xvbmdMZWZ0QXJyb3cnOidcXHUyN0Y1JywnbG9uZ2xlZnRyaWdodGFycm93JzonXFx1MjdGNycsJ0xvbmdsZWZ0cmlnaHRhcnJvdyc6J1xcdTI3RkEnLCdMb25nTGVmdFJpZ2h0QXJyb3cnOidcXHUyN0Y3JywnbG9uZ21hcHN0byc6J1xcdTI3RkMnLCdsb25ncmlnaHRhcnJvdyc6J1xcdTI3RjYnLCdMb25ncmlnaHRhcnJvdyc6J1xcdTI3RjknLCdMb25nUmlnaHRBcnJvdyc6J1xcdTI3RjYnLCdsb29wYXJyb3dsZWZ0JzonXFx1MjFBQicsJ2xvb3BhcnJvd3JpZ2h0JzonXFx1MjFBQycsJ2xvcGFyJzonXFx1Mjk4NScsJ2xvcGYnOidcXHVEODM1XFx1REQ1RCcsJ0xvcGYnOidcXHVEODM1XFx1REQ0MycsJ2xvcGx1cyc6J1xcdTJBMkQnLCdsb3RpbWVzJzonXFx1MkEzNCcsJ2xvd2FzdCc6J1xcdTIyMTcnLCdsb3diYXInOidfJywnTG93ZXJMZWZ0QXJyb3cnOidcXHUyMTk5JywnTG93ZXJSaWdodEFycm93JzonXFx1MjE5OCcsJ2xveic6J1xcdTI1Q0EnLCdsb3plbmdlJzonXFx1MjVDQScsJ2xvemYnOidcXHUyOUVCJywnbHBhcic6JygnLCdscGFybHQnOidcXHUyOTkzJywnbHJhcnInOidcXHUyMUM2JywnbHJjb3JuZXInOidcXHUyMzFGJywnbHJoYXInOidcXHUyMUNCJywnbHJoYXJkJzonXFx1Mjk2RCcsJ2xybSc6J1xcdTIwMEUnLCdscnRyaSc6J1xcdTIyQkYnLCdsc2FxdW8nOidcXHUyMDM5JywnbHNjcic6J1xcdUQ4MzVcXHVEQ0MxJywnTHNjcic6J1xcdTIxMTInLCdsc2gnOidcXHUyMUIwJywnTHNoJzonXFx1MjFCMCcsJ2xzaW0nOidcXHUyMjcyJywnbHNpbWUnOidcXHUyQThEJywnbHNpbWcnOidcXHUyQThGJywnbHNxYic6J1snLCdsc3F1byc6J1xcdTIwMTgnLCdsc3F1b3InOidcXHUyMDFBJywnbHN0cm9rJzonXFx1MDE0MicsJ0xzdHJvayc6J1xcdTAxNDEnLCdsdCc6JzwnLCdMdCc6J1xcdTIyNkEnLCdMVCc6JzwnLCdsdGNjJzonXFx1MkFBNicsJ2x0Y2lyJzonXFx1MkE3OScsJ2x0ZG90JzonXFx1MjJENicsJ2x0aHJlZSc6J1xcdTIyQ0InLCdsdGltZXMnOidcXHUyMkM5JywnbHRsYXJyJzonXFx1Mjk3NicsJ2x0cXVlc3QnOidcXHUyQTdCJywnbHRyaSc6J1xcdTI1QzMnLCdsdHJpZSc6J1xcdTIyQjQnLCdsdHJpZic6J1xcdTI1QzInLCdsdHJQYXInOidcXHUyOTk2JywnbHVyZHNoYXInOidcXHUyOTRBJywnbHVydWhhcic6J1xcdTI5NjYnLCdsdmVydG5lcXEnOidcXHUyMjY4XFx1RkUwMCcsJ2x2bkUnOidcXHUyMjY4XFx1RkUwMCcsJ21hY3InOidcXHhBRicsJ21hbGUnOidcXHUyNjQyJywnbWFsdCc6J1xcdTI3MjAnLCdtYWx0ZXNlJzonXFx1MjcyMCcsJ21hcCc6J1xcdTIxQTYnLCdNYXAnOidcXHUyOTA1JywnbWFwc3RvJzonXFx1MjFBNicsJ21hcHN0b2Rvd24nOidcXHUyMUE3JywnbWFwc3RvbGVmdCc6J1xcdTIxQTQnLCdtYXBzdG91cCc6J1xcdTIxQTUnLCdtYXJrZXInOidcXHUyNUFFJywnbWNvbW1hJzonXFx1MkEyOScsJ21jeSc6J1xcdTA0M0MnLCdNY3knOidcXHUwNDFDJywnbWRhc2gnOidcXHUyMDE0JywnbUREb3QnOidcXHUyMjNBJywnbWVhc3VyZWRhbmdsZSc6J1xcdTIyMjEnLCdNZWRpdW1TcGFjZSc6J1xcdTIwNUYnLCdNZWxsaW50cmYnOidcXHUyMTMzJywnbWZyJzonXFx1RDgzNVxcdUREMkEnLCdNZnInOidcXHVEODM1XFx1REQxMCcsJ21obyc6J1xcdTIxMjcnLCdtaWNybyc6J1xceEI1JywnbWlkJzonXFx1MjIyMycsJ21pZGFzdCc6JyonLCdtaWRjaXInOidcXHUyQUYwJywnbWlkZG90JzonXFx4QjcnLCdtaW51cyc6J1xcdTIyMTInLCdtaW51c2InOidcXHUyMjlGJywnbWludXNkJzonXFx1MjIzOCcsJ21pbnVzZHUnOidcXHUyQTJBJywnTWludXNQbHVzJzonXFx1MjIxMycsJ21sY3AnOidcXHUyQURCJywnbWxkcic6J1xcdTIwMjYnLCdtbnBsdXMnOidcXHUyMjEzJywnbW9kZWxzJzonXFx1MjJBNycsJ21vcGYnOidcXHVEODM1XFx1REQ1RScsJ01vcGYnOidcXHVEODM1XFx1REQ0NCcsJ21wJzonXFx1MjIxMycsJ21zY3InOidcXHVEODM1XFx1RENDMicsJ01zY3InOidcXHUyMTMzJywnbXN0cG9zJzonXFx1MjIzRScsJ211JzonXFx1MDNCQycsJ011JzonXFx1MDM5QycsJ211bHRpbWFwJzonXFx1MjJCOCcsJ211bWFwJzonXFx1MjJCOCcsJ25hYmxhJzonXFx1MjIwNycsJ25hY3V0ZSc6J1xcdTAxNDQnLCdOYWN1dGUnOidcXHUwMTQzJywnbmFuZyc6J1xcdTIyMjBcXHUyMEQyJywnbmFwJzonXFx1MjI0OScsJ25hcEUnOidcXHUyQTcwXFx1MDMzOCcsJ25hcGlkJzonXFx1MjI0QlxcdTAzMzgnLCduYXBvcyc6J1xcdTAxNDknLCduYXBwcm94JzonXFx1MjI0OScsJ25hdHVyJzonXFx1MjY2RScsJ25hdHVyYWwnOidcXHUyNjZFJywnbmF0dXJhbHMnOidcXHUyMTE1JywnbmJzcCc6J1xceEEwJywnbmJ1bXAnOidcXHUyMjRFXFx1MDMzOCcsJ25idW1wZSc6J1xcdTIyNEZcXHUwMzM4JywnbmNhcCc6J1xcdTJBNDMnLCduY2Fyb24nOidcXHUwMTQ4JywnTmNhcm9uJzonXFx1MDE0NycsJ25jZWRpbCc6J1xcdTAxNDYnLCdOY2VkaWwnOidcXHUwMTQ1JywnbmNvbmcnOidcXHUyMjQ3JywnbmNvbmdkb3QnOidcXHUyQTZEXFx1MDMzOCcsJ25jdXAnOidcXHUyQTQyJywnbmN5JzonXFx1MDQzRCcsJ05jeSc6J1xcdTA0MUQnLCduZGFzaCc6J1xcdTIwMTMnLCduZSc6J1xcdTIyNjAnLCduZWFyaGsnOidcXHUyOTI0JywnbmVhcnInOidcXHUyMTk3JywnbmVBcnInOidcXHUyMUQ3JywnbmVhcnJvdyc6J1xcdTIxOTcnLCduZWRvdCc6J1xcdTIyNTBcXHUwMzM4JywnTmVnYXRpdmVNZWRpdW1TcGFjZSc6J1xcdTIwMEInLCdOZWdhdGl2ZVRoaWNrU3BhY2UnOidcXHUyMDBCJywnTmVnYXRpdmVUaGluU3BhY2UnOidcXHUyMDBCJywnTmVnYXRpdmVWZXJ5VGhpblNwYWNlJzonXFx1MjAwQicsJ25lcXVpdic6J1xcdTIyNjInLCduZXNlYXInOidcXHUyOTI4JywnbmVzaW0nOidcXHUyMjQyXFx1MDMzOCcsJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJzonXFx1MjI2QicsJ05lc3RlZExlc3NMZXNzJzonXFx1MjI2QScsJ05ld0xpbmUnOidcXG4nLCduZXhpc3QnOidcXHUyMjA0JywnbmV4aXN0cyc6J1xcdTIyMDQnLCduZnInOidcXHVEODM1XFx1REQyQicsJ05mcic6J1xcdUQ4MzVcXHVERDExJywnbmdlJzonXFx1MjI3MScsJ25nRSc6J1xcdTIyNjdcXHUwMzM4JywnbmdlcSc6J1xcdTIyNzEnLCduZ2VxcSc6J1xcdTIyNjdcXHUwMzM4JywnbmdlcXNsYW50JzonXFx1MkE3RVxcdTAzMzgnLCduZ2VzJzonXFx1MkE3RVxcdTAzMzgnLCduR2cnOidcXHUyMkQ5XFx1MDMzOCcsJ25nc2ltJzonXFx1MjI3NScsJ25ndCc6J1xcdTIyNkYnLCduR3QnOidcXHUyMjZCXFx1MjBEMicsJ25ndHInOidcXHUyMjZGJywnbkd0dic6J1xcdTIyNkJcXHUwMzM4JywnbmhhcnInOidcXHUyMUFFJywnbmhBcnInOidcXHUyMUNFJywnbmhwYXInOidcXHUyQUYyJywnbmknOidcXHUyMjBCJywnbmlzJzonXFx1MjJGQycsJ25pc2QnOidcXHUyMkZBJywnbml2JzonXFx1MjIwQicsJ25qY3knOidcXHUwNDVBJywnTkpjeSc6J1xcdTA0MEEnLCdubGFycic6J1xcdTIxOUEnLCdubEFycic6J1xcdTIxQ0QnLCdubGRyJzonXFx1MjAyNScsJ25sZSc6J1xcdTIyNzAnLCdubEUnOidcXHUyMjY2XFx1MDMzOCcsJ25sZWZ0YXJyb3cnOidcXHUyMTlBJywnbkxlZnRhcnJvdyc6J1xcdTIxQ0QnLCdubGVmdHJpZ2h0YXJyb3cnOidcXHUyMUFFJywnbkxlZnRyaWdodGFycm93JzonXFx1MjFDRScsJ25sZXEnOidcXHUyMjcwJywnbmxlcXEnOidcXHUyMjY2XFx1MDMzOCcsJ25sZXFzbGFudCc6J1xcdTJBN0RcXHUwMzM4Jywnbmxlcyc6J1xcdTJBN0RcXHUwMzM4Jywnbmxlc3MnOidcXHUyMjZFJywnbkxsJzonXFx1MjJEOFxcdTAzMzgnLCdubHNpbSc6J1xcdTIyNzQnLCdubHQnOidcXHUyMjZFJywnbkx0JzonXFx1MjI2QVxcdTIwRDInLCdubHRyaSc6J1xcdTIyRUEnLCdubHRyaWUnOidcXHUyMkVDJywnbkx0dic6J1xcdTIyNkFcXHUwMzM4Jywnbm1pZCc6J1xcdTIyMjQnLCdOb0JyZWFrJzonXFx1MjA2MCcsJ05vbkJyZWFraW5nU3BhY2UnOidcXHhBMCcsJ25vcGYnOidcXHVEODM1XFx1REQ1RicsJ05vcGYnOidcXHUyMTE1Jywnbm90JzonXFx4QUMnLCdOb3QnOidcXHUyQUVDJywnTm90Q29uZ3J1ZW50JzonXFx1MjI2MicsJ05vdEN1cENhcCc6J1xcdTIyNkQnLCdOb3REb3VibGVWZXJ0aWNhbEJhcic6J1xcdTIyMjYnLCdOb3RFbGVtZW50JzonXFx1MjIwOScsJ05vdEVxdWFsJzonXFx1MjI2MCcsJ05vdEVxdWFsVGlsZGUnOidcXHUyMjQyXFx1MDMzOCcsJ05vdEV4aXN0cyc6J1xcdTIyMDQnLCdOb3RHcmVhdGVyJzonXFx1MjI2RicsJ05vdEdyZWF0ZXJFcXVhbCc6J1xcdTIyNzEnLCdOb3RHcmVhdGVyRnVsbEVxdWFsJzonXFx1MjI2N1xcdTAzMzgnLCdOb3RHcmVhdGVyR3JlYXRlcic6J1xcdTIyNkJcXHUwMzM4JywnTm90R3JlYXRlckxlc3MnOidcXHUyMjc5JywnTm90R3JlYXRlclNsYW50RXF1YWwnOidcXHUyQTdFXFx1MDMzOCcsJ05vdEdyZWF0ZXJUaWxkZSc6J1xcdTIyNzUnLCdOb3RIdW1wRG93bkh1bXAnOidcXHUyMjRFXFx1MDMzOCcsJ05vdEh1bXBFcXVhbCc6J1xcdTIyNEZcXHUwMzM4Jywnbm90aW4nOidcXHUyMjA5Jywnbm90aW5kb3QnOidcXHUyMkY1XFx1MDMzOCcsJ25vdGluRSc6J1xcdTIyRjlcXHUwMzM4Jywnbm90aW52YSc6J1xcdTIyMDknLCdub3RpbnZiJzonXFx1MjJGNycsJ25vdGludmMnOidcXHUyMkY2JywnTm90TGVmdFRyaWFuZ2xlJzonXFx1MjJFQScsJ05vdExlZnRUcmlhbmdsZUJhcic6J1xcdTI5Q0ZcXHUwMzM4JywnTm90TGVmdFRyaWFuZ2xlRXF1YWwnOidcXHUyMkVDJywnTm90TGVzcyc6J1xcdTIyNkUnLCdOb3RMZXNzRXF1YWwnOidcXHUyMjcwJywnTm90TGVzc0dyZWF0ZXInOidcXHUyMjc4JywnTm90TGVzc0xlc3MnOidcXHUyMjZBXFx1MDMzOCcsJ05vdExlc3NTbGFudEVxdWFsJzonXFx1MkE3RFxcdTAzMzgnLCdOb3RMZXNzVGlsZGUnOidcXHUyMjc0JywnTm90TmVzdGVkR3JlYXRlckdyZWF0ZXInOidcXHUyQUEyXFx1MDMzOCcsJ05vdE5lc3RlZExlc3NMZXNzJzonXFx1MkFBMVxcdTAzMzgnLCdub3RuaSc6J1xcdTIyMEMnLCdub3RuaXZhJzonXFx1MjIwQycsJ25vdG5pdmInOidcXHUyMkZFJywnbm90bml2Yyc6J1xcdTIyRkQnLCdOb3RQcmVjZWRlcyc6J1xcdTIyODAnLCdOb3RQcmVjZWRlc0VxdWFsJzonXFx1MkFBRlxcdTAzMzgnLCdOb3RQcmVjZWRlc1NsYW50RXF1YWwnOidcXHUyMkUwJywnTm90UmV2ZXJzZUVsZW1lbnQnOidcXHUyMjBDJywnTm90UmlnaHRUcmlhbmdsZSc6J1xcdTIyRUInLCdOb3RSaWdodFRyaWFuZ2xlQmFyJzonXFx1MjlEMFxcdTAzMzgnLCdOb3RSaWdodFRyaWFuZ2xlRXF1YWwnOidcXHUyMkVEJywnTm90U3F1YXJlU3Vic2V0JzonXFx1MjI4RlxcdTAzMzgnLCdOb3RTcXVhcmVTdWJzZXRFcXVhbCc6J1xcdTIyRTInLCdOb3RTcXVhcmVTdXBlcnNldCc6J1xcdTIyOTBcXHUwMzM4JywnTm90U3F1YXJlU3VwZXJzZXRFcXVhbCc6J1xcdTIyRTMnLCdOb3RTdWJzZXQnOidcXHUyMjgyXFx1MjBEMicsJ05vdFN1YnNldEVxdWFsJzonXFx1MjI4OCcsJ05vdFN1Y2NlZWRzJzonXFx1MjI4MScsJ05vdFN1Y2NlZWRzRXF1YWwnOidcXHUyQUIwXFx1MDMzOCcsJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcdTIyRTEnLCdOb3RTdWNjZWVkc1RpbGRlJzonXFx1MjI3RlxcdTAzMzgnLCdOb3RTdXBlcnNldCc6J1xcdTIyODNcXHUyMEQyJywnTm90U3VwZXJzZXRFcXVhbCc6J1xcdTIyODknLCdOb3RUaWxkZSc6J1xcdTIyNDEnLCdOb3RUaWxkZUVxdWFsJzonXFx1MjI0NCcsJ05vdFRpbGRlRnVsbEVxdWFsJzonXFx1MjI0NycsJ05vdFRpbGRlVGlsZGUnOidcXHUyMjQ5JywnTm90VmVydGljYWxCYXInOidcXHUyMjI0JywnbnBhcic6J1xcdTIyMjYnLCducGFyYWxsZWwnOidcXHUyMjI2JywnbnBhcnNsJzonXFx1MkFGRFxcdTIwRTUnLCducGFydCc6J1xcdTIyMDJcXHUwMzM4JywnbnBvbGludCc6J1xcdTJBMTQnLCducHInOidcXHUyMjgwJywnbnByY3VlJzonXFx1MjJFMCcsJ25wcmUnOidcXHUyQUFGXFx1MDMzOCcsJ25wcmVjJzonXFx1MjI4MCcsJ25wcmVjZXEnOidcXHUyQUFGXFx1MDMzOCcsJ25yYXJyJzonXFx1MjE5QicsJ25yQXJyJzonXFx1MjFDRicsJ25yYXJyYyc6J1xcdTI5MzNcXHUwMzM4JywnbnJhcnJ3JzonXFx1MjE5RFxcdTAzMzgnLCducmlnaHRhcnJvdyc6J1xcdTIxOUInLCduUmlnaHRhcnJvdyc6J1xcdTIxQ0YnLCducnRyaSc6J1xcdTIyRUInLCducnRyaWUnOidcXHUyMkVEJywnbnNjJzonXFx1MjI4MScsJ25zY2N1ZSc6J1xcdTIyRTEnLCduc2NlJzonXFx1MkFCMFxcdTAzMzgnLCduc2NyJzonXFx1RDgzNVxcdURDQzMnLCdOc2NyJzonXFx1RDgzNVxcdURDQTknLCduc2hvcnRtaWQnOidcXHUyMjI0JywnbnNob3J0cGFyYWxsZWwnOidcXHUyMjI2JywnbnNpbSc6J1xcdTIyNDEnLCduc2ltZSc6J1xcdTIyNDQnLCduc2ltZXEnOidcXHUyMjQ0JywnbnNtaWQnOidcXHUyMjI0JywnbnNwYXInOidcXHUyMjI2JywnbnNxc3ViZSc6J1xcdTIyRTInLCduc3FzdXBlJzonXFx1MjJFMycsJ25zdWInOidcXHUyMjg0JywnbnN1YmUnOidcXHUyMjg4JywnbnN1YkUnOidcXHUyQUM1XFx1MDMzOCcsJ25zdWJzZXQnOidcXHUyMjgyXFx1MjBEMicsJ25zdWJzZXRlcSc6J1xcdTIyODgnLCduc3Vic2V0ZXFxJzonXFx1MkFDNVxcdTAzMzgnLCduc3VjYyc6J1xcdTIyODEnLCduc3VjY2VxJzonXFx1MkFCMFxcdTAzMzgnLCduc3VwJzonXFx1MjI4NScsJ25zdXBlJzonXFx1MjI4OScsJ25zdXBFJzonXFx1MkFDNlxcdTAzMzgnLCduc3Vwc2V0JzonXFx1MjI4M1xcdTIwRDInLCduc3Vwc2V0ZXEnOidcXHUyMjg5JywnbnN1cHNldGVxcSc6J1xcdTJBQzZcXHUwMzM4JywnbnRnbCc6J1xcdTIyNzknLCdudGlsZGUnOidcXHhGMScsJ050aWxkZSc6J1xceEQxJywnbnRsZyc6J1xcdTIyNzgnLCdudHJpYW5nbGVsZWZ0JzonXFx1MjJFQScsJ250cmlhbmdsZWxlZnRlcSc6J1xcdTIyRUMnLCdudHJpYW5nbGVyaWdodCc6J1xcdTIyRUInLCdudHJpYW5nbGVyaWdodGVxJzonXFx1MjJFRCcsJ251JzonXFx1MDNCRCcsJ051JzonXFx1MDM5RCcsJ251bSc6JyMnLCdudW1lcm8nOidcXHUyMTE2JywnbnVtc3AnOidcXHUyMDA3JywnbnZhcCc6J1xcdTIyNERcXHUyMEQyJywnbnZkYXNoJzonXFx1MjJBQycsJ252RGFzaCc6J1xcdTIyQUQnLCduVmRhc2gnOidcXHUyMkFFJywnblZEYXNoJzonXFx1MjJBRicsJ252Z2UnOidcXHUyMjY1XFx1MjBEMicsJ252Z3QnOic+XFx1MjBEMicsJ252SGFycic6J1xcdTI5MDQnLCdudmluZmluJzonXFx1MjlERScsJ252bEFycic6J1xcdTI5MDInLCdudmxlJzonXFx1MjI2NFxcdTIwRDInLCdudmx0JzonPFxcdTIwRDInLCdudmx0cmllJzonXFx1MjJCNFxcdTIwRDInLCdudnJBcnInOidcXHUyOTAzJywnbnZydHJpZSc6J1xcdTIyQjVcXHUyMEQyJywnbnZzaW0nOidcXHUyMjNDXFx1MjBEMicsJ253YXJoayc6J1xcdTI5MjMnLCdud2Fycic6J1xcdTIxOTYnLCdud0Fycic6J1xcdTIxRDYnLCdud2Fycm93JzonXFx1MjE5NicsJ253bmVhcic6J1xcdTI5MjcnLCdvYWN1dGUnOidcXHhGMycsJ09hY3V0ZSc6J1xceEQzJywnb2FzdCc6J1xcdTIyOUInLCdvY2lyJzonXFx1MjI5QScsJ29jaXJjJzonXFx4RjQnLCdPY2lyYyc6J1xceEQ0Jywnb2N5JzonXFx1MDQzRScsJ09jeSc6J1xcdTA0MUUnLCdvZGFzaCc6J1xcdTIyOUQnLCdvZGJsYWMnOidcXHUwMTUxJywnT2RibGFjJzonXFx1MDE1MCcsJ29kaXYnOidcXHUyQTM4Jywnb2RvdCc6J1xcdTIyOTknLCdvZHNvbGQnOidcXHUyOUJDJywnb2VsaWcnOidcXHUwMTUzJywnT0VsaWcnOidcXHUwMTUyJywnb2ZjaXInOidcXHUyOUJGJywnb2ZyJzonXFx1RDgzNVxcdUREMkMnLCdPZnInOidcXHVEODM1XFx1REQxMicsJ29nb24nOidcXHUwMkRCJywnb2dyYXZlJzonXFx4RjInLCdPZ3JhdmUnOidcXHhEMicsJ29ndCc6J1xcdTI5QzEnLCdvaGJhcic6J1xcdTI5QjUnLCdvaG0nOidcXHUwM0E5Jywnb2ludCc6J1xcdTIyMkUnLCdvbGFycic6J1xcdTIxQkEnLCdvbGNpcic6J1xcdTI5QkUnLCdvbGNyb3NzJzonXFx1MjlCQicsJ29saW5lJzonXFx1MjAzRScsJ29sdCc6J1xcdTI5QzAnLCdvbWFjcic6J1xcdTAxNEQnLCdPbWFjcic6J1xcdTAxNEMnLCdvbWVnYSc6J1xcdTAzQzknLCdPbWVnYSc6J1xcdTAzQTknLCdvbWljcm9uJzonXFx1MDNCRicsJ09taWNyb24nOidcXHUwMzlGJywnb21pZCc6J1xcdTI5QjYnLCdvbWludXMnOidcXHUyMjk2Jywnb29wZic6J1xcdUQ4MzVcXHVERDYwJywnT29wZic6J1xcdUQ4MzVcXHVERDQ2Jywnb3Bhcic6J1xcdTI5QjcnLCdPcGVuQ3VybHlEb3VibGVRdW90ZSc6J1xcdTIwMUMnLCdPcGVuQ3VybHlRdW90ZSc6J1xcdTIwMTgnLCdvcGVycCc6J1xcdTI5QjknLCdvcGx1cyc6J1xcdTIyOTUnLCdvcic6J1xcdTIyMjgnLCdPcic6J1xcdTJBNTQnLCdvcmFycic6J1xcdTIxQkInLCdvcmQnOidcXHUyQTVEJywnb3JkZXInOidcXHUyMTM0Jywnb3JkZXJvZic6J1xcdTIxMzQnLCdvcmRmJzonXFx4QUEnLCdvcmRtJzonXFx4QkEnLCdvcmlnb2YnOidcXHUyMkI2Jywnb3Jvcic6J1xcdTJBNTYnLCdvcnNsb3BlJzonXFx1MkE1NycsJ29ydic6J1xcdTJBNUInLCdvUyc6J1xcdTI0QzgnLCdvc2NyJzonXFx1MjEzNCcsJ09zY3InOidcXHVEODM1XFx1RENBQScsJ29zbGFzaCc6J1xceEY4JywnT3NsYXNoJzonXFx4RDgnLCdvc29sJzonXFx1MjI5OCcsJ290aWxkZSc6J1xceEY1JywnT3RpbGRlJzonXFx4RDUnLCdvdGltZXMnOidcXHUyMjk3JywnT3RpbWVzJzonXFx1MkEzNycsJ290aW1lc2FzJzonXFx1MkEzNicsJ291bWwnOidcXHhGNicsJ091bWwnOidcXHhENicsJ292YmFyJzonXFx1MjMzRCcsJ092ZXJCYXInOidcXHUyMDNFJywnT3ZlckJyYWNlJzonXFx1MjNERScsJ092ZXJCcmFja2V0JzonXFx1MjNCNCcsJ092ZXJQYXJlbnRoZXNpcyc6J1xcdTIzREMnLCdwYXInOidcXHUyMjI1JywncGFyYSc6J1xceEI2JywncGFyYWxsZWwnOidcXHUyMjI1JywncGFyc2ltJzonXFx1MkFGMycsJ3BhcnNsJzonXFx1MkFGRCcsJ3BhcnQnOidcXHUyMjAyJywnUGFydGlhbEQnOidcXHUyMjAyJywncGN5JzonXFx1MDQzRicsJ1BjeSc6J1xcdTA0MUYnLCdwZXJjbnQnOiclJywncGVyaW9kJzonLicsJ3Blcm1pbCc6J1xcdTIwMzAnLCdwZXJwJzonXFx1MjJBNScsJ3BlcnRlbmsnOidcXHUyMDMxJywncGZyJzonXFx1RDgzNVxcdUREMkQnLCdQZnInOidcXHVEODM1XFx1REQxMycsJ3BoaSc6J1xcdTAzQzYnLCdQaGknOidcXHUwM0E2JywncGhpdic6J1xcdTAzRDUnLCdwaG1tYXQnOidcXHUyMTMzJywncGhvbmUnOidcXHUyNjBFJywncGknOidcXHUwM0MwJywnUGknOidcXHUwM0EwJywncGl0Y2hmb3JrJzonXFx1MjJENCcsJ3Bpdic6J1xcdTAzRDYnLCdwbGFuY2snOidcXHUyMTBGJywncGxhbmNraCc6J1xcdTIxMEUnLCdwbGFua3YnOidcXHUyMTBGJywncGx1cyc6JysnLCdwbHVzYWNpcic6J1xcdTJBMjMnLCdwbHVzYic6J1xcdTIyOUUnLCdwbHVzY2lyJzonXFx1MkEyMicsJ3BsdXNkbyc6J1xcdTIyMTQnLCdwbHVzZHUnOidcXHUyQTI1JywncGx1c2UnOidcXHUyQTcyJywnUGx1c01pbnVzJzonXFx4QjEnLCdwbHVzbW4nOidcXHhCMScsJ3BsdXNzaW0nOidcXHUyQTI2JywncGx1c3R3byc6J1xcdTJBMjcnLCdwbSc6J1xceEIxJywnUG9pbmNhcmVwbGFuZSc6J1xcdTIxMEMnLCdwb2ludGludCc6J1xcdTJBMTUnLCdwb3BmJzonXFx1RDgzNVxcdURENjEnLCdQb3BmJzonXFx1MjExOScsJ3BvdW5kJzonXFx4QTMnLCdwcic6J1xcdTIyN0EnLCdQcic6J1xcdTJBQkInLCdwcmFwJzonXFx1MkFCNycsJ3ByY3VlJzonXFx1MjI3QycsJ3ByZSc6J1xcdTJBQUYnLCdwckUnOidcXHUyQUIzJywncHJlYyc6J1xcdTIyN0EnLCdwcmVjYXBwcm94JzonXFx1MkFCNycsJ3ByZWNjdXJseWVxJzonXFx1MjI3QycsJ1ByZWNlZGVzJzonXFx1MjI3QScsJ1ByZWNlZGVzRXF1YWwnOidcXHUyQUFGJywnUHJlY2VkZXNTbGFudEVxdWFsJzonXFx1MjI3QycsJ1ByZWNlZGVzVGlsZGUnOidcXHUyMjdFJywncHJlY2VxJzonXFx1MkFBRicsJ3ByZWNuYXBwcm94JzonXFx1MkFCOScsJ3ByZWNuZXFxJzonXFx1MkFCNScsJ3ByZWNuc2ltJzonXFx1MjJFOCcsJ3ByZWNzaW0nOidcXHUyMjdFJywncHJpbWUnOidcXHUyMDMyJywnUHJpbWUnOidcXHUyMDMzJywncHJpbWVzJzonXFx1MjExOScsJ3BybmFwJzonXFx1MkFCOScsJ3BybkUnOidcXHUyQUI1JywncHJuc2ltJzonXFx1MjJFOCcsJ3Byb2QnOidcXHUyMjBGJywnUHJvZHVjdCc6J1xcdTIyMEYnLCdwcm9mYWxhcic6J1xcdTIzMkUnLCdwcm9mbGluZSc6J1xcdTIzMTInLCdwcm9mc3VyZic6J1xcdTIzMTMnLCdwcm9wJzonXFx1MjIxRCcsJ1Byb3BvcnRpb24nOidcXHUyMjM3JywnUHJvcG9ydGlvbmFsJzonXFx1MjIxRCcsJ3Byb3B0byc6J1xcdTIyMUQnLCdwcnNpbSc6J1xcdTIyN0UnLCdwcnVyZWwnOidcXHUyMkIwJywncHNjcic6J1xcdUQ4MzVcXHVEQ0M1JywnUHNjcic6J1xcdUQ4MzVcXHVEQ0FCJywncHNpJzonXFx1MDNDOCcsJ1BzaSc6J1xcdTAzQTgnLCdwdW5jc3AnOidcXHUyMDA4JywncWZyJzonXFx1RDgzNVxcdUREMkUnLCdRZnInOidcXHVEODM1XFx1REQxNCcsJ3FpbnQnOidcXHUyQTBDJywncW9wZic6J1xcdUQ4MzVcXHVERDYyJywnUW9wZic6J1xcdTIxMUEnLCdxcHJpbWUnOidcXHUyMDU3JywncXNjcic6J1xcdUQ4MzVcXHVEQ0M2JywnUXNjcic6J1xcdUQ4MzVcXHVEQ0FDJywncXVhdGVybmlvbnMnOidcXHUyMTBEJywncXVhdGludCc6J1xcdTJBMTYnLCdxdWVzdCc6Jz8nLCdxdWVzdGVxJzonXFx1MjI1RicsJ3F1b3QnOidcIicsJ1FVT1QnOidcIicsJ3JBYXJyJzonXFx1MjFEQicsJ3JhY2UnOidcXHUyMjNEXFx1MDMzMScsJ3JhY3V0ZSc6J1xcdTAxNTUnLCdSYWN1dGUnOidcXHUwMTU0JywncmFkaWMnOidcXHUyMjFBJywncmFlbXB0eXYnOidcXHUyOUIzJywncmFuZyc6J1xcdTI3RTknLCdSYW5nJzonXFx1MjdFQicsJ3JhbmdkJzonXFx1Mjk5MicsJ3JhbmdlJzonXFx1MjlBNScsJ3JhbmdsZSc6J1xcdTI3RTknLCdyYXF1byc6J1xceEJCJywncmFycic6J1xcdTIxOTInLCdyQXJyJzonXFx1MjFEMicsJ1JhcnInOidcXHUyMUEwJywncmFycmFwJzonXFx1Mjk3NScsJ3JhcnJiJzonXFx1MjFFNScsJ3JhcnJiZnMnOidcXHUyOTIwJywncmFycmMnOidcXHUyOTMzJywncmFycmZzJzonXFx1MjkxRScsJ3JhcnJoayc6J1xcdTIxQUEnLCdyYXJybHAnOidcXHUyMUFDJywncmFycnBsJzonXFx1Mjk0NScsJ3JhcnJzaW0nOidcXHUyOTc0JywncmFycnRsJzonXFx1MjFBMycsJ1JhcnJ0bCc6J1xcdTI5MTYnLCdyYXJydyc6J1xcdTIxOUQnLCdyYXRhaWwnOidcXHUyOTFBJywnckF0YWlsJzonXFx1MjkxQycsJ3JhdGlvJzonXFx1MjIzNicsJ3JhdGlvbmFscyc6J1xcdTIxMUEnLCdyYmFycic6J1xcdTI5MEQnLCdyQmFycic6J1xcdTI5MEYnLCdSQmFycic6J1xcdTI5MTAnLCdyYmJyayc6J1xcdTI3NzMnLCdyYnJhY2UnOid9JywncmJyYWNrJzonXScsJ3JicmtlJzonXFx1Mjk4QycsJ3JicmtzbGQnOidcXHUyOThFJywncmJya3NsdSc6J1xcdTI5OTAnLCdyY2Fyb24nOidcXHUwMTU5JywnUmNhcm9uJzonXFx1MDE1OCcsJ3JjZWRpbCc6J1xcdTAxNTcnLCdSY2VkaWwnOidcXHUwMTU2JywncmNlaWwnOidcXHUyMzA5JywncmN1Yic6J30nLCdyY3knOidcXHUwNDQwJywnUmN5JzonXFx1MDQyMCcsJ3JkY2EnOidcXHUyOTM3JywncmRsZGhhcic6J1xcdTI5NjknLCdyZHF1byc6J1xcdTIwMUQnLCdyZHF1b3InOidcXHUyMDFEJywncmRzaCc6J1xcdTIxQjMnLCdSZSc6J1xcdTIxMUMnLCdyZWFsJzonXFx1MjExQycsJ3JlYWxpbmUnOidcXHUyMTFCJywncmVhbHBhcnQnOidcXHUyMTFDJywncmVhbHMnOidcXHUyMTFEJywncmVjdCc6J1xcdTI1QUQnLCdyZWcnOidcXHhBRScsJ1JFRyc6J1xceEFFJywnUmV2ZXJzZUVsZW1lbnQnOidcXHUyMjBCJywnUmV2ZXJzZUVxdWlsaWJyaXVtJzonXFx1MjFDQicsJ1JldmVyc2VVcEVxdWlsaWJyaXVtJzonXFx1Mjk2RicsJ3JmaXNodCc6J1xcdTI5N0QnLCdyZmxvb3InOidcXHUyMzBCJywncmZyJzonXFx1RDgzNVxcdUREMkYnLCdSZnInOidcXHUyMTFDJywnckhhcic6J1xcdTI5NjQnLCdyaGFyZCc6J1xcdTIxQzEnLCdyaGFydSc6J1xcdTIxQzAnLCdyaGFydWwnOidcXHUyOTZDJywncmhvJzonXFx1MDNDMScsJ1Jobyc6J1xcdTAzQTEnLCdyaG92JzonXFx1MDNGMScsJ1JpZ2h0QW5nbGVCcmFja2V0JzonXFx1MjdFOScsJ3JpZ2h0YXJyb3cnOidcXHUyMTkyJywnUmlnaHRhcnJvdyc6J1xcdTIxRDInLCdSaWdodEFycm93JzonXFx1MjE5MicsJ1JpZ2h0QXJyb3dCYXInOidcXHUyMUU1JywnUmlnaHRBcnJvd0xlZnRBcnJvdyc6J1xcdTIxQzQnLCdyaWdodGFycm93dGFpbCc6J1xcdTIxQTMnLCdSaWdodENlaWxpbmcnOidcXHUyMzA5JywnUmlnaHREb3VibGVCcmFja2V0JzonXFx1MjdFNycsJ1JpZ2h0RG93blRlZVZlY3Rvcic6J1xcdTI5NUQnLCdSaWdodERvd25WZWN0b3InOidcXHUyMUMyJywnUmlnaHREb3duVmVjdG9yQmFyJzonXFx1Mjk1NScsJ1JpZ2h0Rmxvb3InOidcXHUyMzBCJywncmlnaHRoYXJwb29uZG93bic6J1xcdTIxQzEnLCdyaWdodGhhcnBvb251cCc6J1xcdTIxQzAnLCdyaWdodGxlZnRhcnJvd3MnOidcXHUyMUM0JywncmlnaHRsZWZ0aGFycG9vbnMnOidcXHUyMUNDJywncmlnaHRyaWdodGFycm93cyc6J1xcdTIxQzknLCdyaWdodHNxdWlnYXJyb3cnOidcXHUyMTlEJywnUmlnaHRUZWUnOidcXHUyMkEyJywnUmlnaHRUZWVBcnJvdyc6J1xcdTIxQTYnLCdSaWdodFRlZVZlY3Rvcic6J1xcdTI5NUInLCdyaWdodHRocmVldGltZXMnOidcXHUyMkNDJywnUmlnaHRUcmlhbmdsZSc6J1xcdTIyQjMnLCdSaWdodFRyaWFuZ2xlQmFyJzonXFx1MjlEMCcsJ1JpZ2h0VHJpYW5nbGVFcXVhbCc6J1xcdTIyQjUnLCdSaWdodFVwRG93blZlY3Rvcic6J1xcdTI5NEYnLCdSaWdodFVwVGVlVmVjdG9yJzonXFx1Mjk1QycsJ1JpZ2h0VXBWZWN0b3InOidcXHUyMUJFJywnUmlnaHRVcFZlY3RvckJhcic6J1xcdTI5NTQnLCdSaWdodFZlY3Rvcic6J1xcdTIxQzAnLCdSaWdodFZlY3RvckJhcic6J1xcdTI5NTMnLCdyaW5nJzonXFx1MDJEQScsJ3Jpc2luZ2RvdHNlcSc6J1xcdTIyNTMnLCdybGFycic6J1xcdTIxQzQnLCdybGhhcic6J1xcdTIxQ0MnLCdybG0nOidcXHUyMDBGJywncm1vdXN0JzonXFx1MjNCMScsJ3Jtb3VzdGFjaGUnOidcXHUyM0IxJywncm5taWQnOidcXHUyQUVFJywncm9hbmcnOidcXHUyN0VEJywncm9hcnInOidcXHUyMUZFJywncm9icmsnOidcXHUyN0U3Jywncm9wYXInOidcXHUyOTg2Jywncm9wZic6J1xcdUQ4MzVcXHVERDYzJywnUm9wZic6J1xcdTIxMUQnLCdyb3BsdXMnOidcXHUyQTJFJywncm90aW1lcyc6J1xcdTJBMzUnLCdSb3VuZEltcGxpZXMnOidcXHUyOTcwJywncnBhcic6JyknLCdycGFyZ3QnOidcXHUyOTk0JywncnBwb2xpbnQnOidcXHUyQTEyJywncnJhcnInOidcXHUyMUM5JywnUnJpZ2h0YXJyb3cnOidcXHUyMURCJywncnNhcXVvJzonXFx1MjAzQScsJ3JzY3InOidcXHVEODM1XFx1RENDNycsJ1JzY3InOidcXHUyMTFCJywncnNoJzonXFx1MjFCMScsJ1JzaCc6J1xcdTIxQjEnLCdyc3FiJzonXScsJ3JzcXVvJzonXFx1MjAxOScsJ3JzcXVvcic6J1xcdTIwMTknLCdydGhyZWUnOidcXHUyMkNDJywncnRpbWVzJzonXFx1MjJDQScsJ3J0cmknOidcXHUyNUI5JywncnRyaWUnOidcXHUyMkI1JywncnRyaWYnOidcXHUyNUI4JywncnRyaWx0cmknOidcXHUyOUNFJywnUnVsZURlbGF5ZWQnOidcXHUyOUY0JywncnVsdWhhcic6J1xcdTI5NjgnLCdyeCc6J1xcdTIxMUUnLCdzYWN1dGUnOidcXHUwMTVCJywnU2FjdXRlJzonXFx1MDE1QScsJ3NicXVvJzonXFx1MjAxQScsJ3NjJzonXFx1MjI3QicsJ1NjJzonXFx1MkFCQycsJ3NjYXAnOidcXHUyQUI4Jywnc2Nhcm9uJzonXFx1MDE2MScsJ1NjYXJvbic6J1xcdTAxNjAnLCdzY2N1ZSc6J1xcdTIyN0QnLCdzY2UnOidcXHUyQUIwJywnc2NFJzonXFx1MkFCNCcsJ3NjZWRpbCc6J1xcdTAxNUYnLCdTY2VkaWwnOidcXHUwMTVFJywnc2NpcmMnOidcXHUwMTVEJywnU2NpcmMnOidcXHUwMTVDJywnc2NuYXAnOidcXHUyQUJBJywnc2NuRSc6J1xcdTJBQjYnLCdzY25zaW0nOidcXHUyMkU5Jywnc2Nwb2xpbnQnOidcXHUyQTEzJywnc2NzaW0nOidcXHUyMjdGJywnc2N5JzonXFx1MDQ0MScsJ1NjeSc6J1xcdTA0MjEnLCdzZG90JzonXFx1MjJDNScsJ3Nkb3RiJzonXFx1MjJBMScsJ3Nkb3RlJzonXFx1MkE2NicsJ3NlYXJoayc6J1xcdTI5MjUnLCdzZWFycic6J1xcdTIxOTgnLCdzZUFycic6J1xcdTIxRDgnLCdzZWFycm93JzonXFx1MjE5OCcsJ3NlY3QnOidcXHhBNycsJ3NlbWknOic7Jywnc2Vzd2FyJzonXFx1MjkyOScsJ3NldG1pbnVzJzonXFx1MjIxNicsJ3NldG1uJzonXFx1MjIxNicsJ3NleHQnOidcXHUyNzM2Jywnc2ZyJzonXFx1RDgzNVxcdUREMzAnLCdTZnInOidcXHVEODM1XFx1REQxNicsJ3Nmcm93bic6J1xcdTIzMjInLCdzaGFycCc6J1xcdTI2NkYnLCdzaGNoY3knOidcXHUwNDQ5JywnU0hDSGN5JzonXFx1MDQyOScsJ3NoY3knOidcXHUwNDQ4JywnU0hjeSc6J1xcdTA0MjgnLCdTaG9ydERvd25BcnJvdyc6J1xcdTIxOTMnLCdTaG9ydExlZnRBcnJvdyc6J1xcdTIxOTAnLCdzaG9ydG1pZCc6J1xcdTIyMjMnLCdzaG9ydHBhcmFsbGVsJzonXFx1MjIyNScsJ1Nob3J0UmlnaHRBcnJvdyc6J1xcdTIxOTInLCdTaG9ydFVwQXJyb3cnOidcXHUyMTkxJywnc2h5JzonXFx4QUQnLCdzaWdtYSc6J1xcdTAzQzMnLCdTaWdtYSc6J1xcdTAzQTMnLCdzaWdtYWYnOidcXHUwM0MyJywnc2lnbWF2JzonXFx1MDNDMicsJ3NpbSc6J1xcdTIyM0MnLCdzaW1kb3QnOidcXHUyQTZBJywnc2ltZSc6J1xcdTIyNDMnLCdzaW1lcSc6J1xcdTIyNDMnLCdzaW1nJzonXFx1MkE5RScsJ3NpbWdFJzonXFx1MkFBMCcsJ3NpbWwnOidcXHUyQTlEJywnc2ltbEUnOidcXHUyQTlGJywnc2ltbmUnOidcXHUyMjQ2Jywnc2ltcGx1cyc6J1xcdTJBMjQnLCdzaW1yYXJyJzonXFx1Mjk3MicsJ3NsYXJyJzonXFx1MjE5MCcsJ1NtYWxsQ2lyY2xlJzonXFx1MjIxOCcsJ3NtYWxsc2V0bWludXMnOidcXHUyMjE2Jywnc21hc2hwJzonXFx1MkEzMycsJ3NtZXBhcnNsJzonXFx1MjlFNCcsJ3NtaWQnOidcXHUyMjIzJywnc21pbGUnOidcXHUyMzIzJywnc210JzonXFx1MkFBQScsJ3NtdGUnOidcXHUyQUFDJywnc210ZXMnOidcXHUyQUFDXFx1RkUwMCcsJ3NvZnRjeSc6J1xcdTA0NEMnLCdTT0ZUY3knOidcXHUwNDJDJywnc29sJzonLycsJ3NvbGInOidcXHUyOUM0Jywnc29sYmFyJzonXFx1MjMzRicsJ3NvcGYnOidcXHVEODM1XFx1REQ2NCcsJ1NvcGYnOidcXHVEODM1XFx1REQ0QScsJ3NwYWRlcyc6J1xcdTI2NjAnLCdzcGFkZXN1aXQnOidcXHUyNjYwJywnc3Bhcic6J1xcdTIyMjUnLCdzcWNhcCc6J1xcdTIyOTMnLCdzcWNhcHMnOidcXHUyMjkzXFx1RkUwMCcsJ3NxY3VwJzonXFx1MjI5NCcsJ3NxY3Vwcyc6J1xcdTIyOTRcXHVGRTAwJywnU3FydCc6J1xcdTIyMUEnLCdzcXN1Yic6J1xcdTIyOEYnLCdzcXN1YmUnOidcXHUyMjkxJywnc3FzdWJzZXQnOidcXHUyMjhGJywnc3FzdWJzZXRlcSc6J1xcdTIyOTEnLCdzcXN1cCc6J1xcdTIyOTAnLCdzcXN1cGUnOidcXHUyMjkyJywnc3FzdXBzZXQnOidcXHUyMjkwJywnc3FzdXBzZXRlcSc6J1xcdTIyOTInLCdzcXUnOidcXHUyNUExJywnc3F1YXJlJzonXFx1MjVBMScsJ1NxdWFyZSc6J1xcdTI1QTEnLCdTcXVhcmVJbnRlcnNlY3Rpb24nOidcXHUyMjkzJywnU3F1YXJlU3Vic2V0JzonXFx1MjI4RicsJ1NxdWFyZVN1YnNldEVxdWFsJzonXFx1MjI5MScsJ1NxdWFyZVN1cGVyc2V0JzonXFx1MjI5MCcsJ1NxdWFyZVN1cGVyc2V0RXF1YWwnOidcXHUyMjkyJywnU3F1YXJlVW5pb24nOidcXHUyMjk0Jywnc3F1YXJmJzonXFx1MjVBQScsJ3NxdWYnOidcXHUyNUFBJywnc3JhcnInOidcXHUyMTkyJywnc3Njcic6J1xcdUQ4MzVcXHVEQ0M4JywnU3Njcic6J1xcdUQ4MzVcXHVEQ0FFJywnc3NldG1uJzonXFx1MjIxNicsJ3NzbWlsZSc6J1xcdTIzMjMnLCdzc3RhcmYnOidcXHUyMkM2Jywnc3Rhcic6J1xcdTI2MDYnLCdTdGFyJzonXFx1MjJDNicsJ3N0YXJmJzonXFx1MjYwNScsJ3N0cmFpZ2h0ZXBzaWxvbic6J1xcdTAzRjUnLCdzdHJhaWdodHBoaSc6J1xcdTAzRDUnLCdzdHJucyc6J1xceEFGJywnc3ViJzonXFx1MjI4MicsJ1N1Yic6J1xcdTIyRDAnLCdzdWJkb3QnOidcXHUyQUJEJywnc3ViZSc6J1xcdTIyODYnLCdzdWJFJzonXFx1MkFDNScsJ3N1YmVkb3QnOidcXHUyQUMzJywnc3VibXVsdCc6J1xcdTJBQzEnLCdzdWJuZSc6J1xcdTIyOEEnLCdzdWJuRSc6J1xcdTJBQ0InLCdzdWJwbHVzJzonXFx1MkFCRicsJ3N1YnJhcnInOidcXHUyOTc5Jywnc3Vic2V0JzonXFx1MjI4MicsJ1N1YnNldCc6J1xcdTIyRDAnLCdzdWJzZXRlcSc6J1xcdTIyODYnLCdzdWJzZXRlcXEnOidcXHUyQUM1JywnU3Vic2V0RXF1YWwnOidcXHUyMjg2Jywnc3Vic2V0bmVxJzonXFx1MjI4QScsJ3N1YnNldG5lcXEnOidcXHUyQUNCJywnc3Vic2ltJzonXFx1MkFDNycsJ3N1YnN1Yic6J1xcdTJBRDUnLCdzdWJzdXAnOidcXHUyQUQzJywnc3VjYyc6J1xcdTIyN0InLCdzdWNjYXBwcm94JzonXFx1MkFCOCcsJ3N1Y2NjdXJseWVxJzonXFx1MjI3RCcsJ1N1Y2NlZWRzJzonXFx1MjI3QicsJ1N1Y2NlZWRzRXF1YWwnOidcXHUyQUIwJywnU3VjY2VlZHNTbGFudEVxdWFsJzonXFx1MjI3RCcsJ1N1Y2NlZWRzVGlsZGUnOidcXHUyMjdGJywnc3VjY2VxJzonXFx1MkFCMCcsJ3N1Y2NuYXBwcm94JzonXFx1MkFCQScsJ3N1Y2NuZXFxJzonXFx1MkFCNicsJ3N1Y2Nuc2ltJzonXFx1MjJFOScsJ3N1Y2NzaW0nOidcXHUyMjdGJywnU3VjaFRoYXQnOidcXHUyMjBCJywnc3VtJzonXFx1MjIxMScsJ1N1bSc6J1xcdTIyMTEnLCdzdW5nJzonXFx1MjY2QScsJ3N1cCc6J1xcdTIyODMnLCdTdXAnOidcXHUyMkQxJywnc3VwMSc6J1xceEI5Jywnc3VwMic6J1xceEIyJywnc3VwMyc6J1xceEIzJywnc3VwZG90JzonXFx1MkFCRScsJ3N1cGRzdWInOidcXHUyQUQ4Jywnc3VwZSc6J1xcdTIyODcnLCdzdXBFJzonXFx1MkFDNicsJ3N1cGVkb3QnOidcXHUyQUM0JywnU3VwZXJzZXQnOidcXHUyMjgzJywnU3VwZXJzZXRFcXVhbCc6J1xcdTIyODcnLCdzdXBoc29sJzonXFx1MjdDOScsJ3N1cGhzdWInOidcXHUyQUQ3Jywnc3VwbGFycic6J1xcdTI5N0InLCdzdXBtdWx0JzonXFx1MkFDMicsJ3N1cG5lJzonXFx1MjI4QicsJ3N1cG5FJzonXFx1MkFDQycsJ3N1cHBsdXMnOidcXHUyQUMwJywnc3Vwc2V0JzonXFx1MjI4MycsJ1N1cHNldCc6J1xcdTIyRDEnLCdzdXBzZXRlcSc6J1xcdTIyODcnLCdzdXBzZXRlcXEnOidcXHUyQUM2Jywnc3Vwc2V0bmVxJzonXFx1MjI4QicsJ3N1cHNldG5lcXEnOidcXHUyQUNDJywnc3Vwc2ltJzonXFx1MkFDOCcsJ3N1cHN1Yic6J1xcdTJBRDQnLCdzdXBzdXAnOidcXHUyQUQ2Jywnc3dhcmhrJzonXFx1MjkyNicsJ3N3YXJyJzonXFx1MjE5OScsJ3N3QXJyJzonXFx1MjFEOScsJ3N3YXJyb3cnOidcXHUyMTk5Jywnc3dud2FyJzonXFx1MjkyQScsJ3N6bGlnJzonXFx4REYnLCdUYWInOidcXHQnLCd0YXJnZXQnOidcXHUyMzE2JywndGF1JzonXFx1MDNDNCcsJ1RhdSc6J1xcdTAzQTQnLCd0YnJrJzonXFx1MjNCNCcsJ3RjYXJvbic6J1xcdTAxNjUnLCdUY2Fyb24nOidcXHUwMTY0JywndGNlZGlsJzonXFx1MDE2MycsJ1RjZWRpbCc6J1xcdTAxNjInLCd0Y3knOidcXHUwNDQyJywnVGN5JzonXFx1MDQyMicsJ3Rkb3QnOidcXHUyMERCJywndGVscmVjJzonXFx1MjMxNScsJ3Rmcic6J1xcdUQ4MzVcXHVERDMxJywnVGZyJzonXFx1RDgzNVxcdUREMTcnLCd0aGVyZTQnOidcXHUyMjM0JywndGhlcmVmb3JlJzonXFx1MjIzNCcsJ1RoZXJlZm9yZSc6J1xcdTIyMzQnLCd0aGV0YSc6J1xcdTAzQjgnLCdUaGV0YSc6J1xcdTAzOTgnLCd0aGV0YXN5bSc6J1xcdTAzRDEnLCd0aGV0YXYnOidcXHUwM0QxJywndGhpY2thcHByb3gnOidcXHUyMjQ4JywndGhpY2tzaW0nOidcXHUyMjNDJywnVGhpY2tTcGFjZSc6J1xcdTIwNUZcXHUyMDBBJywndGhpbnNwJzonXFx1MjAwOScsJ1RoaW5TcGFjZSc6J1xcdTIwMDknLCd0aGthcCc6J1xcdTIyNDgnLCd0aGtzaW0nOidcXHUyMjNDJywndGhvcm4nOidcXHhGRScsJ1RIT1JOJzonXFx4REUnLCd0aWxkZSc6J1xcdTAyREMnLCdUaWxkZSc6J1xcdTIyM0MnLCdUaWxkZUVxdWFsJzonXFx1MjI0MycsJ1RpbGRlRnVsbEVxdWFsJzonXFx1MjI0NScsJ1RpbGRlVGlsZGUnOidcXHUyMjQ4JywndGltZXMnOidcXHhENycsJ3RpbWVzYic6J1xcdTIyQTAnLCd0aW1lc2Jhcic6J1xcdTJBMzEnLCd0aW1lc2QnOidcXHUyQTMwJywndGludCc6J1xcdTIyMkQnLCd0b2VhJzonXFx1MjkyOCcsJ3RvcCc6J1xcdTIyQTQnLCd0b3Bib3QnOidcXHUyMzM2JywndG9wY2lyJzonXFx1MkFGMScsJ3RvcGYnOidcXHVEODM1XFx1REQ2NScsJ1RvcGYnOidcXHVEODM1XFx1REQ0QicsJ3RvcGZvcmsnOidcXHUyQURBJywndG9zYSc6J1xcdTI5MjknLCd0cHJpbWUnOidcXHUyMDM0JywndHJhZGUnOidcXHUyMTIyJywnVFJBREUnOidcXHUyMTIyJywndHJpYW5nbGUnOidcXHUyNUI1JywndHJpYW5nbGVkb3duJzonXFx1MjVCRicsJ3RyaWFuZ2xlbGVmdCc6J1xcdTI1QzMnLCd0cmlhbmdsZWxlZnRlcSc6J1xcdTIyQjQnLCd0cmlhbmdsZXEnOidcXHUyMjVDJywndHJpYW5nbGVyaWdodCc6J1xcdTI1QjknLCd0cmlhbmdsZXJpZ2h0ZXEnOidcXHUyMkI1JywndHJpZG90JzonXFx1MjVFQycsJ3RyaWUnOidcXHUyMjVDJywndHJpbWludXMnOidcXHUyQTNBJywnVHJpcGxlRG90JzonXFx1MjBEQicsJ3RyaXBsdXMnOidcXHUyQTM5JywndHJpc2InOidcXHUyOUNEJywndHJpdGltZSc6J1xcdTJBM0InLCd0cnBleml1bSc6J1xcdTIzRTInLCd0c2NyJzonXFx1RDgzNVxcdURDQzknLCdUc2NyJzonXFx1RDgzNVxcdURDQUYnLCd0c2N5JzonXFx1MDQ0NicsJ1RTY3knOidcXHUwNDI2JywndHNoY3knOidcXHUwNDVCJywnVFNIY3knOidcXHUwNDBCJywndHN0cm9rJzonXFx1MDE2NycsJ1RzdHJvayc6J1xcdTAxNjYnLCd0d2l4dCc6J1xcdTIyNkMnLCd0d29oZWFkbGVmdGFycm93JzonXFx1MjE5RScsJ3R3b2hlYWRyaWdodGFycm93JzonXFx1MjFBMCcsJ3VhY3V0ZSc6J1xceEZBJywnVWFjdXRlJzonXFx4REEnLCd1YXJyJzonXFx1MjE5MScsJ3VBcnInOidcXHUyMUQxJywnVWFycic6J1xcdTIxOUYnLCdVYXJyb2Npcic6J1xcdTI5NDknLCd1YnJjeSc6J1xcdTA0NUUnLCdVYnJjeSc6J1xcdTA0MEUnLCd1YnJldmUnOidcXHUwMTZEJywnVWJyZXZlJzonXFx1MDE2QycsJ3VjaXJjJzonXFx4RkInLCdVY2lyYyc6J1xceERCJywndWN5JzonXFx1MDQ0MycsJ1VjeSc6J1xcdTA0MjMnLCd1ZGFycic6J1xcdTIxQzUnLCd1ZGJsYWMnOidcXHUwMTcxJywnVWRibGFjJzonXFx1MDE3MCcsJ3VkaGFyJzonXFx1Mjk2RScsJ3VmaXNodCc6J1xcdTI5N0UnLCd1ZnInOidcXHVEODM1XFx1REQzMicsJ1Vmcic6J1xcdUQ4MzVcXHVERDE4JywndWdyYXZlJzonXFx4RjknLCdVZ3JhdmUnOidcXHhEOScsJ3VIYXInOidcXHUyOTYzJywndWhhcmwnOidcXHUyMUJGJywndWhhcnInOidcXHUyMUJFJywndWhibGsnOidcXHUyNTgwJywndWxjb3JuJzonXFx1MjMxQycsJ3VsY29ybmVyJzonXFx1MjMxQycsJ3VsY3JvcCc6J1xcdTIzMEYnLCd1bHRyaSc6J1xcdTI1RjgnLCd1bWFjcic6J1xcdTAxNkInLCdVbWFjcic6J1xcdTAxNkEnLCd1bWwnOidcXHhBOCcsJ1VuZGVyQmFyJzonXycsJ1VuZGVyQnJhY2UnOidcXHUyM0RGJywnVW5kZXJCcmFja2V0JzonXFx1MjNCNScsJ1VuZGVyUGFyZW50aGVzaXMnOidcXHUyM0REJywnVW5pb24nOidcXHUyMkMzJywnVW5pb25QbHVzJzonXFx1MjI4RScsJ3VvZ29uJzonXFx1MDE3MycsJ1VvZ29uJzonXFx1MDE3MicsJ3VvcGYnOidcXHVEODM1XFx1REQ2NicsJ1VvcGYnOidcXHVEODM1XFx1REQ0QycsJ3VwYXJyb3cnOidcXHUyMTkxJywnVXBhcnJvdyc6J1xcdTIxRDEnLCdVcEFycm93JzonXFx1MjE5MScsJ1VwQXJyb3dCYXInOidcXHUyOTEyJywnVXBBcnJvd0Rvd25BcnJvdyc6J1xcdTIxQzUnLCd1cGRvd25hcnJvdyc6J1xcdTIxOTUnLCdVcGRvd25hcnJvdyc6J1xcdTIxRDUnLCdVcERvd25BcnJvdyc6J1xcdTIxOTUnLCdVcEVxdWlsaWJyaXVtJzonXFx1Mjk2RScsJ3VwaGFycG9vbmxlZnQnOidcXHUyMUJGJywndXBoYXJwb29ucmlnaHQnOidcXHUyMUJFJywndXBsdXMnOidcXHUyMjhFJywnVXBwZXJMZWZ0QXJyb3cnOidcXHUyMTk2JywnVXBwZXJSaWdodEFycm93JzonXFx1MjE5NycsJ3Vwc2knOidcXHUwM0M1JywnVXBzaSc6J1xcdTAzRDInLCd1cHNpaCc6J1xcdTAzRDInLCd1cHNpbG9uJzonXFx1MDNDNScsJ1Vwc2lsb24nOidcXHUwM0E1JywnVXBUZWUnOidcXHUyMkE1JywnVXBUZWVBcnJvdyc6J1xcdTIxQTUnLCd1cHVwYXJyb3dzJzonXFx1MjFDOCcsJ3VyY29ybic6J1xcdTIzMUQnLCd1cmNvcm5lcic6J1xcdTIzMUQnLCd1cmNyb3AnOidcXHUyMzBFJywndXJpbmcnOidcXHUwMTZGJywnVXJpbmcnOidcXHUwMTZFJywndXJ0cmknOidcXHUyNUY5JywndXNjcic6J1xcdUQ4MzVcXHVEQ0NBJywnVXNjcic6J1xcdUQ4MzVcXHVEQ0IwJywndXRkb3QnOidcXHUyMkYwJywndXRpbGRlJzonXFx1MDE2OScsJ1V0aWxkZSc6J1xcdTAxNjgnLCd1dHJpJzonXFx1MjVCNScsJ3V0cmlmJzonXFx1MjVCNCcsJ3V1YXJyJzonXFx1MjFDOCcsJ3V1bWwnOidcXHhGQycsJ1V1bWwnOidcXHhEQycsJ3V3YW5nbGUnOidcXHUyOUE3JywndmFuZ3J0JzonXFx1Mjk5QycsJ3ZhcmVwc2lsb24nOidcXHUwM0Y1JywndmFya2FwcGEnOidcXHUwM0YwJywndmFybm90aGluZyc6J1xcdTIyMDUnLCd2YXJwaGknOidcXHUwM0Q1JywndmFycGknOidcXHUwM0Q2JywndmFycHJvcHRvJzonXFx1MjIxRCcsJ3ZhcnInOidcXHUyMTk1JywndkFycic6J1xcdTIxRDUnLCd2YXJyaG8nOidcXHUwM0YxJywndmFyc2lnbWEnOidcXHUwM0MyJywndmFyc3Vic2V0bmVxJzonXFx1MjI4QVxcdUZFMDAnLCd2YXJzdWJzZXRuZXFxJzonXFx1MkFDQlxcdUZFMDAnLCd2YXJzdXBzZXRuZXEnOidcXHUyMjhCXFx1RkUwMCcsJ3ZhcnN1cHNldG5lcXEnOidcXHUyQUNDXFx1RkUwMCcsJ3ZhcnRoZXRhJzonXFx1MDNEMScsJ3ZhcnRyaWFuZ2xlbGVmdCc6J1xcdTIyQjInLCd2YXJ0cmlhbmdsZXJpZ2h0JzonXFx1MjJCMycsJ3ZCYXInOidcXHUyQUU4JywnVmJhcic6J1xcdTJBRUInLCd2QmFydic6J1xcdTJBRTknLCd2Y3knOidcXHUwNDMyJywnVmN5JzonXFx1MDQxMicsJ3ZkYXNoJzonXFx1MjJBMicsJ3ZEYXNoJzonXFx1MjJBOCcsJ1ZkYXNoJzonXFx1MjJBOScsJ1ZEYXNoJzonXFx1MjJBQicsJ1ZkYXNobCc6J1xcdTJBRTYnLCd2ZWUnOidcXHUyMjI4JywnVmVlJzonXFx1MjJDMScsJ3ZlZWJhcic6J1xcdTIyQkInLCd2ZWVlcSc6J1xcdTIyNUEnLCd2ZWxsaXAnOidcXHUyMkVFJywndmVyYmFyJzonfCcsJ1ZlcmJhcic6J1xcdTIwMTYnLCd2ZXJ0JzonfCcsJ1ZlcnQnOidcXHUyMDE2JywnVmVydGljYWxCYXInOidcXHUyMjIzJywnVmVydGljYWxMaW5lJzonfCcsJ1ZlcnRpY2FsU2VwYXJhdG9yJzonXFx1Mjc1OCcsJ1ZlcnRpY2FsVGlsZGUnOidcXHUyMjQwJywnVmVyeVRoaW5TcGFjZSc6J1xcdTIwMEEnLCd2ZnInOidcXHVEODM1XFx1REQzMycsJ1Zmcic6J1xcdUQ4MzVcXHVERDE5Jywndmx0cmknOidcXHUyMkIyJywndm5zdWInOidcXHUyMjgyXFx1MjBEMicsJ3Zuc3VwJzonXFx1MjI4M1xcdTIwRDInLCd2b3BmJzonXFx1RDgzNVxcdURENjcnLCdWb3BmJzonXFx1RDgzNVxcdURENEQnLCd2cHJvcCc6J1xcdTIyMUQnLCd2cnRyaSc6J1xcdTIyQjMnLCd2c2NyJzonXFx1RDgzNVxcdURDQ0InLCdWc2NyJzonXFx1RDgzNVxcdURDQjEnLCd2c3VibmUnOidcXHUyMjhBXFx1RkUwMCcsJ3ZzdWJuRSc6J1xcdTJBQ0JcXHVGRTAwJywndnN1cG5lJzonXFx1MjI4QlxcdUZFMDAnLCd2c3VwbkUnOidcXHUyQUNDXFx1RkUwMCcsJ1Z2ZGFzaCc6J1xcdTIyQUEnLCd2emlnemFnJzonXFx1Mjk5QScsJ3djaXJjJzonXFx1MDE3NScsJ1djaXJjJzonXFx1MDE3NCcsJ3dlZGJhcic6J1xcdTJBNUYnLCd3ZWRnZSc6J1xcdTIyMjcnLCdXZWRnZSc6J1xcdTIyQzAnLCd3ZWRnZXEnOidcXHUyMjU5Jywnd2VpZXJwJzonXFx1MjExOCcsJ3dmcic6J1xcdUQ4MzVcXHVERDM0JywnV2ZyJzonXFx1RDgzNVxcdUREMUEnLCd3b3BmJzonXFx1RDgzNVxcdURENjgnLCdXb3BmJzonXFx1RDgzNVxcdURENEUnLCd3cCc6J1xcdTIxMTgnLCd3cic6J1xcdTIyNDAnLCd3cmVhdGgnOidcXHUyMjQwJywnd3Njcic6J1xcdUQ4MzVcXHVEQ0NDJywnV3Njcic6J1xcdUQ4MzVcXHVEQ0IyJywneGNhcCc6J1xcdTIyQzInLCd4Y2lyYyc6J1xcdTI1RUYnLCd4Y3VwJzonXFx1MjJDMycsJ3hkdHJpJzonXFx1MjVCRCcsJ3hmcic6J1xcdUQ4MzVcXHVERDM1JywnWGZyJzonXFx1RDgzNVxcdUREMUInLCd4aGFycic6J1xcdTI3RjcnLCd4aEFycic6J1xcdTI3RkEnLCd4aSc6J1xcdTAzQkUnLCdYaSc6J1xcdTAzOUUnLCd4bGFycic6J1xcdTI3RjUnLCd4bEFycic6J1xcdTI3RjgnLCd4bWFwJzonXFx1MjdGQycsJ3huaXMnOidcXHUyMkZCJywneG9kb3QnOidcXHUyQTAwJywneG9wZic6J1xcdUQ4MzVcXHVERDY5JywnWG9wZic6J1xcdUQ4MzVcXHVERDRGJywneG9wbHVzJzonXFx1MkEwMScsJ3hvdGltZSc6J1xcdTJBMDInLCd4cmFycic6J1xcdTI3RjYnLCd4ckFycic6J1xcdTI3RjknLCd4c2NyJzonXFx1RDgzNVxcdURDQ0QnLCdYc2NyJzonXFx1RDgzNVxcdURDQjMnLCd4c3FjdXAnOidcXHUyQTA2JywneHVwbHVzJzonXFx1MkEwNCcsJ3h1dHJpJzonXFx1MjVCMycsJ3h2ZWUnOidcXHUyMkMxJywneHdlZGdlJzonXFx1MjJDMCcsJ3lhY3V0ZSc6J1xceEZEJywnWWFjdXRlJzonXFx4REQnLCd5YWN5JzonXFx1MDQ0RicsJ1lBY3knOidcXHUwNDJGJywneWNpcmMnOidcXHUwMTc3JywnWWNpcmMnOidcXHUwMTc2JywneWN5JzonXFx1MDQ0QicsJ1ljeSc6J1xcdTA0MkInLCd5ZW4nOidcXHhBNScsJ3lmcic6J1xcdUQ4MzVcXHVERDM2JywnWWZyJzonXFx1RDgzNVxcdUREMUMnLCd5aWN5JzonXFx1MDQ1NycsJ1lJY3knOidcXHUwNDA3JywneW9wZic6J1xcdUQ4MzVcXHVERDZBJywnWW9wZic6J1xcdUQ4MzVcXHVERDUwJywneXNjcic6J1xcdUQ4MzVcXHVEQ0NFJywnWXNjcic6J1xcdUQ4MzVcXHVEQ0I0JywneXVjeSc6J1xcdTA0NEUnLCdZVWN5JzonXFx1MDQyRScsJ3l1bWwnOidcXHhGRicsJ1l1bWwnOidcXHUwMTc4JywnemFjdXRlJzonXFx1MDE3QScsJ1phY3V0ZSc6J1xcdTAxNzknLCd6Y2Fyb24nOidcXHUwMTdFJywnWmNhcm9uJzonXFx1MDE3RCcsJ3pjeSc6J1xcdTA0MzcnLCdaY3knOidcXHUwNDE3JywnemRvdCc6J1xcdTAxN0MnLCdaZG90JzonXFx1MDE3QicsJ3plZXRyZic6J1xcdTIxMjgnLCdaZXJvV2lkdGhTcGFjZSc6J1xcdTIwMEInLCd6ZXRhJzonXFx1MDNCNicsJ1pldGEnOidcXHUwMzk2JywnemZyJzonXFx1RDgzNVxcdUREMzcnLCdaZnInOidcXHUyMTI4JywnemhjeSc6J1xcdTA0MzYnLCdaSGN5JzonXFx1MDQxNicsJ3ppZ3JhcnInOidcXHUyMUREJywnem9wZic6J1xcdUQ4MzVcXHVERDZCJywnWm9wZic6J1xcdTIxMjQnLCd6c2NyJzonXFx1RDgzNVxcdURDQ0YnLCdac2NyJzonXFx1RDgzNVxcdURDQjUnLCd6d2onOidcXHUyMDBEJywnenduaic6J1xcdTIwMEMnfTtcblx0dmFyIGRlY29kZU1hcExlZ2FjeSA9IHsnYWFjdXRlJzonXFx4RTEnLCdBYWN1dGUnOidcXHhDMScsJ2FjaXJjJzonXFx4RTInLCdBY2lyYyc6J1xceEMyJywnYWN1dGUnOidcXHhCNCcsJ2FlbGlnJzonXFx4RTYnLCdBRWxpZyc6J1xceEM2JywnYWdyYXZlJzonXFx4RTAnLCdBZ3JhdmUnOidcXHhDMCcsJ2FtcCc6JyYnLCdBTVAnOicmJywnYXJpbmcnOidcXHhFNScsJ0FyaW5nJzonXFx4QzUnLCdhdGlsZGUnOidcXHhFMycsJ0F0aWxkZSc6J1xceEMzJywnYXVtbCc6J1xceEU0JywnQXVtbCc6J1xceEM0JywnYnJ2YmFyJzonXFx4QTYnLCdjY2VkaWwnOidcXHhFNycsJ0NjZWRpbCc6J1xceEM3JywnY2VkaWwnOidcXHhCOCcsJ2NlbnQnOidcXHhBMicsJ2NvcHknOidcXHhBOScsJ0NPUFknOidcXHhBOScsJ2N1cnJlbic6J1xceEE0JywnZGVnJzonXFx4QjAnLCdkaXZpZGUnOidcXHhGNycsJ2VhY3V0ZSc6J1xceEU5JywnRWFjdXRlJzonXFx4QzknLCdlY2lyYyc6J1xceEVBJywnRWNpcmMnOidcXHhDQScsJ2VncmF2ZSc6J1xceEU4JywnRWdyYXZlJzonXFx4QzgnLCdldGgnOidcXHhGMCcsJ0VUSCc6J1xceEQwJywnZXVtbCc6J1xceEVCJywnRXVtbCc6J1xceENCJywnZnJhYzEyJzonXFx4QkQnLCdmcmFjMTQnOidcXHhCQycsJ2ZyYWMzNCc6J1xceEJFJywnZ3QnOic+JywnR1QnOic+JywnaWFjdXRlJzonXFx4RUQnLCdJYWN1dGUnOidcXHhDRCcsJ2ljaXJjJzonXFx4RUUnLCdJY2lyYyc6J1xceENFJywnaWV4Y2wnOidcXHhBMScsJ2lncmF2ZSc6J1xceEVDJywnSWdyYXZlJzonXFx4Q0MnLCdpcXVlc3QnOidcXHhCRicsJ2l1bWwnOidcXHhFRicsJ0l1bWwnOidcXHhDRicsJ2xhcXVvJzonXFx4QUInLCdsdCc6JzwnLCdMVCc6JzwnLCdtYWNyJzonXFx4QUYnLCdtaWNybyc6J1xceEI1JywnbWlkZG90JzonXFx4QjcnLCduYnNwJzonXFx4QTAnLCdub3QnOidcXHhBQycsJ250aWxkZSc6J1xceEYxJywnTnRpbGRlJzonXFx4RDEnLCdvYWN1dGUnOidcXHhGMycsJ09hY3V0ZSc6J1xceEQzJywnb2NpcmMnOidcXHhGNCcsJ09jaXJjJzonXFx4RDQnLCdvZ3JhdmUnOidcXHhGMicsJ09ncmF2ZSc6J1xceEQyJywnb3JkZic6J1xceEFBJywnb3JkbSc6J1xceEJBJywnb3NsYXNoJzonXFx4RjgnLCdPc2xhc2gnOidcXHhEOCcsJ290aWxkZSc6J1xceEY1JywnT3RpbGRlJzonXFx4RDUnLCdvdW1sJzonXFx4RjYnLCdPdW1sJzonXFx4RDYnLCdwYXJhJzonXFx4QjYnLCdwbHVzbW4nOidcXHhCMScsJ3BvdW5kJzonXFx4QTMnLCdxdW90JzonXCInLCdRVU9UJzonXCInLCdyYXF1byc6J1xceEJCJywncmVnJzonXFx4QUUnLCdSRUcnOidcXHhBRScsJ3NlY3QnOidcXHhBNycsJ3NoeSc6J1xceEFEJywnc3VwMSc6J1xceEI5Jywnc3VwMic6J1xceEIyJywnc3VwMyc6J1xceEIzJywnc3psaWcnOidcXHhERicsJ3Rob3JuJzonXFx4RkUnLCdUSE9STic6J1xceERFJywndGltZXMnOidcXHhENycsJ3VhY3V0ZSc6J1xceEZBJywnVWFjdXRlJzonXFx4REEnLCd1Y2lyYyc6J1xceEZCJywnVWNpcmMnOidcXHhEQicsJ3VncmF2ZSc6J1xceEY5JywnVWdyYXZlJzonXFx4RDknLCd1bWwnOidcXHhBOCcsJ3V1bWwnOidcXHhGQycsJ1V1bWwnOidcXHhEQycsJ3lhY3V0ZSc6J1xceEZEJywnWWFjdXRlJzonXFx4REQnLCd5ZW4nOidcXHhBNScsJ3l1bWwnOidcXHhGRid9O1xuXHR2YXIgZGVjb2RlTWFwTnVtZXJpYyA9IHsnMCc6J1xcdUZGRkQnLCcxMjgnOidcXHUyMEFDJywnMTMwJzonXFx1MjAxQScsJzEzMSc6J1xcdTAxOTInLCcxMzInOidcXHUyMDFFJywnMTMzJzonXFx1MjAyNicsJzEzNCc6J1xcdTIwMjAnLCcxMzUnOidcXHUyMDIxJywnMTM2JzonXFx1MDJDNicsJzEzNyc6J1xcdTIwMzAnLCcxMzgnOidcXHUwMTYwJywnMTM5JzonXFx1MjAzOScsJzE0MCc6J1xcdTAxNTInLCcxNDInOidcXHUwMTdEJywnMTQ1JzonXFx1MjAxOCcsJzE0Nic6J1xcdTIwMTknLCcxNDcnOidcXHUyMDFDJywnMTQ4JzonXFx1MjAxRCcsJzE0OSc6J1xcdTIwMjInLCcxNTAnOidcXHUyMDEzJywnMTUxJzonXFx1MjAxNCcsJzE1Mic6J1xcdTAyREMnLCcxNTMnOidcXHUyMTIyJywnMTU0JzonXFx1MDE2MScsJzE1NSc6J1xcdTIwM0EnLCcxNTYnOidcXHUwMTUzJywnMTU4JzonXFx1MDE3RScsJzE1OSc6J1xcdTAxNzgnfTtcblx0dmFyIGludmFsaWRSZWZlcmVuY2VDb2RlUG9pbnRzID0gWzEsMiwzLDQsNSw2LDcsOCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwxMjcsMTI4LDEyOSwxMzAsMTMxLDEzMiwxMzMsMTM0LDEzNSwxMzYsMTM3LDEzOCwxMzksMTQwLDE0MSwxNDIsMTQzLDE0NCwxNDUsMTQ2LDE0NywxNDgsMTQ5LDE1MCwxNTEsMTUyLDE1MywxNTQsMTU1LDE1NiwxNTcsMTU4LDE1OSw2NDk3Niw2NDk3Nyw2NDk3OCw2NDk3OSw2NDk4MCw2NDk4MSw2NDk4Miw2NDk4Myw2NDk4NCw2NDk4NSw2NDk4Niw2NDk4Nyw2NDk4OCw2NDk4OSw2NDk5MCw2NDk5MSw2NDk5Miw2NDk5Myw2NDk5NCw2NDk5NSw2NDk5Niw2NDk5Nyw2NDk5OCw2NDk5OSw2NTAwMCw2NTAwMSw2NTAwMiw2NTAwMyw2NTAwNCw2NTAwNSw2NTAwNiw2NTAwNyw2NTUzNCw2NTUzNSwxMzEwNzAsMTMxMDcxLDE5NjYwNiwxOTY2MDcsMjYyMTQyLDI2MjE0MywzMjc2NzgsMzI3Njc5LDM5MzIxNCwzOTMyMTUsNDU4NzUwLDQ1ODc1MSw1MjQyODYsNTI0Mjg3LDU4OTgyMiw1ODk4MjMsNjU1MzU4LDY1NTM1OSw3MjA4OTQsNzIwODk1LDc4NjQzMCw3ODY0MzEsODUxOTY2LDg1MTk2Nyw5MTc1MDIsOTE3NTAzLDk4MzAzOCw5ODMwMzksMTA0ODU3NCwxMDQ4NTc1LDExMTQxMTAsMTExNDExMV07XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG5cblx0dmFyIG9iamVjdCA9IHt9O1xuXHR2YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3QuaGFzT3duUHJvcGVydHk7XG5cdHZhciBoYXMgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5TmFtZSkge1xuXHRcdHJldHVybiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHlOYW1lKTtcblx0fTtcblxuXHR2YXIgY29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgdmFsdWUpIHtcblx0XHR2YXIgaW5kZXggPSAtMTtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG5cdFx0XHRpZiAoYXJyYXlbaW5kZXhdID09IHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0dmFyIG1lcmdlID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpIHtcblx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBkZWZhdWx0cztcblx0XHR9XG5cdFx0dmFyIHJlc3VsdCA9IHt9O1xuXHRcdHZhciBrZXk7XG5cdFx0Zm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcblx0XHRcdC8vIEEgYGhhc093blByb3BlcnR5YCBjaGVjayBpcyBub3QgbmVlZGVkIGhlcmUsIHNpbmNlIG9ubHkgcmVjb2duaXplZFxuXHRcdFx0Ly8gb3B0aW9uIG5hbWVzIGFyZSB1c2VkIGFueXdheS4gQW55IG90aGVycyBhcmUgaWdub3JlZC5cblx0XHRcdHJlc3VsdFtrZXldID0gaGFzKG9wdGlvbnMsIGtleSkgPyBvcHRpb25zW2tleV0gOiBkZWZhdWx0c1trZXldO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYHVjczJlbmNvZGVgOyBzZWUgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlLlxuXHR2YXIgY29kZVBvaW50VG9TeW1ib2wgPSBmdW5jdGlvbihjb2RlUG9pbnQsIHN0cmljdCkge1xuXHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRpZiAoKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikgfHwgY29kZVBvaW50ID4gMHgxMEZGRkYpIHtcblx0XHRcdC8vIFNlZSBpc3N1ZSAjNDpcblx0XHRcdC8vIOKAnE90aGVyd2lzZSwgaWYgdGhlIG51bWJlciBpcyBpbiB0aGUgcmFuZ2UgMHhEODAwIHRvIDB4REZGRiBvciBpc1xuXHRcdFx0Ly8gZ3JlYXRlciB0aGFuIDB4MTBGRkZGLCB0aGVuIHRoaXMgaXMgYSBwYXJzZSBlcnJvci4gUmV0dXJuIGEgVStGRkZEXG5cdFx0XHQvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVIu4oCdXG5cdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugb3V0c2lkZSB0aGUgcGVybWlzc2libGUgVW5pY29kZSByYW5nZScpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICdcXHVGRkZEJztcblx0XHR9XG5cdFx0aWYgKGhhcyhkZWNvZGVNYXBOdW1lcmljLCBjb2RlUG9pbnQpKSB7XG5cdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdHBhcnNlRXJyb3IoJ2Rpc2FsbG93ZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGRlY29kZU1hcE51bWVyaWNbY29kZVBvaW50XTtcblx0XHR9XG5cdFx0aWYgKHN0cmljdCAmJiBjb250YWlucyhpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cywgY29kZVBvaW50KSkge1xuXHRcdFx0cGFyc2VFcnJvcignZGlzYWxsb3dlZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcblx0XHRcdGNvZGVQb2ludCAtPSAweDEwMDAwO1xuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0Y29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkY7XG5cdFx0fVxuXHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9O1xuXG5cdHZhciBoZXhFc2NhcGUgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcblx0XHRyZXR1cm4gJyYjeCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnOyc7XG5cdH07XG5cblx0dmFyIGRlY0VzY2FwZSA9IGZ1bmN0aW9uKGNvZGVQb2ludCkge1xuXHRcdHJldHVybiAnJiMnICsgY29kZVBvaW50ICsgJzsnO1xuXHR9O1xuXG5cdHZhciBwYXJzZUVycm9yID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHRocm93IEVycm9yKCdQYXJzZSBlcnJvcjogJyArIG1lc3NhZ2UpO1xuXHR9O1xuXG5cdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG5cdHZhciBlbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgZW5jb2RlLm9wdGlvbnMpO1xuXHRcdHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcblx0XHRpZiAoc3RyaWN0ICYmIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludC50ZXN0KHN0cmluZykpIHtcblx0XHRcdHBhcnNlRXJyb3IoJ2ZvcmJpZGRlbiBjb2RlIHBvaW50Jyk7XG5cdFx0fVxuXHRcdHZhciBlbmNvZGVFdmVyeXRoaW5nID0gb3B0aW9ucy5lbmNvZGVFdmVyeXRoaW5nO1xuXHRcdHZhciB1c2VOYW1lZFJlZmVyZW5jZXMgPSBvcHRpb25zLnVzZU5hbWVkUmVmZXJlbmNlcztcblx0XHR2YXIgYWxsb3dVbnNhZmVTeW1ib2xzID0gb3B0aW9ucy5hbGxvd1Vuc2FmZVN5bWJvbHM7XG5cdFx0dmFyIGVzY2FwZUNvZGVQb2ludCA9IG9wdGlvbnMuZGVjaW1hbCA/IGRlY0VzY2FwZSA6IGhleEVzY2FwZTtcblxuXHRcdHZhciBlc2NhcGVCbXBTeW1ib2wgPSBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiBlc2NhcGVDb2RlUG9pbnQoc3ltYm9sLmNoYXJDb2RlQXQoMCkpO1xuXHRcdH07XG5cblx0XHRpZiAoZW5jb2RlRXZlcnl0aGluZykge1xuXHRcdFx0Ly8gRW5jb2RlIEFTQ0lJIHN5bWJvbHMuXG5cdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEFzY2lpV2hpdGVsaXN0LCBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdFx0Ly8gVXNlIG5hbWVkIHJlZmVyZW5jZXMgaWYgcmVxdWVzdGVkICYgcG9zc2libGUuXG5cdFx0XHRcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMgJiYgaGFzKGVuY29kZU1hcCwgc3ltYm9sKSkge1xuXHRcdFx0XHRcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3ltYm9sXSArICc7Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZXNjYXBlQm1wU3ltYm9sKHN5bWJvbCk7XG5cdFx0XHR9KTtcblx0XHRcdC8vIFNob3J0ZW4gYSBmZXcgZXNjYXBlcyB0aGF0IHJlcHJlc2VudCB0d28gc3ltYm9scywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lXG5cdFx0XHQvLyBpcyB3aXRoaW4gdGhlIEFTQ0lJIHJhbmdlLlxuXHRcdFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xuXHRcdFx0XHRzdHJpbmcgPSBzdHJpbmdcblx0XHRcdFx0XHQucmVwbGFjZSgvJmd0O1xcdTIwRDIvZywgJyZudmd0OycpXG5cdFx0XHRcdFx0LnJlcGxhY2UoLyZsdDtcXHUyMEQyL2csICcmbnZsdDsnKVxuXHRcdFx0XHRcdC5yZXBsYWNlKC8mI3g2NjsmI3g2QTsvZywgJyZmamxpZzsnKTtcblx0XHRcdH1cblx0XHRcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scy5cblx0XHRcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcblx0XHRcdFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzIHRoYXQgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBuYW1lZCByZWZlcmVuY2UuXG5cdFx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RW5jb2RlTm9uQXNjaWksIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlbmNvZGVNYXAsIHN0cmluZylgIGhlcmUuXG5cdFx0XHRcdFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIE5vdGU6IGFueSByZW1haW5pbmcgbm9uLUFTQ0lJIHN5bWJvbHMgYXJlIGhhbmRsZWQgb3V0c2lkZSBvZiB0aGUgYGlmYC5cblx0XHR9IGVsc2UgaWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xuXHRcdFx0Ly8gQXBwbHkgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG5cdFx0XHQvLyBFbmNvZGUgYDw+XCInJmAgdXNpbmcgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXG5cdFx0XHRpZiAoIWFsbG93VW5zYWZlU3ltYm9scykge1xuXHRcdFx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRcdFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnOyAvLyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoKWAgaGVyZVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHRcdC8vIFNob3J0ZW4gZXNjYXBlcyB0aGF0IHJlcHJlc2VudCB0d28gc3ltYm9scywgb2Ygd2hpY2ggYXQgbGVhc3Qgb25lIGlzXG5cdFx0XHQvLyBgPD5cIicmYC5cblx0XHRcdHN0cmluZyA9IHN0cmluZ1xuXHRcdFx0XHQucmVwbGFjZSgvJmd0O1xcdTIwRDIvZywgJyZudmd0OycpXG5cdFx0XHRcdC5yZXBsYWNlKC8mbHQ7XFx1MjBEMi9nLCAnJm52bHQ7Jyk7XG5cdFx0XHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cblx0XHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RW5jb2RlTm9uQXNjaWksIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0XHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxuXHRcdFx0XHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N0cmluZ10gKyAnOyc7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcblx0XHRcdC8vIEVuY29kZSBgPD5cIicmYCB1c2luZyBoZXhhZGVjaW1hbCBlc2NhcGVzLCBub3cgdGhhdCB0aGV54oCZcmUgbm90IGhhbmRsZWRcblx0XHRcdC8vIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxuXHRcdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhFc2NhcGUsIGVzY2FwZUJtcFN5bWJvbCk7XG5cdFx0fVxuXHRcdHJldHVybiBzdHJpbmdcblx0XHRcdC8vIEVuY29kZSBhc3RyYWwgc3ltYm9scy5cblx0XHRcdC5yZXBsYWNlKHJlZ2V4QXN0cmFsU3ltYm9scywgZnVuY3Rpb24oJDApIHtcblx0XHRcdFx0Ly8gaHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmcjc3Vycm9nYXRlLWZvcm11bGFlXG5cdFx0XHRcdHZhciBoaWdoID0gJDAuY2hhckNvZGVBdCgwKTtcblx0XHRcdFx0dmFyIGxvdyA9ICQwLmNoYXJDb2RlQXQoMSk7XG5cdFx0XHRcdHZhciBjb2RlUG9pbnQgPSAoaGlnaCAtIDB4RDgwMCkgKiAweDQwMCArIGxvdyAtIDB4REMwMCArIDB4MTAwMDA7XG5cdFx0XHRcdHJldHVybiBlc2NhcGVDb2RlUG9pbnQoY29kZVBvaW50KTtcblx0XHRcdH0pXG5cdFx0XHQvLyBFbmNvZGUgYW55IHJlbWFpbmluZyBCTVAgc3ltYm9scyB0aGF0IGFyZSBub3QgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHNcblx0XHRcdC8vIHVzaW5nIGEgaGV4YWRlY2ltYWwgZXNjYXBlLlxuXHRcdFx0LnJlcGxhY2UocmVnZXhCbXBXaGl0ZWxpc3QsIGVzY2FwZUJtcFN5bWJvbCk7XG5cdH07XG5cdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxuXHRlbmNvZGUub3B0aW9ucyA9IHtcblx0XHQnYWxsb3dVbnNhZmVTeW1ib2xzJzogZmFsc2UsXG5cdFx0J2VuY29kZUV2ZXJ5dGhpbmcnOiBmYWxzZSxcblx0XHQnc3RyaWN0JzogZmFsc2UsXG5cdFx0J3VzZU5hbWVkUmVmZXJlbmNlcyc6IGZhbHNlLFxuXHRcdCdkZWNpbWFsJyA6IGZhbHNlXG5cdH07XG5cblx0dmFyIGRlY29kZSA9IGZ1bmN0aW9uKGh0bWwsIG9wdGlvbnMpIHtcblx0XHRvcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgZGVjb2RlLm9wdGlvbnMpO1xuXHRcdHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcblx0XHRpZiAoc3RyaWN0ICYmIHJlZ2V4SW52YWxpZEVudGl0eS50ZXN0KGh0bWwpKSB7XG5cdFx0XHRwYXJzZUVycm9yKCdtYWxmb3JtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xuXHRcdH1cblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKHJlZ2V4RGVjb2RlLCBmdW5jdGlvbigkMCwgJDEsICQyLCAkMywgJDQsICQ1LCAkNiwgJDcsICQ4KSB7XG5cdFx0XHR2YXIgY29kZVBvaW50O1xuXHRcdFx0dmFyIHNlbWljb2xvbjtcblx0XHRcdHZhciBkZWNEaWdpdHM7XG5cdFx0XHR2YXIgaGV4RGlnaXRzO1xuXHRcdFx0dmFyIHJlZmVyZW5jZTtcblx0XHRcdHZhciBuZXh0O1xuXG5cdFx0XHRpZiAoJDEpIHtcblx0XHRcdFx0cmVmZXJlbmNlID0gJDE7XG5cdFx0XHRcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhkZWNvZGVNYXAsIHJlZmVyZW5jZSlgLlxuXHRcdFx0XHRyZXR1cm4gZGVjb2RlTWFwW3JlZmVyZW5jZV07XG5cdFx0XHR9XG5cblx0XHRcdGlmICgkMikge1xuXHRcdFx0XHQvLyBEZWNvZGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2l0aG91dCB0cmFpbGluZyBgO2AsIGUuZy4gYCZhbXBgLlxuXHRcdFx0XHQvLyBUaGlzIGlzIG9ubHkgYSBwYXJzZSBlcnJvciBpZiBpdCBnZXRzIGNvbnZlcnRlZCB0byBgJmAsIG9yIGlmIGl0IGlzXG5cdFx0XHRcdC8vIGZvbGxvd2VkIGJ5IGA9YCBpbiBhbiBhdHRyaWJ1dGUgY29udGV4dC5cblx0XHRcdFx0cmVmZXJlbmNlID0gJDI7XG5cdFx0XHRcdG5leHQgPSAkMztcblx0XHRcdFx0aWYgKG5leHQgJiYgb3B0aW9ucy5pc0F0dHJpYnV0ZVZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHN0cmljdCAmJiBuZXh0ID09ICc9Jykge1xuXHRcdFx0XHRcdFx0cGFyc2VFcnJvcignYCZgIGRpZCBub3Qgc3RhcnQgYSBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAkMDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdFx0XHRwYXJzZUVycm9yKFxuXHRcdFx0XHRcdFx0XHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZGVjb2RlTWFwTGVnYWN5LCByZWZlcmVuY2UpYC5cblx0XHRcdFx0XHRyZXR1cm4gZGVjb2RlTWFwTGVnYWN5W3JlZmVyZW5jZV0gKyAobmV4dCB8fCAnJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCQ0KSB7XG5cdFx0XHRcdC8vIERlY29kZSBkZWNpbWFsIGVzY2FwZXMsIGUuZy4gYCYjMTE5NTU4O2AuXG5cdFx0XHRcdGRlY0RpZ2l0cyA9ICQ0O1xuXHRcdFx0XHRzZW1pY29sb24gPSAkNTtcblx0XHRcdFx0aWYgKHN0cmljdCAmJiAhc2VtaWNvbG9uKSB7XG5cdFx0XHRcdFx0cGFyc2VFcnJvcignY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2RlUG9pbnQgPSBwYXJzZUludChkZWNEaWdpdHMsIDEwKTtcblx0XHRcdFx0cmV0dXJuIGNvZGVQb2ludFRvU3ltYm9sKGNvZGVQb2ludCwgc3RyaWN0KTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCQ2KSB7XG5cdFx0XHRcdC8vIERlY29kZSBoZXhhZGVjaW1hbCBlc2NhcGVzLCBlLmcuIGAmI3gxRDMwNjtgLlxuXHRcdFx0XHRoZXhEaWdpdHMgPSAkNjtcblx0XHRcdFx0c2VtaWNvbG9uID0gJDc7XG5cdFx0XHRcdGlmIChzdHJpY3QgJiYgIXNlbWljb2xvbikge1xuXHRcdFx0XHRcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29kZVBvaW50ID0gcGFyc2VJbnQoaGV4RGlnaXRzLCAxNik7XG5cdFx0XHRcdHJldHVybiBjb2RlUG9pbnRUb1N5bWJvbChjb2RlUG9pbnQsIHN0cmljdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHdl4oCZcmUgc3RpbGwgaGVyZSwgYGlmICgkNylgIGlzIGltcGxpZWQ7IGl04oCZcyBhbiBhbWJpZ3VvdXNcblx0XHRcdC8vIGFtcGVyc2FuZCBmb3Igc3VyZS4gaHR0cHM6Ly9tdGhzLmJlL25vdGVzL2FtYmlndW91cy1hbXBlcnNhbmRzXG5cdFx0XHRpZiAoc3RyaWN0KSB7XG5cdFx0XHRcdHBhcnNlRXJyb3IoXG5cdFx0XHRcdFx0J25hbWVkIGNoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJ1xuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuICQwO1xuXHRcdH0pO1xuXHR9O1xuXHQvLyBFeHBvc2UgZGVmYXVsdCBvcHRpb25zIChzbyB0aGV5IGNhbiBiZSBvdmVycmlkZGVuIGdsb2JhbGx5KS5cblx0ZGVjb2RlLm9wdGlvbnMgPSB7XG5cdFx0J2lzQXR0cmlidXRlVmFsdWUnOiBmYWxzZSxcblx0XHQnc3RyaWN0JzogZmFsc2Vcblx0fTtcblxuXHR2YXIgZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBmdW5jdGlvbigkMCkge1xuXHRcdFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGVzY2FwZU1hcCwgJDApYCBoZXJlLlxuXHRcdFx0cmV0dXJuIGVzY2FwZU1hcFskMF07XG5cdFx0fSk7XG5cdH07XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0dmFyIGhlID0ge1xuXHRcdCd2ZXJzaW9uJzogJzEuMi4wJyxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VzY2FwZSc6IGVzY2FwZSxcblx0XHQndW5lc2NhcGUnOiBkZWNvZGVcblx0fTtcblxuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZShmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBoZTtcblx0XHR9KTtcblx0fVx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XG5cdFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xuXHRcdFx0ZnJlZU1vZHVsZS5leHBvcnRzID0gaGU7XG5cdFx0fSBlbHNlIHsgLy8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAodmFyIGtleSBpbiBoZSkge1xuXHRcdFx0XHRoYXMoaGUsIGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBoZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7IC8vIGluIFJoaW5vIG9yIGEgd2ViIGJyb3dzZXJcblx0XHRyb290LmhlID0gaGU7XG5cdH1cblxufSh0aGlzKSk7XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsIihmdW5jdGlvbigpe1xyXG4gIHZhciBjcnlwdCA9IHJlcXVpcmUoJ2NyeXB0JyksXHJcbiAgICAgIHV0ZjggPSByZXF1aXJlKCdjaGFyZW5jJykudXRmOCxcclxuICAgICAgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKSxcclxuICAgICAgYmluID0gcmVxdWlyZSgnY2hhcmVuYycpLmJpbixcclxuXHJcbiAgLy8gVGhlIGNvcmVcclxuICBtZDUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3B0aW9ucykge1xyXG4gICAgLy8gQ29udmVydCB0byBieXRlIGFycmF5XHJcbiAgICBpZiAobWVzc2FnZS5jb25zdHJ1Y3RvciA9PSBTdHJpbmcpXHJcbiAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgPT09ICdiaW5hcnknKVxyXG4gICAgICAgIG1lc3NhZ2UgPSBiaW4uc3RyaW5nVG9CeXRlcyhtZXNzYWdlKTtcclxuICAgICAgZWxzZVxyXG4gICAgICAgIG1lc3NhZ2UgPSB1dGY4LnN0cmluZ1RvQnl0ZXMobWVzc2FnZSk7XHJcbiAgICBlbHNlIGlmIChpc0J1ZmZlcihtZXNzYWdlKSlcclxuICAgICAgbWVzc2FnZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG1lc3NhZ2UsIDApO1xyXG4gICAgZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkobWVzc2FnZSkpXHJcbiAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnRvU3RyaW5nKCk7XHJcbiAgICAvLyBlbHNlLCBhc3N1bWUgYnl0ZSBhcnJheSBhbHJlYWR5XHJcblxyXG4gICAgdmFyIG0gPSBjcnlwdC5ieXRlc1RvV29yZHMobWVzc2FnZSksXHJcbiAgICAgICAgbCA9IG1lc3NhZ2UubGVuZ3RoICogOCxcclxuICAgICAgICBhID0gIDE3MzI1ODQxOTMsXHJcbiAgICAgICAgYiA9IC0yNzE3MzM4NzksXHJcbiAgICAgICAgYyA9IC0xNzMyNTg0MTk0LFxyXG4gICAgICAgIGQgPSAgMjcxNzMzODc4O1xyXG5cclxuICAgIC8vIFN3YXAgZW5kaWFuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG0ubGVuZ3RoOyBpKyspIHtcclxuICAgICAgbVtpXSA9ICgobVtpXSA8PCAgOCkgfCAobVtpXSA+Pj4gMjQpKSAmIDB4MDBGRjAwRkYgfFxyXG4gICAgICAgICAgICAgKChtW2ldIDw8IDI0KSB8IChtW2ldID4+PiAgOCkpICYgMHhGRjAwRkYwMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQYWRkaW5nXHJcbiAgICBtW2wgPj4+IDVdIHw9IDB4ODAgPDwgKGwgJSAzMik7XHJcbiAgICBtWygoKGwgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gbDtcclxuXHJcbiAgICAvLyBNZXRob2Qgc2hvcnRjdXRzXHJcbiAgICB2YXIgRkYgPSBtZDUuX2ZmLFxyXG4gICAgICAgIEdHID0gbWQ1Ll9nZyxcclxuICAgICAgICBISCA9IG1kNS5faGgsXHJcbiAgICAgICAgSUkgPSBtZDUuX2lpO1xyXG5cclxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbS5sZW5ndGg7IGkgKz0gMTYpIHtcclxuXHJcbiAgICAgIHZhciBhYSA9IGEsXHJcbiAgICAgICAgICBiYiA9IGIsXHJcbiAgICAgICAgICBjYyA9IGMsXHJcbiAgICAgICAgICBkZCA9IGQ7XHJcblxyXG4gICAgICBhID0gRkYoYSwgYiwgYywgZCwgbVtpKyAwXSwgIDcsIC02ODA4NzY5MzYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xyXG4gICAgICBjID0gRkYoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTcsICA2MDYxMDU4MTkpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyAzXSwgMjIsIC0xMDQ0NTI1MzMwKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsgNF0sICA3LCAtMTc2NDE4ODk3KTtcclxuICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIG1baSsgNV0sIDEyLCAgMTIwMDA4MDQyNik7XHJcbiAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBtW2krIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKyA3XSwgMjIsIC00NTcwNTk4Myk7XHJcbiAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBtW2krIDhdLCAgNywgIDE3NzAwMzU0MTYpO1xyXG4gICAgICBkID0gRkYoZCwgYSwgYiwgYywgbVtpKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE3LCAtNDIwNjMpO1xyXG4gICAgICBiID0gRkYoYiwgYywgZCwgYSwgbVtpKzExXSwgMjIsIC0xOTkwNDA0MTYyKTtcclxuICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIG1baSsxMl0sICA3LCAgMTgwNDYwMzY4Mik7XHJcbiAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBtW2krMTNdLCAxMiwgLTQwMzQxMTAxKTtcclxuICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIG1baSsxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XHJcbiAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBtW2krMTVdLCAyMiwgIDEyMzY1MzUzMjkpO1xyXG5cclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgMV0sICA1LCAtMTY1Nzk2NTEwKTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgNl0sICA5LCAtMTA2OTUwMTYzMik7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krMTFdLCAxNCwgIDY0MzcxNzcxMyk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDBdLCAyMCwgLTM3Mzg5NzMwMik7XHJcbiAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBtW2krIDVdLCAgNSwgLTcwMTU1ODY5MSk7XHJcbiAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBtW2krMTBdLCAgOSwgIDM4MDE2MDgzKTtcclxuICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIG1baSsxNV0sIDE0LCAtNjYwNDc4MzM1KTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsgNF0sIDIwLCAtNDA1NTM3ODQ4KTtcclxuICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIG1baSsgOV0sICA1LCAgNTY4NDQ2NDM4KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsxNF0sICA5LCAtMTAxOTgwMzY5MCk7XHJcbiAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBtW2krIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XHJcbiAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBtW2krIDhdLCAyMCwgIDExNjM1MzE1MDEpO1xyXG4gICAgICBhID0gR0coYSwgYiwgYywgZCwgbVtpKzEzXSwgIDUsIC0xNDQ0NjgxNDY3KTtcclxuICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIG1baSsgMl0sICA5LCAtNTE0MDM3ODQpO1xyXG4gICAgICBjID0gR0coYywgZCwgYSwgYiwgbVtpKyA3XSwgMTQsICAxNzM1MzI4NDczKTtcclxuICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIG1baSsxMl0sIDIwLCAtMTkyNjYwNzczNCk7XHJcblxyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA1XSwgIDQsIC0zNzg1NTgpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKyA4XSwgMTEsIC0yMDIyNTc0NDYzKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsxMV0sIDE2LCAgMTgzOTAzMDU2Mik7XHJcbiAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBtW2krMTRdLCAyMywgLTM1MzA5NTU2KTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsgMV0sICA0LCAtMTUzMDk5MjA2MCk7XHJcbiAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBtW2krIDRdLCAxMSwgIDEyNzI4OTMzNTMpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKzEwXSwgMjMsIC0xMDk0NzMwNjQwKTtcclxuICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIG1baSsxM10sICA0LCAgNjgxMjc5MTc0KTtcclxuICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIG1baSsgMF0sIDExLCAtMzU4NTM3MjIyKTtcclxuICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIG1baSsgM10sIDE2LCAtNzIyNTIxOTc5KTtcclxuICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIG1baSsgNl0sIDIzLCAgNzYwMjkxODkpO1xyXG4gICAgICBhID0gSEgoYSwgYiwgYywgZCwgbVtpKyA5XSwgIDQsIC02NDAzNjQ0ODcpO1xyXG4gICAgICBkID0gSEgoZCwgYSwgYiwgYywgbVtpKzEyXSwgMTEsIC00MjE4MTU4MzUpO1xyXG4gICAgICBjID0gSEgoYywgZCwgYSwgYiwgbVtpKzE1XSwgMTYsICA1MzA3NDI1MjApO1xyXG4gICAgICBiID0gSEgoYiwgYywgZCwgYSwgbVtpKyAyXSwgMjMsIC05OTUzMzg2NTEpO1xyXG5cclxuICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIG1baSsgMF0sICA2LCAtMTk4NjMwODQ0KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsgN10sIDEwLCAgMTEyNjg5MTQxNSk7XHJcbiAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBtW2krMTRdLCAxNSwgLTE0MTYzNTQ5MDUpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA1XSwgMjEsIC01NzQzNDA1NSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krMTJdLCAgNiwgIDE3MDA0ODU1NzEpO1xyXG4gICAgICBkID0gSUkoZCwgYSwgYiwgYywgbVtpKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcclxuICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIG1baSsxMF0sIDE1LCAtMTA1MTUyMyk7XHJcbiAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBtW2krIDFdLCAyMSwgLTIwNTQ5MjI3OTkpO1xyXG4gICAgICBhID0gSUkoYSwgYiwgYywgZCwgbVtpKyA4XSwgIDYsICAxODczMzEzMzU5KTtcclxuICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIG1baSsxNV0sIDEwLCAtMzA2MTE3NDQpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcclxuICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIG1baSsxM10sIDIxLCAgMTMwOTE1MTY0OSk7XHJcbiAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBtW2krIDRdLCAgNiwgLTE0NTUyMzA3MCk7XHJcbiAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBtW2krMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xyXG4gICAgICBjID0gSUkoYywgZCwgYSwgYiwgbVtpKyAyXSwgMTUsICA3MTg3ODcyNTkpO1xyXG4gICAgICBiID0gSUkoYiwgYywgZCwgYSwgbVtpKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xyXG5cclxuICAgICAgYSA9IChhICsgYWEpID4+PiAwO1xyXG4gICAgICBiID0gKGIgKyBiYikgPj4+IDA7XHJcbiAgICAgIGMgPSAoYyArIGNjKSA+Pj4gMDtcclxuICAgICAgZCA9IChkICsgZGQpID4+PiAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjcnlwdC5lbmRpYW4oW2EsIGIsIGMsIGRdKTtcclxuICB9O1xyXG5cclxuICAvLyBBdXhpbGlhcnkgZnVuY3Rpb25zXHJcbiAgbWQ1Ll9mZiAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBjIHwgfmIgJiBkKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9nZyAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgJiBkIHwgYyAmIH5kKSArICh4ID4+PiAwKSArIHQ7XHJcbiAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG4gIH07XHJcbiAgbWQ1Ll9oaCAgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG4gICAgdmFyIG4gPSBhICsgKGIgXiBjIF4gZCkgKyAoeCA+Pj4gMCkgKyB0O1xyXG4gICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuICB9O1xyXG4gIG1kNS5faWkgID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgKHggPj4+IDApICsgdDtcclxuICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcbiAgfTtcclxuXHJcbiAgLy8gUGFja2FnZSBwcml2YXRlIGJsb2Nrc2l6ZVxyXG4gIG1kNS5fYmxvY2tzaXplID0gMTY7XHJcbiAgbWQ1Ll9kaWdlc3RzaXplID0gMTY7XHJcblxyXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG1lc3NhZ2UsIG9wdGlvbnMpIHtcclxuICAgIGlmIChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgbWVzc2FnZSA9PT0gbnVsbClcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbGxlZ2FsIGFyZ3VtZW50ICcgKyBtZXNzYWdlKTtcclxuXHJcbiAgICB2YXIgZGlnZXN0Ynl0ZXMgPSBjcnlwdC53b3Jkc1RvQnl0ZXMobWQ1KG1lc3NhZ2UsIG9wdGlvbnMpKTtcclxuICAgIHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNCeXRlcyA/IGRpZ2VzdGJ5dGVzIDpcclxuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPyBiaW4uYnl0ZXNUb1N0cmluZyhkaWdlc3RieXRlcykgOlxyXG4gICAgICAgIGNyeXB0LmJ5dGVzVG9IZXgoZGlnZXN0Ynl0ZXMpO1xyXG4gIH07XHJcblxyXG59KSgpO1xyXG4iLCIvLyEgbW9tZW50LmpzXG5cbjsoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgICB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuICAgIGdsb2JhbC5tb21lbnQgPSBmYWN0b3J5KClcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGhvb2tDYWxsYmFjaztcblxuICAgIGZ1bmN0aW9uIGhvb2tzICgpIHtcbiAgICAgICAgcmV0dXJuIGhvb2tDYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIFRoaXMgaXMgZG9uZSB0byByZWdpc3RlciB0aGUgbWV0aG9kIGNhbGxlZCB3aXRoIG1vbWVudCgpXG4gICAgLy8gd2l0aG91dCBjcmVhdGluZyBjaXJjdWxhciBkZXBlbmRlbmNpZXMuXG4gICAgZnVuY3Rpb24gc2V0SG9va0NhbGxiYWNrIChjYWxsYmFjaykge1xuICAgICAgICBob29rQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FycmF5KGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIEFycmF5IHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpbnB1dCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3QoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IHdpbGwgdHJlYXQgdW5kZWZpbmVkIGFuZCBudWxsIGFzIG9iamVjdCBpZiBpdCB3YXNuJ3QgZm9yXG4gICAgICAgIC8vIGlucHV0ICE9IG51bGxcbiAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgT2JqZWN0XSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoID09PSAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgZm9yIChrIGluIG9iaikge1xuICAgICAgICAgICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVbmRlZmluZWQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09PSB2b2lkIDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNEYXRlKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBpbnB1dCBpbnN0YW5jZW9mIERhdGUgfHwgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGlucHV0KSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1hcChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXMgPSBbXSwgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgcmVzLnB1c2goZm4oYXJyW2ldLCBpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNPd25Qcm9wKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBiKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgICAgICBmb3IgKHZhciBpIGluIGIpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGIsIGkpKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IGJbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndG9TdHJpbmcnKSkge1xuICAgICAgICAgICAgYS50b1N0cmluZyA9IGIudG9TdHJpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzT3duUHJvcChiLCAndmFsdWVPZicpKSB7XG4gICAgICAgICAgICBhLnZhbHVlT2YgPSBiLnZhbHVlT2Y7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbE9yVVRDKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCB0cnVlKS51dGMoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZhdWx0UGFyc2luZ0ZsYWdzKCkge1xuICAgICAgICAvLyBXZSBuZWVkIHRvIGRlZXAgY2xvbmUgdGhpcyBvYmplY3QuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlbXB0eSAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVudXNlZFRva2VucyAgICA6IFtdLFxuICAgICAgICAgICAgdW51c2VkSW5wdXQgICAgIDogW10sXG4gICAgICAgICAgICBvdmVyZmxvdyAgICAgICAgOiAtMixcbiAgICAgICAgICAgIGNoYXJzTGVmdE92ZXIgICA6IDAsXG4gICAgICAgICAgICBudWxsSW5wdXQgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGludmFsaWRNb250aCAgICA6IG51bGwsXG4gICAgICAgICAgICBpbnZhbGlkRm9ybWF0ICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHVzZXJJbnZhbGlkYXRlZCA6IGZhbHNlLFxuICAgICAgICAgICAgaXNvICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBwYXJzZWREYXRlUGFydHMgOiBbXSxcbiAgICAgICAgICAgIG1lcmlkaWVtICAgICAgICA6IG51bGwsXG4gICAgICAgICAgICByZmMyODIyICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIHdlZWtkYXlNaXNtYXRjaCA6IGZhbHNlXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2luZ0ZsYWdzKG0pIHtcbiAgICAgICAgaWYgKG0uX3BmID09IG51bGwpIHtcbiAgICAgICAgICAgIG0uX3BmID0gZGVmYXVsdFBhcnNpbmdGbGFncygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtLl9wZjtcbiAgICB9XG5cbiAgICB2YXIgc29tZTtcbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLnNvbWUpIHtcbiAgICAgICAgc29tZSA9IEFycmF5LnByb3RvdHlwZS5zb21lO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNvbWUgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgICAgICAgICB2YXIgdCA9IE9iamVjdCh0aGlzKTtcbiAgICAgICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpIGluIHQgJiYgZnVuLmNhbGwodGhpcywgdFtpXSwgaSwgdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZChtKSB7XG4gICAgICAgIGlmIChtLl9pc1ZhbGlkID09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBmbGFncyA9IGdldFBhcnNpbmdGbGFncyhtKTtcbiAgICAgICAgICAgIHZhciBwYXJzZWRQYXJ0cyA9IHNvbWUuY2FsbChmbGFncy5wYXJzZWREYXRlUGFydHMsIGZ1bmN0aW9uIChpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGkgIT0gbnVsbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIGlzTm93VmFsaWQgPSAhaXNOYU4obS5fZC5nZXRUaW1lKCkpICYmXG4gICAgICAgICAgICAgICAgZmxhZ3Mub3ZlcmZsb3cgPCAwICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmVtcHR5ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRNb250aCAmJlxuICAgICAgICAgICAgICAgICFmbGFncy5pbnZhbGlkV2Vla2RheSAmJlxuICAgICAgICAgICAgICAgICFmbGFncy53ZWVrZGF5TWlzbWF0Y2ggJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MubnVsbElucHV0ICYmXG4gICAgICAgICAgICAgICAgIWZsYWdzLmludmFsaWRGb3JtYXQgJiZcbiAgICAgICAgICAgICAgICAhZmxhZ3MudXNlckludmFsaWRhdGVkICYmXG4gICAgICAgICAgICAgICAgKCFmbGFncy5tZXJpZGllbSB8fCAoZmxhZ3MubWVyaWRpZW0gJiYgcGFyc2VkUGFydHMpKTtcblxuICAgICAgICAgICAgaWYgKG0uX3N0cmljdCkge1xuICAgICAgICAgICAgICAgIGlzTm93VmFsaWQgPSBpc05vd1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgIGZsYWdzLmNoYXJzTGVmdE92ZXIgPT09IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgZmxhZ3MudW51c2VkVG9rZW5zLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgICAgICAgICBmbGFncy5iaWdIb3VyID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChPYmplY3QuaXNGcm96ZW4gPT0gbnVsbCB8fCAhT2JqZWN0LmlzRnJvemVuKG0pKSB7XG4gICAgICAgICAgICAgICAgbS5faXNWYWxpZCA9IGlzTm93VmFsaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNOb3dWYWxpZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbS5faXNWYWxpZDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnZhbGlkIChmbGFncykge1xuICAgICAgICB2YXIgbSA9IGNyZWF0ZVVUQyhOYU4pO1xuICAgICAgICBpZiAoZmxhZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgZXh0ZW5kKGdldFBhcnNpbmdGbGFncyhtKSwgZmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKG0pLnVzZXJJbnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbTtcbiAgICB9XG5cbiAgICAvLyBQbHVnaW5zIHRoYXQgYWRkIHByb3BlcnRpZXMgc2hvdWxkIGFsc28gYWRkIHRoZSBrZXkgaGVyZSAobnVsbCB2YWx1ZSksXG4gICAgLy8gc28gd2UgY2FuIHByb3Blcmx5IGNsb25lIG91cnNlbHZlcy5cbiAgICB2YXIgbW9tZW50UHJvcGVydGllcyA9IGhvb2tzLm1vbWVudFByb3BlcnRpZXMgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGNvcHlDb25maWcodG8sIGZyb20pIHtcbiAgICAgICAgdmFyIGksIHByb3AsIHZhbDtcblxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzQU1vbWVudE9iamVjdCkpIHtcbiAgICAgICAgICAgIHRvLl9pc0FNb21lbnRPYmplY3QgPSBmcm9tLl9pc0FNb21lbnRPYmplY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9pKSkge1xuICAgICAgICAgICAgdG8uX2kgPSBmcm9tLl9pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fZikpIHtcbiAgICAgICAgICAgIHRvLl9mID0gZnJvbS5fZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2wpKSB7XG4gICAgICAgICAgICB0by5fbCA9IGZyb20uX2w7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9zdHJpY3QpKSB7XG4gICAgICAgICAgICB0by5fc3RyaWN0ID0gZnJvbS5fc3RyaWN0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fdHptKSkge1xuICAgICAgICAgICAgdG8uX3R6bSA9IGZyb20uX3R6bTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKGZyb20uX2lzVVRDKSkge1xuICAgICAgICAgICAgdG8uX2lzVVRDID0gZnJvbS5faXNVVEM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9vZmZzZXQpKSB7XG4gICAgICAgICAgICB0by5fb2Zmc2V0ID0gZnJvbS5fb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNVbmRlZmluZWQoZnJvbS5fcGYpKSB7XG4gICAgICAgICAgICB0by5fcGYgPSBnZXRQYXJzaW5nRmxhZ3MoZnJvbSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChmcm9tLl9sb2NhbGUpKSB7XG4gICAgICAgICAgICB0by5fbG9jYWxlID0gZnJvbS5fbG9jYWxlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1vbWVudFByb3BlcnRpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG1vbWVudFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9wID0gbW9tZW50UHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgICAgICB2YWwgPSBmcm9tW3Byb3BdO1xuICAgICAgICAgICAgICAgIGlmICghaXNVbmRlZmluZWQodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICB0b1twcm9wXSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZUluUHJvZ3Jlc3MgPSBmYWxzZTtcblxuICAgIC8vIE1vbWVudCBwcm90b3R5cGUgb2JqZWN0XG4gICAgZnVuY3Rpb24gTW9tZW50KGNvbmZpZykge1xuICAgICAgICBjb3B5Q29uZmlnKHRoaXMsIGNvbmZpZyk7XG4gICAgICAgIHRoaXMuX2QgPSBuZXcgRGF0ZShjb25maWcuX2QgIT0gbnVsbCA/IGNvbmZpZy5fZC5nZXRUaW1lKCkgOiBOYU4pO1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLl9kID0gbmV3IERhdGUoTmFOKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGluZmluaXRlIGxvb3AgaW4gY2FzZSB1cGRhdGVPZmZzZXQgY3JlYXRlcyBuZXcgbW9tZW50XG4gICAgICAgIC8vIG9iamVjdHMuXG4gICAgICAgIGlmICh1cGRhdGVJblByb2dyZXNzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlSW5Qcm9ncmVzcyA9IHRydWU7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcyk7XG4gICAgICAgICAgICB1cGRhdGVJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc01vbWVudCAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogaW5zdGFuY2VvZiBNb21lbnQgfHwgKG9iaiAhPSBudWxsICYmIG9iai5faXNBTW9tZW50T2JqZWN0ICE9IG51bGwpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic0Zsb29yIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIC8vIC0wIC0+IDBcbiAgICAgICAgICAgIHJldHVybiBNYXRoLmNlaWwobnVtYmVyKSB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguZmxvb3IobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSW50KGFyZ3VtZW50Rm9yQ29lcmNpb24pIHtcbiAgICAgICAgdmFyIGNvZXJjZWROdW1iZXIgPSArYXJndW1lbnRGb3JDb2VyY2lvbixcbiAgICAgICAgICAgIHZhbHVlID0gMDtcblxuICAgICAgICBpZiAoY29lcmNlZE51bWJlciAhPT0gMCAmJiBpc0Zpbml0ZShjb2VyY2VkTnVtYmVyKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBhYnNGbG9vcihjb2VyY2VkTnVtYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvLyBjb21wYXJlIHR3byBhcnJheXMsIHJldHVybiB0aGUgbnVtYmVyIG9mIGRpZmZlcmVuY2VzXG4gICAgZnVuY3Rpb24gY29tcGFyZUFycmF5cyhhcnJheTEsIGFycmF5MiwgZG9udENvbnZlcnQpIHtcbiAgICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycmF5MS5sZW5ndGgsIGFycmF5Mi5sZW5ndGgpLFxuICAgICAgICAgICAgbGVuZ3RoRGlmZiA9IE1hdGguYWJzKGFycmF5MS5sZW5ndGggLSBhcnJheTIubGVuZ3RoKSxcbiAgICAgICAgICAgIGRpZmZzID0gMCxcbiAgICAgICAgICAgIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKChkb250Q29udmVydCAmJiBhcnJheTFbaV0gIT09IGFycmF5MltpXSkgfHxcbiAgICAgICAgICAgICAgICAoIWRvbnRDb252ZXJ0ICYmIHRvSW50KGFycmF5MVtpXSkgIT09IHRvSW50KGFycmF5MltpXSkpKSB7XG4gICAgICAgICAgICAgICAgZGlmZnMrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlmZnMgKyBsZW5ndGhEaWZmO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gICAgICAgIGlmIChob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPT09IGZhbHNlICYmXG4gICAgICAgICAgICAgICAgKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdEZXByZWNhdGlvbiB3YXJuaW5nOiAnICsgbXNnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlcHJlY2F0ZShtc2csIGZuKSB7XG4gICAgICAgIHZhciBmaXJzdFRpbWUgPSB0cnVlO1xuXG4gICAgICAgIHJldHVybiBleHRlbmQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKGhvb2tzLmRlcHJlY2F0aW9uSGFuZGxlciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG51bGwsIG1zZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlyc3RUaW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICB2YXIgYXJnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZyA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1tpXSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyArPSAnXFxuWycgKyBpICsgJ10gJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiBhcmd1bWVudHNbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmcgKz0ga2V5ICsgJzogJyArIGFyZ3VtZW50c1swXVtrZXldICsgJywgJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZy5zbGljZSgwLCAtMik7IC8vIFJlbW92ZSB0cmFpbGluZyBjb21tYSBhbmQgc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZyA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2Fybihtc2cgKyAnXFxuQXJndW1lbnRzOiAnICsgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuam9pbignJykgKyAnXFxuJyArIChuZXcgRXJyb3IoKSkuc3RhY2spO1xuICAgICAgICAgICAgICAgIGZpcnN0VGltZSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sIGZuKTtcbiAgICB9XG5cbiAgICB2YXIgZGVwcmVjYXRpb25zID0ge307XG5cbiAgICBmdW5jdGlvbiBkZXByZWNhdGVTaW1wbGUobmFtZSwgbXNnKSB7XG4gICAgICAgIGlmIChob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgaG9va3MuZGVwcmVjYXRpb25IYW5kbGVyKG5hbWUsIG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZXByZWNhdGlvbnNbbmFtZV0pIHtcbiAgICAgICAgICAgIHdhcm4obXNnKTtcbiAgICAgICAgICAgIGRlcHJlY2F0aW9uc1tuYW1lXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBob29rcy5zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZ3MgPSBmYWxzZTtcbiAgICBob29rcy5kZXByZWNhdGlvbkhhbmRsZXIgPSBudWxsO1xuXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBGdW5jdGlvbiB8fCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaW5wdXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldCAoY29uZmlnKSB7XG4gICAgICAgIHZhciBwcm9wLCBpO1xuICAgICAgICBmb3IgKGkgaW4gY29uZmlnKSB7XG4gICAgICAgICAgICBwcm9wID0gY29uZmlnW2ldO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24ocHJvcCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzW2ldID0gcHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1snXycgKyBpXSA9IHByb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgICAgICAvLyBMZW5pZW50IG9yZGluYWwgcGFyc2luZyBhY2NlcHRzIGp1c3QgYSBudW1iZXIgaW4gYWRkaXRpb24gdG9cbiAgICAgICAgLy8gbnVtYmVyICsgKHBvc3NpYmx5KSBzdHVmZiBjb21pbmcgZnJvbSBfZGF5T2ZNb250aE9yZGluYWxQYXJzZS5cbiAgICAgICAgLy8gVE9ETzogUmVtb3ZlIFwib3JkaW5hbFBhcnNlXCIgZmFsbGJhY2sgaW4gbmV4dCBtYWpvciByZWxlYXNlLlxuICAgICAgICB0aGlzLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudCA9IG5ldyBSZWdFeHAoXG4gICAgICAgICAgICAodGhpcy5fZGF5T2ZNb250aE9yZGluYWxQYXJzZS5zb3VyY2UgfHwgdGhpcy5fb3JkaW5hbFBhcnNlLnNvdXJjZSkgK1xuICAgICAgICAgICAgICAgICd8JyArICgvXFxkezEsMn0vKS5zb3VyY2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNoaWxkQ29uZmlnKSB7XG4gICAgICAgIHZhciByZXMgPSBleHRlbmQoe30sIHBhcmVudENvbmZpZyksIHByb3A7XG4gICAgICAgIGZvciAocHJvcCBpbiBjaGlsZENvbmZpZykge1xuICAgICAgICAgICAgaWYgKGhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkgJiYgaXNPYmplY3QoY2hpbGRDb25maWdbcHJvcF0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBwYXJlbnRDb25maWdbcHJvcF0pO1xuICAgICAgICAgICAgICAgICAgICBleHRlbmQocmVzW3Byb3BdLCBjaGlsZENvbmZpZ1twcm9wXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaGlsZENvbmZpZ1twcm9wXSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc1twcm9wXSA9IGNoaWxkQ29uZmlnW3Byb3BdO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXNbcHJvcF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAocHJvcCBpbiBwYXJlbnRDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKHBhcmVudENvbmZpZywgcHJvcCkgJiZcbiAgICAgICAgICAgICAgICAgICAgIWhhc093blByb3AoY2hpbGRDb25maWcsIHByb3ApICYmXG4gICAgICAgICAgICAgICAgICAgIGlzT2JqZWN0KHBhcmVudENvbmZpZ1twcm9wXSkpIHtcbiAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgY2hhbmdlcyB0byBwcm9wZXJ0aWVzIGRvbid0IG1vZGlmeSBwYXJlbnQgY29uZmlnXG4gICAgICAgICAgICAgICAgcmVzW3Byb3BdID0gZXh0ZW5kKHt9LCByZXNbcHJvcF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gTG9jYWxlKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0KGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIga2V5cztcblxuICAgIGlmIChPYmplY3Qua2V5cykge1xuICAgICAgICBrZXlzID0gT2JqZWN0LmtleXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAga2V5cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHZhciBpLCByZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzT3duUHJvcChvYmosIGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRDYWxlbmRhciA9IHtcbiAgICAgICAgc2FtZURheSA6ICdbVG9kYXkgYXRdIExUJyxcbiAgICAgICAgbmV4dERheSA6ICdbVG9tb3Jyb3cgYXRdIExUJyxcbiAgICAgICAgbmV4dFdlZWsgOiAnZGRkZCBbYXRdIExUJyxcbiAgICAgICAgbGFzdERheSA6ICdbWWVzdGVyZGF5IGF0XSBMVCcsXG4gICAgICAgIGxhc3RXZWVrIDogJ1tMYXN0XSBkZGRkIFthdF0gTFQnLFxuICAgICAgICBzYW1lRWxzZSA6ICdMJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciAoa2V5LCBtb20sIG5vdykge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fY2FsZW5kYXJba2V5XSB8fCB0aGlzLl9jYWxlbmRhclsnc2FtZUVsc2UnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ob3V0cHV0KSA/IG91dHB1dC5jYWxsKG1vbSwgbm93KSA6IG91dHB1dDtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvbmdEYXRlRm9ybWF0ID0ge1xuICAgICAgICBMVFMgIDogJ2g6bW06c3MgQScsXG4gICAgICAgIExUICAgOiAnaDptbSBBJyxcbiAgICAgICAgTCAgICA6ICdNTS9ERC9ZWVlZJyxcbiAgICAgICAgTEwgICA6ICdNTU1NIEQsIFlZWVknLFxuICAgICAgICBMTEwgIDogJ01NTU0gRCwgWVlZWSBoOm1tIEEnLFxuICAgICAgICBMTExMIDogJ2RkZGQsIE1NTU0gRCwgWVlZWSBoOm1tIEEnXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvbmdEYXRlRm9ybWF0IChrZXkpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0sXG4gICAgICAgICAgICBmb3JtYXRVcHBlciA9IHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleS50b1VwcGVyQ2FzZSgpXTtcblxuICAgICAgICBpZiAoZm9ybWF0IHx8ICFmb3JtYXRVcHBlcikge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV0gPSBmb3JtYXRVcHBlci5yZXBsYWNlKC9NTU1NfE1NfEREfGRkZGQvZywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zbGljZSgxKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvbmdEYXRlRm9ybWF0W2tleV07XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRJbnZhbGlkRGF0ZSA9ICdJbnZhbGlkIGRhdGUnO1xuXG4gICAgZnVuY3Rpb24gaW52YWxpZERhdGUgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52YWxpZERhdGU7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRPcmRpbmFsID0gJyVkJztcbiAgICB2YXIgZGVmYXVsdERheU9mTW9udGhPcmRpbmFsUGFyc2UgPSAvXFxkezEsMn0vO1xuXG4gICAgZnVuY3Rpb24gb3JkaW5hbCAobnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmRpbmFsLnJlcGxhY2UoJyVkJywgbnVtYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFJlbGF0aXZlVGltZSA9IHtcbiAgICAgICAgZnV0dXJlIDogJ2luICVzJyxcbiAgICAgICAgcGFzdCAgIDogJyVzIGFnbycsXG4gICAgICAgIHMgIDogJ2EgZmV3IHNlY29uZHMnLFxuICAgICAgICBzcyA6ICclZCBzZWNvbmRzJyxcbiAgICAgICAgbSAgOiAnYSBtaW51dGUnLFxuICAgICAgICBtbSA6ICclZCBtaW51dGVzJyxcbiAgICAgICAgaCAgOiAnYW4gaG91cicsXG4gICAgICAgIGhoIDogJyVkIGhvdXJzJyxcbiAgICAgICAgZCAgOiAnYSBkYXknLFxuICAgICAgICBkZCA6ICclZCBkYXlzJyxcbiAgICAgICAgTSAgOiAnYSBtb250aCcsXG4gICAgICAgIE1NIDogJyVkIG1vbnRocycsXG4gICAgICAgIHkgIDogJ2EgeWVhcicsXG4gICAgICAgIHl5IDogJyVkIHllYXJzJ1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiByZWxhdGl2ZVRpbWUgKG51bWJlciwgd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSkge1xuICAgICAgICB2YXIgb3V0cHV0ID0gdGhpcy5fcmVsYXRpdmVUaW1lW3N0cmluZ107XG4gICAgICAgIHJldHVybiAoaXNGdW5jdGlvbihvdXRwdXQpKSA/XG4gICAgICAgICAgICBvdXRwdXQobnVtYmVyLCB3aXRob3V0U3VmZml4LCBzdHJpbmcsIGlzRnV0dXJlKSA6XG4gICAgICAgICAgICBvdXRwdXQucmVwbGFjZSgvJWQvaSwgbnVtYmVyKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXN0RnV0dXJlIChkaWZmLCBvdXRwdXQpIHtcbiAgICAgICAgdmFyIGZvcm1hdCA9IHRoaXMuX3JlbGF0aXZlVGltZVtkaWZmID4gMCA/ICdmdXR1cmUnIDogJ3Bhc3QnXTtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24oZm9ybWF0KSA/IGZvcm1hdChvdXRwdXQpIDogZm9ybWF0LnJlcGxhY2UoLyVzL2ksIG91dHB1dCk7XG4gICAgfVxuXG4gICAgdmFyIGFsaWFzZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFVuaXRBbGlhcyAodW5pdCwgc2hvcnRoYW5kKSB7XG4gICAgICAgIHZhciBsb3dlckNhc2UgPSB1bml0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGFsaWFzZXNbbG93ZXJDYXNlXSA9IGFsaWFzZXNbbG93ZXJDYXNlICsgJ3MnXSA9IGFsaWFzZXNbc2hvcnRoYW5kXSA9IHVuaXQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplVW5pdHModW5pdHMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB1bml0cyA9PT0gJ3N0cmluZycgPyBhbGlhc2VzW3VuaXRzXSB8fCBhbGlhc2VzW3VuaXRzLnRvTG93ZXJDYXNlKCldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZU9iamVjdFVuaXRzKGlucHV0T2JqZWN0KSB7XG4gICAgICAgIHZhciBub3JtYWxpemVkSW5wdXQgPSB7fSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wLFxuICAgICAgICAgICAgcHJvcDtcblxuICAgICAgICBmb3IgKHByb3AgaW4gaW5wdXRPYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wKGlucHV0T2JqZWN0LCBwcm9wKSkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRQcm9wID0gbm9ybWFsaXplVW5pdHMocHJvcCk7XG4gICAgICAgICAgICAgICAgaWYgKG5vcm1hbGl6ZWRQcm9wKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRJbnB1dFtub3JtYWxpemVkUHJvcF0gPSBpbnB1dE9iamVjdFtwcm9wXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9ybWFsaXplZElucHV0O1xuICAgIH1cblxuICAgIHZhciBwcmlvcml0aWVzID0ge307XG5cbiAgICBmdW5jdGlvbiBhZGRVbml0UHJpb3JpdHkodW5pdCwgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdGllc1t1bml0XSA9IHByaW9yaXR5O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFByaW9yaXRpemVkVW5pdHModW5pdHNPYmopIHtcbiAgICAgICAgdmFyIHVuaXRzID0gW107XG4gICAgICAgIGZvciAodmFyIHUgaW4gdW5pdHNPYmopIHtcbiAgICAgICAgICAgIHVuaXRzLnB1c2goe3VuaXQ6IHUsIHByaW9yaXR5OiBwcmlvcml0aWVzW3VdfSk7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGEucHJpb3JpdHkgLSBiLnByaW9yaXR5O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHVuaXRzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHplcm9GaWxsKG51bWJlciwgdGFyZ2V0TGVuZ3RoLCBmb3JjZVNpZ24pIHtcbiAgICAgICAgdmFyIGFic051bWJlciA9ICcnICsgTWF0aC5hYnMobnVtYmVyKSxcbiAgICAgICAgICAgIHplcm9zVG9GaWxsID0gdGFyZ2V0TGVuZ3RoIC0gYWJzTnVtYmVyLmxlbmd0aCxcbiAgICAgICAgICAgIHNpZ24gPSBudW1iZXIgPj0gMDtcbiAgICAgICAgcmV0dXJuIChzaWduID8gKGZvcmNlU2lnbiA/ICcrJyA6ICcnKSA6ICctJykgK1xuICAgICAgICAgICAgTWF0aC5wb3coMTAsIE1hdGgubWF4KDAsIHplcm9zVG9GaWxsKSkudG9TdHJpbmcoKS5zdWJzdHIoMSkgKyBhYnNOdW1iZXI7XG4gICAgfVxuXG4gICAgdmFyIGZvcm1hdHRpbmdUb2tlbnMgPSAvKFxcW1teXFxbXSpcXF0pfChcXFxcKT8oW0hoXW1tKHNzKT98TW98TU0/TT9NP3xEb3xERERvfEREP0Q/RD98ZGRkP2Q/fGRvP3x3W298d10/fFdbb3xXXT98UW8/fFlZWVlZWXxZWVlZWXxZWVlZfFlZfGdnKGdnZz8pP3xHRyhHR0c/KT98ZXxFfGF8QXxoaD98SEg/fGtrP3xtbT98c3M/fFN7MSw5fXx4fFh8eno/fFpaP3wuKS9nO1xuXG4gICAgdmFyIGxvY2FsRm9ybWF0dGluZ1Rva2VucyA9IC8oXFxbW15cXFtdKlxcXSl8KFxcXFwpPyhMVFN8TFR8TEw/TD9MP3xsezEsNH0pL2c7XG5cbiAgICB2YXIgZm9ybWF0RnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgZm9ybWF0VG9rZW5GdW5jdGlvbnMgPSB7fTtcblxuICAgIC8vIHRva2VuOiAgICAnTSdcbiAgICAvLyBwYWRkZWQ6ICAgWydNTScsIDJdXG4gICAgLy8gb3JkaW5hbDogICdNbydcbiAgICAvLyBjYWxsYmFjazogZnVuY3Rpb24gKCkgeyB0aGlzLm1vbnRoKCkgKyAxIH1cbiAgICBmdW5jdGlvbiBhZGRGb3JtYXRUb2tlbiAodG9rZW4sIHBhZGRlZCwgb3JkaW5hbCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbY2FsbGJhY2tdKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dID0gZnVuYztcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFkZGVkKSB7XG4gICAgICAgICAgICBmb3JtYXRUb2tlbkZ1bmN0aW9uc1twYWRkZWRbMF1dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6ZXJvRmlsbChmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIHBhZGRlZFsxXSwgcGFkZGVkWzJdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9yZGluYWwpIHtcbiAgICAgICAgICAgIGZvcm1hdFRva2VuRnVuY3Rpb25zW29yZGluYWxdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5vcmRpbmFsKGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKSwgdG9rZW4pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoaW5wdXQpIHtcbiAgICAgICAgaWYgKGlucHV0Lm1hdGNoKC9cXFtbXFxzXFxTXS8pKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXlxcW3xcXF0kL2csICcnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXFxcXC9nLCAnJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCkge1xuICAgICAgICB2YXIgYXJyYXkgPSBmb3JtYXQubWF0Y2goZm9ybWF0dGluZ1Rva2VucyksIGksIGxlbmd0aDtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBhcnJheS5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGZvcm1hdFRva2VuRnVuY3Rpb25zW2FycmF5W2ldXSkge1xuICAgICAgICAgICAgICAgIGFycmF5W2ldID0gZm9ybWF0VG9rZW5GdW5jdGlvbnNbYXJyYXlbaV1dO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcnJheVtpXSA9IHJlbW92ZUZvcm1hdHRpbmdUb2tlbnMoYXJyYXlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtb20pIHtcbiAgICAgICAgICAgIHZhciBvdXRwdXQgPSAnJywgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG91dHB1dCArPSBpc0Z1bmN0aW9uKGFycmF5W2ldKSA/IGFycmF5W2ldLmNhbGwobW9tLCBmb3JtYXQpIDogYXJyYXlbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIGZvcm1hdCBkYXRlIHVzaW5nIG5hdGl2ZSBkYXRlIG9iamVjdFxuICAgIGZ1bmN0aW9uIGZvcm1hdE1vbWVudChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG0ubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3JtYXQgPSBleHBhbmRGb3JtYXQoZm9ybWF0LCBtLmxvY2FsZURhdGEoKSk7XG4gICAgICAgIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdID0gZm9ybWF0RnVuY3Rpb25zW2Zvcm1hdF0gfHwgbWFrZUZvcm1hdEZ1bmN0aW9uKGZvcm1hdCk7XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdEZ1bmN0aW9uc1tmb3JtYXRdKG0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGV4cGFuZEZvcm1hdChmb3JtYXQsIGxvY2FsZSkge1xuICAgICAgICB2YXIgaSA9IDU7XG5cbiAgICAgICAgZnVuY3Rpb24gcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKGlucHV0KSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLmxvbmdEYXRlRm9ybWF0KGlucHV0KSB8fCBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICB3aGlsZSAoaSA+PSAwICYmIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy50ZXN0KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdC5yZXBsYWNlKGxvY2FsRm9ybWF0dGluZ1Rva2VucywgcmVwbGFjZUxvbmdEYXRlRm9ybWF0VG9rZW5zKTtcbiAgICAgICAgICAgIGxvY2FsRm9ybWF0dGluZ1Rva2Vucy5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZvcm1hdDtcbiAgICB9XG5cbiAgICB2YXIgbWF0Y2gxICAgICAgICAgPSAvXFxkLzsgICAgICAgICAgICAvLyAgICAgICAwIC0gOVxuICAgIHZhciBtYXRjaDIgICAgICAgICA9IC9cXGRcXGQvOyAgICAgICAgICAvLyAgICAgIDAwIC0gOTlcbiAgICB2YXIgbWF0Y2gzICAgICAgICAgPSAvXFxkezN9LzsgICAgICAgICAvLyAgICAgMDAwIC0gOTk5XG4gICAgdmFyIG1hdGNoNCAgICAgICAgID0gL1xcZHs0fS87ICAgICAgICAgLy8gICAgMDAwMCAtIDk5OTlcbiAgICB2YXIgbWF0Y2g2ICAgICAgICAgPSAvWystXT9cXGR7Nn0vOyAgICAvLyAtOTk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMiAgICAgID0gL1xcZFxcZD8vOyAgICAgICAgIC8vICAgICAgIDAgLSA5OVxuICAgIHZhciBtYXRjaDN0bzQgICAgICA9IC9cXGRcXGRcXGRcXGQ/LzsgICAgIC8vICAgICA5OTkgLSA5OTk5XG4gICAgdmFyIG1hdGNoNXRvNiAgICAgID0gL1xcZFxcZFxcZFxcZFxcZFxcZD8vOyAvLyAgIDk5OTk5IC0gOTk5OTk5XG4gICAgdmFyIG1hdGNoMXRvMyAgICAgID0gL1xcZHsxLDN9LzsgICAgICAgLy8gICAgICAgMCAtIDk5OVxuICAgIHZhciBtYXRjaDF0bzQgICAgICA9IC9cXGR7MSw0fS87ICAgICAgIC8vICAgICAgIDAgLSA5OTk5XG4gICAgdmFyIG1hdGNoMXRvNiAgICAgID0gL1srLV0/XFxkezEsNn0vOyAgLy8gLTk5OTk5OSAtIDk5OTk5OVxuXG4gICAgdmFyIG1hdGNoVW5zaWduZWQgID0gL1xcZCsvOyAgICAgICAgICAgLy8gICAgICAgMCAtIGluZlxuICAgIHZhciBtYXRjaFNpZ25lZCAgICA9IC9bKy1dP1xcZCsvOyAgICAgIC8vICAgIC1pbmYgLSBpbmZcblxuICAgIHZhciBtYXRjaE9mZnNldCAgICA9IC9afFsrLV1cXGRcXGQ6P1xcZFxcZC9naTsgLy8gKzAwOjAwIC0wMDowMCArMDAwMCAtMDAwMCBvciBaXG4gICAgdmFyIG1hdGNoU2hvcnRPZmZzZXQgPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy9naTsgLy8gKzAwIC0wMCArMDA6MDAgLTAwOjAwICswMDAwIC0wMDAwIG9yIFpcblxuICAgIHZhciBtYXRjaFRpbWVzdGFtcCA9IC9bKy1dP1xcZCsoXFwuXFxkezEsM30pPy87IC8vIDEyMzQ1Njc4OSAxMjM0NTY3ODkuMTIzXG5cbiAgICAvLyBhbnkgd29yZCAob3IgdHdvKSBjaGFyYWN0ZXJzIG9yIG51bWJlcnMgaW5jbHVkaW5nIHR3by90aHJlZSB3b3JkIG1vbnRoIGluIGFyYWJpYy5cbiAgICAvLyBpbmNsdWRlcyBzY290dGlzaCBnYWVsaWMgdHdvIHdvcmQgYW5kIGh5cGhlbmF0ZWQgbW9udGhzXG4gICAgdmFyIG1hdGNoV29yZCA9IC9bMC05XXswLDI1Nn1bJ2EtelxcdTAwQTAtXFx1MDVGRlxcdTA3MDAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkYwN1xcdUZGMTAtXFx1RkZFRl17MSwyNTZ9fFtcXHUwNjAwLVxcdTA2RkZcXC9dezEsMjU2fShcXHMqP1tcXHUwNjAwLVxcdTA2RkZdezEsMjU2fSl7MSwyfS9pO1xuXG4gICAgdmFyIHJlZ2V4ZXMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFJlZ2V4VG9rZW4gKHRva2VuLCByZWdleCwgc3RyaWN0UmVnZXgpIHtcbiAgICAgICAgcmVnZXhlc1t0b2tlbl0gPSBpc0Z1bmN0aW9uKHJlZ2V4KSA/IHJlZ2V4IDogZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGVEYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4gKGlzU3RyaWN0ICYmIHN0cmljdFJlZ2V4KSA/IHN0cmljdFJlZ2V4IDogcmVnZXg7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UGFyc2VSZWdleEZvclRva2VuICh0b2tlbiwgY29uZmlnKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcChyZWdleGVzLCB0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHVuZXNjYXBlRm9ybWF0KHRva2VuKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVnZXhlc1t0b2tlbl0oY29uZmlnLl9zdHJpY3QsIGNvbmZpZy5fbG9jYWxlKTtcbiAgICB9XG5cbiAgICAvLyBDb2RlIGZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNTYxNDkzL2lzLXRoZXJlLWEtcmVnZXhwLWVzY2FwZS1mdW5jdGlvbi1pbi1qYXZhc2NyaXB0XG4gICAgZnVuY3Rpb24gdW5lc2NhcGVGb3JtYXQocykge1xuICAgICAgICByZXR1cm4gcmVnZXhFc2NhcGUocy5yZXBsYWNlKCdcXFxcJywgJycpLnJlcGxhY2UoL1xcXFwoXFxbKXxcXFxcKFxcXSl8XFxbKFteXFxdXFxbXSopXFxdfFxcXFwoLikvZywgZnVuY3Rpb24gKG1hdGNoZWQsIHAxLCBwMiwgcDMsIHA0KSB7XG4gICAgICAgICAgICByZXR1cm4gcDEgfHwgcDIgfHwgcDMgfHwgcDQ7XG4gICAgICAgIH0pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZWdleEVzY2FwZShzKSB7XG4gICAgICAgIHJldHVybiBzLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbnMgPSB7fTtcblxuICAgIGZ1bmN0aW9uIGFkZFBhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgaSwgZnVuYyA9IGNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdG9rZW4gPSBbdG9rZW5dO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc051bWJlcihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgICAgICAgICAgYXJyYXlbY2FsbGJhY2tdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdG9rZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRva2Vuc1t0b2tlbltpXV0gPSBmdW5jO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkV2Vla1BhcnNlVG9rZW4gKHRva2VuLCBjYWxsYmFjaykge1xuICAgICAgICBhZGRQYXJzZVRva2VuKHRva2VuLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgICAgICBjb25maWcuX3cgPSBjb25maWcuX3cgfHwge307XG4gICAgICAgICAgICBjYWxsYmFjayhpbnB1dCwgY29uZmlnLl93LCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkVGltZVRvQXJyYXlGcm9tVG9rZW4odG9rZW4sIGlucHV0LCBjb25maWcpIHtcbiAgICAgICAgaWYgKGlucHV0ICE9IG51bGwgJiYgaGFzT3duUHJvcCh0b2tlbnMsIHRva2VuKSkge1xuICAgICAgICAgICAgdG9rZW5zW3Rva2VuXShpbnB1dCwgY29uZmlnLl9hLCBjb25maWcsIHRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciBZRUFSID0gMDtcbiAgICB2YXIgTU9OVEggPSAxO1xuICAgIHZhciBEQVRFID0gMjtcbiAgICB2YXIgSE9VUiA9IDM7XG4gICAgdmFyIE1JTlVURSA9IDQ7XG4gICAgdmFyIFNFQ09ORCA9IDU7XG4gICAgdmFyIE1JTExJU0VDT05EID0gNjtcbiAgICB2YXIgV0VFSyA9IDc7XG4gICAgdmFyIFdFRUtEQVkgPSA4O1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1knLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB5ID0gdGhpcy55ZWFyKCk7XG4gICAgICAgIHJldHVybiB5IDw9IDk5OTkgPyAnJyArIHkgOiAnKycgKyB5O1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWScsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnllYXIoKSAlIDEwMDtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnWVlZWScsICAgNF0sICAgICAgIDAsICd5ZWFyJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydZWVlZWScsICA1XSwgICAgICAgMCwgJ3llYXInKTtcbiAgICBhZGRGb3JtYXRUb2tlbigwLCBbJ1lZWVlZWScsIDYsIHRydWVdLCAwLCAneWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd5ZWFyJywgJ3knKTtcblxuICAgIC8vIFBSSU9SSVRJRVNcblxuICAgIGFkZFVuaXRQcmlvcml0eSgneWVhcicsIDEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWScsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdZWVlZJywgICBtYXRjaDF0bzQsIG1hdGNoNCk7XG4gICAgYWRkUmVnZXhUb2tlbignWVlZWVknLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1lZWVlZWScsIG1hdGNoMXRvNiwgbWF0Y2g2KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydZWVlZWScsICdZWVlZWVknXSwgWUVBUik7XG4gICAgYWRkUGFyc2VUb2tlbignWVlZWScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXkpIHtcbiAgICAgICAgYXJyYXlbWUVBUl0gPSBpbnB1dC5sZW5ndGggPT09IDIgPyBob29rcy5wYXJzZVR3b0RpZ2l0WWVhcihpbnB1dCkgOiB0b0ludChpbnB1dCk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignWVknLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1knLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W1lFQVJdID0gcGFyc2VJbnQoaW5wdXQsIDEwKTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIGRheXNJblllYXIoeWVhcikge1xuICAgICAgICByZXR1cm4gaXNMZWFwWWVhcih5ZWFyKSA/IDM2NiA6IDM2NTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0xlYXBZZWFyKHllYXIpIHtcbiAgICAgICAgcmV0dXJuICh5ZWFyICUgNCA9PT0gMCAmJiB5ZWFyICUgMTAwICE9PSAwKSB8fCB5ZWFyICUgNDAwID09PSAwO1xuICAgIH1cblxuICAgIC8vIEhPT0tTXG5cbiAgICBob29rcy5wYXJzZVR3b0RpZ2l0WWVhciA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gdG9JbnQoaW5wdXQpICsgKHRvSW50KGlucHV0KSA+IDY4ID8gMTkwMCA6IDIwMDApO1xuICAgIH07XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0WWVhciA9IG1ha2VHZXRTZXQoJ0Z1bGxZZWFyJywgdHJ1ZSk7XG5cbiAgICBmdW5jdGlvbiBnZXRJc0xlYXBZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzTGVhcFllYXIodGhpcy55ZWFyKCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXRTZXQgKHVuaXQsIGtlZXBUaW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0JDEodGhpcywgdW5pdCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCBrZWVwVGltZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXQodGhpcywgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0IChtb20sIHVuaXQpIHtcbiAgICAgICAgcmV0dXJuIG1vbS5pc1ZhbGlkKCkgP1xuICAgICAgICAgICAgbW9tLl9kWydnZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKCkgOiBOYU47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0JDEgKG1vbSwgdW5pdCwgdmFsdWUpIHtcbiAgICAgICAgaWYgKG1vbS5pc1ZhbGlkKCkgJiYgIWlzTmFOKHZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHVuaXQgPT09ICdGdWxsWWVhcicgJiYgaXNMZWFwWWVhcihtb20ueWVhcigpKSAmJiBtb20ubW9udGgoKSA9PT0gMSAmJiBtb20uZGF0ZSgpID09PSAyOSkge1xuICAgICAgICAgICAgICAgIG1vbS5fZFsnc2V0JyArIChtb20uX2lzVVRDID8gJ1VUQycgOiAnJykgKyB1bml0XSh2YWx1ZSwgbW9tLm1vbnRoKCksIGRheXNJbk1vbnRoKHZhbHVlLCBtb20ubW9udGgoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArIHVuaXRdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIHN0cmluZ0dldCAodW5pdHMpIHtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmIChpc0Z1bmN0aW9uKHRoaXNbdW5pdHNdKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBzdHJpbmdTZXQgKHVuaXRzLCB2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mIHVuaXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgdW5pdHMgPSBub3JtYWxpemVPYmplY3RVbml0cyh1bml0cyk7XG4gICAgICAgICAgICB2YXIgcHJpb3JpdGl6ZWQgPSBnZXRQcmlvcml0aXplZFVuaXRzKHVuaXRzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJpb3JpdGl6ZWQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzW3ByaW9yaXRpemVkW2ldLnVuaXRdKHVuaXRzW3ByaW9yaXRpemVkW2ldLnVuaXRdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICAgICAgaWYgKGlzRnVuY3Rpb24odGhpc1t1bml0c10pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbdW5pdHNdKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtb2QobiwgeCkge1xuICAgICAgICByZXR1cm4gKChuICUgeCkgKyB4KSAlIHg7XG4gICAgfVxuXG4gICAgdmFyIGluZGV4T2Y7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmluZGV4T2YpIHtcbiAgICAgICAgaW5kZXhPZiA9IEFycmF5LnByb3RvdHlwZS5pbmRleE9mO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGluZGV4T2YgPSBmdW5jdGlvbiAobykge1xuICAgICAgICAgICAgLy8gSSBrbm93XG4gICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbaV0gPT09IG8pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNJbk1vbnRoKHllYXIsIG1vbnRoKSB7XG4gICAgICAgIGlmIChpc05hTih5ZWFyKSB8fCBpc05hTihtb250aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1vZE1vbnRoID0gbW9kKG1vbnRoLCAxMik7XG4gICAgICAgIHllYXIgKz0gKG1vbnRoIC0gbW9kTW9udGgpIC8gMTI7XG4gICAgICAgIHJldHVybiBtb2RNb250aCA9PT0gMSA/IChpc0xlYXBZZWFyKHllYXIpID8gMjkgOiAyOCkgOiAoMzEgLSBtb2RNb250aCAlIDcgJSAyKTtcbiAgICB9XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignTScsIFsnTU0nLCAyXSwgJ01vJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb250aCgpICsgMTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdNTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHNTaG9ydCh0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ01NTU0nLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5tb250aHModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbW9udGgnLCAnTScpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnbW9udGgnLCA4KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ00nLCAgICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ01NJywgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NJywgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignTU1NTScsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUubW9udGhzUmVnZXgoaXNTdHJpY3QpO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ00nLCAnTU0nXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNT05USF0gPSB0b0ludChpbnB1dCkgLSAxO1xuICAgIH0pO1xuXG4gICAgYWRkUGFyc2VUb2tlbihbJ01NTScsICdNTU1NJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZywgdG9rZW4pIHtcbiAgICAgICAgdmFyIG1vbnRoID0gY29uZmlnLl9sb2NhbGUubW9udGhzUGFyc2UoaW5wdXQsIHRva2VuLCBjb25maWcuX3N0cmljdCk7XG4gICAgICAgIC8vIGlmIHdlIGRpZG4ndCBmaW5kIGEgbW9udGggbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkLlxuICAgICAgICBpZiAobW9udGggIT0gbnVsbCkge1xuICAgICAgICAgICAgYXJyYXlbTU9OVEhdID0gbW9udGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkTW9udGggPSBpbnB1dDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgdmFyIE1PTlRIU19JTl9GT1JNQVQgPSAvRFtvRF0/KFxcW1teXFxbXFxdXSpcXF18XFxzKStNTU1NPy87XG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNb250aHMgPSAnSmFudWFyeV9GZWJydWFyeV9NYXJjaF9BcHJpbF9NYXlfSnVuZV9KdWx5X0F1Z3VzdF9TZXB0ZW1iZXJfT2N0b2Jlcl9Ob3ZlbWJlcl9EZWNlbWJlcicuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHMgKG0sIGZvcm1hdCkge1xuICAgICAgICBpZiAoIW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHMgOlxuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1snc3RhbmRhbG9uZSddO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc0FycmF5KHRoaXMuX21vbnRocykgPyB0aGlzLl9tb250aHNbbS5tb250aCgpXSA6XG4gICAgICAgICAgICB0aGlzLl9tb250aHNbKHRoaXMuX21vbnRocy5pc0Zvcm1hdCB8fCBNT05USFNfSU5fRk9STUFUKS50ZXN0KGZvcm1hdCkgPyAnZm9ybWF0JyA6ICdzdGFuZGFsb25lJ11bbS5tb250aCgpXTtcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZU1vbnRoc1Nob3J0ID0gJ0phbl9GZWJfTWFyX0Fwcl9NYXlfSnVuX0p1bF9BdWdfU2VwX09jdF9Ob3ZfRGVjJy5zcGxpdCgnXycpO1xuICAgIGZ1bmN0aW9uIGxvY2FsZU1vbnRoc1Nob3J0IChtLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFtKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydCA6XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRbJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheSh0aGlzLl9tb250aHNTaG9ydCkgPyB0aGlzLl9tb250aHNTaG9ydFttLm1vbnRoKCldIDpcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0W01PTlRIU19JTl9GT1JNQVQudGVzdChmb3JtYXQpID8gJ2Zvcm1hdCcgOiAnc3RhbmRhbG9uZSddW20ubW9udGgoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgaWksIG1vbSwgbGxjID0gbW9udGhOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fbW9udGhzUGFyc2UpIHtcbiAgICAgICAgICAgIC8vIHRoaXMgaXMgbm90IHVzZWRcbiAgICAgICAgICAgIHRoaXMuX21vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuX3Nob3J0TW9udGhzUGFyc2UgPSBbXTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCAxMjsgKytpKSB7XG4gICAgICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2hvcnRNb250aHNQYXJzZVtpXSA9IHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0gPSB0aGlzLm1vbnRocyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX2xvbmdNb250aHNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ01NTScpIHtcbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9sb25nTW9udGhzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbG9uZ01vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9zaG9ydE1vbnRoc1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbGVNb250aHNQYXJzZSAobW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCkge1xuICAgICAgICB2YXIgaSwgbW9tLCByZWdleDtcblxuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgcmV0dXJuIGhhbmRsZVN0cmljdFBhcnNlLmNhbGwodGhpcywgbW9udGhOYW1lLCBmb3JtYXQsIHN0cmljdCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX21vbnRoc1BhcnNlKSB7XG4gICAgICAgICAgICB0aGlzLl9tb250aHNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbG9uZ01vbnRoc1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlID0gW107XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPOiBhZGQgc29ydGluZ1xuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyXG4gICAgICAgIC8vIHNlZSBzb3J0aW5nIGluIGNvbXB1dGVNb250aHNQYXJzZVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG4gICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIGldKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvbmdNb250aHNQYXJzZVtpXSA9IG5ldyBSZWdFeHAoJ14nICsgdGhpcy5tb250aHMobW9tLCAnJykucmVwbGFjZSgnLicsICcnKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydE1vbnRoc1BhcnNlW2ldID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpLnJlcGxhY2UoJy4nLCAnJykgKyAnJCcsICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXN0cmljdCAmJiAhdGhpcy5fbW9udGhzUGFyc2VbaV0pIHtcbiAgICAgICAgICAgICAgICByZWdleCA9ICdeJyArIHRoaXMubW9udGhzKG1vbSwgJycpICsgJ3xeJyArIHRoaXMubW9udGhzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKHJlZ2V4LnJlcGxhY2UoJy4nLCAnJyksICdpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0ZXN0IHRoZSByZWdleFxuICAgICAgICAgICAgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU1NJyAmJiB0aGlzLl9sb25nTW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdNTU0nICYmIHRoaXMuX3Nob3J0TW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFzdHJpY3QgJiYgdGhpcy5fbW9udGhzUGFyc2VbaV0udGVzdChtb250aE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBzZXRNb250aCAobW9tLCB2YWx1ZSkge1xuICAgICAgICB2YXIgZGF5T2ZNb250aDtcblxuICAgICAgICBpZiAoIW1vbS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIC8vIE5vIG9wXG4gICAgICAgICAgICByZXR1cm4gbW9tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICgvXlxcZCskLy50ZXN0KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gdG9JbnQodmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1vbS5sb2NhbGVEYXRhKCkubW9udGhzUGFyc2UodmFsdWUpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE86IEFub3RoZXIgc2lsZW50IGZhaWx1cmU/XG4gICAgICAgICAgICAgICAgaWYgKCFpc051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1vbTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkYXlPZk1vbnRoID0gTWF0aC5taW4obW9tLmRhdGUoKSwgZGF5c0luTW9udGgobW9tLnllYXIoKSwgdmFsdWUpKTtcbiAgICAgICAgbW9tLl9kWydzZXQnICsgKG1vbS5faXNVVEMgPyAnVVRDJyA6ICcnKSArICdNb250aCddKHZhbHVlLCBkYXlPZk1vbnRoKTtcbiAgICAgICAgcmV0dXJuIG1vbTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRNb250aCAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldE1vbnRoKHRoaXMsIHZhbHVlKTtcbiAgICAgICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGdldCh0aGlzLCAnTW9udGgnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERheXNJbk1vbnRoICgpIHtcbiAgICAgICAgcmV0dXJuIGRheXNJbk1vbnRoKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TW9udGhzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNTaG9ydFJlZ2V4IChpc1N0cmljdCkge1xuICAgICAgICBpZiAodGhpcy5fbW9udGhzUGFyc2VFeGFjdCkge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVNb250aHNQYXJzZS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzU3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXg7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzU2hvcnRSZWdleCcpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRSZWdleCA9IGRlZmF1bHRNb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggJiYgaXNTdHJpY3QgP1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1Nob3J0U3RyaWN0UmVnZXggOiB0aGlzLl9tb250aHNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRNb250aHNSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiBtb250aHNSZWdleCAoaXNTdHJpY3QpIHtcbiAgICAgICAgaWYgKHRoaXMuX21vbnRoc1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX21vbnRoc1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICBjb21wdXRlTW9udGhzUGFyc2UuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1N0cmljdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9tb250aHNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfbW9udGhzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX21vbnRoc1JlZ2V4ID0gZGVmYXVsdE1vbnRoc1JlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21vbnRoc1N0cmljdFJlZ2V4ICYmIGlzU3RyaWN0ID9cbiAgICAgICAgICAgICAgICB0aGlzLl9tb250aHNTdHJpY3RSZWdleCA6IHRoaXMuX21vbnRoc1JlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29tcHV0ZU1vbnRoc1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNob3J0UGllY2VzID0gW10sIGxvbmdQaWVjZXMgPSBbXSwgbWl4ZWRQaWVjZXMgPSBbXSxcbiAgICAgICAgICAgIGksIG1vbTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCBpXSk7XG4gICAgICAgICAgICBzaG9ydFBpZWNlcy5wdXNoKHRoaXMubW9udGhzU2hvcnQobW9tLCAnJykpO1xuICAgICAgICAgICAgbG9uZ1BpZWNlcy5wdXNoKHRoaXMubW9udGhzKG1vbSwgJycpKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzLnB1c2godGhpcy5tb250aHMobW9tLCAnJykpO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaCh0aGlzLm1vbnRoc1Nob3J0KG1vbSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb3J0aW5nIG1ha2VzIHN1cmUgaWYgb25lIG1vbnRoIChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgICAgICAgICAgc2hvcnRQaWVjZXNbaV0gPSByZWdleEVzY2FwZShzaG9ydFBpZWNlc1tpXSk7XG4gICAgICAgICAgICBsb25nUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobG9uZ1BpZWNlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDI0OyBpKyspIHtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbW9udGhzUmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaXhlZFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX21vbnRoc1Nob3J0UmVnZXggPSB0aGlzLl9tb250aHNSZWdleDtcbiAgICAgICAgdGhpcy5fbW9udGhzU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBsb25nUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fbW9udGhzU2hvcnRTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIHNob3J0UGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVEYXRlICh5LCBtLCBkLCBoLCBNLCBzLCBtcykge1xuICAgICAgICAvLyBjYW4ndCBqdXN0IGFwcGx5KCkgdG8gY3JlYXRlIGEgZGF0ZTpcbiAgICAgICAgLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xLzE4MTM0OFxuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkLCBoLCBNLCBzLCBtcyk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0RnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoeSwgbSwgZCwgaCwgTSwgcywgbXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRhdGU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlVVRDRGF0ZSAoeSkge1xuICAgICAgICB2YXIgZGF0ZTtcbiAgICAgICAgLy8gdGhlIERhdGUuVVRDIGZ1bmN0aW9uIHJlbWFwcyB5ZWFycyAwLTk5IHRvIDE5MDAtMTk5OVxuICAgICAgICBpZiAoeSA8IDEwMCAmJiB5ID49IDApIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIC8vIHByZXNlcnZlIGxlYXAgeWVhcnMgdXNpbmcgYSBmdWxsIDQwMCB5ZWFyIGN5Y2xlLCB0aGVuIHJlc2V0XG4gICAgICAgICAgICBhcmdzWzBdID0geSArIDQwMDtcbiAgICAgICAgICAgIGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQy5hcHBseShudWxsLCBhcmdzKSk7XG4gICAgICAgICAgICBpZiAoaXNGaW5pdGUoZGF0ZS5nZXRVVENGdWxsWWVhcigpKSkge1xuICAgICAgICAgICAgICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYXRlID0gbmV3IERhdGUoRGF0ZS5VVEMuYXBwbHkobnVsbCwgYXJndW1lbnRzKSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGF0ZTtcbiAgICB9XG5cbiAgICAvLyBzdGFydC1vZi1maXJzdC13ZWVrIC0gc3RhcnQtb2YteWVhclxuICAgIGZ1bmN0aW9uIGZpcnN0V2Vla09mZnNldCh5ZWFyLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgLy8gZmlyc3Qtd2VlayBkYXkgLS0gd2hpY2ggamFudWFyeSBpcyBhbHdheXMgaW4gdGhlIGZpcnN0IHdlZWsgKDQgZm9yIGlzbywgMSBmb3Igb3RoZXIpXG4gICAgICAgICAgICBmd2QgPSA3ICsgZG93IC0gZG95LFxuICAgICAgICAgICAgLy8gZmlyc3Qtd2VlayBkYXkgbG9jYWwgd2Vla2RheSAtLSB3aGljaCBsb2NhbCB3ZWVrZGF5IGlzIGZ3ZFxuICAgICAgICAgICAgZndkbHcgPSAoNyArIGNyZWF0ZVVUQ0RhdGUoeWVhciwgMCwgZndkKS5nZXRVVENEYXkoKSAtIGRvdykgJSA3O1xuXG4gICAgICAgIHJldHVybiAtZndkbHcgKyBmd2QgLSAxO1xuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lTT193ZWVrX2RhdGUjQ2FsY3VsYXRpbmdfYV9kYXRlX2dpdmVuX3RoZV95ZWFyLjJDX3dlZWtfbnVtYmVyX2FuZF93ZWVrZGF5XG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtzKHllYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95KSB7XG4gICAgICAgIHZhciBsb2NhbFdlZWtkYXkgPSAoNyArIHdlZWtkYXkgLSBkb3cpICUgNyxcbiAgICAgICAgICAgIHdlZWtPZmZzZXQgPSBmaXJzdFdlZWtPZmZzZXQoeWVhciwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF5T2ZZZWFyID0gMSArIDcgKiAod2VlayAtIDEpICsgbG9jYWxXZWVrZGF5ICsgd2Vla09mZnNldCxcbiAgICAgICAgICAgIHJlc1llYXIsIHJlc0RheU9mWWVhcjtcblxuICAgICAgICBpZiAoZGF5T2ZZZWFyIDw9IDApIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyIC0gMTtcbiAgICAgICAgICAgIHJlc0RheU9mWWVhciA9IGRheXNJblllYXIocmVzWWVhcikgKyBkYXlPZlllYXI7XG4gICAgICAgIH0gZWxzZSBpZiAoZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyKSkge1xuICAgICAgICAgICAgcmVzWWVhciA9IHllYXIgKyAxO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyIC0gZGF5c0luWWVhcih5ZWFyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSB5ZWFyO1xuICAgICAgICAgICAgcmVzRGF5T2ZZZWFyID0gZGF5T2ZZZWFyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHllYXI6IHJlc1llYXIsXG4gICAgICAgICAgICBkYXlPZlllYXI6IHJlc0RheU9mWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtPZlllYXIobW9tLCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla09mZnNldCA9IGZpcnN0V2Vla09mZnNldChtb20ueWVhcigpLCBkb3csIGRveSksXG4gICAgICAgICAgICB3ZWVrID0gTWF0aC5mbG9vcigobW9tLmRheU9mWWVhcigpIC0gd2Vla09mZnNldCAtIDEpIC8gNykgKyAxLFxuICAgICAgICAgICAgcmVzV2VlaywgcmVzWWVhcjtcblxuICAgICAgICBpZiAod2VlayA8IDEpIHtcbiAgICAgICAgICAgIHJlc1llYXIgPSBtb20ueWVhcigpIC0gMTtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrICsgd2Vla3NJblllYXIocmVzWWVhciwgZG93LCBkb3kpO1xuICAgICAgICB9IGVsc2UgaWYgKHdlZWsgPiB3ZWVrc0luWWVhcihtb20ueWVhcigpLCBkb3csIGRveSkpIHtcbiAgICAgICAgICAgIHJlc1dlZWsgPSB3ZWVrIC0gd2Vla3NJblllYXIobW9tLnllYXIoKSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCkgKyAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzWWVhciA9IG1vbS55ZWFyKCk7XG4gICAgICAgICAgICByZXNXZWVrID0gd2VlaztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3ZWVrOiByZXNXZWVrLFxuICAgICAgICAgICAgeWVhcjogcmVzWWVhclxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHdlZWtzSW5ZZWFyKHllYXIsIGRvdywgZG95KSB7XG4gICAgICAgIHZhciB3ZWVrT2Zmc2V0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIsIGRvdywgZG95KSxcbiAgICAgICAgICAgIHdlZWtPZmZzZXROZXh0ID0gZmlyc3RXZWVrT2Zmc2V0KHllYXIgKyAxLCBkb3csIGRveSk7XG4gICAgICAgIHJldHVybiAoZGF5c0luWWVhcih5ZWFyKSAtIHdlZWtPZmZzZXQgKyB3ZWVrT2Zmc2V0TmV4dCkgLyA3O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd3JywgWyd3dycsIDJdLCAnd28nLCAnd2VlaycpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdXJywgWydXVycsIDJdLCAnV28nLCAnaXNvV2VlaycpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrJywgJ3cnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWsnLCAnVycpO1xuXG4gICAgLy8gUFJJT1JJVElFU1xuXG4gICAgYWRkVW5pdFByaW9yaXR5KCd3ZWVrJywgNSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrJywgNSk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCd3JywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignd3cnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignVycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1dXJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWyd3JywgJ3d3JywgJ1cnLCAnV1cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDEpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIC8vIExPQ0FMRVNcblxuICAgIGZ1bmN0aW9uIGxvY2FsZVdlZWsgKG1vbSkge1xuICAgICAgICByZXR1cm4gd2Vla09mWWVhcihtb20sIHRoaXMuX3dlZWsuZG93LCB0aGlzLl93ZWVrLmRveSkud2VlaztcbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdExvY2FsZVdlZWsgPSB7XG4gICAgICAgIGRvdyA6IDAsIC8vIFN1bmRheSBpcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAgICBkb3kgOiA2ICAvLyBUaGUgd2VlayB0aGF0IGNvbnRhaW5zIEphbiA2dGggaXMgdGhlIGZpcnN0IHdlZWsgb2YgdGhlIHllYXIuXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZXZWVrICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxvY2FsZUZpcnN0RGF5T2ZZZWFyICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWsuZG95O1xuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gdGhpcy5sb2NhbGVEYXRhKCkud2Vlayh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGlucHV0ID09IG51bGwgPyB3ZWVrIDogdGhpcy5hZGQoKGlucHV0IC0gd2VlaykgKiA3LCAnZCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldElTT1dlZWsgKGlucHV0KSB7XG4gICAgICAgIHZhciB3ZWVrID0gd2Vla09mWWVhcih0aGlzLCAxLCA0KS53ZWVrO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWsgOiB0aGlzLmFkZCgoaW5wdXQgLSB3ZWVrKSAqIDcsICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2QnLCAwLCAnZG8nLCAnZGF5Jyk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignZGQnLCAwLCAwLCBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS53ZWVrZGF5c01pbih0aGlzLCBmb3JtYXQpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2RkZCcsIDAsIDAsIGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLndlZWtkYXlzU2hvcnQodGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdkZGRkJywgMCwgMCwgZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkud2Vla2RheXModGhpcywgZm9ybWF0KTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdlJywgMCwgMCwgJ3dlZWtkYXknKTtcbiAgICBhZGRGb3JtYXRUb2tlbignRScsIDAsIDAsICdpc29XZWVrZGF5Jyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RheScsICdkJyk7XG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrZGF5JywgJ2UnKTtcbiAgICBhZGRVbml0QWxpYXMoJ2lzb1dlZWtkYXknLCAnRScpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RheScsIDExKTtcbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtkYXknLCAxMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrZGF5JywgMTEpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignZCcsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignRScsICAgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignZGQnLCAgIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIHJldHVybiBsb2NhbGUud2Vla2RheXNNaW5SZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkJywgICBmdW5jdGlvbiAoaXNTdHJpY3QsIGxvY2FsZSkge1xuICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzU2hvcnRSZWdleChpc1N0cmljdCk7XG4gICAgfSk7XG4gICAgYWRkUmVnZXhUb2tlbignZGRkZCcsICAgZnVuY3Rpb24gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS53ZWVrZGF5c1JlZ2V4KGlzU3RyaWN0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZGQnLCAnZGRkJywgJ2RkZGQnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHZhciB3ZWVrZGF5ID0gY29uZmlnLl9sb2NhbGUud2Vla2RheXNQYXJzZShpbnB1dCwgdG9rZW4sIGNvbmZpZy5fc3RyaWN0KTtcbiAgICAgICAgLy8gaWYgd2UgZGlkbid0IGdldCBhIHdlZWtkYXkgbmFtZSwgbWFyayB0aGUgZGF0ZSBhcyBpbnZhbGlkXG4gICAgICAgIGlmICh3ZWVrZGF5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHdlZWsuZCA9IHdlZWtkYXk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5pbnZhbGlkV2Vla2RheSA9IGlucHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBhZGRXZWVrUGFyc2VUb2tlbihbJ2QnLCAnZScsICdFJ10sIGZ1bmN0aW9uIChpbnB1dCwgd2VlaywgY29uZmlnLCB0b2tlbikge1xuICAgICAgICB3ZWVrW3Rva2VuXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIC8vIEhFTFBFUlNcblxuICAgIGZ1bmN0aW9uIHBhcnNlV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWlzTmFOKGlucHV0KSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0LCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dCA9IGxvY2FsZS53ZWVrZGF5c1BhcnNlKGlucHV0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvV2Vla2RheShpbnB1dCwgbG9jYWxlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlLndlZWtkYXlzUGFyc2UoaW5wdXQpICUgNyB8fCA3O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpc05hTihpbnB1dCkgPyBudWxsIDogaW5wdXQ7XG4gICAgfVxuXG4gICAgLy8gTE9DQUxFU1xuICAgIGZ1bmN0aW9uIHNoaWZ0V2Vla2RheXMgKHdzLCBuKSB7XG4gICAgICAgIHJldHVybiB3cy5zbGljZShuLCA3KS5jb25jYXQod3Muc2xpY2UoMCwgbikpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXMgPSAnU3VuZGF5X01vbmRheV9UdWVzZGF5X1dlZG5lc2RheV9UaHVyc2RheV9GcmlkYXlfU2F0dXJkYXknLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXMgKG0sIGZvcm1hdCkge1xuICAgICAgICB2YXIgd2Vla2RheXMgPSBpc0FycmF5KHRoaXMuX3dlZWtkYXlzKSA/IHRoaXMuX3dlZWtkYXlzIDpcbiAgICAgICAgICAgIHRoaXMuX3dlZWtkYXlzWyhtICYmIG0gIT09IHRydWUgJiYgdGhpcy5fd2Vla2RheXMuaXNGb3JtYXQudGVzdChmb3JtYXQpKSA/ICdmb3JtYXQnIDogJ3N0YW5kYWxvbmUnXTtcbiAgICAgICAgcmV0dXJuIChtID09PSB0cnVlKSA/IHNoaWZ0V2Vla2RheXMod2Vla2RheXMsIHRoaXMuX3dlZWsuZG93KVxuICAgICAgICAgICAgOiAobSkgPyB3ZWVrZGF5c1ttLmRheSgpXSA6IHdlZWtkYXlzO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCA9ICdTdW5fTW9uX1R1ZV9XZWRfVGh1X0ZyaV9TYXQnLnNwbGl0KCdfJyk7XG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNTaG9ydCAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c1Nob3J0LCB0aGlzLl93ZWVrLmRvdylcbiAgICAgICAgICAgIDogKG0pID8gdGhpcy5fd2Vla2RheXNTaG9ydFttLmRheSgpXSA6IHRoaXMuX3dlZWtkYXlzU2hvcnQ7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVXZWVrZGF5c01pbiA9ICdTdV9Nb19UdV9XZV9UaF9Gcl9TYScuc3BsaXQoJ18nKTtcbiAgICBmdW5jdGlvbiBsb2NhbGVXZWVrZGF5c01pbiAobSkge1xuICAgICAgICByZXR1cm4gKG0gPT09IHRydWUpID8gc2hpZnRXZWVrZGF5cyh0aGlzLl93ZWVrZGF5c01pbiwgdGhpcy5fd2Vlay5kb3cpXG4gICAgICAgICAgICA6IChtKSA/IHRoaXMuX3dlZWtkYXlzTWluW20uZGF5KCldIDogdGhpcy5fd2Vla2RheXNNaW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaGFuZGxlU3RyaWN0UGFyc2UkMSh3ZWVrZGF5TmFtZSwgZm9ybWF0LCBzdHJpY3QpIHtcbiAgICAgICAgdmFyIGksIGlpLCBtb20sIGxsYyA9IHdlZWtkYXlOYW1lLnRvTG9jYWxlTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9taW5XZWVrZGF5c1BhcnNlID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyArK2kpIHtcbiAgICAgICAgICAgICAgICBtb20gPSBjcmVhdGVVVEMoWzIwMDAsIDFdKS5kYXkoaSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXSA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykudG9Mb2NhbGVMb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gdGhpcy53ZWVrZGF5cyhtb20sICcnKS50b0xvY2FsZUxvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gJ2RkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fd2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlpICE9PSAtMSA/IGlpIDogbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChmb3JtYXQgPT09ICdkZGRkJykge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICBpZiAoaWkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fbWluV2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChmb3JtYXQgPT09ICdkZGQnKSB7XG4gICAgICAgICAgICAgICAgaWkgPSBpbmRleE9mLmNhbGwodGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl93ZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIGlmIChpaSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpaSA9IGluZGV4T2YuY2FsbCh0aGlzLl9taW5XZWVrZGF5c1BhcnNlLCBsbGMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpaSAhPT0gLTEgPyBpaSA6IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX21pbldlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3dlZWtkYXlzUGFyc2UsIGxsYyk7XG4gICAgICAgICAgICAgICAgaWYgKGlpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaWk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlpID0gaW5kZXhPZi5jYWxsKHRoaXMuX3Nob3J0V2Vla2RheXNQYXJzZSwgbGxjKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWkgIT09IC0xID8gaWkgOiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbG9jYWxlV2Vla2RheXNQYXJzZSAod2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KSB7XG4gICAgICAgIHZhciBpLCBtb20sIHJlZ2V4O1xuXG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIHJldHVybiBoYW5kbGVTdHJpY3RQYXJzZSQxLmNhbGwodGhpcywgd2Vla2RheU5hbWUsIGZvcm1hdCwgc3RyaWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZSkge1xuICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbWluV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlID0gW107XG4gICAgICAgICAgICB0aGlzLl9mdWxsV2Vla2RheXNQYXJzZSA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgLy8gbWFrZSB0aGUgcmVnZXggaWYgd2UgZG9uJ3QgaGF2ZSBpdCBhbHJlYWR5XG5cbiAgICAgICAgICAgIG1vbSA9IGNyZWF0ZVVUQyhbMjAwMCwgMV0pLmRheShpKTtcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgIXRoaXMuX2Z1bGxXZWVrZGF5c1BhcnNlW2ldKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXMobW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zaG9ydFdlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNTaG9ydChtb20sICcnKS5yZXBsYWNlKCcuJywgJ1xcXFwuPycpICsgJyQnLCAnaScpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbldlZWtkYXlzUGFyc2VbaV0gPSBuZXcgUmVnRXhwKCdeJyArIHRoaXMud2Vla2RheXNNaW4obW9tLCAnJykucmVwbGFjZSgnLicsICdcXFxcLj8nKSArICckJywgJ2knKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fd2Vla2RheXNQYXJzZVtpXSkge1xuICAgICAgICAgICAgICAgIHJlZ2V4ID0gJ14nICsgdGhpcy53ZWVrZGF5cyhtb20sICcnKSArICd8XicgKyB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJykgKyAnfF4nICsgdGhpcy53ZWVrZGF5c01pbihtb20sICcnKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1BhcnNlW2ldID0gbmV3IFJlZ0V4cChyZWdleC5yZXBsYWNlKCcuJywgJycpLCAnaScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdGVzdCB0aGUgcmVnZXhcbiAgICAgICAgICAgIGlmIChzdHJpY3QgJiYgZm9ybWF0ID09PSAnZGRkZCcgJiYgdGhpcy5fZnVsbFdlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3RyaWN0ICYmIGZvcm1hdCA9PT0gJ2RkZCcgJiYgdGhpcy5fc2hvcnRXZWVrZGF5c1BhcnNlW2ldLnRlc3Qod2Vla2RheU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0cmljdCAmJiBmb3JtYXQgPT09ICdkZCcgJiYgdGhpcy5fbWluV2Vla2RheXNQYXJzZVtpXS50ZXN0KHdlZWtkYXlOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghc3RyaWN0ICYmIHRoaXMuX3dlZWtkYXlzUGFyc2VbaV0udGVzdCh3ZWVrZGF5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1PTUVOVFNcblxuICAgIGZ1bmN0aW9uIGdldFNldERheU9mV2VlayAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGlucHV0ICE9IG51bGwgPyB0aGlzIDogTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXkgPSB0aGlzLl9pc1VUQyA/IHRoaXMuX2QuZ2V0VVRDRGF5KCkgOiB0aGlzLl9kLmdldERheSgpO1xuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaW5wdXQgPSBwYXJzZVdlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChpbnB1dCAtIGRheSwgJ2QnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBkYXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRTZXRMb2NhbGVEYXlPZldlZWsgKGlucHV0KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2Vla2RheSA9ICh0aGlzLmRheSgpICsgNyAtIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRvdykgJSA3O1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IHdlZWtkYXkgOiB0aGlzLmFkZChpbnB1dCAtIHdlZWtkYXksICdkJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPRGF5T2ZXZWVrIChpbnB1dCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQgIT0gbnVsbCA/IHRoaXMgOiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBiZWhhdmVzIHRoZSBzYW1lIGFzIG1vbWVudCNkYXkgZXhjZXB0XG4gICAgICAgIC8vIGFzIGEgZ2V0dGVyLCByZXR1cm5zIDcgaW5zdGVhZCBvZiAwICgxLTcgcmFuZ2UgaW5zdGVhZCBvZiAwLTYpXG4gICAgICAgIC8vIGFzIGEgc2V0dGVyLCBzdW5kYXkgc2hvdWxkIGJlbG9uZyB0byB0aGUgcHJldmlvdXMgd2Vlay5cblxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHdlZWtkYXkgPSBwYXJzZUlzb1dlZWtkYXkoaW5wdXQsIHRoaXMubG9jYWxlRGF0YSgpKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRheSh0aGlzLmRheSgpICUgNyA/IHdlZWtkYXkgOiB3ZWVrZGF5IC0gNyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXkoKSB8fCA3O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c1JlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c1JlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1JlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVmYXVsdFdlZWtkYXlzU2hvcnRSZWdleCA9IG1hdGNoV29yZDtcbiAgICBmdW5jdGlvbiB3ZWVrZGF5c1Nob3J0UmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFoYXNPd25Qcm9wKHRoaXMsICdfd2Vla2RheXNTaG9ydFJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0UmVnZXggPSBkZWZhdWx0V2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzU2hvcnRTdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFN0cmljdFJlZ2V4IDogdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRXZWVrZGF5c01pblJlZ2V4ID0gbWF0Y2hXb3JkO1xuICAgIGZ1bmN0aW9uIHdlZWtkYXlzTWluUmVnZXggKGlzU3RyaWN0KSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWVrZGF5c1BhcnNlRXhhY3QpIHtcbiAgICAgICAgICAgIGlmICghaGFzT3duUHJvcCh0aGlzLCAnX3dlZWtkYXlzUmVnZXgnKSkge1xuICAgICAgICAgICAgICAgIGNvbXB1dGVXZWVrZGF5c1BhcnNlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3AodGhpcywgJ193ZWVrZGF5c01pblJlZ2V4JykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWVrZGF5c01pblJlZ2V4ID0gZGVmYXVsdFdlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCAmJiBpc1N0cmljdCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5TdHJpY3RSZWdleCA6IHRoaXMuX3dlZWtkYXlzTWluUmVnZXg7XG4gICAgICAgIH1cbiAgICB9XG5cblxuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrZGF5c1BhcnNlICgpIHtcbiAgICAgICAgZnVuY3Rpb24gY21wTGVuUmV2KGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBiLmxlbmd0aCAtIGEubGVuZ3RoO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1pblBpZWNlcyA9IFtdLCBzaG9ydFBpZWNlcyA9IFtdLCBsb25nUGllY2VzID0gW10sIG1peGVkUGllY2VzID0gW10sXG4gICAgICAgICAgICBpLCBtb20sIG1pbnAsIHNob3J0cCwgbG9uZ3A7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA3OyBpKyspIHtcbiAgICAgICAgICAgIC8vIG1ha2UgdGhlIHJlZ2V4IGlmIHdlIGRvbid0IGhhdmUgaXQgYWxyZWFkeVxuICAgICAgICAgICAgbW9tID0gY3JlYXRlVVRDKFsyMDAwLCAxXSkuZGF5KGkpO1xuICAgICAgICAgICAgbWlucCA9IHRoaXMud2Vla2RheXNNaW4obW9tLCAnJyk7XG4gICAgICAgICAgICBzaG9ydHAgPSB0aGlzLndlZWtkYXlzU2hvcnQobW9tLCAnJyk7XG4gICAgICAgICAgICBsb25ncCA9IHRoaXMud2Vla2RheXMobW9tLCAnJyk7XG4gICAgICAgICAgICBtaW5QaWVjZXMucHVzaChtaW5wKTtcbiAgICAgICAgICAgIHNob3J0UGllY2VzLnB1c2goc2hvcnRwKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgICAgICBtaXhlZFBpZWNlcy5wdXNoKG1pbnApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChzaG9ydHApO1xuICAgICAgICAgICAgbWl4ZWRQaWVjZXMucHVzaChsb25ncCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydGluZyBtYWtlcyBzdXJlIGlmIG9uZSB3ZWVrZGF5IChvciBhYmJyKSBpcyBhIHByZWZpeCBvZiBhbm90aGVyIGl0XG4gICAgICAgIC8vIHdpbGwgbWF0Y2ggdGhlIGxvbmdlciBwaWVjZS5cbiAgICAgICAgbWluUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgc2hvcnRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBsb25nUGllY2VzLnNvcnQoY21wTGVuUmV2KTtcbiAgICAgICAgbWl4ZWRQaWVjZXMuc29ydChjbXBMZW5SZXYpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNzsgaSsrKSB7XG4gICAgICAgICAgICBzaG9ydFBpZWNlc1tpXSA9IHJlZ2V4RXNjYXBlKHNob3J0UGllY2VzW2ldKTtcbiAgICAgICAgICAgIGxvbmdQaWVjZXNbaV0gPSByZWdleEVzY2FwZShsb25nUGllY2VzW2ldKTtcbiAgICAgICAgICAgIG1peGVkUGllY2VzW2ldID0gcmVnZXhFc2NhcGUobWl4ZWRQaWVjZXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIG1peGVkUGllY2VzLmpvaW4oJ3wnKSArICcpJywgJ2knKTtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNTaG9ydFJlZ2V4ID0gdGhpcy5fd2Vla2RheXNSZWdleDtcbiAgICAgICAgdGhpcy5fd2Vla2RheXNNaW5SZWdleCA9IHRoaXMuX3dlZWtkYXlzUmVnZXg7XG5cbiAgICAgICAgdGhpcy5fd2Vla2RheXNTdHJpY3RSZWdleCA9IG5ldyBSZWdFeHAoJ14oJyArIGxvbmdQaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgICAgICB0aGlzLl93ZWVrZGF5c1Nob3J0U3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBzaG9ydFBpZWNlcy5qb2luKCd8JykgKyAnKScsICdpJyk7XG4gICAgICAgIHRoaXMuX3dlZWtkYXlzTWluU3RyaWN0UmVnZXggPSBuZXcgUmVnRXhwKCdeKCcgKyBtaW5QaWVjZXMuam9pbignfCcpICsgJyknLCAnaScpO1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIGhGb3JtYXQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmhvdXJzKCkgJSAxMiB8fCAxMjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBrRm9ybWF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3VycygpIHx8IDI0O1xuICAgIH1cblxuICAgIGFkZEZvcm1hdFRva2VuKCdIJywgWydISCcsIDJdLCAwLCAnaG91cicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCdoJywgWydoaCcsIDJdLCAwLCBoRm9ybWF0KTtcbiAgICBhZGRGb3JtYXRUb2tlbignaycsIFsna2snLCAyXSwgMCwga0Zvcm1hdCk7XG5cbiAgICBhZGRGb3JtYXRUb2tlbignaG1tJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ2htbXNzJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJycgKyBoRm9ybWF0LmFwcGx5KHRoaXMpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW0nLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiAnJyArIHRoaXMuaG91cnMoKSArIHplcm9GaWxsKHRoaXMubWludXRlcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKCdIbW1zcycsIDAsIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICcnICsgdGhpcy5ob3VycygpICsgemVyb0ZpbGwodGhpcy5taW51dGVzKCksIDIpICtcbiAgICAgICAgICAgIHplcm9GaWxsKHRoaXMuc2Vjb25kcygpLCAyKTtcbiAgICB9KTtcblxuICAgIGZ1bmN0aW9uIG1lcmlkaWVtICh0b2tlbiwgbG93ZXJjYXNlKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKHRva2VuLCAwLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkubWVyaWRpZW0odGhpcy5ob3VycygpLCB0aGlzLm1pbnV0ZXMoKSwgbG93ZXJjYXNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgbWVyaWRpZW0oJ2EnLCB0cnVlKTtcbiAgICBtZXJpZGllbSgnQScsIGZhbHNlKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnaG91cicsICdoJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnaG91cicsIDEzKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGZ1bmN0aW9uIG1hdGNoTWVyaWRpZW0gKGlzU3RyaWN0LCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5fbWVyaWRpZW1QYXJzZTtcbiAgICB9XG5cbiAgICBhZGRSZWdleFRva2VuKCdhJywgIG1hdGNoTWVyaWRpZW0pO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0EnLCAgbWF0Y2hNZXJpZGllbSk7XG4gICAgYWRkUmVnZXhUb2tlbignSCcsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2gnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdrJywgIG1hdGNoMXRvMik7XG4gICAgYWRkUmVnZXhUb2tlbignSEgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignaGgnLCBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbigna2snLCBtYXRjaDF0bzIsIG1hdGNoMik7XG5cbiAgICBhZGRSZWdleFRva2VuKCdobW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2htbXNzJywgbWF0Y2g1dG82KTtcbiAgICBhZGRSZWdleFRva2VuKCdIbW0nLCBtYXRjaDN0bzQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0htbXNzJywgbWF0Y2g1dG82KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydIJywgJ0hIJ10sIEhPVVIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydrJywgJ2trJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIga0lucHV0ID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBhcnJheVtIT1VSXSA9IGtJbnB1dCA9PT0gMjQgPyAwIDoga0lucHV0O1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oWydhJywgJ0EnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5faXNQbSA9IGNvbmZpZy5fbG9jYWxlLmlzUE0oaW5wdXQpO1xuICAgICAgICBjb25maWcuX21lcmlkaWVtID0gaW5wdXQ7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbihbJ2gnLCAnaGgnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW0nLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvcyA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvcykpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvcykpO1xuICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5iaWdIb3VyID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBhZGRQYXJzZVRva2VuKCdobW1zcycsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zMSA9IGlucHV0Lmxlbmd0aCAtIDQ7XG4gICAgICAgIHZhciBwb3MyID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zMSkpO1xuICAgICAgICBhcnJheVtNSU5VVEVdID0gdG9JbnQoaW5wdXQuc3Vic3RyKHBvczEsIDIpKTtcbiAgICAgICAgYXJyYXlbU0VDT05EXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MyKSk7XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmJpZ0hvdXIgPSB0cnVlO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0htbScsIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICB2YXIgcG9zID0gaW5wdXQubGVuZ3RoIC0gMjtcbiAgICAgICAgYXJyYXlbSE9VUl0gPSB0b0ludChpbnB1dC5zdWJzdHIoMCwgcG9zKSk7XG4gICAgICAgIGFycmF5W01JTlVURV0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zKSk7XG4gICAgfSk7XG4gICAgYWRkUGFyc2VUb2tlbignSG1tc3MnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgdmFyIHBvczEgPSBpbnB1dC5sZW5ndGggLSA0O1xuICAgICAgICB2YXIgcG9zMiA9IGlucHV0Lmxlbmd0aCAtIDI7XG4gICAgICAgIGFycmF5W0hPVVJdID0gdG9JbnQoaW5wdXQuc3Vic3RyKDAsIHBvczEpKTtcbiAgICAgICAgYXJyYXlbTUlOVVRFXSA9IHRvSW50KGlucHV0LnN1YnN0cihwb3MxLCAyKSk7XG4gICAgICAgIGFycmF5W1NFQ09ORF0gPSB0b0ludChpbnB1dC5zdWJzdHIocG9zMikpO1xuICAgIH0pO1xuXG4gICAgLy8gTE9DQUxFU1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlSXNQTSAoaW5wdXQpIHtcbiAgICAgICAgLy8gSUU4IFF1aXJrcyBNb2RlICYgSUU3IFN0YW5kYXJkcyBNb2RlIGRvIG5vdCBhbGxvdyBhY2Nlc3Npbmcgc3RyaW5ncyBsaWtlIGFycmF5c1xuICAgICAgICAvLyBVc2luZyBjaGFyQXQgc2hvdWxkIGJlIG1vcmUgY29tcGF0aWJsZS5cbiAgICAgICAgcmV0dXJuICgoaW5wdXQgKyAnJykudG9Mb3dlckNhc2UoKS5jaGFyQXQoMCkgPT09ICdwJyk7XG4gICAgfVxuXG4gICAgdmFyIGRlZmF1bHRMb2NhbGVNZXJpZGllbVBhcnNlID0gL1thcF1cXC4/bT9cXC4/L2k7XG4gICAgZnVuY3Rpb24gbG9jYWxlTWVyaWRpZW0gKGhvdXJzLCBtaW51dGVzLCBpc0xvd2VyKSB7XG4gICAgICAgIGlmIChob3VycyA+IDExKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNMb3dlciA/ICdwbScgOiAnUE0nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGlzTG93ZXIgPyAnYW0nIDogJ0FNJztcbiAgICAgICAgfVxuICAgIH1cblxuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8gU2V0dGluZyB0aGUgaG91ciBzaG91bGQga2VlcCB0aGUgdGltZSwgYmVjYXVzZSB0aGUgdXNlciBleHBsaWNpdGx5XG4gICAgLy8gc3BlY2lmaWVkIHdoaWNoIGhvdXIgdGhleSB3YW50LiBTbyB0cnlpbmcgdG8gbWFpbnRhaW4gdGhlIHNhbWUgaG91ciAoaW5cbiAgICAvLyBhIG5ldyB0aW1lem9uZSkgbWFrZXMgc2Vuc2UuIEFkZGluZy9zdWJ0cmFjdGluZyBob3VycyBkb2VzIG5vdCBmb2xsb3dcbiAgICAvLyB0aGlzIHJ1bGUuXG4gICAgdmFyIGdldFNldEhvdXIgPSBtYWtlR2V0U2V0KCdIb3VycycsIHRydWUpO1xuXG4gICAgdmFyIGJhc2VDb25maWcgPSB7XG4gICAgICAgIGNhbGVuZGFyOiBkZWZhdWx0Q2FsZW5kYXIsXG4gICAgICAgIGxvbmdEYXRlRm9ybWF0OiBkZWZhdWx0TG9uZ0RhdGVGb3JtYXQsXG4gICAgICAgIGludmFsaWREYXRlOiBkZWZhdWx0SW52YWxpZERhdGUsXG4gICAgICAgIG9yZGluYWw6IGRlZmF1bHRPcmRpbmFsLFxuICAgICAgICBkYXlPZk1vbnRoT3JkaW5hbFBhcnNlOiBkZWZhdWx0RGF5T2ZNb250aE9yZGluYWxQYXJzZSxcbiAgICAgICAgcmVsYXRpdmVUaW1lOiBkZWZhdWx0UmVsYXRpdmVUaW1lLFxuXG4gICAgICAgIG1vbnRoczogZGVmYXVsdExvY2FsZU1vbnRocyxcbiAgICAgICAgbW9udGhzU2hvcnQ6IGRlZmF1bHRMb2NhbGVNb250aHNTaG9ydCxcblxuICAgICAgICB3ZWVrOiBkZWZhdWx0TG9jYWxlV2VlayxcblxuICAgICAgICB3ZWVrZGF5czogZGVmYXVsdExvY2FsZVdlZWtkYXlzLFxuICAgICAgICB3ZWVrZGF5c01pbjogZGVmYXVsdExvY2FsZVdlZWtkYXlzTWluLFxuICAgICAgICB3ZWVrZGF5c1Nob3J0OiBkZWZhdWx0TG9jYWxlV2Vla2RheXNTaG9ydCxcblxuICAgICAgICBtZXJpZGllbVBhcnNlOiBkZWZhdWx0TG9jYWxlTWVyaWRpZW1QYXJzZVxuICAgIH07XG5cbiAgICAvLyBpbnRlcm5hbCBzdG9yYWdlIGZvciBsb2NhbGUgY29uZmlnIGZpbGVzXG4gICAgdmFyIGxvY2FsZXMgPSB7fTtcbiAgICB2YXIgbG9jYWxlRmFtaWxpZXMgPSB7fTtcbiAgICB2YXIgZ2xvYmFsTG9jYWxlO1xuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplTG9jYWxlKGtleSkge1xuICAgICAgICByZXR1cm4ga2V5ID8ga2V5LnRvTG93ZXJDYXNlKCkucmVwbGFjZSgnXycsICctJykgOiBrZXk7XG4gICAgfVxuXG4gICAgLy8gcGljayB0aGUgbG9jYWxlIGZyb20gdGhlIGFycmF5XG4gICAgLy8gdHJ5IFsnZW4tYXUnLCAnZW4tZ2InXSBhcyAnZW4tYXUnLCAnZW4tZ2InLCAnZW4nLCBhcyBpbiBtb3ZlIHRocm91Z2ggdGhlIGxpc3QgdHJ5aW5nIGVhY2hcbiAgICAvLyBzdWJzdHJpbmcgZnJvbSBtb3N0IHNwZWNpZmljIHRvIGxlYXN0LCBidXQgbW92ZSB0byB0aGUgbmV4dCBhcnJheSBpdGVtIGlmIGl0J3MgYSBtb3JlIHNwZWNpZmljIHZhcmlhbnQgdGhhbiB0aGUgY3VycmVudCByb290XG4gICAgZnVuY3Rpb24gY2hvb3NlTG9jYWxlKG5hbWVzKSB7XG4gICAgICAgIHZhciBpID0gMCwgaiwgbmV4dCwgbG9jYWxlLCBzcGxpdDtcblxuICAgICAgICB3aGlsZSAoaSA8IG5hbWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgc3BsaXQgPSBub3JtYWxpemVMb2NhbGUobmFtZXNbaV0pLnNwbGl0KCctJyk7XG4gICAgICAgICAgICBqID0gc3BsaXQubGVuZ3RoO1xuICAgICAgICAgICAgbmV4dCA9IG5vcm1hbGl6ZUxvY2FsZShuYW1lc1tpICsgMV0pO1xuICAgICAgICAgICAgbmV4dCA9IG5leHQgPyBuZXh0LnNwbGl0KCctJykgOiBudWxsO1xuICAgICAgICAgICAgd2hpbGUgKGogPiAwKSB7XG4gICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShzcGxpdC5zbGljZSgwLCBqKS5qb2luKCctJykpO1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5sZW5ndGggPj0gaiAmJiBjb21wYXJlQXJyYXlzKHNwbGl0LCBuZXh0LCB0cnVlKSA+PSBqIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAvL3RoZSBuZXh0IGFycmF5IGl0ZW0gaXMgYmV0dGVyIHRoYW4gYSBzaGFsbG93ZXIgc3Vic3RyaW5nIG9mIHRoaXMgb25lXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBqLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2FkTG9jYWxlKG5hbWUpIHtcbiAgICAgICAgdmFyIG9sZExvY2FsZSA9IG51bGw7XG4gICAgICAgIC8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIHJlZ2lzdGVyIGFuZCBsb2FkIGFsbCB0aGUgbG9jYWxlcyBpbiBOb2RlXG4gICAgICAgIGlmICghbG9jYWxlc1tuYW1lXSAmJiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpICYmXG4gICAgICAgICAgICAgICAgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG9sZExvY2FsZSA9IGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICAgICAgICAgICAgICB2YXIgYWxpYXNlZFJlcXVpcmUgPSByZXF1aXJlO1xuICAgICAgICAgICAgICAgIGFsaWFzZWRSZXF1aXJlKCcuL2xvY2FsZS8nICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgZ2V0U2V0R2xvYmFsTG9jYWxlKG9sZExvY2FsZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2NhbGVzW25hbWVdO1xuICAgIH1cblxuICAgIC8vIFRoaXMgZnVuY3Rpb24gd2lsbCBsb2FkIGxvY2FsZSBhbmQgdGhlbiBzZXQgdGhlIGdsb2JhbCBsb2NhbGUuICBJZlxuICAgIC8vIG5vIGFyZ3VtZW50cyBhcmUgcGFzc2VkIGluLCBpdCB3aWxsIHNpbXBseSByZXR1cm4gdGhlIGN1cnJlbnQgZ2xvYmFsXG4gICAgLy8gbG9jYWxlIGtleS5cbiAgICBmdW5jdGlvbiBnZXRTZXRHbG9iYWxMb2NhbGUgKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBnZXRMb2NhbGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkZWZpbmVMb2NhbGUoa2V5LCB2YWx1ZXMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIC8vIG1vbWVudC5kdXJhdGlvbi5fbG9jYWxlID0gbW9tZW50Ll9sb2NhbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGdsb2JhbExvY2FsZSA9IGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZiBjb25zb2xlICE9PSAgJ3VuZGVmaW5lZCcpICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgICAgICAgICAgICAvL3dhcm4gdXNlciBpZiBhcmd1bWVudHMgYXJlIHBhc3NlZCBidXQgdGhlIGxvY2FsZSBjb3VsZCBub3QgYmUgc2V0XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignTG9jYWxlICcgKyBrZXkgKyAgJyBub3QgZm91bmQuIERpZCB5b3UgZm9yZ2V0IHRvIGxvYWQgaXQ/Jyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZS5fYWJicjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkZWZpbmVMb2NhbGUgKG5hbWUsIGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCBwYXJlbnRDb25maWcgPSBiYXNlQ29uZmlnO1xuICAgICAgICAgICAgY29uZmlnLmFiYnIgPSBuYW1lO1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZSgnZGVmaW5lTG9jYWxlT3ZlcnJpZGUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ3VzZSBtb21lbnQudXBkYXRlTG9jYWxlKGxvY2FsZU5hbWUsIGNvbmZpZykgdG8gY2hhbmdlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2FuIGV4aXN0aW5nIGxvY2FsZS4gbW9tZW50LmRlZmluZUxvY2FsZShsb2NhbGVOYW1lLCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdjb25maWcpIHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGNyZWF0aW5nIGEgbmV3IGxvY2FsZSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdTZWUgaHR0cDovL21vbWVudGpzLmNvbS9ndWlkZXMvIy93YXJuaW5ncy9kZWZpbmUtbG9jYWxlLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IGxvY2FsZXNbbmFtZV0uX2NvbmZpZztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxvY2FsZXNbY29uZmlnLnBhcmVudExvY2FsZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGVzW2NvbmZpZy5wYXJlbnRMb2NhbGVdLl9jb25maWc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlID0gbG9hZExvY2FsZShjb25maWcucGFyZW50TG9jYWxlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRDb25maWcgPSBsb2NhbGUuX2NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tjb25maWcucGFyZW50TG9jYWxlXSA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9jYWxlRmFtaWxpZXNbY29uZmlnLnBhcmVudExvY2FsZV0ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maWc6IGNvbmZpZ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBuZXcgTG9jYWxlKG1lcmdlQ29uZmlncyhwYXJlbnRDb25maWcsIGNvbmZpZykpO1xuXG4gICAgICAgICAgICBpZiAobG9jYWxlRmFtaWxpZXNbbmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2NhbGVGYW1pbGllc1tuYW1lXS5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZUxvY2FsZSh4Lm5hbWUsIHguY29uZmlnKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgd2Ugc2V0IHRoZSBsb2NhbGUgQUZURVIgYWxsIGNoaWxkIGxvY2FsZXMgaGF2ZSBiZWVuXG4gICAgICAgICAgICAvLyBjcmVhdGVkLCBzbyB3ZSB3b24ndCBlbmQgdXAgd2l0aCB0aGUgY2hpbGQgbG9jYWxlIHNldC5cbiAgICAgICAgICAgIGdldFNldEdsb2JhbExvY2FsZShuYW1lKTtcblxuXG4gICAgICAgICAgICByZXR1cm4gbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHVzZWZ1bCBmb3IgdGVzdGluZ1xuICAgICAgICAgICAgZGVsZXRlIGxvY2FsZXNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZUxvY2FsZShuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbG9jYWxlLCB0bXBMb2NhbGUsIHBhcmVudENvbmZpZyA9IGJhc2VDb25maWc7XG4gICAgICAgICAgICAvLyBNRVJHRVxuICAgICAgICAgICAgdG1wTG9jYWxlID0gbG9hZExvY2FsZShuYW1lKTtcbiAgICAgICAgICAgIGlmICh0bXBMb2NhbGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHBhcmVudENvbmZpZyA9IHRtcExvY2FsZS5fY29uZmlnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uZmlnID0gbWVyZ2VDb25maWdzKHBhcmVudENvbmZpZywgY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZSA9IG5ldyBMb2NhbGUoY29uZmlnKTtcbiAgICAgICAgICAgIGxvY2FsZS5wYXJlbnRMb2NhbGUgPSBsb2NhbGVzW25hbWVdO1xuICAgICAgICAgICAgbG9jYWxlc1tuYW1lXSA9IGxvY2FsZTtcblxuICAgICAgICAgICAgLy8gYmFja3dhcmRzIGNvbXBhdCBmb3Igbm93OiBhbHNvIHNldCB0aGUgbG9jYWxlXG4gICAgICAgICAgICBnZXRTZXRHbG9iYWxMb2NhbGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXNzIG51bGwgZm9yIGNvbmZpZyB0byB1bnVwZGF0ZSwgdXNlZnVsIGZvciB0ZXN0c1xuICAgICAgICAgICAgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZXNbbmFtZV0gPSBsb2NhbGVzW25hbWVdLnBhcmVudExvY2FsZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxvY2FsZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgbG9jYWxlc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvY2FsZXNbbmFtZV07XG4gICAgfVxuXG4gICAgLy8gcmV0dXJucyBsb2NhbGUgZGF0YVxuICAgIGZ1bmN0aW9uIGdldExvY2FsZSAoa2V5KSB7XG4gICAgICAgIHZhciBsb2NhbGU7XG5cbiAgICAgICAgaWYgKGtleSAmJiBrZXkuX2xvY2FsZSAmJiBrZXkuX2xvY2FsZS5fYWJicikge1xuICAgICAgICAgICAga2V5ID0ga2V5Ll9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdsb2JhbExvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaXNBcnJheShrZXkpKSB7XG4gICAgICAgICAgICAvL3Nob3J0LWNpcmN1aXQgZXZlcnl0aGluZyBlbHNlXG4gICAgICAgICAgICBsb2NhbGUgPSBsb2FkTG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvY2FsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleSA9IFtrZXldO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNob29zZUxvY2FsZShrZXkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RMb2NhbGVzKCkge1xuICAgICAgICByZXR1cm4ga2V5cyhsb2NhbGVzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjaGVja092ZXJmbG93IChtKSB7XG4gICAgICAgIHZhciBvdmVyZmxvdztcbiAgICAgICAgdmFyIGEgPSBtLl9hO1xuXG4gICAgICAgIGlmIChhICYmIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9PT0gLTIpIHtcbiAgICAgICAgICAgIG92ZXJmbG93ID1cbiAgICAgICAgICAgICAgICBhW01PTlRIXSAgICAgICA8IDAgfHwgYVtNT05USF0gICAgICAgPiAxMSAgPyBNT05USCA6XG4gICAgICAgICAgICAgICAgYVtEQVRFXSAgICAgICAgPCAxIHx8IGFbREFURV0gICAgICAgID4gZGF5c0luTW9udGgoYVtZRUFSXSwgYVtNT05USF0pID8gREFURSA6XG4gICAgICAgICAgICAgICAgYVtIT1VSXSAgICAgICAgPCAwIHx8IGFbSE9VUl0gICAgICAgID4gMjQgfHwgKGFbSE9VUl0gPT09IDI0ICYmIChhW01JTlVURV0gIT09IDAgfHwgYVtTRUNPTkRdICE9PSAwIHx8IGFbTUlMTElTRUNPTkRdICE9PSAwKSkgPyBIT1VSIDpcbiAgICAgICAgICAgICAgICBhW01JTlVURV0gICAgICA8IDAgfHwgYVtNSU5VVEVdICAgICAgPiA1OSAgPyBNSU5VVEUgOlxuICAgICAgICAgICAgICAgIGFbU0VDT05EXSAgICAgIDwgMCB8fCBhW1NFQ09ORF0gICAgICA+IDU5ICA/IFNFQ09ORCA6XG4gICAgICAgICAgICAgICAgYVtNSUxMSVNFQ09ORF0gPCAwIHx8IGFbTUlMTElTRUNPTkRdID4gOTk5ID8gTUlMTElTRUNPTkQgOlxuICAgICAgICAgICAgICAgIC0xO1xuXG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd0RheU9mWWVhciAmJiAob3ZlcmZsb3cgPCBZRUFSIHx8IG92ZXJmbG93ID4gREFURSkpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IERBVEU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZ2V0UGFyc2luZ0ZsYWdzKG0pLl9vdmVyZmxvd1dlZWtzICYmIG92ZXJmbG93ID09PSAtMSkge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93ID0gV0VFSztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChnZXRQYXJzaW5nRmxhZ3MobSkuX292ZXJmbG93V2Vla2RheSAmJiBvdmVyZmxvdyA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvdmVyZmxvdyA9IFdFRUtEQVk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhtKS5vdmVyZmxvdyA9IG92ZXJmbG93O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG07XG4gICAgfVxuXG4gICAgLy8gUGljayB0aGUgZmlyc3QgZGVmaW5lZCBvZiB0d28gb3IgdGhyZWUgYXJndW1lbnRzLlxuICAgIGZ1bmN0aW9uIGRlZmF1bHRzKGEsIGIsIGMpIHtcbiAgICAgICAgaWYgKGEgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGIgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3VycmVudERhdGVBcnJheShjb25maWcpIHtcbiAgICAgICAgLy8gaG9va3MgaXMgYWN0dWFsbHkgdGhlIGV4cG9ydGVkIG1vbWVudCBvYmplY3RcbiAgICAgICAgdmFyIG5vd1ZhbHVlID0gbmV3IERhdGUoaG9va3Mubm93KCkpO1xuICAgICAgICBpZiAoY29uZmlnLl91c2VVVEMpIHtcbiAgICAgICAgICAgIHJldHVybiBbbm93VmFsdWUuZ2V0VVRDRnVsbFllYXIoKSwgbm93VmFsdWUuZ2V0VVRDTW9udGgoKSwgbm93VmFsdWUuZ2V0VVRDRGF0ZSgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25vd1ZhbHVlLmdldEZ1bGxZZWFyKCksIG5vd1ZhbHVlLmdldE1vbnRoKCksIG5vd1ZhbHVlLmdldERhdGUoKV07XG4gICAgfVxuXG4gICAgLy8gY29udmVydCBhbiBhcnJheSB0byBhIGRhdGUuXG4gICAgLy8gdGhlIGFycmF5IHNob3VsZCBtaXJyb3IgdGhlIHBhcmFtZXRlcnMgYmVsb3dcbiAgICAvLyBub3RlOiBhbGwgdmFsdWVzIHBhc3QgdGhlIHllYXIgYXJlIG9wdGlvbmFsIGFuZCB3aWxsIGRlZmF1bHQgdG8gdGhlIGxvd2VzdCBwb3NzaWJsZSB2YWx1ZS5cbiAgICAvLyBbeWVhciwgbW9udGgsIGRheSAsIGhvdXIsIG1pbnV0ZSwgc2Vjb25kLCBtaWxsaXNlY29uZF1cbiAgICBmdW5jdGlvbiBjb25maWdGcm9tQXJyYXkgKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgZGF0ZSwgaW5wdXQgPSBbXSwgY3VycmVudERhdGUsIGV4cGVjdGVkV2Vla2RheSwgeWVhclRvVXNlO1xuXG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnREYXRlID0gY3VycmVudERhdGVBcnJheShjb25maWcpO1xuXG4gICAgICAgIC8vY29tcHV0ZSBkYXkgb2YgdGhlIHllYXIgZnJvbSB3ZWVrcyBhbmQgd2Vla2RheXNcbiAgICAgICAgaWYgKGNvbmZpZy5fdyAmJiBjb25maWcuX2FbREFURV0gPT0gbnVsbCAmJiBjb25maWcuX2FbTU9OVEhdID09IG51bGwpIHtcbiAgICAgICAgICAgIGRheU9mWWVhckZyb21XZWVrSW5mbyhjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9pZiB0aGUgZGF5IG9mIHRoZSB5ZWFyIGlzIHNldCwgZmlndXJlIG91dCB3aGF0IGl0IGlzXG4gICAgICAgIGlmIChjb25maWcuX2RheU9mWWVhciAhPSBudWxsKSB7XG4gICAgICAgICAgICB5ZWFyVG9Vc2UgPSBkZWZhdWx0cyhjb25maWcuX2FbWUVBUl0sIGN1cnJlbnREYXRlW1lFQVJdKTtcblxuICAgICAgICAgICAgaWYgKGNvbmZpZy5fZGF5T2ZZZWFyID4gZGF5c0luWWVhcih5ZWFyVG9Vc2UpIHx8IGNvbmZpZy5fZGF5T2ZZZWFyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuX292ZXJmbG93RGF5T2ZZZWFyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoeWVhclRvVXNlLCAwLCBjb25maWcuX2RheU9mWWVhcik7XG4gICAgICAgICAgICBjb25maWcuX2FbTU9OVEhdID0gZGF0ZS5nZXRVVENNb250aCgpO1xuICAgICAgICAgICAgY29uZmlnLl9hW0RBVEVdID0gZGF0ZS5nZXRVVENEYXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZhdWx0IHRvIGN1cnJlbnQgZGF0ZS5cbiAgICAgICAgLy8gKiBpZiBubyB5ZWFyLCBtb250aCwgZGF5IG9mIG1vbnRoIGFyZSBnaXZlbiwgZGVmYXVsdCB0byB0b2RheVxuICAgICAgICAvLyAqIGlmIGRheSBvZiBtb250aCBpcyBnaXZlbiwgZGVmYXVsdCBtb250aCBhbmQgeWVhclxuICAgICAgICAvLyAqIGlmIG1vbnRoIGlzIGdpdmVuLCBkZWZhdWx0IG9ubHkgeWVhclxuICAgICAgICAvLyAqIGlmIHllYXIgaXMgZ2l2ZW4sIGRvbid0IGRlZmF1bHQgYW55dGhpbmdcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDMgJiYgY29uZmlnLl9hW2ldID09IG51bGw7ICsraSkge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSBjdXJyZW50RGF0ZVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFplcm8gb3V0IHdoYXRldmVyIHdhcyBub3QgZGVmYXVsdGVkLCBpbmNsdWRpbmcgdGltZVxuICAgICAgICBmb3IgKDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgY29uZmlnLl9hW2ldID0gaW5wdXRbaV0gPSAoY29uZmlnLl9hW2ldID09IG51bGwpID8gKGkgPT09IDIgPyAxIDogMCkgOiBjb25maWcuX2FbaV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBDaGVjayBmb3IgMjQ6MDA6MDAuMDAwXG4gICAgICAgIGlmIChjb25maWcuX2FbSE9VUl0gPT09IDI0ICYmXG4gICAgICAgICAgICAgICAgY29uZmlnLl9hW01JTlVURV0gPT09IDAgJiZcbiAgICAgICAgICAgICAgICBjb25maWcuX2FbU0VDT05EXSA9PT0gMCAmJlxuICAgICAgICAgICAgICAgIGNvbmZpZy5fYVtNSUxMSVNFQ09ORF0gPT09IDApIHtcbiAgICAgICAgICAgIGNvbmZpZy5fbmV4dERheSA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2FbSE9VUl0gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnLl9kID0gKGNvbmZpZy5fdXNlVVRDID8gY3JlYXRlVVRDRGF0ZSA6IGNyZWF0ZURhdGUpLmFwcGx5KG51bGwsIGlucHV0KTtcbiAgICAgICAgZXhwZWN0ZWRXZWVrZGF5ID0gY29uZmlnLl91c2VVVEMgPyBjb25maWcuX2QuZ2V0VVRDRGF5KCkgOiBjb25maWcuX2QuZ2V0RGF5KCk7XG5cbiAgICAgICAgLy8gQXBwbHkgdGltZXpvbmUgb2Zmc2V0IGZyb20gaW5wdXQuIFRoZSBhY3R1YWwgdXRjT2Zmc2V0IGNhbiBiZSBjaGFuZ2VkXG4gICAgICAgIC8vIHdpdGggcGFyc2Vab25lLlxuICAgICAgICBpZiAoY29uZmlnLl90em0gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuX25leHREYXkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYVtIT1VSXSA9IDI0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIG1pc21hdGNoaW5nIGRheSBvZiB3ZWVrXG4gICAgICAgIGlmIChjb25maWcuX3cgJiYgdHlwZW9mIGNvbmZpZy5fdy5kICE9PSAndW5kZWZpbmVkJyAmJiBjb25maWcuX3cuZCAhPT0gZXhwZWN0ZWRXZWVrZGF5KSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS53ZWVrZGF5TWlzbWF0Y2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGF5T2ZZZWFyRnJvbVdlZWtJbmZvKGNvbmZpZykge1xuICAgICAgICB2YXIgdywgd2Vla1llYXIsIHdlZWssIHdlZWtkYXksIGRvdywgZG95LCB0ZW1wLCB3ZWVrZGF5T3ZlcmZsb3c7XG5cbiAgICAgICAgdyA9IGNvbmZpZy5fdztcbiAgICAgICAgaWYgKHcuR0cgIT0gbnVsbCB8fCB3LlcgIT0gbnVsbCB8fCB3LkUgIT0gbnVsbCkge1xuICAgICAgICAgICAgZG93ID0gMTtcbiAgICAgICAgICAgIGRveSA9IDQ7XG5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIG5lZWQgdG8gdGFrZSB0aGUgY3VycmVudCBpc29XZWVrWWVhciwgYnV0IHRoYXQgZGVwZW5kcyBvblxuICAgICAgICAgICAgLy8gaG93IHdlIGludGVycHJldCBub3cgKGxvY2FsLCB1dGMsIGZpeGVkIG9mZnNldCkuIFNvIGNyZWF0ZVxuICAgICAgICAgICAgLy8gYSBub3cgdmVyc2lvbiBvZiBjdXJyZW50IGNvbmZpZyAodGFrZSBsb2NhbC91dGMvb2Zmc2V0IGZsYWdzLCBhbmRcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBub3cpLlxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LkdHLCBjb25maWcuX2FbWUVBUl0sIHdlZWtPZlllYXIoY3JlYXRlTG9jYWwoKSwgMSwgNCkueWVhcik7XG4gICAgICAgICAgICB3ZWVrID0gZGVmYXVsdHMody5XLCAxKTtcbiAgICAgICAgICAgIHdlZWtkYXkgPSBkZWZhdWx0cyh3LkUsIDEpO1xuICAgICAgICAgICAgaWYgKHdlZWtkYXkgPCAxIHx8IHdlZWtkYXkgPiA3KSB7XG4gICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRvdyA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRvdztcbiAgICAgICAgICAgIGRveSA9IGNvbmZpZy5fbG9jYWxlLl93ZWVrLmRveTtcblxuICAgICAgICAgICAgdmFyIGN1cldlZWsgPSB3ZWVrT2ZZZWFyKGNyZWF0ZUxvY2FsKCksIGRvdywgZG95KTtcblxuICAgICAgICAgICAgd2Vla1llYXIgPSBkZWZhdWx0cyh3LmdnLCBjb25maWcuX2FbWUVBUl0sIGN1cldlZWsueWVhcik7XG5cbiAgICAgICAgICAgIC8vIERlZmF1bHQgdG8gY3VycmVudCB3ZWVrLlxuICAgICAgICAgICAgd2VlayA9IGRlZmF1bHRzKHcudywgY3VyV2Vlay53ZWVrKTtcblxuICAgICAgICAgICAgaWYgKHcuZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Vla2RheSAtLSBsb3cgZGF5IG51bWJlcnMgYXJlIGNvbnNpZGVyZWQgbmV4dCB3ZWVrXG4gICAgICAgICAgICAgICAgd2Vla2RheSA9IHcuZDtcbiAgICAgICAgICAgICAgICBpZiAod2Vla2RheSA8IDAgfHwgd2Vla2RheSA+IDYpIHtcbiAgICAgICAgICAgICAgICAgICAgd2Vla2RheU92ZXJmbG93ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHcuZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gbG9jYWwgd2Vla2RheSAtLSBjb3VudGluZyBzdGFydHMgZnJvbSBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSB3LmUgKyBkb3c7XG4gICAgICAgICAgICAgICAgaWYgKHcuZSA8IDAgfHwgdy5lID4gNikge1xuICAgICAgICAgICAgICAgICAgICB3ZWVrZGF5T3ZlcmZsb3cgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gZGVmYXVsdCB0byBiZWdpbm5pbmcgb2Ygd2Vla1xuICAgICAgICAgICAgICAgIHdlZWtkYXkgPSBkb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdlZWsgPCAxIHx8IHdlZWsgPiB3ZWVrc0luWWVhcih3ZWVrWWVhciwgZG93LCBkb3kpKSB7XG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS5fb3ZlcmZsb3dXZWVrcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAod2Vla2RheU92ZXJmbG93ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLl9vdmVyZmxvd1dlZWtkYXkgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGVtcCA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpO1xuICAgICAgICAgICAgY29uZmlnLl9hW1lFQVJdID0gdGVtcC55ZWFyO1xuICAgICAgICAgICAgY29uZmlnLl9kYXlPZlllYXIgPSB0ZW1wLmRheU9mWWVhcjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGlzbyA4NjAxIHJlZ2V4XG4gICAgLy8gMDAwMC0wMC0wMCAwMDAwLVcwMCBvciAwMDAwLVcwMC0wICsgVCArIDAwIG9yIDAwOjAwIG9yIDAwOjAwOjAwIG9yIDAwOjAwOjAwLjAwMCArICswMDowMCBvciArMDAwMCBvciArMDApXG4gICAgdmFyIGV4dGVuZGVkSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pLSg/OlxcZFxcZC1cXGRcXGR8V1xcZFxcZC1cXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzo6XFxkXFxkKD86OlxcZFxcZCg/OlsuLF1cXGQrKT8pPyk/KShbXFwrXFwtXVxcZFxcZCg/Ojo/XFxkXFxkKT98XFxzKlopPyk/JC87XG4gICAgdmFyIGJhc2ljSXNvUmVnZXggPSAvXlxccyooKD86WystXVxcZHs2fXxcXGR7NH0pKD86XFxkXFxkXFxkXFxkfFdcXGRcXGRcXGR8V1xcZFxcZHxcXGRcXGRcXGR8XFxkXFxkKSkoPzooVHwgKShcXGRcXGQoPzpcXGRcXGQoPzpcXGRcXGQoPzpbLixdXFxkKyk/KT8pPykoW1xcK1xcLV1cXGRcXGQoPzo6P1xcZFxcZCk/fFxccypaKT8pPyQvO1xuXG4gICAgdmFyIHR6UmVnZXggPSAvWnxbKy1dXFxkXFxkKD86Oj9cXGRcXGQpPy87XG5cbiAgICB2YXIgaXNvRGF0ZXMgPSBbXG4gICAgICAgIFsnWVlZWVlZLU1NLUREJywgL1srLV1cXGR7Nn0tXFxkXFxkLVxcZFxcZC9dLFxuICAgICAgICBbJ1lZWVktTU0tREQnLCAvXFxkezR9LVxcZFxcZC1cXGRcXGQvXSxcbiAgICAgICAgWydHR0dHLVtXXVdXLUUnLCAvXFxkezR9LVdcXGRcXGQtXFxkL10sXG4gICAgICAgIFsnR0dHRy1bV11XVycsIC9cXGR7NH0tV1xcZFxcZC8sIGZhbHNlXSxcbiAgICAgICAgWydZWVlZLURERCcsIC9cXGR7NH0tXFxkezN9L10sXG4gICAgICAgIFsnWVlZWS1NTScsIC9cXGR7NH0tXFxkXFxkLywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlZWU1NREQnLCAvWystXVxcZHsxMH0vXSxcbiAgICAgICAgWydZWVlZTU1ERCcsIC9cXGR7OH0vXSxcbiAgICAgICAgLy8gWVlZWU1NIGlzIE5PVCBhbGxvd2VkIGJ5IHRoZSBzdGFuZGFyZFxuICAgICAgICBbJ0dHR0dbV11XV0UnLCAvXFxkezR9V1xcZHszfS9dLFxuICAgICAgICBbJ0dHR0dbV11XVycsIC9cXGR7NH1XXFxkezJ9LywgZmFsc2VdLFxuICAgICAgICBbJ1lZWVlEREQnLCAvXFxkezd9L11cbiAgICBdO1xuXG4gICAgLy8gaXNvIHRpbWUgZm9ybWF0cyBhbmQgcmVnZXhlc1xuICAgIHZhciBpc29UaW1lcyA9IFtcbiAgICAgICAgWydISDptbTpzcy5TU1NTJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkXFwuXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzLFNTU1MnLCAvXFxkXFxkOlxcZFxcZDpcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIOm1tOnNzJywgL1xcZFxcZDpcXGRcXGQ6XFxkXFxkL10sXG4gICAgICAgIFsnSEg6bW0nLCAvXFxkXFxkOlxcZFxcZC9dLFxuICAgICAgICBbJ0hIbW1zcy5TU1NTJywgL1xcZFxcZFxcZFxcZFxcZFxcZFxcLlxcZCsvXSxcbiAgICAgICAgWydISG1tc3MsU1NTUycsIC9cXGRcXGRcXGRcXGRcXGRcXGQsXFxkKy9dLFxuICAgICAgICBbJ0hIbW1zcycsIC9cXGRcXGRcXGRcXGRcXGRcXGQvXSxcbiAgICAgICAgWydISG1tJywgL1xcZFxcZFxcZFxcZC9dLFxuICAgICAgICBbJ0hIJywgL1xcZFxcZC9dXG4gICAgXTtcblxuICAgIHZhciBhc3BOZXRKc29uUmVnZXggPSAvXlxcLz9EYXRlXFwoKFxcLT9cXGQrKS9pO1xuXG4gICAgLy8gZGF0ZSBmcm9tIGlzbyBmb3JtYXRcbiAgICBmdW5jdGlvbiBjb25maWdGcm9tSVNPKGNvbmZpZykge1xuICAgICAgICB2YXIgaSwgbCxcbiAgICAgICAgICAgIHN0cmluZyA9IGNvbmZpZy5faSxcbiAgICAgICAgICAgIG1hdGNoID0gZXh0ZW5kZWRJc29SZWdleC5leGVjKHN0cmluZykgfHwgYmFzaWNJc29SZWdleC5leGVjKHN0cmluZyksXG4gICAgICAgICAgICBhbGxvd1RpbWUsIGRhdGVGb3JtYXQsIHRpbWVGb3JtYXQsIHR6Rm9ybWF0O1xuXG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaXNvID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGlzb0RhdGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChpc29EYXRlc1tpXVsxXS5leGVjKG1hdGNoWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRlRm9ybWF0ID0gaXNvRGF0ZXNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGFsbG93VGltZSA9IGlzb0RhdGVzW2ldWzJdICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGVGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5faXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFszXSkge1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSBpc29UaW1lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzb1RpbWVzW2ldWzFdLmV4ZWMobWF0Y2hbM10pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYXRjaFsyXSBzaG91bGQgYmUgJ1QnIG9yIHNwYWNlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lRm9ybWF0ID0gKG1hdGNoWzJdIHx8ICcgJykgKyBpc29UaW1lc1tpXVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aW1lRm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWFsbG93VGltZSAmJiB0aW1lRm9ybWF0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobWF0Y2hbNF0pIHtcbiAgICAgICAgICAgICAgICBpZiAodHpSZWdleC5leGVjKG1hdGNoWzRdKSkge1xuICAgICAgICAgICAgICAgICAgICB0ekZvcm1hdCA9ICdaJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbmZpZy5fZiA9IGRhdGVGb3JtYXQgKyAodGltZUZvcm1hdCB8fCAnJykgKyAodHpGb3JtYXQgfHwgJycpO1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uZmlnLl9pc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSRkMgMjgyMiByZWdleDogRm9yIGRldGFpbHMgc2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyODIyI3NlY3Rpb24tMy4zXG4gICAgdmFyIHJmYzI4MjIgPSAvXig/OihNb258VHVlfFdlZHxUaHV8RnJpfFNhdHxTdW4pLD9cXHMpPyhcXGR7MSwyfSlcXHMoSmFufEZlYnxNYXJ8QXByfE1heXxKdW58SnVsfEF1Z3xTZXB8T2N0fE5vdnxEZWMpXFxzKFxcZHsyLDR9KVxccyhcXGRcXGQpOihcXGRcXGQpKD86OihcXGRcXGQpKT9cXHMoPzooVVR8R01UfFtFQ01QXVtTRF1UKXwoW1p6XSl8KFsrLV1cXGR7NH0pKSQvO1xuXG4gICAgZnVuY3Rpb24gZXh0cmFjdEZyb21SRkMyODIyU3RyaW5ncyh5ZWFyU3RyLCBtb250aFN0ciwgZGF5U3RyLCBob3VyU3RyLCBtaW51dGVTdHIsIHNlY29uZFN0cikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW1xuICAgICAgICAgICAgdW50cnVuY2F0ZVllYXIoeWVhclN0ciksXG4gICAgICAgICAgICBkZWZhdWx0TG9jYWxlTW9udGhzU2hvcnQuaW5kZXhPZihtb250aFN0ciksXG4gICAgICAgICAgICBwYXJzZUludChkYXlTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KGhvdXJTdHIsIDEwKSxcbiAgICAgICAgICAgIHBhcnNlSW50KG1pbnV0ZVN0ciwgMTApXG4gICAgICAgIF07XG5cbiAgICAgICAgaWYgKHNlY29uZFN0cikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoc2Vjb25kU3RyLCAxMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB1bnRydW5jYXRlWWVhcih5ZWFyU3RyKSB7XG4gICAgICAgIHZhciB5ZWFyID0gcGFyc2VJbnQoeWVhclN0ciwgMTApO1xuICAgICAgICBpZiAoeWVhciA8PSA0OSkge1xuICAgICAgICAgICAgcmV0dXJuIDIwMDAgKyB5ZWFyO1xuICAgICAgICB9IGVsc2UgaWYgKHllYXIgPD0gOTk5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTkwMCArIHllYXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHllYXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc1JGQzI4MjIocykge1xuICAgICAgICAvLyBSZW1vdmUgY29tbWVudHMgYW5kIGZvbGRpbmcgd2hpdGVzcGFjZSBhbmQgcmVwbGFjZSBtdWx0aXBsZS1zcGFjZXMgd2l0aCBhIHNpbmdsZSBzcGFjZVxuICAgICAgICByZXR1cm4gcy5yZXBsYWNlKC9cXChbXildKlxcKXxbXFxuXFx0XS9nLCAnICcpLnJlcGxhY2UoLyhcXHNcXHMrKS9nLCAnICcpLnJlcGxhY2UoL15cXHNcXHMqLywgJycpLnJlcGxhY2UoL1xcc1xccyokLywgJycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrV2Vla2RheSh3ZWVrZGF5U3RyLCBwYXJzZWRJbnB1dCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh3ZWVrZGF5U3RyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoZSB2YW5pbGxhIEpTIERhdGUgb2JqZWN0IHdpdGggYW4gaW5kZXBlbnRlbnQgZGF5LW9mLXdlZWsgY2hlY2suXG4gICAgICAgICAgICB2YXIgd2Vla2RheVByb3ZpZGVkID0gZGVmYXVsdExvY2FsZVdlZWtkYXlzU2hvcnQuaW5kZXhPZih3ZWVrZGF5U3RyKSxcbiAgICAgICAgICAgICAgICB3ZWVrZGF5QWN0dWFsID0gbmV3IERhdGUocGFyc2VkSW5wdXRbMF0sIHBhcnNlZElucHV0WzFdLCBwYXJzZWRJbnB1dFsyXSkuZ2V0RGF5KCk7XG4gICAgICAgICAgICBpZiAod2Vla2RheVByb3ZpZGVkICE9PSB3ZWVrZGF5QWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykud2Vla2RheU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIG9ic09mZnNldHMgPSB7XG4gICAgICAgIFVUOiAwLFxuICAgICAgICBHTVQ6IDAsXG4gICAgICAgIEVEVDogLTQgKiA2MCxcbiAgICAgICAgRVNUOiAtNSAqIDYwLFxuICAgICAgICBDRFQ6IC01ICogNjAsXG4gICAgICAgIENTVDogLTYgKiA2MCxcbiAgICAgICAgTURUOiAtNiAqIDYwLFxuICAgICAgICBNU1Q6IC03ICogNjAsXG4gICAgICAgIFBEVDogLTcgKiA2MCxcbiAgICAgICAgUFNUOiAtOCAqIDYwXG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGN1bGF0ZU9mZnNldChvYnNPZmZzZXQsIG1pbGl0YXJ5T2Zmc2V0LCBudW1PZmZzZXQpIHtcbiAgICAgICAgaWYgKG9ic09mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG9ic09mZnNldHNbb2JzT2Zmc2V0XTtcbiAgICAgICAgfSBlbHNlIGlmIChtaWxpdGFyeU9mZnNldCkge1xuICAgICAgICAgICAgLy8gdGhlIG9ubHkgYWxsb3dlZCBtaWxpdGFyeSB0eiBpcyBaXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBobSA9IHBhcnNlSW50KG51bU9mZnNldCwgMTApO1xuICAgICAgICAgICAgdmFyIG0gPSBobSAlIDEwMCwgaCA9IChobSAtIG0pIC8gMTAwO1xuICAgICAgICAgICAgcmV0dXJuIGggKiA2MCArIG07XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBkYXRlIGFuZCB0aW1lIGZyb20gcmVmIDI4MjIgZm9ybWF0XG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKSB7XG4gICAgICAgIHZhciBtYXRjaCA9IHJmYzI4MjIuZXhlYyhwcmVwcm9jZXNzUkZDMjgyMihjb25maWcuX2kpKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQXJyYXkgPSBleHRyYWN0RnJvbVJGQzI4MjJTdHJpbmdzKG1hdGNoWzRdLCBtYXRjaFszXSwgbWF0Y2hbMl0sIG1hdGNoWzVdLCBtYXRjaFs2XSwgbWF0Y2hbN10pO1xuICAgICAgICAgICAgaWYgKCFjaGVja1dlZWtkYXkobWF0Y2hbMV0sIHBhcnNlZEFycmF5LCBjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25maWcuX2EgPSBwYXJzZWRBcnJheTtcbiAgICAgICAgICAgIGNvbmZpZy5fdHptID0gY2FsY3VsYXRlT2Zmc2V0KG1hdGNoWzhdLCBtYXRjaFs5XSwgbWF0Y2hbMTBdKTtcblxuICAgICAgICAgICAgY29uZmlnLl9kID0gY3JlYXRlVVRDRGF0ZS5hcHBseShudWxsLCBjb25maWcuX2EpO1xuICAgICAgICAgICAgY29uZmlnLl9kLnNldFVUQ01pbnV0ZXMoY29uZmlnLl9kLmdldFVUQ01pbnV0ZXMoKSAtIGNvbmZpZy5fdHptKTtcblxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykucmZjMjgyMiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25maWcuX2lzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBpc28gZm9ybWF0IG9yIGZhbGxiYWNrXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZyhjb25maWcpIHtcbiAgICAgICAgdmFyIG1hdGNoZWQgPSBhc3BOZXRKc29uUmVnZXguZXhlYyhjb25maWcuX2kpO1xuXG4gICAgICAgIGlmIChtYXRjaGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZSgrbWF0Y2hlZFsxXSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgIGlmIChjb25maWcuX2lzVmFsaWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBkZWxldGUgY29uZmlnLl9pc1ZhbGlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uZmlnRnJvbVJGQzI4MjIoY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5faXNWYWxpZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBjb25maWcuX2lzVmFsaWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBGaW5hbCBhdHRlbXB0LCB1c2UgSW5wdXQgRmFsbGJhY2tcbiAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICB9XG5cbiAgICBob29rcy5jcmVhdGVGcm9tSW5wdXRGYWxsYmFjayA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ3ZhbHVlIHByb3ZpZGVkIGlzIG5vdCBpbiBhIHJlY29nbml6ZWQgUkZDMjgyMiBvciBJU08gZm9ybWF0LiBtb21lbnQgY29uc3RydWN0aW9uIGZhbGxzIGJhY2sgdG8ganMgRGF0ZSgpLCAnICtcbiAgICAgICAgJ3doaWNoIGlzIG5vdCByZWxpYWJsZSBhY3Jvc3MgYWxsIGJyb3dzZXJzIGFuZCB2ZXJzaW9ucy4gTm9uIFJGQzI4MjIvSVNPIGRhdGUgZm9ybWF0cyBhcmUgJyArXG4gICAgICAgICdkaXNjb3VyYWdlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGFuIHVwY29taW5nIG1ham9yIHJlbGVhc2UuIFBsZWFzZSByZWZlciB0byAnICtcbiAgICAgICAgJ2h0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvanMtZGF0ZS8gZm9yIG1vcmUgaW5mby4nLFxuICAgICAgICBmdW5jdGlvbiAoY29uZmlnKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShjb25maWcuX2kgKyAoY29uZmlnLl91c2VVVEMgPyAnIFVUQycgOiAnJykpO1xuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIGNvbnN0YW50IHRoYXQgcmVmZXJzIHRvIHRoZSBJU08gc3RhbmRhcmRcbiAgICBob29rcy5JU09fODYwMSA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gY29uc3RhbnQgdGhhdCByZWZlcnMgdG8gdGhlIFJGQyAyODIyIGZvcm1cbiAgICBob29rcy5SRkNfMjgyMiA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gZGF0ZSBmcm9tIHN0cmluZyBhbmQgZm9ybWF0IHN0cmluZ1xuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21TdHJpbmdBbmRGb3JtYXQoY29uZmlnKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhpcyB0byBhbm90aGVyIHBhcnQgb2YgdGhlIGNyZWF0aW9uIGZsb3cgdG8gcHJldmVudCBjaXJjdWxhciBkZXBzXG4gICAgICAgIGlmIChjb25maWcuX2YgPT09IGhvb2tzLklTT184NjAxKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tSVNPKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5fZiA9PT0gaG9va3MuUkZDXzI4MjIpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21SRkMyODIyKGNvbmZpZyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLl9hID0gW107XG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gdHJ1ZTtcblxuICAgICAgICAvLyBUaGlzIGFycmF5IGlzIHVzZWQgdG8gbWFrZSBhIERhdGUsIGVpdGhlciB3aXRoIGBuZXcgRGF0ZWAgb3IgYERhdGUuVVRDYFxuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBjb25maWcuX2ksXG4gICAgICAgICAgICBpLCBwYXJzZWRJbnB1dCwgdG9rZW5zLCB0b2tlbiwgc2tpcHBlZCxcbiAgICAgICAgICAgIHN0cmluZ0xlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG4gICAgICAgICAgICB0b3RhbFBhcnNlZElucHV0TGVuZ3RoID0gMDtcblxuICAgICAgICB0b2tlbnMgPSBleHBhbmRGb3JtYXQoY29uZmlnLl9mLCBjb25maWcuX2xvY2FsZSkubWF0Y2goZm9ybWF0dGluZ1Rva2VucykgfHwgW107XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICAgICAgICBwYXJzZWRJbnB1dCA9IChzdHJpbmcubWF0Y2goZ2V0UGFyc2VSZWdleEZvclRva2VuKHRva2VuLCBjb25maWcpKSB8fCBbXSlbMF07XG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZygndG9rZW4nLCB0b2tlbiwgJ3BhcnNlZElucHV0JywgcGFyc2VkSW5wdXQsXG4gICAgICAgICAgICAvLyAgICAgICAgICdyZWdleCcsIGdldFBhcnNlUmVnZXhGb3JUb2tlbih0b2tlbiwgY29uZmlnKSk7XG4gICAgICAgICAgICBpZiAocGFyc2VkSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBza2lwcGVkID0gc3RyaW5nLnN1YnN0cigwLCBzdHJpbmcuaW5kZXhPZihwYXJzZWRJbnB1dCkpO1xuICAgICAgICAgICAgICAgIGlmIChza2lwcGVkLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChza2lwcGVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5nID0gc3RyaW5nLnNsaWNlKHN0cmluZy5pbmRleE9mKHBhcnNlZElucHV0KSArIHBhcnNlZElucHV0Lmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgdG90YWxQYXJzZWRJbnB1dExlbmd0aCArPSBwYXJzZWRJbnB1dC5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkb24ndCBwYXJzZSBpZiBpdCdzIG5vdCBhIGtub3duIHRva2VuXG4gICAgICAgICAgICBpZiAoZm9ybWF0VG9rZW5GdW5jdGlvbnNbdG9rZW5dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLmVtcHR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3MoY29uZmlnKS51bnVzZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFkZFRpbWVUb0FycmF5RnJvbVRva2VuKHRva2VuLCBwYXJzZWRJbnB1dCwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbmZpZy5fc3RyaWN0ICYmICFwYXJzZWRJbnB1dCkge1xuICAgICAgICAgICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnVudXNlZFRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkZCByZW1haW5pbmcgdW5wYXJzZWQgaW5wdXQgbGVuZ3RoIHRvIHRoZSBzdHJpbmdcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuY2hhcnNMZWZ0T3ZlciA9IHN0cmluZ0xlbmd0aCAtIHRvdGFsUGFyc2VkSW5wdXRMZW5ndGg7XG4gICAgICAgIGlmIChzdHJpbmcubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykudW51c2VkSW5wdXQucHVzaChzdHJpbmcpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2xlYXIgXzEyaCBmbGFnIGlmIGhvdXIgaXMgPD0gMTJcbiAgICAgICAgaWYgKGNvbmZpZy5fYVtIT1VSXSA8PSAxMiAmJlxuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9PT0gdHJ1ZSAmJlxuICAgICAgICAgICAgY29uZmlnLl9hW0hPVVJdID4gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuYmlnSG91ciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGdldFBhcnNpbmdGbGFncyhjb25maWcpLnBhcnNlZERhdGVQYXJ0cyA9IGNvbmZpZy5fYS5zbGljZSgwKTtcbiAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykubWVyaWRpZW0gPSBjb25maWcuX21lcmlkaWVtO1xuICAgICAgICAvLyBoYW5kbGUgbWVyaWRpZW1cbiAgICAgICAgY29uZmlnLl9hW0hPVVJdID0gbWVyaWRpZW1GaXhXcmFwKGNvbmZpZy5fbG9jYWxlLCBjb25maWcuX2FbSE9VUl0sIGNvbmZpZy5fbWVyaWRpZW0pO1xuXG4gICAgICAgIGNvbmZpZ0Zyb21BcnJheShjb25maWcpO1xuICAgICAgICBjaGVja092ZXJmbG93KGNvbmZpZyk7XG4gICAgfVxuXG5cbiAgICBmdW5jdGlvbiBtZXJpZGllbUZpeFdyYXAgKGxvY2FsZSwgaG91ciwgbWVyaWRpZW0pIHtcbiAgICAgICAgdmFyIGlzUG07XG5cbiAgICAgICAgaWYgKG1lcmlkaWVtID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2NhbGUubWVyaWRpZW1Ib3VyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbGUubWVyaWRpZW1Ib3VyKGhvdXIsIG1lcmlkaWVtKTtcbiAgICAgICAgfSBlbHNlIGlmIChsb2NhbGUuaXNQTSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFja1xuICAgICAgICAgICAgaXNQbSA9IGxvY2FsZS5pc1BNKG1lcmlkaWVtKTtcbiAgICAgICAgICAgIGlmIChpc1BtICYmIGhvdXIgPCAxMikge1xuICAgICAgICAgICAgICAgIGhvdXIgKz0gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzUG0gJiYgaG91ciA9PT0gMTIpIHtcbiAgICAgICAgICAgICAgICBob3VyID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBob3VyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBub3Qgc3VwcG9zZWQgdG8gaGFwcGVuXG4gICAgICAgICAgICByZXR1cm4gaG91cjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRhdGUgZnJvbSBzdHJpbmcgYW5kIGFycmF5IG9mIGZvcm1hdCBzdHJpbmdzXG4gICAgZnVuY3Rpb24gY29uZmlnRnJvbVN0cmluZ0FuZEFycmF5KGNvbmZpZykge1xuICAgICAgICB2YXIgdGVtcENvbmZpZyxcbiAgICAgICAgICAgIGJlc3RNb21lbnQsXG5cbiAgICAgICAgICAgIHNjb3JlVG9CZWF0LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZTtcblxuICAgICAgICBpZiAoY29uZmlnLl9mLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgZ2V0UGFyc2luZ0ZsYWdzKGNvbmZpZykuaW52YWxpZEZvcm1hdCA9IHRydWU7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShOYU4pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbmZpZy5fZi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY3VycmVudFNjb3JlID0gMDtcbiAgICAgICAgICAgIHRlbXBDb25maWcgPSBjb3B5Q29uZmlnKHt9LCBjb25maWcpO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5fdXNlVVRDICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0ZW1wQ29uZmlnLl91c2VVVEMgPSBjb25maWcuX3VzZVVUQztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRlbXBDb25maWcuX2YgPSBjb25maWcuX2ZbaV07XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nQW5kRm9ybWF0KHRlbXBDb25maWcpO1xuXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQodGVtcENvbmZpZykpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW55IGlucHV0IHRoYXQgd2FzIG5vdCBwYXJzZWQgYWRkIGEgcGVuYWx0eSBmb3IgdGhhdCBmb3JtYXRcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuY2hhcnNMZWZ0T3ZlcjtcblxuICAgICAgICAgICAgLy9vciB0b2tlbnNcbiAgICAgICAgICAgIGN1cnJlbnRTY29yZSArPSBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykudW51c2VkVG9rZW5zLmxlbmd0aCAqIDEwO1xuXG4gICAgICAgICAgICBnZXRQYXJzaW5nRmxhZ3ModGVtcENvbmZpZykuc2NvcmUgPSBjdXJyZW50U2NvcmU7XG5cbiAgICAgICAgICAgIGlmIChzY29yZVRvQmVhdCA9PSBudWxsIHx8IGN1cnJlbnRTY29yZSA8IHNjb3JlVG9CZWF0KSB7XG4gICAgICAgICAgICAgICAgc2NvcmVUb0JlYXQgPSBjdXJyZW50U2NvcmU7XG4gICAgICAgICAgICAgICAgYmVzdE1vbWVudCA9IHRlbXBDb25maWc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBleHRlbmQoY29uZmlnLCBiZXN0TW9tZW50IHx8IHRlbXBDb25maWcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21PYmplY3QoY29uZmlnKSB7XG4gICAgICAgIGlmIChjb25maWcuX2QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gbm9ybWFsaXplT2JqZWN0VW5pdHMoY29uZmlnLl9pKTtcbiAgICAgICAgY29uZmlnLl9hID0gbWFwKFtpLnllYXIsIGkubW9udGgsIGkuZGF5IHx8IGkuZGF0ZSwgaS5ob3VyLCBpLm1pbnV0ZSwgaS5zZWNvbmQsIGkubWlsbGlzZWNvbmRdLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqICYmIHBhcnNlSW50KG9iaiwgMTApO1xuICAgICAgICB9KTtcblxuICAgICAgICBjb25maWdGcm9tQXJyYXkoY29uZmlnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVGcm9tQ29uZmlnIChjb25maWcpIHtcbiAgICAgICAgdmFyIHJlcyA9IG5ldyBNb21lbnQoY2hlY2tPdmVyZmxvdyhwcmVwYXJlQ29uZmlnKGNvbmZpZykpKTtcbiAgICAgICAgaWYgKHJlcy5fbmV4dERheSkge1xuICAgICAgICAgICAgLy8gQWRkaW5nIGlzIHNtYXJ0IGVub3VnaCBhcm91bmQgRFNUXG4gICAgICAgICAgICByZXMuYWRkKDEsICdkJyk7XG4gICAgICAgICAgICByZXMuX25leHREYXkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBhcmVDb25maWcgKGNvbmZpZykge1xuICAgICAgICB2YXIgaW5wdXQgPSBjb25maWcuX2ksXG4gICAgICAgICAgICBmb3JtYXQgPSBjb25maWcuX2Y7XG5cbiAgICAgICAgY29uZmlnLl9sb2NhbGUgPSBjb25maWcuX2xvY2FsZSB8fCBnZXRMb2NhbGUoY29uZmlnLl9sKTtcblxuICAgICAgICBpZiAoaW5wdXQgPT09IG51bGwgfHwgKGZvcm1hdCA9PT0gdW5kZWZpbmVkICYmIGlucHV0ID09PSAnJykpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKHtudWxsSW5wdXQ6IHRydWV9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWcuX2kgPSBpbnB1dCA9IGNvbmZpZy5fbG9jYWxlLnByZXBhcnNlKGlucHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc01vbWVudChpbnB1dCkpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgTW9tZW50KGNoZWNrT3ZlcmZsb3coaW5wdXQpKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RhdGUoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBpbnB1dDtcbiAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21TdHJpbmdBbmRBcnJheShjb25maWcpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgY29uZmlnRnJvbVN0cmluZ0FuZEZvcm1hdChjb25maWcpO1xuICAgICAgICB9ICBlbHNlIHtcbiAgICAgICAgICAgIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkKGNvbmZpZykpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fZCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbmZpZ0Zyb21JbnB1dChjb25maWcpIHtcbiAgICAgICAgdmFyIGlucHV0ID0gY29uZmlnLl9pO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWcuX2QgPSBuZXcgRGF0ZShob29rcy5ub3coKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNEYXRlKGlucHV0KSkge1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQudmFsdWVPZigpKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tU3RyaW5nKGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgICAgIGNvbmZpZy5fYSA9IG1hcChpbnB1dC5zbGljZSgwKSwgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJzZUludChvYmosIDEwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uZmlnRnJvbUFycmF5KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNPYmplY3QoaW5wdXQpKSB7XG4gICAgICAgICAgICBjb25maWdGcm9tT2JqZWN0KGNvbmZpZyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICAvLyBmcm9tIG1pbGxpc2Vjb25kc1xuICAgICAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUoaW5wdXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaG9va3MuY3JlYXRlRnJvbUlucHV0RmFsbGJhY2soY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2FsT3JVVEMgKGlucHV0LCBmb3JtYXQsIGxvY2FsZSwgc3RyaWN0LCBpc1VUQykge1xuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGlmIChsb2NhbGUgPT09IHRydWUgfHwgbG9jYWxlID09PSBmYWxzZSkge1xuICAgICAgICAgICAgc3RyaWN0ID0gbG9jYWxlO1xuICAgICAgICAgICAgbG9jYWxlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChpc09iamVjdChpbnB1dCkgJiYgaXNPYmplY3RFbXB0eShpbnB1dCkpIHx8XG4gICAgICAgICAgICAgICAgKGlzQXJyYXkoaW5wdXQpICYmIGlucHV0Lmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIGlucHV0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9iamVjdCBjb25zdHJ1Y3Rpb24gbXVzdCBiZSBkb25lIHRoaXMgd2F5LlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMTQyM1xuICAgICAgICBjLl9pc0FNb21lbnRPYmplY3QgPSB0cnVlO1xuICAgICAgICBjLl91c2VVVEMgPSBjLl9pc1VUQyA9IGlzVVRDO1xuICAgICAgICBjLl9sID0gbG9jYWxlO1xuICAgICAgICBjLl9pID0gaW5wdXQ7XG4gICAgICAgIGMuX2YgPSBmb3JtYXQ7XG4gICAgICAgIGMuX3N0cmljdCA9IHN0cmljdDtcblxuICAgICAgICByZXR1cm4gY3JlYXRlRnJvbUNvbmZpZyhjKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMb2NhbCAoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUxvY2FsT3JVVEMoaW5wdXQsIGZvcm1hdCwgbG9jYWxlLCBzdHJpY3QsIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgcHJvdG90eXBlTWluID0gZGVwcmVjYXRlKFxuICAgICAgICAnbW9tZW50KCkubWluIGlzIGRlcHJlY2F0ZWQsIHVzZSBtb21lbnQubWF4IGluc3RlYWQuIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvbWluLW1heC8nLFxuICAgICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdGhlciA8IHRoaXMgPyB0aGlzIDogb3RoZXI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbnZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgdmFyIHByb3RvdHlwZU1heCA9IGRlcHJlY2F0ZShcbiAgICAgICAgJ21vbWVudCgpLm1heCBpcyBkZXByZWNhdGVkLCB1c2UgbW9tZW50Lm1pbiBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL21pbi1tYXgvJyxcbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlTG9jYWwuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJiBvdGhlci5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3RoZXIgPiB0aGlzID8gdGhpcyA6IG90aGVyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlSW52YWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgKTtcblxuICAgIC8vIFBpY2sgYSBtb21lbnQgbSBmcm9tIG1vbWVudHMgc28gdGhhdCBtW2ZuXShvdGhlcikgaXMgdHJ1ZSBmb3IgYWxsXG4gICAgLy8gb3RoZXIuIFRoaXMgcmVsaWVzIG9uIHRoZSBmdW5jdGlvbiBmbiB0byBiZSB0cmFuc2l0aXZlLlxuICAgIC8vXG4gICAgLy8gbW9tZW50cyBzaG91bGQgZWl0aGVyIGJlIGFuIGFycmF5IG9mIG1vbWVudCBvYmplY3RzIG9yIGFuIGFycmF5LCB3aG9zZVxuICAgIC8vIGZpcnN0IGVsZW1lbnQgaXMgYW4gYXJyYXkgb2YgbW9tZW50IG9iamVjdHMuXG4gICAgZnVuY3Rpb24gcGlja0J5KGZuLCBtb21lbnRzKSB7XG4gICAgICAgIHZhciByZXMsIGk7XG4gICAgICAgIGlmIChtb21lbnRzLmxlbmd0aCA9PT0gMSAmJiBpc0FycmF5KG1vbWVudHNbMF0pKSB7XG4gICAgICAgICAgICBtb21lbnRzID0gbW9tZW50c1swXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIW1vbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlTG9jYWwoKTtcbiAgICAgICAgfVxuICAgICAgICByZXMgPSBtb21lbnRzWzBdO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgbW9tZW50cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFtb21lbnRzW2ldLmlzVmFsaWQoKSB8fCBtb21lbnRzW2ldW2ZuXShyZXMpKSB7XG4gICAgICAgICAgICAgICAgcmVzID0gbW9tZW50c1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSBbXS5zb3J0IGluc3RlYWQ/XG4gICAgZnVuY3Rpb24gbWluICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBpY2tCeSgnaXNCZWZvcmUnLCBhcmdzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBtYXggKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcblxuICAgICAgICByZXR1cm4gcGlja0J5KCdpc0FmdGVyJywgYXJncyk7XG4gICAgfVxuXG4gICAgdmFyIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIERhdGUubm93ID8gRGF0ZS5ub3coKSA6ICsobmV3IERhdGUoKSk7XG4gICAgfTtcblxuICAgIHZhciBvcmRlcmluZyA9IFsneWVhcicsICdxdWFydGVyJywgJ21vbnRoJywgJ3dlZWsnLCAnZGF5JywgJ2hvdXInLCAnbWludXRlJywgJ3NlY29uZCcsICdtaWxsaXNlY29uZCddO1xuXG4gICAgZnVuY3Rpb24gaXNEdXJhdGlvblZhbGlkKG0pIHtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG0pIHtcbiAgICAgICAgICAgIGlmICghKGluZGV4T2YuY2FsbChvcmRlcmluZywga2V5KSAhPT0gLTEgJiYgKG1ba2V5XSA9PSBudWxsIHx8ICFpc05hTihtW2tleV0pKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pdEhhc0RlY2ltYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlcmluZy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKG1bb3JkZXJpbmdbaV1dKSB7XG4gICAgICAgICAgICAgICAgaWYgKHVuaXRIYXNEZWNpbWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gb25seSBhbGxvdyBub24taW50ZWdlcnMgZm9yIHNtYWxsZXN0IHVuaXRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBhcnNlRmxvYXQobVtvcmRlcmluZ1tpXV0pICE9PSB0b0ludChtW29yZGVyaW5nW2ldXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdW5pdEhhc0RlY2ltYWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzVmFsaWQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlSW52YWxpZCQxKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oTmFOKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBEdXJhdGlvbiAoZHVyYXRpb24pIHtcbiAgICAgICAgdmFyIG5vcm1hbGl6ZWRJbnB1dCA9IG5vcm1hbGl6ZU9iamVjdFVuaXRzKGR1cmF0aW9uKSxcbiAgICAgICAgICAgIHllYXJzID0gbm9ybWFsaXplZElucHV0LnllYXIgfHwgMCxcbiAgICAgICAgICAgIHF1YXJ0ZXJzID0gbm9ybWFsaXplZElucHV0LnF1YXJ0ZXIgfHwgMCxcbiAgICAgICAgICAgIG1vbnRocyA9IG5vcm1hbGl6ZWRJbnB1dC5tb250aCB8fCAwLFxuICAgICAgICAgICAgd2Vla3MgPSBub3JtYWxpemVkSW5wdXQud2VlayB8fCBub3JtYWxpemVkSW5wdXQuaXNvV2VlayB8fCAwLFxuICAgICAgICAgICAgZGF5cyA9IG5vcm1hbGl6ZWRJbnB1dC5kYXkgfHwgMCxcbiAgICAgICAgICAgIGhvdXJzID0gbm9ybWFsaXplZElucHV0LmhvdXIgfHwgMCxcbiAgICAgICAgICAgIG1pbnV0ZXMgPSBub3JtYWxpemVkSW5wdXQubWludXRlIHx8IDAsXG4gICAgICAgICAgICBzZWNvbmRzID0gbm9ybWFsaXplZElucHV0LnNlY29uZCB8fCAwLFxuICAgICAgICAgICAgbWlsbGlzZWNvbmRzID0gbm9ybWFsaXplZElucHV0Lm1pbGxpc2Vjb25kIHx8IDA7XG5cbiAgICAgICAgdGhpcy5faXNWYWxpZCA9IGlzRHVyYXRpb25WYWxpZChub3JtYWxpemVkSW5wdXQpO1xuXG4gICAgICAgIC8vIHJlcHJlc2VudGF0aW9uIGZvciBkYXRlQWRkUmVtb3ZlXG4gICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyA9ICttaWxsaXNlY29uZHMgK1xuICAgICAgICAgICAgc2Vjb25kcyAqIDFlMyArIC8vIDEwMDBcbiAgICAgICAgICAgIG1pbnV0ZXMgKiA2ZTQgKyAvLyAxMDAwICogNjBcbiAgICAgICAgICAgIGhvdXJzICogMTAwMCAqIDYwICogNjA7IC8vdXNpbmcgMTAwMCAqIDYwICogNjAgaW5zdGVhZCBvZiAzNmU1IHRvIGF2b2lkIGZsb2F0aW5nIHBvaW50IHJvdW5kaW5nIGVycm9ycyBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjk3OFxuICAgICAgICAvLyBCZWNhdXNlIG9mIGRhdGVBZGRSZW1vdmUgdHJlYXRzIDI0IGhvdXJzIGFzIGRpZmZlcmVudCBmcm9tIGFcbiAgICAgICAgLy8gZGF5IHdoZW4gd29ya2luZyBhcm91bmQgRFNULCB3ZSBuZWVkIHRvIHN0b3JlIHRoZW0gc2VwYXJhdGVseVxuICAgICAgICB0aGlzLl9kYXlzID0gK2RheXMgK1xuICAgICAgICAgICAgd2Vla3MgKiA3O1xuICAgICAgICAvLyBJdCBpcyBpbXBvc3NpYmxlIHRvIHRyYW5zbGF0ZSBtb250aHMgaW50byBkYXlzIHdpdGhvdXQga25vd2luZ1xuICAgICAgICAvLyB3aGljaCBtb250aHMgeW91IGFyZSBhcmUgdGFsa2luZyBhYm91dCwgc28gd2UgaGF2ZSB0byBzdG9yZVxuICAgICAgICAvLyBpdCBzZXBhcmF0ZWx5LlxuICAgICAgICB0aGlzLl9tb250aHMgPSArbW9udGhzICtcbiAgICAgICAgICAgIHF1YXJ0ZXJzICogMyArXG4gICAgICAgICAgICB5ZWFycyAqIDEyO1xuXG4gICAgICAgIHRoaXMuX2RhdGEgPSB7fTtcblxuICAgICAgICB0aGlzLl9sb2NhbGUgPSBnZXRMb2NhbGUoKTtcblxuICAgICAgICB0aGlzLl9idWJibGUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0R1cmF0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIER1cmF0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFic1JvdW5kIChudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBNYXRoLnJvdW5kKC0xICogbnVtYmVyKSAqIC0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQobnVtYmVyKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGZ1bmN0aW9uIG9mZnNldCAodG9rZW4sIHNlcGFyYXRvcikge1xuICAgICAgICBhZGRGb3JtYXRUb2tlbih0b2tlbiwgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMudXRjT2Zmc2V0KCk7XG4gICAgICAgICAgICB2YXIgc2lnbiA9ICcrJztcbiAgICAgICAgICAgIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLW9mZnNldDtcbiAgICAgICAgICAgICAgICBzaWduID0gJy0nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpZ24gKyB6ZXJvRmlsbCh+fihvZmZzZXQgLyA2MCksIDIpICsgc2VwYXJhdG9yICsgemVyb0ZpbGwofn4ob2Zmc2V0KSAlIDYwLCAyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0KCdaJywgJzonKTtcbiAgICBvZmZzZXQoJ1paJywgJycpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignWicsICBtYXRjaFNob3J0T2Zmc2V0KTtcbiAgICBhZGRSZWdleFRva2VuKCdaWicsIG1hdGNoU2hvcnRPZmZzZXQpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydaJywgJ1paJ10sIGZ1bmN0aW9uIChpbnB1dCwgYXJyYXksIGNvbmZpZykge1xuICAgICAgICBjb25maWcuX3VzZVVUQyA9IHRydWU7XG4gICAgICAgIGNvbmZpZy5fdHptID0gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaFNob3J0T2Zmc2V0LCBpbnB1dCk7XG4gICAgfSk7XG5cbiAgICAvLyBIRUxQRVJTXG5cbiAgICAvLyB0aW1lem9uZSBjaHVua2VyXG4gICAgLy8gJysxMDowMCcgPiBbJzEwJywgICcwMCddXG4gICAgLy8gJy0xNTMwJyAgPiBbJy0xNScsICczMCddXG4gICAgdmFyIGNodW5rT2Zmc2V0ID0gLyhbXFwrXFwtXXxcXGRcXGQpL2dpO1xuXG4gICAgZnVuY3Rpb24gb2Zmc2V0RnJvbVN0cmluZyhtYXRjaGVyLCBzdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAoc3RyaW5nIHx8ICcnKS5tYXRjaChtYXRjaGVyKTtcblxuICAgICAgICBpZiAobWF0Y2hlcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY2h1bmsgICA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXSB8fCBbXTtcbiAgICAgICAgdmFyIHBhcnRzICAgPSAoY2h1bmsgKyAnJykubWF0Y2goY2h1bmtPZmZzZXQpIHx8IFsnLScsIDAsIDBdO1xuICAgICAgICB2YXIgbWludXRlcyA9ICsocGFydHNbMV0gKiA2MCkgKyB0b0ludChwYXJ0c1syXSk7XG5cbiAgICAgICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgP1xuICAgICAgICAgIDAgOlxuICAgICAgICAgIHBhcnRzWzBdID09PSAnKycgPyBtaW51dGVzIDogLW1pbnV0ZXM7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGEgbW9tZW50IGZyb20gaW5wdXQsIHRoYXQgaXMgbG9jYWwvdXRjL3pvbmUgZXF1aXZhbGVudCB0byBtb2RlbC5cbiAgICBmdW5jdGlvbiBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIG1vZGVsKSB7XG4gICAgICAgIHZhciByZXMsIGRpZmY7XG4gICAgICAgIGlmIChtb2RlbC5faXNVVEMpIHtcbiAgICAgICAgICAgIHJlcyA9IG1vZGVsLmNsb25lKCk7XG4gICAgICAgICAgICBkaWZmID0gKGlzTW9tZW50KGlucHV0KSB8fCBpc0RhdGUoaW5wdXQpID8gaW5wdXQudmFsdWVPZigpIDogY3JlYXRlTG9jYWwoaW5wdXQpLnZhbHVlT2YoKSkgLSByZXMudmFsdWVPZigpO1xuICAgICAgICAgICAgLy8gVXNlIGxvdy1sZXZlbCBhcGksIGJlY2F1c2UgdGhpcyBmbiBpcyBsb3ctbGV2ZWwgYXBpLlxuICAgICAgICAgICAgcmVzLl9kLnNldFRpbWUocmVzLl9kLnZhbHVlT2YoKSArIGRpZmYpO1xuICAgICAgICAgICAgaG9va3MudXBkYXRlT2Zmc2V0KHJlcywgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCkubG9jYWwoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldERhdGVPZmZzZXQgKG0pIHtcbiAgICAgICAgLy8gT24gRmlyZWZveC4yNCBEYXRlI2dldFRpbWV6b25lT2Zmc2V0IHJldHVybnMgYSBmbG9hdGluZyBwb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21vbWVudC9tb21lbnQvcHVsbC8xODcxXG4gICAgICAgIHJldHVybiAtTWF0aC5yb3VuZChtLl9kLmdldFRpbWV6b25lT2Zmc2V0KCkgLyAxNSkgKiAxNTtcbiAgICB9XG5cbiAgICAvLyBIT09LU1xuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aGVuZXZlciBhIG1vbWVudCBpcyBtdXRhdGVkLlxuICAgIC8vIEl0IGlzIGludGVuZGVkIHRvIGtlZXAgdGhlIG9mZnNldCBpbiBzeW5jIHdpdGggdGhlIHRpbWV6b25lLlxuICAgIGhvb2tzLnVwZGF0ZU9mZnNldCA9IGZ1bmN0aW9uICgpIHt9O1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgLy8ga2VlcExvY2FsVGltZSA9IHRydWUgbWVhbnMgb25seSBjaGFuZ2UgdGhlIHRpbWV6b25lLCB3aXRob3V0XG4gICAgLy8gYWZmZWN0aW5nIHRoZSBsb2NhbCBob3VyLiBTbyA1OjMxOjI2ICswMzAwIC0tW3V0Y09mZnNldCgyLCB0cnVlKV0tLT5cbiAgICAvLyA1OjMxOjI2ICswMjAwIEl0IGlzIHBvc3NpYmxlIHRoYXQgNTozMToyNiBkb2Vzbid0IGV4aXN0IHdpdGggb2Zmc2V0XG4gICAgLy8gKzAyMDAsIHNvIHdlIGFkanVzdCB0aGUgdGltZSBhcyBuZWVkZWQsIHRvIGJlIHZhbGlkLlxuICAgIC8vXG4gICAgLy8gS2VlcGluZyB0aGUgdGltZSBhY3R1YWxseSBhZGRzL3N1YnRyYWN0cyAob25lIGhvdXIpXG4gICAgLy8gZnJvbSB0aGUgYWN0dWFsIHJlcHJlc2VudGVkIHRpbWUuIFRoYXQgaXMgd2h5IHdlIGNhbGwgdXBkYXRlT2Zmc2V0XG4gICAgLy8gYSBzZWNvbmQgdGltZS4gSW4gY2FzZSBpdCB3YW50cyB1cyB0byBjaGFuZ2UgdGhlIG9mZnNldCBhZ2FpblxuICAgIC8vIF9jaGFuZ2VJblByb2dyZXNzID09IHRydWUgY2FzZSwgdGhlbiB3ZSBoYXZlIHRvIGFkanVzdCwgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIG5vIHN1Y2ggdGltZSBpbiB0aGUgZ2l2ZW4gdGltZXpvbmUuXG4gICAgZnVuY3Rpb24gZ2V0U2V0T2Zmc2V0IChpbnB1dCwga2VlcExvY2FsVGltZSwga2VlcE1pbnV0ZXMpIHtcbiAgICAgICAgdmFyIG9mZnNldCA9IHRoaXMuX29mZnNldCB8fCAwLFxuICAgICAgICAgICAgbG9jYWxBZGp1c3Q7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dCAhPSBudWxsID8gdGhpcyA6IE5hTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5wdXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hTaG9ydE9mZnNldCwgaW5wdXQpO1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKE1hdGguYWJzKGlucHV0KSA8IDE2ICYmICFrZWVwTWludXRlcykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gaW5wdXQgKiA2MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5faXNVVEMgJiYga2VlcExvY2FsVGltZSkge1xuICAgICAgICAgICAgICAgIGxvY2FsQWRqdXN0ID0gZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX29mZnNldCA9IGlucHV0O1xuICAgICAgICAgICAgdGhpcy5faXNVVEMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGxvY2FsQWRqdXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZChsb2NhbEFkanVzdCwgJ20nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvZmZzZXQgIT09IGlucHV0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFrZWVwTG9jYWxUaW1lIHx8IHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkU3VidHJhY3QodGhpcywgY3JlYXRlRHVyYXRpb24oaW5wdXQgLSBvZmZzZXQsICdtJyksIDEsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jaGFuZ2VJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NoYW5nZUluUHJvZ3Jlc3MgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gb2Zmc2V0IDogZ2V0RGF0ZU9mZnNldCh0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFpvbmUgKGlucHV0LCBrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgIGlmIChpbnB1dCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlucHV0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gLWlucHV0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldChpbnB1dCwga2VlcExvY2FsVGltZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIC10aGlzLnV0Y09mZnNldCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2V0T2Zmc2V0VG9VVEMgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXRjT2Zmc2V0KDAsIGtlZXBMb2NhbFRpbWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvTG9jYWwgKGtlZXBMb2NhbFRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzVVRDKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCBrZWVwTG9jYWxUaW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2lzVVRDID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChrZWVwTG9jYWxUaW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJ0cmFjdChnZXREYXRlT2Zmc2V0KHRoaXMpLCAnbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0ICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3R6bSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0aGlzLl90em0sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5faSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhciB0Wm9uZSA9IG9mZnNldEZyb21TdHJpbmcobWF0Y2hPZmZzZXQsIHRoaXMuX2kpO1xuICAgICAgICAgICAgaWYgKHRab25lICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCh0Wm9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnV0Y09mZnNldCgwLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBoYXNBbGlnbmVkSG91ck9mZnNldCAoaW5wdXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0ID0gaW5wdXQgPyBjcmVhdGVMb2NhbChpbnB1dCkudXRjT2Zmc2V0KCkgOiAwO1xuXG4gICAgICAgIHJldHVybiAodGhpcy51dGNPZmZzZXQoKSAtIGlucHV0KSAlIDYwID09PSAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzRGF5bGlnaHRTYXZpbmdUaW1lICgpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoMCkudXRjT2Zmc2V0KCkgfHxcbiAgICAgICAgICAgIHRoaXMudXRjT2Zmc2V0KCkgPiB0aGlzLmNsb25lKCkubW9udGgoNSkudXRjT2Zmc2V0KClcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0RheWxpZ2h0U2F2aW5nVGltZVNoaWZ0ZWQgKCkge1xuICAgICAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX2lzRFNUU2hpZnRlZCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pc0RTVFNoaWZ0ZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgYyA9IHt9O1xuXG4gICAgICAgIGNvcHlDb25maWcoYywgdGhpcyk7XG4gICAgICAgIGMgPSBwcmVwYXJlQ29uZmlnKGMpO1xuXG4gICAgICAgIGlmIChjLl9hKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXIgPSBjLl9pc1VUQyA/IGNyZWF0ZVVUQyhjLl9hKSA6IGNyZWF0ZUxvY2FsKGMuX2EpO1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gdGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICBjb21wYXJlQXJyYXlzKGMuX2EsIG90aGVyLnRvQXJyYXkoKSkgPiAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faXNEU1RTaGlmdGVkID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcy5faXNEU1RTaGlmdGVkO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzTG9jYWwgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyAhdGhpcy5faXNVVEMgOiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1V0Y09mZnNldCAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMuX2lzVVRDIDogZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNVdGMgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzLl9pc1VUQyAmJiB0aGlzLl9vZmZzZXQgPT09IDAgOiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBBU1AuTkVUIGpzb24gZGF0ZSBmb3JtYXQgcmVnZXhcbiAgICB2YXIgYXNwTmV0UmVnZXggPSAvXihcXC18XFwrKT8oPzooXFxkKilbLiBdKT8oXFxkKylcXDooXFxkKykoPzpcXDooXFxkKykoXFwuXFxkKik/KT8kLztcblxuICAgIC8vIGZyb20gaHR0cDovL2RvY3MuY2xvc3VyZS1saWJyYXJ5Lmdvb2dsZWNvZGUuY29tL2dpdC9jbG9zdXJlX2dvb2dfZGF0ZV9kYXRlLmpzLnNvdXJjZS5odG1sXG4gICAgLy8gc29tZXdoYXQgbW9yZSBpbiBsaW5lIHdpdGggNC40LjMuMiAyMDA0IHNwZWMsIGJ1dCBhbGxvd3MgZGVjaW1hbCBhbnl3aGVyZVxuICAgIC8vIGFuZCBmdXJ0aGVyIG1vZGlmaWVkIHRvIGFsbG93IGZvciBzdHJpbmdzIGNvbnRhaW5pbmcgYm90aCB3ZWVrIGFuZCBkYXlcbiAgICB2YXIgaXNvUmVnZXggPSAvXigtfFxcKyk/UCg/OihbLStdP1swLTksLl0qKVkpPyg/OihbLStdP1swLTksLl0qKU0pPyg/OihbLStdP1swLTksLl0qKVcpPyg/OihbLStdP1swLTksLl0qKUQpPyg/OlQoPzooWy0rXT9bMC05LC5dKilIKT8oPzooWy0rXT9bMC05LC5dKilNKT8oPzooWy0rXT9bMC05LC5dKilTKT8pPyQvO1xuXG4gICAgZnVuY3Rpb24gY3JlYXRlRHVyYXRpb24gKGlucHV0LCBrZXkpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gaW5wdXQsXG4gICAgICAgICAgICAvLyBtYXRjaGluZyBhZ2FpbnN0IHJlZ2V4cCBpcyBleHBlbnNpdmUsIGRvIGl0IG9uIGRlbWFuZFxuICAgICAgICAgICAgbWF0Y2ggPSBudWxsLFxuICAgICAgICAgICAgc2lnbixcbiAgICAgICAgICAgIHJldCxcbiAgICAgICAgICAgIGRpZmZSZXM7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBtcyA6IGlucHV0Ll9taWxsaXNlY29uZHMsXG4gICAgICAgICAgICAgICAgZCAgOiBpbnB1dC5fZGF5cyxcbiAgICAgICAgICAgICAgICBNICA6IGlucHV0Ll9tb250aHNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoaXNOdW1iZXIoaW5wdXQpKSB7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgaWYgKGtleSkge1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uW2tleV0gPSBpbnB1dDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24ubWlsbGlzZWNvbmRzID0gaW5wdXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBhc3BOZXRSZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5ICA6IDAsXG4gICAgICAgICAgICAgICAgZCAgOiB0b0ludChtYXRjaFtEQVRFXSkgICAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIGggIDogdG9JbnQobWF0Y2hbSE9VUl0pICAgICAgICAgICAgICAgICAgICAgICAgICogc2lnbixcbiAgICAgICAgICAgICAgICBtICA6IHRvSW50KG1hdGNoW01JTlVURV0pICAgICAgICAgICAgICAgICAgICAgICAqIHNpZ24sXG4gICAgICAgICAgICAgICAgcyAgOiB0b0ludChtYXRjaFtTRUNPTkRdKSAgICAgICAgICAgICAgICAgICAgICAgKiBzaWduLFxuICAgICAgICAgICAgICAgIG1zIDogdG9JbnQoYWJzUm91bmQobWF0Y2hbTUlMTElTRUNPTkRdICogMTAwMCkpICogc2lnbiAvLyB0aGUgbWlsbGlzZWNvbmQgZGVjaW1hbCBwb2ludCBpcyBpbmNsdWRlZCBpbiB0aGUgbWF0Y2hcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSBpZiAoISEobWF0Y2ggPSBpc29SZWdleC5leGVjKGlucHV0KSkpIHtcbiAgICAgICAgICAgIHNpZ24gPSAobWF0Y2hbMV0gPT09ICctJykgPyAtMSA6IDE7XG4gICAgICAgICAgICBkdXJhdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB5IDogcGFyc2VJc28obWF0Y2hbMl0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIE0gOiBwYXJzZUlzbyhtYXRjaFszXSwgc2lnbiksXG4gICAgICAgICAgICAgICAgdyA6IHBhcnNlSXNvKG1hdGNoWzRdLCBzaWduKSxcbiAgICAgICAgICAgICAgICBkIDogcGFyc2VJc28obWF0Y2hbNV0sIHNpZ24pLFxuICAgICAgICAgICAgICAgIGggOiBwYXJzZUlzbyhtYXRjaFs2XSwgc2lnbiksXG4gICAgICAgICAgICAgICAgbSA6IHBhcnNlSXNvKG1hdGNoWzddLCBzaWduKSxcbiAgICAgICAgICAgICAgICBzIDogcGFyc2VJc28obWF0Y2hbOF0sIHNpZ24pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2UgaWYgKGR1cmF0aW9uID09IG51bGwpIHsvLyBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkdXJhdGlvbiA9PT0gJ29iamVjdCcgJiYgKCdmcm9tJyBpbiBkdXJhdGlvbiB8fCAndG8nIGluIGR1cmF0aW9uKSkge1xuICAgICAgICAgICAgZGlmZlJlcyA9IG1vbWVudHNEaWZmZXJlbmNlKGNyZWF0ZUxvY2FsKGR1cmF0aW9uLmZyb20pLCBjcmVhdGVMb2NhbChkdXJhdGlvbi50bykpO1xuXG4gICAgICAgICAgICBkdXJhdGlvbiA9IHt9O1xuICAgICAgICAgICAgZHVyYXRpb24ubXMgPSBkaWZmUmVzLm1pbGxpc2Vjb25kcztcbiAgICAgICAgICAgIGR1cmF0aW9uLk0gPSBkaWZmUmVzLm1vbnRocztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldCA9IG5ldyBEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgICAgICAgaWYgKGlzRHVyYXRpb24oaW5wdXQpICYmIGhhc093blByb3AoaW5wdXQsICdfbG9jYWxlJykpIHtcbiAgICAgICAgICAgIHJldC5fbG9jYWxlID0gaW5wdXQuX2xvY2FsZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgY3JlYXRlRHVyYXRpb24uZm4gPSBEdXJhdGlvbi5wcm90b3R5cGU7XG4gICAgY3JlYXRlRHVyYXRpb24uaW52YWxpZCA9IGNyZWF0ZUludmFsaWQkMTtcblxuICAgIGZ1bmN0aW9uIHBhcnNlSXNvIChpbnAsIHNpZ24pIHtcbiAgICAgICAgLy8gV2UnZCBub3JtYWxseSB1c2Ugfn5pbnAgZm9yIHRoaXMsIGJ1dCB1bmZvcnR1bmF0ZWx5IGl0IGFsc29cbiAgICAgICAgLy8gY29udmVydHMgZmxvYXRzIHRvIGludHMuXG4gICAgICAgIC8vIGlucCBtYXkgYmUgdW5kZWZpbmVkLCBzbyBjYXJlZnVsIGNhbGxpbmcgcmVwbGFjZSBvbiBpdC5cbiAgICAgICAgdmFyIHJlcyA9IGlucCAmJiBwYXJzZUZsb2F0KGlucC5yZXBsYWNlKCcsJywgJy4nKSk7XG4gICAgICAgIC8vIGFwcGx5IHNpZ24gd2hpbGUgd2UncmUgYXQgaXRcbiAgICAgICAgcmV0dXJuIChpc05hTihyZXMpID8gMCA6IHJlcykgKiBzaWduO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlcyA9IHt9O1xuXG4gICAgICAgIHJlcy5tb250aHMgPSBvdGhlci5tb250aCgpIC0gYmFzZS5tb250aCgpICtcbiAgICAgICAgICAgIChvdGhlci55ZWFyKCkgLSBiYXNlLnllYXIoKSkgKiAxMjtcbiAgICAgICAgaWYgKGJhc2UuY2xvbmUoKS5hZGQocmVzLm1vbnRocywgJ00nKS5pc0FmdGVyKG90aGVyKSkge1xuICAgICAgICAgICAgLS1yZXMubW9udGhzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzLm1pbGxpc2Vjb25kcyA9ICtvdGhlciAtICsoYmFzZS5jbG9uZSgpLmFkZChyZXMubW9udGhzLCAnTScpKTtcblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbWVudHNEaWZmZXJlbmNlKGJhc2UsIG90aGVyKSB7XG4gICAgICAgIHZhciByZXM7XG4gICAgICAgIGlmICghKGJhc2UuaXNWYWxpZCgpICYmIG90aGVyLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiB7bWlsbGlzZWNvbmRzOiAwLCBtb250aHM6IDB9O1xuICAgICAgICB9XG5cbiAgICAgICAgb3RoZXIgPSBjbG9uZVdpdGhPZmZzZXQob3RoZXIsIGJhc2UpO1xuICAgICAgICBpZiAoYmFzZS5pc0JlZm9yZShvdGhlcikpIHtcbiAgICAgICAgICAgIHJlcyA9IHBvc2l0aXZlTW9tZW50c0RpZmZlcmVuY2UoYmFzZSwgb3RoZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzID0gcG9zaXRpdmVNb21lbnRzRGlmZmVyZW5jZShvdGhlciwgYmFzZSk7XG4gICAgICAgICAgICByZXMubWlsbGlzZWNvbmRzID0gLXJlcy5taWxsaXNlY29uZHM7XG4gICAgICAgICAgICByZXMubW9udGhzID0gLXJlcy5tb250aHM7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIC8vIFRPRE86IHJlbW92ZSAnbmFtZScgYXJnIGFmdGVyIGRlcHJlY2F0aW9uIGlzIHJlbW92ZWRcbiAgICBmdW5jdGlvbiBjcmVhdGVBZGRlcihkaXJlY3Rpb24sIG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwsIHBlcmlvZCkge1xuICAgICAgICAgICAgdmFyIGR1ciwgdG1wO1xuICAgICAgICAgICAgLy9pbnZlcnQgdGhlIGFyZ3VtZW50cywgYnV0IGNvbXBsYWluIGFib3V0IGl0XG4gICAgICAgICAgICBpZiAocGVyaW9kICE9PSBudWxsICYmICFpc05hTigrcGVyaW9kKSkge1xuICAgICAgICAgICAgICAgIGRlcHJlY2F0ZVNpbXBsZShuYW1lLCAnbW9tZW50KCkuJyArIG5hbWUgICsgJyhwZXJpb2QsIG51bWJlcikgaXMgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBtb21lbnQoKS4nICsgbmFtZSArICcobnVtYmVyLCBwZXJpb2QpLiAnICtcbiAgICAgICAgICAgICAgICAnU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvYWRkLWludmVydGVkLXBhcmFtLyBmb3IgbW9yZSBpbmZvLicpO1xuICAgICAgICAgICAgICAgIHRtcCA9IHZhbDsgdmFsID0gcGVyaW9kOyBwZXJpb2QgPSB0bXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhbCA9IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnID8gK3ZhbCA6IHZhbDtcbiAgICAgICAgICAgIGR1ciA9IGNyZWF0ZUR1cmF0aW9uKHZhbCwgcGVyaW9kKTtcbiAgICAgICAgICAgIGFkZFN1YnRyYWN0KHRoaXMsIGR1ciwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZFN1YnRyYWN0IChtb20sIGR1cmF0aW9uLCBpc0FkZGluZywgdXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgIHZhciBtaWxsaXNlY29uZHMgPSBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzLFxuICAgICAgICAgICAgZGF5cyA9IGFic1JvdW5kKGR1cmF0aW9uLl9kYXlzKSxcbiAgICAgICAgICAgIG1vbnRocyA9IGFic1JvdW5kKGR1cmF0aW9uLl9tb250aHMpO1xuXG4gICAgICAgIGlmICghbW9tLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgLy8gTm8gb3BcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZU9mZnNldCA9IHVwZGF0ZU9mZnNldCA9PSBudWxsID8gdHJ1ZSA6IHVwZGF0ZU9mZnNldDtcblxuICAgICAgICBpZiAobW9udGhzKSB7XG4gICAgICAgICAgICBzZXRNb250aChtb20sIGdldChtb20sICdNb250aCcpICsgbW9udGhzICogaXNBZGRpbmcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXlzKSB7XG4gICAgICAgICAgICBzZXQkMShtb20sICdEYXRlJywgZ2V0KG1vbSwgJ0RhdGUnKSArIGRheXMgKiBpc0FkZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1pbGxpc2Vjb25kcykge1xuICAgICAgICAgICAgbW9tLl9kLnNldFRpbWUobW9tLl9kLnZhbHVlT2YoKSArIG1pbGxpc2Vjb25kcyAqIGlzQWRkaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodXBkYXRlT2Zmc2V0KSB7XG4gICAgICAgICAgICBob29rcy51cGRhdGVPZmZzZXQobW9tLCBkYXlzIHx8IG1vbnRocyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgYWRkICAgICAgPSBjcmVhdGVBZGRlcigxLCAnYWRkJyk7XG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlQWRkZXIoLTEsICdzdWJ0cmFjdCcpO1xuXG4gICAgZnVuY3Rpb24gZ2V0Q2FsZW5kYXJGb3JtYXQobXlNb21lbnQsIG5vdykge1xuICAgICAgICB2YXIgZGlmZiA9IG15TW9tZW50LmRpZmYobm93LCAnZGF5cycsIHRydWUpO1xuICAgICAgICByZXR1cm4gZGlmZiA8IC02ID8gJ3NhbWVFbHNlJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IC0xID8gJ2xhc3RXZWVrJyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDAgPyAnbGFzdERheScgOlxuICAgICAgICAgICAgICAgIGRpZmYgPCAxID8gJ3NhbWVEYXknIDpcbiAgICAgICAgICAgICAgICBkaWZmIDwgMiA/ICduZXh0RGF5JyA6XG4gICAgICAgICAgICAgICAgZGlmZiA8IDcgPyAnbmV4dFdlZWsnIDogJ3NhbWVFbHNlJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYWxlbmRhciQxICh0aW1lLCBmb3JtYXRzKSB7XG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY29tcGFyZSB0aGUgc3RhcnQgb2YgdG9kYXksIHZzIHRoaXMuXG4gICAgICAgIC8vIEdldHRpbmcgc3RhcnQtb2YtdG9kYXkgZGVwZW5kcyBvbiB3aGV0aGVyIHdlJ3JlIGxvY2FsL3V0Yy9vZmZzZXQgb3Igbm90LlxuICAgICAgICB2YXIgbm93ID0gdGltZSB8fCBjcmVhdGVMb2NhbCgpLFxuICAgICAgICAgICAgc29kID0gY2xvbmVXaXRoT2Zmc2V0KG5vdywgdGhpcykuc3RhcnRPZignZGF5JyksXG4gICAgICAgICAgICBmb3JtYXQgPSBob29rcy5jYWxlbmRhckZvcm1hdCh0aGlzLCBzb2QpIHx8ICdzYW1lRWxzZSc7XG5cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdHMgJiYgKGlzRnVuY3Rpb24oZm9ybWF0c1tmb3JtYXRdKSA/IGZvcm1hdHNbZm9ybWF0XS5jYWxsKHRoaXMsIG5vdykgOiBmb3JtYXRzW2Zvcm1hdF0pO1xuXG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdChvdXRwdXQgfHwgdGhpcy5sb2NhbGVEYXRhKCkuY2FsZW5kYXIoZm9ybWF0LCB0aGlzLCBjcmVhdGVMb2NhbChub3cpKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgICAgICByZXR1cm4gbmV3IE1vbWVudCh0aGlzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0FmdGVyIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KTtcbiAgICAgICAgaWYgKCEodGhpcy5pc1ZhbGlkKCkgJiYgbG9jYWxJbnB1dC5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cykgfHwgJ21pbGxpc2Vjb25kJztcbiAgICAgICAgaWYgKHVuaXRzID09PSAnbWlsbGlzZWNvbmQnKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52YWx1ZU9mKCkgPiBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBsb2NhbElucHV0LnZhbHVlT2YoKSA8IHRoaXMuY2xvbmUoKS5zdGFydE9mKHVuaXRzKS52YWx1ZU9mKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc0JlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHZhciBsb2NhbElucHV0ID0gaXNNb21lbnQoaW5wdXQpID8gaW5wdXQgOiBjcmVhdGVMb2NhbChpbnB1dCk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpIDwgbG9jYWxJbnB1dC52YWx1ZU9mKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmVuZE9mKHVuaXRzKS52YWx1ZU9mKCkgPCBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzQmV0d2VlbiAoZnJvbSwgdG8sIHVuaXRzLCBpbmNsdXNpdml0eSkge1xuICAgICAgICB2YXIgbG9jYWxGcm9tID0gaXNNb21lbnQoZnJvbSkgPyBmcm9tIDogY3JlYXRlTG9jYWwoZnJvbSksXG4gICAgICAgICAgICBsb2NhbFRvID0gaXNNb21lbnQodG8pID8gdG8gOiBjcmVhdGVMb2NhbCh0byk7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsRnJvbS5pc1ZhbGlkKCkgJiYgbG9jYWxUby5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaW5jbHVzaXZpdHkgPSBpbmNsdXNpdml0eSB8fCAnKCknO1xuICAgICAgICByZXR1cm4gKGluY2x1c2l2aXR5WzBdID09PSAnKCcgPyB0aGlzLmlzQWZ0ZXIobG9jYWxGcm9tLCB1bml0cykgOiAhdGhpcy5pc0JlZm9yZShsb2NhbEZyb20sIHVuaXRzKSkgJiZcbiAgICAgICAgICAgIChpbmNsdXNpdml0eVsxXSA9PT0gJyknID8gdGhpcy5pc0JlZm9yZShsb2NhbFRvLCB1bml0cykgOiAhdGhpcy5pc0FmdGVyKGxvY2FsVG8sIHVuaXRzKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNTYW1lIChpbnB1dCwgdW5pdHMpIHtcbiAgICAgICAgdmFyIGxvY2FsSW5wdXQgPSBpc01vbWVudChpbnB1dCkgPyBpbnB1dCA6IGNyZWF0ZUxvY2FsKGlucHV0KSxcbiAgICAgICAgICAgIGlucHV0TXM7XG4gICAgICAgIGlmICghKHRoaXMuaXNWYWxpZCgpICYmIGxvY2FsSW5wdXQuaXNWYWxpZCgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpIHx8ICdtaWxsaXNlY29uZCc7XG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21pbGxpc2Vjb25kJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVPZigpID09PSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlucHV0TXMgPSBsb2NhbElucHV0LnZhbHVlT2YoKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNsb25lKCkuc3RhcnRPZih1bml0cykudmFsdWVPZigpIDw9IGlucHV0TXMgJiYgaW5wdXRNcyA8PSB0aGlzLmNsb25lKCkuZW5kT2YodW5pdHMpLnZhbHVlT2YoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGlzU2FtZU9yQWZ0ZXIgKGlucHV0LCB1bml0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1NhbWUoaW5wdXQsIHVuaXRzKSB8fCB0aGlzLmlzQWZ0ZXIoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpc1NhbWVPckJlZm9yZSAoaW5wdXQsIHVuaXRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzU2FtZShpbnB1dCwgdW5pdHMpIHx8IHRoaXMuaXNCZWZvcmUoaW5wdXQsIHVuaXRzKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBkaWZmIChpbnB1dCwgdW5pdHMsIGFzRmxvYXQpIHtcbiAgICAgICAgdmFyIHRoYXQsXG4gICAgICAgICAgICB6b25lRGVsdGEsXG4gICAgICAgICAgICBvdXRwdXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoYXQgPSBjbG9uZVdpdGhPZmZzZXQoaW5wdXQsIHRoaXMpO1xuXG4gICAgICAgIGlmICghdGhhdC5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cblxuICAgICAgICB6b25lRGVsdGEgPSAodGhhdC51dGNPZmZzZXQoKSAtIHRoaXMudXRjT2Zmc2V0KCkpICogNmU0O1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOiBvdXRwdXQgPSBtb250aERpZmYodGhpcywgdGhhdCkgLyAxMjsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6IG91dHB1dCA9IG1vbnRoRGlmZih0aGlzLCB0aGF0KTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzogb3V0cHV0ID0gbW9udGhEaWZmKHRoaXMsIHRoYXQpIC8gMzsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQpIC8gMWUzOyBicmVhazsgLy8gMTAwMFxuICAgICAgICAgICAgY2FzZSAnbWludXRlJzogb3V0cHV0ID0gKHRoaXMgLSB0aGF0KSAvIDZlNDsgYnJlYWs7IC8vIDEwMDAgKiA2MFxuICAgICAgICAgICAgY2FzZSAnaG91cic6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCkgLyAzNmU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjBcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6IG91dHB1dCA9ICh0aGlzIC0gdGhhdCAtIHpvbmVEZWx0YSkgLyA4NjRlNTsgYnJlYWs7IC8vIDEwMDAgKiA2MCAqIDYwICogMjQsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOiBvdXRwdXQgPSAodGhpcyAtIHRoYXQgLSB6b25lRGVsdGEpIC8gNjA0OGU1OyBicmVhazsgLy8gMTAwMCAqIDYwICogNjAgKiAyNCAqIDcsIG5lZ2F0ZSBkc3RcbiAgICAgICAgICAgIGRlZmF1bHQ6IG91dHB1dCA9IHRoaXMgLSB0aGF0O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGFzRmxvYXQgPyBvdXRwdXQgOiBhYnNGbG9vcihvdXRwdXQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vbnRoRGlmZiAoYSwgYikge1xuICAgICAgICAvLyBkaWZmZXJlbmNlIGluIG1vbnRoc1xuICAgICAgICB2YXIgd2hvbGVNb250aERpZmYgPSAoKGIueWVhcigpIC0gYS55ZWFyKCkpICogMTIpICsgKGIubW9udGgoKSAtIGEubW9udGgoKSksXG4gICAgICAgICAgICAvLyBiIGlzIGluIChhbmNob3IgLSAxIG1vbnRoLCBhbmNob3IgKyAxIG1vbnRoKVxuICAgICAgICAgICAgYW5jaG9yID0gYS5jbG9uZSgpLmFkZCh3aG9sZU1vbnRoRGlmZiwgJ21vbnRocycpLFxuICAgICAgICAgICAgYW5jaG9yMiwgYWRqdXN0O1xuXG4gICAgICAgIGlmIChiIC0gYW5jaG9yIDwgMCkge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgLSAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvciAtIGFuY2hvcjIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5jaG9yMiA9IGEuY2xvbmUoKS5hZGQod2hvbGVNb250aERpZmYgKyAxLCAnbW9udGhzJyk7XG4gICAgICAgICAgICAvLyBsaW5lYXIgYWNyb3NzIHRoZSBtb250aFxuICAgICAgICAgICAgYWRqdXN0ID0gKGIgLSBhbmNob3IpIC8gKGFuY2hvcjIgLSBhbmNob3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9jaGVjayBmb3IgbmVnYXRpdmUgemVybywgcmV0dXJuIHplcm8gaWYgbmVnYXRpdmUgemVyb1xuICAgICAgICByZXR1cm4gLSh3aG9sZU1vbnRoRGlmZiArIGFkanVzdCkgfHwgMDtcbiAgICB9XG5cbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0ID0gJ1lZWVktTU0tRERUSEg6bW06c3NaJztcbiAgICBob29rcy5kZWZhdWx0Rm9ybWF0VXRjID0gJ1lZWVktTU0tRERUSEg6bW06c3NbWl0nO1xuXG4gICAgZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmxvY2FsZSgnZW4nKS5mb3JtYXQoJ2RkZCBNTU0gREQgWVlZWSBISDptbTpzcyBbR01UXVpaJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9JU09TdHJpbmcoa2VlcE9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdXRjID0ga2VlcE9mZnNldCAhPT0gdHJ1ZTtcbiAgICAgICAgdmFyIG0gPSB1dGMgPyB0aGlzLmNsb25lKCkudXRjKCkgOiB0aGlzO1xuICAgICAgICBpZiAobS55ZWFyKCkgPCAwIHx8IG0ueWVhcigpID4gOTk5OSkge1xuICAgICAgICAgICAgcmV0dXJuIGZvcm1hdE1vbWVudChtLCB1dGMgPyAnWVlZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZWVktTU0tRERbVF1ISDptbTpzcy5TU1NaJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRnVuY3Rpb24oRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmcpKSB7XG4gICAgICAgICAgICAvLyBuYXRpdmUgaW1wbGVtZW50YXRpb24gaXMgfjUweCBmYXN0ZXIsIHVzZSBpdCB3aGVuIHdlIGNhblxuICAgICAgICAgICAgaWYgKHV0Yykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRvRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSArIHRoaXMudXRjT2Zmc2V0KCkgKiA2MCAqIDEwMDApLnRvSVNPU3RyaW5nKCkucmVwbGFjZSgnWicsIGZvcm1hdE1vbWVudChtLCAnWicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm9ybWF0TW9tZW50KG0sIHV0YyA/ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTW1pdJyA6ICdZWVlZLU1NLUREW1RdSEg6bW06c3MuU1NTWicpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGh1bWFuIHJlYWRhYmxlIHJlcHJlc2VudGF0aW9uIG9mIGEgbW9tZW50IHRoYXQgY2FuXG4gICAgICogYWxzbyBiZSBldmFsdWF0ZWQgdG8gZ2V0IGEgbmV3IG1vbWVudCB3aGljaCBpcyB0aGUgc2FtZVxuICAgICAqXG4gICAgICogQGxpbmsgaHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvbGF0ZXN0L2RvY3MvYXBpL3V0aWwuaHRtbCN1dGlsX2N1c3RvbV9pbnNwZWN0X2Z1bmN0aW9uX29uX29iamVjdHNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuICdtb21lbnQuaW52YWxpZCgvKiAnICsgdGhpcy5faSArICcgKi8pJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgZnVuYyA9ICdtb21lbnQnO1xuICAgICAgICB2YXIgem9uZSA9ICcnO1xuICAgICAgICBpZiAoIXRoaXMuaXNMb2NhbCgpKSB7XG4gICAgICAgICAgICBmdW5jID0gdGhpcy51dGNPZmZzZXQoKSA9PT0gMCA/ICdtb21lbnQudXRjJyA6ICdtb21lbnQucGFyc2Vab25lJztcbiAgICAgICAgICAgIHpvbmUgPSAnWic7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZWZpeCA9ICdbJyArIGZ1bmMgKyAnKFwiXSc7XG4gICAgICAgIHZhciB5ZWFyID0gKDAgPD0gdGhpcy55ZWFyKCkgJiYgdGhpcy55ZWFyKCkgPD0gOTk5OSkgPyAnWVlZWScgOiAnWVlZWVlZJztcbiAgICAgICAgdmFyIGRhdGV0aW1lID0gJy1NTS1ERFtUXUhIOm1tOnNzLlNTUyc7XG4gICAgICAgIHZhciBzdWZmaXggPSB6b25lICsgJ1tcIildJztcblxuICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXQocHJlZml4ICsgeWVhciArIGRhdGV0aW1lICsgc3VmZml4KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXQgKGlucHV0U3RyaW5nKSB7XG4gICAgICAgIGlmICghaW5wdXRTdHJpbmcpIHtcbiAgICAgICAgICAgIGlucHV0U3RyaW5nID0gdGhpcy5pc1V0YygpID8gaG9va3MuZGVmYXVsdEZvcm1hdFV0YyA6IGhvb2tzLmRlZmF1bHRGb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG91dHB1dCA9IGZvcm1hdE1vbWVudCh0aGlzLCBpbnB1dFN0cmluZyk7XG4gICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5wb3N0Zm9ybWF0KG91dHB1dCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbSAodGltZSwgd2l0aG91dFN1ZmZpeCkge1xuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKCkgJiZcbiAgICAgICAgICAgICAgICAoKGlzTW9tZW50KHRpbWUpICYmIHRpbWUuaXNWYWxpZCgpKSB8fFxuICAgICAgICAgICAgICAgICBjcmVhdGVMb2NhbCh0aW1lKS5pc1ZhbGlkKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24oe3RvOiB0aGlzLCBmcm9tOiB0aW1lfSkubG9jYWxlKHRoaXMubG9jYWxlKCkpLmh1bWFuaXplKCF3aXRob3V0U3VmZml4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKS5pbnZhbGlkRGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZnJvbU5vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tKGNyZWF0ZUxvY2FsKCksIHdpdGhvdXRTdWZmaXgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvICh0aW1lLCB3aXRob3V0U3VmZml4KSB7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQoKSAmJlxuICAgICAgICAgICAgICAgICgoaXNNb21lbnQodGltZSkgJiYgdGltZS5pc1ZhbGlkKCkpIHx8XG4gICAgICAgICAgICAgICAgIGNyZWF0ZUxvY2FsKHRpbWUpLmlzVmFsaWQoKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVEdXJhdGlvbih7ZnJvbTogdGhpcywgdG86IHRpbWV9KS5sb2NhbGUodGhpcy5sb2NhbGUoKSkuaHVtYW5pemUoIXdpdGhvdXRTdWZmaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlRGF0YSgpLmludmFsaWREYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b05vdyAod2l0aG91dFN1ZmZpeCkge1xuICAgICAgICByZXR1cm4gdGhpcy50byhjcmVhdGVMb2NhbCgpLCB3aXRob3V0U3VmZml4KTtcbiAgICB9XG5cbiAgICAvLyBJZiBwYXNzZWQgYSBsb2NhbGUga2V5LCBpdCB3aWxsIHNldCB0aGUgbG9jYWxlIGZvciB0aGlzXG4gICAgLy8gaW5zdGFuY2UuICBPdGhlcndpc2UsIGl0IHdpbGwgcmV0dXJuIHRoZSBsb2NhbGUgY29uZmlndXJhdGlvblxuICAgIC8vIHZhcmlhYmxlcyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICBmdW5jdGlvbiBsb2NhbGUgKGtleSkge1xuICAgICAgICB2YXIgbmV3TG9jYWxlRGF0YTtcblxuICAgICAgICBpZiAoa2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGUuX2FiYnI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMb2NhbGVEYXRhID0gZ2V0TG9jYWxlKGtleSk7XG4gICAgICAgICAgICBpZiAobmV3TG9jYWxlRGF0YSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbG9jYWxlID0gbmV3TG9jYWxlRGF0YTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGxhbmcgPSBkZXByZWNhdGUoXG4gICAgICAgICdtb21lbnQoKS5sYW5nKCkgaXMgZGVwcmVjYXRlZC4gSW5zdGVhZCwgdXNlIG1vbWVudCgpLmxvY2FsZURhdGEoKSB0byBnZXQgdGhlIGxhbmd1YWdlIGNvbmZpZ3VyYXRpb24uIFVzZSBtb21lbnQoKS5sb2NhbGUoKSB0byBjaGFuZ2UgbGFuZ3VhZ2VzLicsXG4gICAgICAgIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xuXG4gICAgZnVuY3Rpb24gbG9jYWxlRGF0YSAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbGU7XG4gICAgfVxuXG4gICAgdmFyIE1TX1BFUl9TRUNPTkQgPSAxMDAwO1xuICAgIHZhciBNU19QRVJfTUlOVVRFID0gNjAgKiBNU19QRVJfU0VDT05EO1xuICAgIHZhciBNU19QRVJfSE9VUiA9IDYwICogTVNfUEVSX01JTlVURTtcbiAgICB2YXIgTVNfUEVSXzQwMF9ZRUFSUyA9ICgzNjUgKiA0MDAgKyA5NykgKiAyNCAqIE1TX1BFUl9IT1VSO1xuXG4gICAgLy8gYWN0dWFsIG1vZHVsbyAtIGhhbmRsZXMgbmVnYXRpdmUgbnVtYmVycyAoZm9yIGRhdGVzIGJlZm9yZSAxOTcwKTpcbiAgICBmdW5jdGlvbiBtb2QkMShkaXZpZGVuZCwgZGl2aXNvcikge1xuICAgICAgICByZXR1cm4gKGRpdmlkZW5kICUgZGl2aXNvciArIGRpdmlzb3IpICUgZGl2aXNvcjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsb2NhbFN0YXJ0T2ZEYXRlKHksIG0sIGQpIHtcbiAgICAgICAgLy8gdGhlIGRhdGUgY29uc3RydWN0b3IgcmVtYXBzIHllYXJzIDAtOTkgdG8gMTkwMC0xOTk5XG4gICAgICAgIGlmICh5IDwgMTAwICYmIHkgPj0gMCkge1xuICAgICAgICAgICAgLy8gcHJlc2VydmUgbGVhcCB5ZWFycyB1c2luZyBhIGZ1bGwgNDAwIHllYXIgY3ljbGUsIHRoZW4gcmVzZXRcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZSh5ICsgNDAwLCBtLCBkKSAtIE1TX1BFUl80MDBfWUVBUlM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERhdGUoeSwgbSwgZCkudmFsdWVPZigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdXRjU3RhcnRPZkRhdGUoeSwgbSwgZCkge1xuICAgICAgICAvLyBEYXRlLlVUQyByZW1hcHMgeWVhcnMgMC05OSB0byAxOTAwLTE5OTlcbiAgICAgICAgaWYgKHkgPCAxMDAgJiYgeSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwcmVzZXJ2ZSBsZWFwIHllYXJzIHVzaW5nIGEgZnVsbCA0MDAgeWVhciBjeWNsZSwgdGhlbiByZXNldFxuICAgICAgICAgICAgcmV0dXJuIERhdGUuVVRDKHkgKyA0MDAsIG0sIGQpIC0gTVNfUEVSXzQwMF9ZRUFSUztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEYXRlLlVUQyh5LCBtLCBkKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHN0YXJ0T2YgKHVuaXRzKSB7XG4gICAgICAgIHZhciB0aW1lO1xuICAgICAgICB1bml0cyA9IG5vcm1hbGl6ZVVuaXRzKHVuaXRzKTtcbiAgICAgICAgaWYgKHVuaXRzID09PSB1bmRlZmluZWQgfHwgdW5pdHMgPT09ICdtaWxsaXNlY29uZCcgfHwgIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzdGFydE9mRGF0ZSA9IHRoaXMuX2lzVVRDID8gdXRjU3RhcnRPZkRhdGUgOiBsb2NhbFN0YXJ0T2ZEYXRlO1xuXG4gICAgICAgIHN3aXRjaCAodW5pdHMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3llYXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgMCwgMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbW9udGgnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCAxKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtIHRoaXMud2Vla2RheSgpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2RheSc6XG4gICAgICAgICAgICBjYXNlICdkYXRlJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaG91cic6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHRoaXMuX2QudmFsdWVPZigpO1xuICAgICAgICAgICAgICAgIHRpbWUgLT0gbW9kJDEodGltZSwgTVNfUEVSX01JTlVURSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lIC09IG1vZCQxKHRpbWUsIE1TX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZC5zZXRUaW1lKHRpbWUpO1xuICAgICAgICBob29rcy51cGRhdGVPZmZzZXQodGhpcywgdHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuZE9mICh1bml0cykge1xuICAgICAgICB2YXIgdGltZTtcbiAgICAgICAgdW5pdHMgPSBub3JtYWxpemVVbml0cyh1bml0cyk7XG4gICAgICAgIGlmICh1bml0cyA9PT0gdW5kZWZpbmVkIHx8IHVuaXRzID09PSAnbWlsbGlzZWNvbmQnIHx8ICF0aGlzLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnRPZkRhdGUgPSB0aGlzLl9pc1VUQyA/IHV0Y1N0YXJ0T2ZEYXRlIDogbG9jYWxTdGFydE9mRGF0ZTtcblxuICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICBjYXNlICd5ZWFyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCkgKyAxLCAwLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdxdWFydGVyJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSAtIHRoaXMubW9udGgoKSAlIDMgKyAzLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtb250aCc6XG4gICAgICAgICAgICAgICAgdGltZSA9IHN0YXJ0T2ZEYXRlKHRoaXMueWVhcigpLCB0aGlzLm1vbnRoKCkgKyAxLCAxKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd3ZWVrJzpcbiAgICAgICAgICAgICAgICB0aW1lID0gc3RhcnRPZkRhdGUodGhpcy55ZWFyKCksIHRoaXMubW9udGgoKSwgdGhpcy5kYXRlKCkgLSB0aGlzLndlZWtkYXkoKSArIDcpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2lzb1dlZWsnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSAtICh0aGlzLmlzb1dlZWtkYXkoKSAtIDEpICsgNykgLSAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGF5JzpcbiAgICAgICAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSBzdGFydE9mRGF0ZSh0aGlzLnllYXIoKSwgdGhpcy5tb250aCgpLCB0aGlzLmRhdGUoKSArIDEpIC0gMTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2hvdXInOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9IT1VSIC0gbW9kJDEodGltZSArICh0aGlzLl9pc1VUQyA/IDAgOiB0aGlzLnV0Y09mZnNldCgpICogTVNfUEVSX01JTlVURSksIE1TX1BFUl9IT1VSKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdtaW51dGUnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9NSU5VVEUgLSBtb2QkMSh0aW1lLCBNU19QRVJfTUlOVVRFKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWNvbmQnOlxuICAgICAgICAgICAgICAgIHRpbWUgPSB0aGlzLl9kLnZhbHVlT2YoKTtcbiAgICAgICAgICAgICAgICB0aW1lICs9IE1TX1BFUl9TRUNPTkQgLSBtb2QkMSh0aW1lLCBNU19QRVJfU0VDT05EKSAtIDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kLnNldFRpbWUodGltZSk7XG4gICAgICAgIGhvb2tzLnVwZGF0ZU9mZnNldCh0aGlzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsdWVPZiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kLnZhbHVlT2YoKSAtICgodGhpcy5fb2Zmc2V0IHx8IDApICogNjAwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVuaXggKCkge1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcih0aGlzLnZhbHVlT2YoKSAvIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvRGF0ZSAoKSB7XG4gICAgICAgIHJldHVybiBuZXcgRGF0ZSh0aGlzLnZhbHVlT2YoKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9BcnJheSAoKSB7XG4gICAgICAgIHZhciBtID0gdGhpcztcbiAgICAgICAgcmV0dXJuIFttLnllYXIoKSwgbS5tb250aCgpLCBtLmRhdGUoKSwgbS5ob3VyKCksIG0ubWludXRlKCksIG0uc2Vjb25kKCksIG0ubWlsbGlzZWNvbmQoKV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdG9PYmplY3QgKCkge1xuICAgICAgICB2YXIgbSA9IHRoaXM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB5ZWFyczogbS55ZWFyKCksXG4gICAgICAgICAgICBtb250aHM6IG0ubW9udGgoKSxcbiAgICAgICAgICAgIGRhdGU6IG0uZGF0ZSgpLFxuICAgICAgICAgICAgaG91cnM6IG0uaG91cnMoKSxcbiAgICAgICAgICAgIG1pbnV0ZXM6IG0ubWludXRlcygpLFxuICAgICAgICAgICAgc2Vjb25kczogbS5zZWNvbmRzKCksXG4gICAgICAgICAgICBtaWxsaXNlY29uZHM6IG0ubWlsbGlzZWNvbmRzKClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0pTT04gKCkge1xuICAgICAgICAvLyBuZXcgRGF0ZShOYU4pLnRvSlNPTigpID09PSBudWxsXG4gICAgICAgIHJldHVybiB0aGlzLmlzVmFsaWQoKSA/IHRoaXMudG9JU09TdHJpbmcoKSA6IG51bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaXNWYWxpZCQyICgpIHtcbiAgICAgICAgcmV0dXJuIGlzVmFsaWQodGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFyc2luZ0ZsYWdzICgpIHtcbiAgICAgICAgcmV0dXJuIGV4dGVuZCh7fSwgZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnZhbGlkQXQgKCkge1xuICAgICAgICByZXR1cm4gZ2V0UGFyc2luZ0ZsYWdzKHRoaXMpLm92ZXJmbG93O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0aW9uRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlucHV0OiB0aGlzLl9pLFxuICAgICAgICAgICAgZm9ybWF0OiB0aGlzLl9mLFxuICAgICAgICAgICAgbG9jYWxlOiB0aGlzLl9sb2NhbGUsXG4gICAgICAgICAgICBpc1VUQzogdGhpcy5faXNVVEMsXG4gICAgICAgICAgICBzdHJpY3Q6IHRoaXMuX3N0cmljdFxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnZ2cnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53ZWVrWWVhcigpICUgMTAwO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydHRycsIDJdLCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzb1dlZWtZZWFyKCkgJSAxMDA7XG4gICAgfSk7XG5cbiAgICBmdW5jdGlvbiBhZGRXZWVrWWVhckZvcm1hdFRva2VuICh0b2tlbiwgZ2V0dGVyKSB7XG4gICAgICAgIGFkZEZvcm1hdFRva2VuKDAsIFt0b2tlbiwgdG9rZW4ubGVuZ3RoXSwgMCwgZ2V0dGVyKTtcbiAgICB9XG5cbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdnZ2dnJywgICAgICd3ZWVrWWVhcicpO1xuICAgIGFkZFdlZWtZZWFyRm9ybWF0VG9rZW4oJ2dnZ2dnJywgICAgJ3dlZWtZZWFyJyk7XG4gICAgYWRkV2Vla1llYXJGb3JtYXRUb2tlbignR0dHRycsICAnaXNvV2Vla1llYXInKTtcbiAgICBhZGRXZWVrWWVhckZvcm1hdFRva2VuKCdHR0dHRycsICdpc29XZWVrWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCd3ZWVrWWVhcicsICdnZycpO1xuICAgIGFkZFVuaXRBbGlhcygnaXNvV2Vla1llYXInLCAnR0cnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3dlZWtZZWFyJywgMSk7XG4gICAgYWRkVW5pdFByaW9yaXR5KCdpc29XZWVrWWVhcicsIDEpO1xuXG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdHJywgICAgICBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignZycsICAgICAgbWF0Y2hTaWduZWQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ0dHJywgICAgIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdnZycsICAgICBtYXRjaDF0bzIsIG1hdGNoMik7XG4gICAgYWRkUmVnZXhUb2tlbignR0dHRycsICAgbWF0Y2gxdG80LCBtYXRjaDQpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ2dnZ2cnLCAgIG1hdGNoMXRvNCwgbWF0Y2g0KTtcbiAgICBhZGRSZWdleFRva2VuKCdHR0dHRycsICBtYXRjaDF0bzYsIG1hdGNoNik7XG4gICAgYWRkUmVnZXhUb2tlbignZ2dnZ2cnLCAgbWF0Y2gxdG82LCBtYXRjaDYpO1xuXG4gICAgYWRkV2Vla1BhcnNlVG9rZW4oWydnZ2dnJywgJ2dnZ2dnJywgJ0dHR0cnLCAnR0dHR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW4uc3Vic3RyKDAsIDIpXSA9IHRvSW50KGlucHV0KTtcbiAgICB9KTtcblxuICAgIGFkZFdlZWtQYXJzZVRva2VuKFsnZ2cnLCAnR0cnXSwgZnVuY3Rpb24gKGlucHV0LCB3ZWVrLCBjb25maWcsIHRva2VuKSB7XG4gICAgICAgIHdlZWtbdG9rZW5dID0gaG9va3MucGFyc2VUd29EaWdpdFllYXIoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0V2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrKCksXG4gICAgICAgICAgICAgICAgdGhpcy53ZWVrZGF5KCksXG4gICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWsuZG93LFxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlRGF0YSgpLl93ZWVrLmRveSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0U2V0SVNPV2Vla1llYXIgKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBnZXRTZXRXZWVrWWVhckhlbHBlci5jYWxsKHRoaXMsXG4gICAgICAgICAgICAgICAgaW5wdXQsIHRoaXMuaXNvV2VlaygpLCB0aGlzLmlzb1dlZWtkYXkoKSwgMSwgNCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0SVNPV2Vla3NJblllYXIgKCkge1xuICAgICAgICByZXR1cm4gd2Vla3NJblllYXIodGhpcy55ZWFyKCksIDEsIDQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFdlZWtzSW5ZZWFyICgpIHtcbiAgICAgICAgdmFyIHdlZWtJbmZvID0gdGhpcy5sb2NhbGVEYXRhKCkuX3dlZWs7XG4gICAgICAgIHJldHVybiB3ZWVrc0luWWVhcih0aGlzLnllYXIoKSwgd2Vla0luZm8uZG93LCB3ZWVrSW5mby5kb3kpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFNldFdlZWtZZWFySGVscGVyKGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgd2Vla3NUYXJnZXQ7XG4gICAgICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gd2Vla09mWWVhcih0aGlzLCBkb3csIGRveSkueWVhcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdlZWtzVGFyZ2V0ID0gd2Vla3NJblllYXIoaW5wdXQsIGRvdywgZG95KTtcbiAgICAgICAgICAgIGlmICh3ZWVrID4gd2Vla3NUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICB3ZWVrID0gd2Vla3NUYXJnZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2V0V2Vla0FsbC5jYWxsKHRoaXMsIGlucHV0LCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZXRXZWVrQWxsKHdlZWtZZWFyLCB3ZWVrLCB3ZWVrZGF5LCBkb3csIGRveSkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyRGF0YSA9IGRheU9mWWVhckZyb21XZWVrcyh3ZWVrWWVhciwgd2Vlaywgd2Vla2RheSwgZG93LCBkb3kpLFxuICAgICAgICAgICAgZGF0ZSA9IGNyZWF0ZVVUQ0RhdGUoZGF5T2ZZZWFyRGF0YS55ZWFyLCAwLCBkYXlPZlllYXJEYXRhLmRheU9mWWVhcik7XG5cbiAgICAgICAgdGhpcy55ZWFyKGRhdGUuZ2V0VVRDRnVsbFllYXIoKSk7XG4gICAgICAgIHRoaXMubW9udGgoZGF0ZS5nZXRVVENNb250aCgpKTtcbiAgICAgICAgdGhpcy5kYXRlKGRhdGUuZ2V0VVRDRGF0ZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1EnLCAwLCAnUW8nLCAncXVhcnRlcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdxdWFydGVyJywgJ1EnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ3F1YXJ0ZXInLCA3KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ1EnLCBtYXRjaDEpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ1EnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5KSB7XG4gICAgICAgIGFycmF5W01PTlRIXSA9ICh0b0ludChpbnB1dCkgLSAxKSAqIDM7XG4gICAgfSk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICBmdW5jdGlvbiBnZXRTZXRRdWFydGVyIChpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IE1hdGguY2VpbCgodGhpcy5tb250aCgpICsgMSkgLyAzKSA6IHRoaXMubW9udGgoKGlucHV0IC0gMSkgKiAzICsgdGhpcy5tb250aCgpICUgMyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ0QnLCBbJ0REJywgMl0sICdEbycsICdkYXRlJyk7XG5cbiAgICAvLyBBTElBU0VTXG5cbiAgICBhZGRVbml0QWxpYXMoJ2RhdGUnLCAnRCcpO1xuXG4gICAgLy8gUFJJT1JJVFlcbiAgICBhZGRVbml0UHJpb3JpdHkoJ2RhdGUnLCA5KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ0QnLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdERCcsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRSZWdleFRva2VuKCdEbycsIGZ1bmN0aW9uIChpc1N0cmljdCwgbG9jYWxlKSB7XG4gICAgICAgIC8vIFRPRE86IFJlbW92ZSBcIm9yZGluYWxQYXJzZVwiIGZhbGxiYWNrIGluIG5leHQgbWFqb3IgcmVsZWFzZS5cbiAgICAgICAgcmV0dXJuIGlzU3RyaWN0ID9cbiAgICAgICAgICAobG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlIHx8IGxvY2FsZS5fb3JkaW5hbFBhcnNlKSA6XG4gICAgICAgICAgbG9jYWxlLl9kYXlPZk1vbnRoT3JkaW5hbFBhcnNlTGVuaWVudDtcbiAgICB9KTtcblxuICAgIGFkZFBhcnNlVG9rZW4oWydEJywgJ0REJ10sIERBVEUpO1xuICAgIGFkZFBhcnNlVG9rZW4oJ0RvJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtEQVRFXSA9IHRvSW50KGlucHV0Lm1hdGNoKG1hdGNoMXRvMilbMF0pO1xuICAgIH0pO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldERheU9mTW9udGggPSBtYWtlR2V0U2V0KCdEYXRlJywgdHJ1ZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbignREREJywgWydEREREJywgM10sICdERERvJywgJ2RheU9mWWVhcicpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdkYXlPZlllYXInLCAnREREJyk7XG5cbiAgICAvLyBQUklPUklUWVxuICAgIGFkZFVuaXRQcmlvcml0eSgnZGF5T2ZZZWFyJywgNCk7XG5cbiAgICAvLyBQQVJTSU5HXG5cbiAgICBhZGRSZWdleFRva2VuKCdEREQnLCAgbWF0Y2gxdG8zKTtcbiAgICBhZGRSZWdleFRva2VuKCdEREREJywgbWF0Y2gzKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnREREJywgJ0REREQnXSwgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZGF5T2ZZZWFyID0gdG9JbnQoaW5wdXQpO1xuICAgIH0pO1xuXG4gICAgLy8gSEVMUEVSU1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0U2V0RGF5T2ZZZWFyIChpbnB1dCkge1xuICAgICAgICB2YXIgZGF5T2ZZZWFyID0gTWF0aC5yb3VuZCgodGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ2RheScpIC0gdGhpcy5jbG9uZSgpLnN0YXJ0T2YoJ3llYXInKSkgLyA4NjRlNSkgKyAxO1xuICAgICAgICByZXR1cm4gaW5wdXQgPT0gbnVsbCA/IGRheU9mWWVhciA6IHRoaXMuYWRkKChpbnB1dCAtIGRheU9mWWVhciksICdkJyk7XG4gICAgfVxuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ20nLCBbJ21tJywgMl0sIDAsICdtaW51dGUnKTtcblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWludXRlJywgJ20nKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbnV0ZScsIDE0KTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ20nLCAgbWF0Y2gxdG8yKTtcbiAgICBhZGRSZWdleFRva2VuKCdtbScsIG1hdGNoMXRvMiwgbWF0Y2gyKTtcbiAgICBhZGRQYXJzZVRva2VuKFsnbScsICdtbSddLCBNSU5VVEUpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgdmFyIGdldFNldE1pbnV0ZSA9IG1ha2VHZXRTZXQoJ01pbnV0ZXMnLCBmYWxzZSk7XG5cbiAgICAvLyBGT1JNQVRUSU5HXG5cbiAgICBhZGRGb3JtYXRUb2tlbigncycsIFsnc3MnLCAyXSwgMCwgJ3NlY29uZCcpO1xuXG4gICAgLy8gQUxJQVNFU1xuXG4gICAgYWRkVW5pdEFsaWFzKCdzZWNvbmQnLCAncycpO1xuXG4gICAgLy8gUFJJT1JJVFlcblxuICAgIGFkZFVuaXRQcmlvcml0eSgnc2Vjb25kJywgMTUpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbigncycsICBtYXRjaDF0bzIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ3NzJywgbWF0Y2gxdG8yLCBtYXRjaDIpO1xuICAgIGFkZFBhcnNlVG9rZW4oWydzJywgJ3NzJ10sIFNFQ09ORCk7XG5cbiAgICAvLyBNT01FTlRTXG5cbiAgICB2YXIgZ2V0U2V0U2Vjb25kID0gbWFrZUdldFNldCgnU2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCdTJywgMCwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTAwKTtcbiAgICB9KTtcblxuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1MnLCAyXSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gfn4odGhpcy5taWxsaXNlY29uZCgpIC8gMTApO1xuICAgIH0pO1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1MnLCAzXSwgMCwgJ21pbGxpc2Vjb25kJyk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTJywgNF0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1MnLCA1XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTJywgNl0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDA7XG4gICAgfSk7XG4gICAgYWRkRm9ybWF0VG9rZW4oMCwgWydTU1NTU1NTJywgN10sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1MnLCA4XSwgMCwgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taWxsaXNlY29uZCgpICogMTAwMDAwO1xuICAgIH0pO1xuICAgIGFkZEZvcm1hdFRva2VuKDAsIFsnU1NTU1NTU1NTJywgOV0sIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWlsbGlzZWNvbmQoKSAqIDEwMDAwMDA7XG4gICAgfSk7XG5cblxuICAgIC8vIEFMSUFTRVNcblxuICAgIGFkZFVuaXRBbGlhcygnbWlsbGlzZWNvbmQnLCAnbXMnKTtcblxuICAgIC8vIFBSSU9SSVRZXG5cbiAgICBhZGRVbml0UHJpb3JpdHkoJ21pbGxpc2Vjb25kJywgMTYpO1xuXG4gICAgLy8gUEFSU0lOR1xuXG4gICAgYWRkUmVnZXhUb2tlbignUycsICAgIG1hdGNoMXRvMywgbWF0Y2gxKTtcbiAgICBhZGRSZWdleFRva2VuKCdTUycsICAgbWF0Y2gxdG8zLCBtYXRjaDIpO1xuICAgIGFkZFJlZ2V4VG9rZW4oJ1NTUycsICBtYXRjaDF0bzMsIG1hdGNoMyk7XG5cbiAgICB2YXIgdG9rZW47XG4gICAgZm9yICh0b2tlbiA9ICdTU1NTJzsgdG9rZW4ubGVuZ3RoIDw9IDk7IHRva2VuICs9ICdTJykge1xuICAgICAgICBhZGRSZWdleFRva2VuKHRva2VuLCBtYXRjaFVuc2lnbmVkKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwYXJzZU1zKGlucHV0LCBhcnJheSkge1xuICAgICAgICBhcnJheVtNSUxMSVNFQ09ORF0gPSB0b0ludCgoJzAuJyArIGlucHV0KSAqIDEwMDApO1xuICAgIH1cblxuICAgIGZvciAodG9rZW4gPSAnUyc7IHRva2VuLmxlbmd0aCA8PSA5OyB0b2tlbiArPSAnUycpIHtcbiAgICAgICAgYWRkUGFyc2VUb2tlbih0b2tlbiwgcGFyc2VNcyk7XG4gICAgfVxuICAgIC8vIE1PTUVOVFNcblxuICAgIHZhciBnZXRTZXRNaWxsaXNlY29uZCA9IG1ha2VHZXRTZXQoJ01pbGxpc2Vjb25kcycsIGZhbHNlKTtcblxuICAgIC8vIEZPUk1BVFRJTkdcblxuICAgIGFkZEZvcm1hdFRva2VuKCd6JywgIDAsIDAsICd6b25lQWJicicpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd6eicsIDAsIDAsICd6b25lTmFtZScpO1xuXG4gICAgLy8gTU9NRU5UU1xuXG4gICAgZnVuY3Rpb24gZ2V0Wm9uZUFiYnIgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNVVEMgPyAnVVRDJyA6ICcnO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFpvbmVOYW1lICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzVVRDID8gJ0Nvb3JkaW5hdGVkIFVuaXZlcnNhbCBUaW1lJyA6ICcnO1xuICAgIH1cblxuICAgIHZhciBwcm90byA9IE1vbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5hZGQgICAgICAgICAgICAgICA9IGFkZDtcbiAgICBwcm90by5jYWxlbmRhciAgICAgICAgICA9IGNhbGVuZGFyJDE7XG4gICAgcHJvdG8uY2xvbmUgICAgICAgICAgICAgPSBjbG9uZTtcbiAgICBwcm90by5kaWZmICAgICAgICAgICAgICA9IGRpZmY7XG4gICAgcHJvdG8uZW5kT2YgICAgICAgICAgICAgPSBlbmRPZjtcbiAgICBwcm90by5mb3JtYXQgICAgICAgICAgICA9IGZvcm1hdDtcbiAgICBwcm90by5mcm9tICAgICAgICAgICAgICA9IGZyb207XG4gICAgcHJvdG8uZnJvbU5vdyAgICAgICAgICAgPSBmcm9tTm93O1xuICAgIHByb3RvLnRvICAgICAgICAgICAgICAgID0gdG87XG4gICAgcHJvdG8udG9Ob3cgICAgICAgICAgICAgPSB0b05vdztcbiAgICBwcm90by5nZXQgICAgICAgICAgICAgICA9IHN0cmluZ0dldDtcbiAgICBwcm90by5pbnZhbGlkQXQgICAgICAgICA9IGludmFsaWRBdDtcbiAgICBwcm90by5pc0FmdGVyICAgICAgICAgICA9IGlzQWZ0ZXI7XG4gICAgcHJvdG8uaXNCZWZvcmUgICAgICAgICAgPSBpc0JlZm9yZTtcbiAgICBwcm90by5pc0JldHdlZW4gICAgICAgICA9IGlzQmV0d2VlbjtcbiAgICBwcm90by5pc1NhbWUgICAgICAgICAgICA9IGlzU2FtZTtcbiAgICBwcm90by5pc1NhbWVPckFmdGVyICAgICA9IGlzU2FtZU9yQWZ0ZXI7XG4gICAgcHJvdG8uaXNTYW1lT3JCZWZvcmUgICAgPSBpc1NhbWVPckJlZm9yZTtcbiAgICBwcm90by5pc1ZhbGlkICAgICAgICAgICA9IGlzVmFsaWQkMjtcbiAgICBwcm90by5sYW5nICAgICAgICAgICAgICA9IGxhbmc7XG4gICAgcHJvdG8ubG9jYWxlICAgICAgICAgICAgPSBsb2NhbGU7XG4gICAgcHJvdG8ubG9jYWxlRGF0YSAgICAgICAgPSBsb2NhbGVEYXRhO1xuICAgIHByb3RvLm1heCAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWF4O1xuICAgIHByb3RvLm1pbiAgICAgICAgICAgICAgID0gcHJvdG90eXBlTWluO1xuICAgIHByb3RvLnBhcnNpbmdGbGFncyAgICAgID0gcGFyc2luZ0ZsYWdzO1xuICAgIHByb3RvLnNldCAgICAgICAgICAgICAgID0gc3RyaW5nU2V0O1xuICAgIHByb3RvLnN0YXJ0T2YgICAgICAgICAgID0gc3RhcnRPZjtcbiAgICBwcm90by5zdWJ0cmFjdCAgICAgICAgICA9IHN1YnRyYWN0O1xuICAgIHByb3RvLnRvQXJyYXkgICAgICAgICAgID0gdG9BcnJheTtcbiAgICBwcm90by50b09iamVjdCAgICAgICAgICA9IHRvT2JqZWN0O1xuICAgIHByb3RvLnRvRGF0ZSAgICAgICAgICAgID0gdG9EYXRlO1xuICAgIHByb3RvLnRvSVNPU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmc7XG4gICAgcHJvdG8uaW5zcGVjdCAgICAgICAgICAgPSBpbnNwZWN0O1xuICAgIHByb3RvLnRvSlNPTiAgICAgICAgICAgID0gdG9KU09OO1xuICAgIHByb3RvLnRvU3RyaW5nICAgICAgICAgID0gdG9TdHJpbmc7XG4gICAgcHJvdG8udW5peCAgICAgICAgICAgICAgPSB1bml4O1xuICAgIHByb3RvLnZhbHVlT2YgICAgICAgICAgID0gdmFsdWVPZjtcbiAgICBwcm90by5jcmVhdGlvbkRhdGEgICAgICA9IGNyZWF0aW9uRGF0YTtcbiAgICBwcm90by55ZWFyICAgICAgID0gZ2V0U2V0WWVhcjtcbiAgICBwcm90by5pc0xlYXBZZWFyID0gZ2V0SXNMZWFwWWVhcjtcbiAgICBwcm90by53ZWVrWWVhciAgICA9IGdldFNldFdlZWtZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtZZWFyID0gZ2V0U2V0SVNPV2Vla1llYXI7XG4gICAgcHJvdG8ucXVhcnRlciA9IHByb3RvLnF1YXJ0ZXJzID0gZ2V0U2V0UXVhcnRlcjtcbiAgICBwcm90by5tb250aCAgICAgICA9IGdldFNldE1vbnRoO1xuICAgIHByb3RvLmRheXNJbk1vbnRoID0gZ2V0RGF5c0luTW9udGg7XG4gICAgcHJvdG8ud2VlayAgICAgICAgICAgPSBwcm90by53ZWVrcyAgICAgICAgPSBnZXRTZXRXZWVrO1xuICAgIHByb3RvLmlzb1dlZWsgICAgICAgID0gcHJvdG8uaXNvV2Vla3MgICAgID0gZ2V0U2V0SVNPV2VlaztcbiAgICBwcm90by53ZWVrc0luWWVhciAgICA9IGdldFdlZWtzSW5ZZWFyO1xuICAgIHByb3RvLmlzb1dlZWtzSW5ZZWFyID0gZ2V0SVNPV2Vla3NJblllYXI7XG4gICAgcHJvdG8uZGF0ZSAgICAgICA9IGdldFNldERheU9mTW9udGg7XG4gICAgcHJvdG8uZGF5ICAgICAgICA9IHByb3RvLmRheXMgICAgICAgICAgICAgPSBnZXRTZXREYXlPZldlZWs7XG4gICAgcHJvdG8ud2Vla2RheSAgICA9IGdldFNldExvY2FsZURheU9mV2VlaztcbiAgICBwcm90by5pc29XZWVrZGF5ID0gZ2V0U2V0SVNPRGF5T2ZXZWVrO1xuICAgIHByb3RvLmRheU9mWWVhciAgPSBnZXRTZXREYXlPZlllYXI7XG4gICAgcHJvdG8uaG91ciA9IHByb3RvLmhvdXJzID0gZ2V0U2V0SG91cjtcbiAgICBwcm90by5taW51dGUgPSBwcm90by5taW51dGVzID0gZ2V0U2V0TWludXRlO1xuICAgIHByb3RvLnNlY29uZCA9IHByb3RvLnNlY29uZHMgPSBnZXRTZXRTZWNvbmQ7XG4gICAgcHJvdG8ubWlsbGlzZWNvbmQgPSBwcm90by5taWxsaXNlY29uZHMgPSBnZXRTZXRNaWxsaXNlY29uZDtcbiAgICBwcm90by51dGNPZmZzZXQgICAgICAgICAgICA9IGdldFNldE9mZnNldDtcbiAgICBwcm90by51dGMgICAgICAgICAgICAgICAgICA9IHNldE9mZnNldFRvVVRDO1xuICAgIHByb3RvLmxvY2FsICAgICAgICAgICAgICAgID0gc2V0T2Zmc2V0VG9Mb2NhbDtcbiAgICBwcm90by5wYXJzZVpvbmUgICAgICAgICAgICA9IHNldE9mZnNldFRvUGFyc2VkT2Zmc2V0O1xuICAgIHByb3RvLmhhc0FsaWduZWRIb3VyT2Zmc2V0ID0gaGFzQWxpZ25lZEhvdXJPZmZzZXQ7XG4gICAgcHJvdG8uaXNEU1QgICAgICAgICAgICAgICAgPSBpc0RheWxpZ2h0U2F2aW5nVGltZTtcbiAgICBwcm90by5pc0xvY2FsICAgICAgICAgICAgICA9IGlzTG9jYWw7XG4gICAgcHJvdG8uaXNVdGNPZmZzZXQgICAgICAgICAgPSBpc1V0Y09mZnNldDtcbiAgICBwcm90by5pc1V0YyAgICAgICAgICAgICAgICA9IGlzVXRjO1xuICAgIHByb3RvLmlzVVRDICAgICAgICAgICAgICAgID0gaXNVdGM7XG4gICAgcHJvdG8uem9uZUFiYnIgPSBnZXRab25lQWJicjtcbiAgICBwcm90by56b25lTmFtZSA9IGdldFpvbmVOYW1lO1xuICAgIHByb3RvLmRhdGVzICA9IGRlcHJlY2F0ZSgnZGF0ZXMgYWNjZXNzb3IgaXMgZGVwcmVjYXRlZC4gVXNlIGRhdGUgaW5zdGVhZC4nLCBnZXRTZXREYXlPZk1vbnRoKTtcbiAgICBwcm90by5tb250aHMgPSBkZXByZWNhdGUoJ21vbnRocyBhY2Nlc3NvciBpcyBkZXByZWNhdGVkLiBVc2UgbW9udGggaW5zdGVhZCcsIGdldFNldE1vbnRoKTtcbiAgICBwcm90by55ZWFycyAgPSBkZXByZWNhdGUoJ3llYXJzIGFjY2Vzc29yIGlzIGRlcHJlY2F0ZWQuIFVzZSB5ZWFyIGluc3RlYWQnLCBnZXRTZXRZZWFyKTtcbiAgICBwcm90by56b25lICAgPSBkZXByZWNhdGUoJ21vbWVudCgpLnpvbmUgaXMgZGVwcmVjYXRlZCwgdXNlIG1vbWVudCgpLnV0Y09mZnNldCBpbnN0ZWFkLiBodHRwOi8vbW9tZW50anMuY29tL2d1aWRlcy8jL3dhcm5pbmdzL3pvbmUvJywgZ2V0U2V0Wm9uZSk7XG4gICAgcHJvdG8uaXNEU1RTaGlmdGVkID0gZGVwcmVjYXRlKCdpc0RTVFNoaWZ0ZWQgaXMgZGVwcmVjYXRlZC4gU2VlIGh0dHA6Ly9tb21lbnRqcy5jb20vZ3VpZGVzLyMvd2FybmluZ3MvZHN0LXNoaWZ0ZWQvIGZvciBtb3JlIGluZm9ybWF0aW9uJywgaXNEYXlsaWdodFNhdmluZ1RpbWVTaGlmdGVkKTtcblxuICAgIGZ1bmN0aW9uIGNyZWF0ZVVuaXggKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbChpbnB1dCAqIDEwMDApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUluWm9uZSAoKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVMb2NhbC5hcHBseShudWxsLCBhcmd1bWVudHMpLnBhcnNlWm9uZSgpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZVBhcnNlUG9zdEZvcm1hdCAoc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDEgPSBMb2NhbGUucHJvdG90eXBlO1xuXG4gICAgcHJvdG8kMS5jYWxlbmRhciAgICAgICAgPSBjYWxlbmRhcjtcbiAgICBwcm90byQxLmxvbmdEYXRlRm9ybWF0ICA9IGxvbmdEYXRlRm9ybWF0O1xuICAgIHByb3RvJDEuaW52YWxpZERhdGUgICAgID0gaW52YWxpZERhdGU7XG4gICAgcHJvdG8kMS5vcmRpbmFsICAgICAgICAgPSBvcmRpbmFsO1xuICAgIHByb3RvJDEucHJlcGFyc2UgICAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucG9zdGZvcm1hdCAgICAgID0gcHJlUGFyc2VQb3N0Rm9ybWF0O1xuICAgIHByb3RvJDEucmVsYXRpdmVUaW1lICAgID0gcmVsYXRpdmVUaW1lO1xuICAgIHByb3RvJDEucGFzdEZ1dHVyZSAgICAgID0gcGFzdEZ1dHVyZTtcbiAgICBwcm90byQxLnNldCAgICAgICAgICAgICA9IHNldDtcblxuICAgIHByb3RvJDEubW9udGhzICAgICAgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzO1xuICAgIHByb3RvJDEubW9udGhzU2hvcnQgICAgICAgPSAgICAgICAgbG9jYWxlTW9udGhzU2hvcnQ7XG4gICAgcHJvdG8kMS5tb250aHNQYXJzZSAgICAgICA9ICAgICAgICBsb2NhbGVNb250aHNQYXJzZTtcbiAgICBwcm90byQxLm1vbnRoc1JlZ2V4ICAgICAgID0gbW9udGhzUmVnZXg7XG4gICAgcHJvdG8kMS5tb250aHNTaG9ydFJlZ2V4ICA9IG1vbnRoc1Nob3J0UmVnZXg7XG4gICAgcHJvdG8kMS53ZWVrID0gbG9jYWxlV2VlaztcbiAgICBwcm90byQxLmZpcnN0RGF5T2ZZZWFyID0gbG9jYWxlRmlyc3REYXlPZlllYXI7XG4gICAgcHJvdG8kMS5maXJzdERheU9mV2VlayA9IGxvY2FsZUZpcnN0RGF5T2ZXZWVrO1xuXG4gICAgcHJvdG8kMS53ZWVrZGF5cyAgICAgICA9ICAgICAgICBsb2NhbGVXZWVrZGF5cztcbiAgICBwcm90byQxLndlZWtkYXlzTWluICAgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzTWluO1xuICAgIHByb3RvJDEud2Vla2RheXNTaG9ydCAgPSAgICAgICAgbG9jYWxlV2Vla2RheXNTaG9ydDtcbiAgICBwcm90byQxLndlZWtkYXlzUGFyc2UgID0gICAgICAgIGxvY2FsZVdlZWtkYXlzUGFyc2U7XG5cbiAgICBwcm90byQxLndlZWtkYXlzUmVnZXggICAgICAgPSAgICAgICAgd2Vla2RheXNSZWdleDtcbiAgICBwcm90byQxLndlZWtkYXlzU2hvcnRSZWdleCAgPSAgICAgICAgd2Vla2RheXNTaG9ydFJlZ2V4O1xuICAgIHByb3RvJDEud2Vla2RheXNNaW5SZWdleCAgICA9ICAgICAgICB3ZWVrZGF5c01pblJlZ2V4O1xuXG4gICAgcHJvdG8kMS5pc1BNID0gbG9jYWxlSXNQTTtcbiAgICBwcm90byQxLm1lcmlkaWVtID0gbG9jYWxlTWVyaWRpZW07XG5cbiAgICBmdW5jdGlvbiBnZXQkMSAoZm9ybWF0LCBpbmRleCwgZmllbGQsIHNldHRlcikge1xuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCk7XG4gICAgICAgIHZhciB1dGMgPSBjcmVhdGVVVEMoKS5zZXQoc2V0dGVyLCBpbmRleCk7XG4gICAgICAgIHJldHVybiBsb2NhbGVbZmllbGRdKHV0YywgZm9ybWF0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzSW1wbCAoZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9ybWF0ID0gZm9ybWF0IHx8ICcnO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCBpbmRleCwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDEyOyBpKyspIHtcbiAgICAgICAgICAgIG91dFtpXSA9IGdldCQxKGZvcm1hdCwgaSwgZmllbGQsICdtb250aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgLy8gKClcbiAgICAvLyAoNSlcbiAgICAvLyAoZm10LCA1KVxuICAgIC8vIChmbXQpXG4gICAgLy8gKHRydWUpXG4gICAgLy8gKHRydWUsIDUpXG4gICAgLy8gKHRydWUsIGZtdCwgNSlcbiAgICAvLyAodHJ1ZSwgZm10KVxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c0ltcGwgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgZmllbGQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBsb2NhbGVTb3J0ZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgaWYgKGlzTnVtYmVyKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZvcm1hdDtcbiAgICAgICAgICAgICAgICBmb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvcm1hdCA9IGZvcm1hdCB8fCAnJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IGxvY2FsZVNvcnRlZDtcbiAgICAgICAgICAgIGluZGV4ID0gZm9ybWF0O1xuICAgICAgICAgICAgbG9jYWxlU29ydGVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgIGlmIChpc051bWJlcihmb3JtYXQpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBmb3JtYXQ7XG4gICAgICAgICAgICAgICAgZm9ybWF0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3JtYXQgPSBmb3JtYXQgfHwgJyc7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbG9jYWxlID0gZ2V0TG9jYWxlKCksXG4gICAgICAgICAgICBzaGlmdCA9IGxvY2FsZVNvcnRlZCA/IGxvY2FsZS5fd2Vlay5kb3cgOiAwO1xuXG4gICAgICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0JDEoZm9ybWF0LCAoaW5kZXggKyBzaGlmdCkgJSA3LCBmaWVsZCwgJ2RheScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBvdXQgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IDc7IGkrKykge1xuICAgICAgICAgICAgb3V0W2ldID0gZ2V0JDEoZm9ybWF0LCAoaSArIHNoaWZ0KSAlIDcsIGZpZWxkLCAnZGF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0TW9udGhzIChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdE1vbnRoc1Nob3J0IChmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0TW9udGhzSW1wbChmb3JtYXQsIGluZGV4LCAnbW9udGhzU2hvcnQnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBsaXN0V2Vla2RheXMgKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCkge1xuICAgICAgICByZXR1cm4gbGlzdFdlZWtkYXlzSW1wbChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgsICd3ZWVrZGF5cycpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c1Nob3J0IChsb2NhbGVTb3J0ZWQsIGZvcm1hdCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGxpc3RXZWVrZGF5c0ltcGwobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4LCAnd2Vla2RheXNTaG9ydCcpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGxpc3RXZWVrZGF5c01pbiAobG9jYWxlU29ydGVkLCBmb3JtYXQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBsaXN0V2Vla2RheXNJbXBsKGxvY2FsZVNvcnRlZCwgZm9ybWF0LCBpbmRleCwgJ3dlZWtkYXlzTWluJyk7XG4gICAgfVxuXG4gICAgZ2V0U2V0R2xvYmFsTG9jYWxlKCdlbicsIHtcbiAgICAgICAgZGF5T2ZNb250aE9yZGluYWxQYXJzZTogL1xcZHsxLDJ9KHRofHN0fG5kfHJkKS8sXG4gICAgICAgIG9yZGluYWwgOiBmdW5jdGlvbiAobnVtYmVyKSB7XG4gICAgICAgICAgICB2YXIgYiA9IG51bWJlciAlIDEwLFxuICAgICAgICAgICAgICAgIG91dHB1dCA9ICh0b0ludChudW1iZXIgJSAxMDAgLyAxMCkgPT09IDEpID8gJ3RoJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDEpID8gJ3N0JyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDIpID8gJ25kJyA6XG4gICAgICAgICAgICAgICAgKGIgPT09IDMpID8gJ3JkJyA6ICd0aCc7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyICsgb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTaWRlIGVmZmVjdCBpbXBvcnRzXG5cbiAgICBob29rcy5sYW5nID0gZGVwcmVjYXRlKCdtb21lbnQubGFuZyBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZSBpbnN0ZWFkLicsIGdldFNldEdsb2JhbExvY2FsZSk7XG4gICAgaG9va3MubGFuZ0RhdGEgPSBkZXByZWNhdGUoJ21vbWVudC5sYW5nRGF0YSBpcyBkZXByZWNhdGVkLiBVc2UgbW9tZW50LmxvY2FsZURhdGEgaW5zdGVhZC4nLCBnZXRMb2NhbGUpO1xuXG4gICAgdmFyIG1hdGhBYnMgPSBNYXRoLmFicztcblxuICAgIGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgICA9IHRoaXMuX2RhdGE7XG5cbiAgICAgICAgdGhpcy5fbWlsbGlzZWNvbmRzID0gbWF0aEFicyh0aGlzLl9taWxsaXNlY29uZHMpO1xuICAgICAgICB0aGlzLl9kYXlzICAgICAgICAgPSBtYXRoQWJzKHRoaXMuX2RheXMpO1xuICAgICAgICB0aGlzLl9tb250aHMgICAgICAgPSBtYXRoQWJzKHRoaXMuX21vbnRocyk7XG5cbiAgICAgICAgZGF0YS5taWxsaXNlY29uZHMgID0gbWF0aEFicyhkYXRhLm1pbGxpc2Vjb25kcyk7XG4gICAgICAgIGRhdGEuc2Vjb25kcyAgICAgICA9IG1hdGhBYnMoZGF0YS5zZWNvbmRzKTtcbiAgICAgICAgZGF0YS5taW51dGVzICAgICAgID0gbWF0aEFicyhkYXRhLm1pbnV0ZXMpO1xuICAgICAgICBkYXRhLmhvdXJzICAgICAgICAgPSBtYXRoQWJzKGRhdGEuaG91cnMpO1xuICAgICAgICBkYXRhLm1vbnRocyAgICAgICAgPSBtYXRoQWJzKGRhdGEubW9udGhzKTtcbiAgICAgICAgZGF0YS55ZWFycyAgICAgICAgID0gbWF0aEFicyhkYXRhLnllYXJzKTtcblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhZGRTdWJ0cmFjdCQxIChkdXJhdGlvbiwgaW5wdXQsIHZhbHVlLCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIG90aGVyID0gY3JlYXRlRHVyYXRpb24oaW5wdXQsIHZhbHVlKTtcblxuICAgICAgICBkdXJhdGlvbi5fbWlsbGlzZWNvbmRzICs9IGRpcmVjdGlvbiAqIG90aGVyLl9taWxsaXNlY29uZHM7XG4gICAgICAgIGR1cmF0aW9uLl9kYXlzICAgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX2RheXM7XG4gICAgICAgIGR1cmF0aW9uLl9tb250aHMgICAgICAgKz0gZGlyZWN0aW9uICogb3RoZXIuX21vbnRocztcblxuICAgICAgICByZXR1cm4gZHVyYXRpb24uX2J1YmJsZSgpO1xuICAgIH1cblxuICAgIC8vIHN1cHBvcnRzIG9ubHkgMi4wLXN0eWxlIGFkZCgxLCAncycpIG9yIGFkZChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBhZGQkMSAoaW5wdXQsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBhZGRTdWJ0cmFjdCQxKHRoaXMsIGlucHV0LCB2YWx1ZSwgMSk7XG4gICAgfVxuXG4gICAgLy8gc3VwcG9ydHMgb25seSAyLjAtc3R5bGUgc3VidHJhY3QoMSwgJ3MnKSBvciBzdWJ0cmFjdChkdXJhdGlvbilcbiAgICBmdW5jdGlvbiBzdWJ0cmFjdCQxIChpbnB1dCwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGFkZFN1YnRyYWN0JDEodGhpcywgaW5wdXQsIHZhbHVlLCAtMSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWJzQ2VpbCAobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihudW1iZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIE1hdGguY2VpbChudW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnViYmxlICgpIHtcbiAgICAgICAgdmFyIG1pbGxpc2Vjb25kcyA9IHRoaXMuX21pbGxpc2Vjb25kcztcbiAgICAgICAgdmFyIGRheXMgICAgICAgICA9IHRoaXMuX2RheXM7XG4gICAgICAgIHZhciBtb250aHMgICAgICAgPSB0aGlzLl9tb250aHM7XG4gICAgICAgIHZhciBkYXRhICAgICAgICAgPSB0aGlzLl9kYXRhO1xuICAgICAgICB2YXIgc2Vjb25kcywgbWludXRlcywgaG91cnMsIHllYXJzLCBtb250aHNGcm9tRGF5cztcblxuICAgICAgICAvLyBpZiB3ZSBoYXZlIGEgbWl4IG9mIHBvc2l0aXZlIGFuZCBuZWdhdGl2ZSB2YWx1ZXMsIGJ1YmJsZSBkb3duIGZpcnN0XG4gICAgICAgIC8vIGNoZWNrOiBodHRwczovL2dpdGh1Yi5jb20vbW9tZW50L21vbWVudC9pc3N1ZXMvMjE2NlxuICAgICAgICBpZiAoISgobWlsbGlzZWNvbmRzID49IDAgJiYgZGF5cyA+PSAwICYmIG1vbnRocyA+PSAwKSB8fFxuICAgICAgICAgICAgICAgIChtaWxsaXNlY29uZHMgPD0gMCAmJiBkYXlzIDw9IDAgJiYgbW9udGhzIDw9IDApKSkge1xuICAgICAgICAgICAgbWlsbGlzZWNvbmRzICs9IGFic0NlaWwobW9udGhzVG9EYXlzKG1vbnRocykgKyBkYXlzKSAqIDg2NGU1O1xuICAgICAgICAgICAgZGF5cyA9IDA7XG4gICAgICAgICAgICBtb250aHMgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBjb2RlIGJ1YmJsZXMgdXAgdmFsdWVzLCBzZWUgdGhlIHRlc3RzIGZvclxuICAgICAgICAvLyBleGFtcGxlcyBvZiB3aGF0IHRoYXQgbWVhbnMuXG4gICAgICAgIGRhdGEubWlsbGlzZWNvbmRzID0gbWlsbGlzZWNvbmRzICUgMTAwMDtcblxuICAgICAgICBzZWNvbmRzICAgICAgICAgICA9IGFic0Zsb29yKG1pbGxpc2Vjb25kcyAvIDEwMDApO1xuICAgICAgICBkYXRhLnNlY29uZHMgICAgICA9IHNlY29uZHMgJSA2MDtcblxuICAgICAgICBtaW51dGVzICAgICAgICAgICA9IGFic0Zsb29yKHNlY29uZHMgLyA2MCk7XG4gICAgICAgIGRhdGEubWludXRlcyAgICAgID0gbWludXRlcyAlIDYwO1xuXG4gICAgICAgIGhvdXJzICAgICAgICAgICAgID0gYWJzRmxvb3IobWludXRlcyAvIDYwKTtcbiAgICAgICAgZGF0YS5ob3VycyAgICAgICAgPSBob3VycyAlIDI0O1xuXG4gICAgICAgIGRheXMgKz0gYWJzRmxvb3IoaG91cnMgLyAyNCk7XG5cbiAgICAgICAgLy8gY29udmVydCBkYXlzIHRvIG1vbnRoc1xuICAgICAgICBtb250aHNGcm9tRGF5cyA9IGFic0Zsb29yKGRheXNUb01vbnRocyhkYXlzKSk7XG4gICAgICAgIG1vbnRocyArPSBtb250aHNGcm9tRGF5cztcbiAgICAgICAgZGF5cyAtPSBhYnNDZWlsKG1vbnRoc1RvRGF5cyhtb250aHNGcm9tRGF5cykpO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgPSBhYnNGbG9vcihtb250aHMgLyAxMik7XG4gICAgICAgIG1vbnRocyAlPSAxMjtcblxuICAgICAgICBkYXRhLmRheXMgICA9IGRheXM7XG4gICAgICAgIGRhdGEubW9udGhzID0gbW9udGhzO1xuICAgICAgICBkYXRhLnllYXJzICA9IHllYXJzO1xuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRheXNUb01vbnRocyAoZGF5cykge1xuICAgICAgICAvLyA0MDAgeWVhcnMgaGF2ZSAxNDYwOTcgZGF5cyAodGFraW5nIGludG8gYWNjb3VudCBsZWFwIHllYXIgcnVsZXMpXG4gICAgICAgIC8vIDQwMCB5ZWFycyBoYXZlIDEyIG1vbnRocyA9PT0gNDgwMFxuICAgICAgICByZXR1cm4gZGF5cyAqIDQ4MDAgLyAxNDYwOTc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW9udGhzVG9EYXlzIChtb250aHMpIHtcbiAgICAgICAgLy8gdGhlIHJldmVyc2Ugb2YgZGF5c1RvTW9udGhzXG4gICAgICAgIHJldHVybiBtb250aHMgKiAxNDYwOTcgLyA0ODAwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFzICh1bml0cykge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gTmFOO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXlzO1xuICAgICAgICB2YXIgbW9udGhzO1xuICAgICAgICB2YXIgbWlsbGlzZWNvbmRzID0gdGhpcy5fbWlsbGlzZWNvbmRzO1xuXG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuXG4gICAgICAgIGlmICh1bml0cyA9PT0gJ21vbnRoJyB8fCB1bml0cyA9PT0gJ3F1YXJ0ZXInIHx8IHVuaXRzID09PSAneWVhcicpIHtcbiAgICAgICAgICAgIGRheXMgPSB0aGlzLl9kYXlzICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICBtb250aHMgPSB0aGlzLl9tb250aHMgKyBkYXlzVG9Nb250aHMoZGF5cyk7XG4gICAgICAgICAgICBzd2l0Y2ggKHVuaXRzKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnbW9udGgnOiAgIHJldHVybiBtb250aHM7XG4gICAgICAgICAgICAgICAgY2FzZSAncXVhcnRlcic6IHJldHVybiBtb250aHMgLyAzO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3llYXInOiAgICByZXR1cm4gbW9udGhzIC8gMTI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWlsbGlzZWNvbmRzIHNlcGFyYXRlbHkgYmVjYXVzZSBvZiBmbG9hdGluZyBwb2ludCBtYXRoIGVycm9ycyAoaXNzdWUgIzE4NjcpXG4gICAgICAgICAgICBkYXlzID0gdGhpcy5fZGF5cyArIE1hdGgucm91bmQobW9udGhzVG9EYXlzKHRoaXMuX21vbnRocykpO1xuICAgICAgICAgICAgc3dpdGNoICh1bml0cykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3dlZWsnICAgOiByZXR1cm4gZGF5cyAvIDcgICAgICsgbWlsbGlzZWNvbmRzIC8gNjA0OGU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ2RheScgICAgOiByZXR1cm4gZGF5cyAgICAgICAgICsgbWlsbGlzZWNvbmRzIC8gODY0ZTU7XG4gICAgICAgICAgICAgICAgY2FzZSAnaG91cicgICA6IHJldHVybiBkYXlzICogMjQgICAgKyBtaWxsaXNlY29uZHMgLyAzNmU1O1xuICAgICAgICAgICAgICAgIGNhc2UgJ21pbnV0ZScgOiByZXR1cm4gZGF5cyAqIDE0NDAgICsgbWlsbGlzZWNvbmRzIC8gNmU0O1xuICAgICAgICAgICAgICAgIGNhc2UgJ3NlY29uZCcgOiByZXR1cm4gZGF5cyAqIDg2NDAwICsgbWlsbGlzZWNvbmRzIC8gMTAwMDtcbiAgICAgICAgICAgICAgICAvLyBNYXRoLmZsb29yIHByZXZlbnRzIGZsb2F0aW5nIHBvaW50IG1hdGggZXJyb3JzIGhlcmVcbiAgICAgICAgICAgICAgICBjYXNlICdtaWxsaXNlY29uZCc6IHJldHVybiBNYXRoLmZsb29yKGRheXMgKiA4NjRlNSkgKyBtaWxsaXNlY29uZHM7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHVuaXQgJyArIHVuaXRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRPRE86IFVzZSB0aGlzLmFzKCdtcycpP1xuICAgIGZ1bmN0aW9uIHZhbHVlT2YkMSAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBOYU47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHRoaXMuX21pbGxpc2Vjb25kcyArXG4gICAgICAgICAgICB0aGlzLl9kYXlzICogODY0ZTUgK1xuICAgICAgICAgICAgKHRoaXMuX21vbnRocyAlIDEyKSAqIDI1OTJlNiArXG4gICAgICAgICAgICB0b0ludCh0aGlzLl9tb250aHMgLyAxMikgKiAzMTUzNmU2XG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbWFrZUFzIChhbGlhcykge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXMoYWxpYXMpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBhc01pbGxpc2Vjb25kcyA9IG1ha2VBcygnbXMnKTtcbiAgICB2YXIgYXNTZWNvbmRzICAgICAgPSBtYWtlQXMoJ3MnKTtcbiAgICB2YXIgYXNNaW51dGVzICAgICAgPSBtYWtlQXMoJ20nKTtcbiAgICB2YXIgYXNIb3VycyAgICAgICAgPSBtYWtlQXMoJ2gnKTtcbiAgICB2YXIgYXNEYXlzICAgICAgICAgPSBtYWtlQXMoJ2QnKTtcbiAgICB2YXIgYXNXZWVrcyAgICAgICAgPSBtYWtlQXMoJ3cnKTtcbiAgICB2YXIgYXNNb250aHMgICAgICAgPSBtYWtlQXMoJ00nKTtcbiAgICB2YXIgYXNRdWFydGVycyAgICAgPSBtYWtlQXMoJ1EnKTtcbiAgICB2YXIgYXNZZWFycyAgICAgICAgPSBtYWtlQXMoJ3knKTtcblxuICAgIGZ1bmN0aW9uIGNsb25lJDEgKCkge1xuICAgICAgICByZXR1cm4gY3JlYXRlRHVyYXRpb24odGhpcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0JDIgKHVuaXRzKSB7XG4gICAgICAgIHVuaXRzID0gbm9ybWFsaXplVW5pdHModW5pdHMpO1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhbGlkKCkgPyB0aGlzW3VuaXRzICsgJ3MnXSgpIDogTmFOO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1ha2VHZXR0ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNWYWxpZCgpID8gdGhpcy5fZGF0YVtuYW1lXSA6IE5hTjtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgbWlsbGlzZWNvbmRzID0gbWFrZUdldHRlcignbWlsbGlzZWNvbmRzJyk7XG4gICAgdmFyIHNlY29uZHMgICAgICA9IG1ha2VHZXR0ZXIoJ3NlY29uZHMnKTtcbiAgICB2YXIgbWludXRlcyAgICAgID0gbWFrZUdldHRlcignbWludXRlcycpO1xuICAgIHZhciBob3VycyAgICAgICAgPSBtYWtlR2V0dGVyKCdob3VycycpO1xuICAgIHZhciBkYXlzICAgICAgICAgPSBtYWtlR2V0dGVyKCdkYXlzJyk7XG4gICAgdmFyIG1vbnRocyAgICAgICA9IG1ha2VHZXR0ZXIoJ21vbnRocycpO1xuICAgIHZhciB5ZWFycyAgICAgICAgPSBtYWtlR2V0dGVyKCd5ZWFycycpO1xuXG4gICAgZnVuY3Rpb24gd2Vla3MgKCkge1xuICAgICAgICByZXR1cm4gYWJzRmxvb3IodGhpcy5kYXlzKCkgLyA3KTtcbiAgICB9XG5cbiAgICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xuICAgIHZhciB0aHJlc2hvbGRzID0ge1xuICAgICAgICBzczogNDQsICAgICAgICAgLy8gYSBmZXcgc2Vjb25kcyB0byBzZWNvbmRzXG4gICAgICAgIHMgOiA0NSwgICAgICAgICAvLyBzZWNvbmRzIHRvIG1pbnV0ZVxuICAgICAgICBtIDogNDUsICAgICAgICAgLy8gbWludXRlcyB0byBob3VyXG4gICAgICAgIGggOiAyMiwgICAgICAgICAvLyBob3VycyB0byBkYXlcbiAgICAgICAgZCA6IDI2LCAgICAgICAgIC8vIGRheXMgdG8gbW9udGhcbiAgICAgICAgTSA6IDExICAgICAgICAgIC8vIG1vbnRocyB0byB5ZWFyXG4gICAgfTtcblxuICAgIC8vIGhlbHBlciBmdW5jdGlvbiBmb3IgbW9tZW50LmZuLmZyb20sIG1vbWVudC5mbi5mcm9tTm93LCBhbmQgbW9tZW50LmR1cmF0aW9uLmZuLmh1bWFuaXplXG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZVRpbWVBZ28oc3RyaW5nLCBudW1iZXIsIHdpdGhvdXRTdWZmaXgsIGlzRnV0dXJlLCBsb2NhbGUpIHtcbiAgICAgICAgcmV0dXJuIGxvY2FsZS5yZWxhdGl2ZVRpbWUobnVtYmVyIHx8IDEsICEhd2l0aG91dFN1ZmZpeCwgc3RyaW5nLCBpc0Z1dHVyZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVsYXRpdmVUaW1lJDEgKHBvc05lZ0R1cmF0aW9uLCB3aXRob3V0U3VmZml4LCBsb2NhbGUpIHtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gY3JlYXRlRHVyYXRpb24ocG9zTmVnRHVyYXRpb24pLmFicygpO1xuICAgICAgICB2YXIgc2Vjb25kcyAgPSByb3VuZChkdXJhdGlvbi5hcygncycpKTtcbiAgICAgICAgdmFyIG1pbnV0ZXMgID0gcm91bmQoZHVyYXRpb24uYXMoJ20nKSk7XG4gICAgICAgIHZhciBob3VycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCdoJykpO1xuICAgICAgICB2YXIgZGF5cyAgICAgPSByb3VuZChkdXJhdGlvbi5hcygnZCcpKTtcbiAgICAgICAgdmFyIG1vbnRocyAgID0gcm91bmQoZHVyYXRpb24uYXMoJ00nKSk7XG4gICAgICAgIHZhciB5ZWFycyAgICA9IHJvdW5kKGR1cmF0aW9uLmFzKCd5JykpO1xuXG4gICAgICAgIHZhciBhID0gc2Vjb25kcyA8PSB0aHJlc2hvbGRzLnNzICYmIFsncycsIHNlY29uZHNdICB8fFxuICAgICAgICAgICAgICAgIHNlY29uZHMgPCB0aHJlc2hvbGRzLnMgICAmJiBbJ3NzJywgc2Vjb25kc10gfHxcbiAgICAgICAgICAgICAgICBtaW51dGVzIDw9IDEgICAgICAgICAgICAgJiYgWydtJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbWludXRlcyA8IHRocmVzaG9sZHMubSAgICYmIFsnbW0nLCBtaW51dGVzXSB8fFxuICAgICAgICAgICAgICAgIGhvdXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ2gnXSAgICAgICAgICAgfHxcbiAgICAgICAgICAgICAgICBob3VycyAgIDwgdGhyZXNob2xkcy5oICAgJiYgWydoaCcsIGhvdXJzXSAgIHx8XG4gICAgICAgICAgICAgICAgZGF5cyAgICA8PSAxICAgICAgICAgICAgICYmIFsnZCddICAgICAgICAgICB8fFxuICAgICAgICAgICAgICAgIGRheXMgICAgPCB0aHJlc2hvbGRzLmQgICAmJiBbJ2RkJywgZGF5c10gICAgfHxcbiAgICAgICAgICAgICAgICBtb250aHMgIDw9IDEgICAgICAgICAgICAgJiYgWydNJ10gICAgICAgICAgIHx8XG4gICAgICAgICAgICAgICAgbW9udGhzICA8IHRocmVzaG9sZHMuTSAgICYmIFsnTU0nLCBtb250aHNdICB8fFxuICAgICAgICAgICAgICAgIHllYXJzICAgPD0gMSAgICAgICAgICAgICAmJiBbJ3knXSAgICAgICAgICAgfHwgWyd5eScsIHllYXJzXTtcblxuICAgICAgICBhWzJdID0gd2l0aG91dFN1ZmZpeDtcbiAgICAgICAgYVszXSA9ICtwb3NOZWdEdXJhdGlvbiA+IDA7XG4gICAgICAgIGFbNF0gPSBsb2NhbGU7XG4gICAgICAgIHJldHVybiBzdWJzdGl0dXRlVGltZUFnby5hcHBseShudWxsLCBhKTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IHRoZSByb3VuZGluZyBmdW5jdGlvbiBmb3IgcmVsYXRpdmUgdGltZSBzdHJpbmdzXG4gICAgZnVuY3Rpb24gZ2V0U2V0UmVsYXRpdmVUaW1lUm91bmRpbmcgKHJvdW5kaW5nRnVuY3Rpb24pIHtcbiAgICAgICAgaWYgKHJvdW5kaW5nRnVuY3Rpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHJvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yocm91bmRpbmdGdW5jdGlvbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJvdW5kID0gcm91bmRpbmdGdW5jdGlvbjtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGFsbG93cyB5b3UgdG8gc2V0IGEgdGhyZXNob2xkIGZvciByZWxhdGl2ZSB0aW1lIHN0cmluZ3NcbiAgICBmdW5jdGlvbiBnZXRTZXRSZWxhdGl2ZVRpbWVUaHJlc2hvbGQgKHRocmVzaG9sZCwgbGltaXQpIHtcbiAgICAgICAgaWYgKHRocmVzaG9sZHNbdGhyZXNob2xkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aHJlc2hvbGRzW3RocmVzaG9sZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhyZXNob2xkc1t0aHJlc2hvbGRdID0gbGltaXQ7XG4gICAgICAgIGlmICh0aHJlc2hvbGQgPT09ICdzJykge1xuICAgICAgICAgICAgdGhyZXNob2xkcy5zcyA9IGxpbWl0IC0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBodW1hbml6ZSAod2l0aFN1ZmZpeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsb2NhbGUgPSB0aGlzLmxvY2FsZURhdGEoKTtcbiAgICAgICAgdmFyIG91dHB1dCA9IHJlbGF0aXZlVGltZSQxKHRoaXMsICF3aXRoU3VmZml4LCBsb2NhbGUpO1xuXG4gICAgICAgIGlmICh3aXRoU3VmZml4KSB7XG4gICAgICAgICAgICBvdXRwdXQgPSBsb2NhbGUucGFzdEZ1dHVyZSgrdGhpcywgb3V0cHV0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBsb2NhbGUucG9zdGZvcm1hdChvdXRwdXQpO1xuICAgIH1cblxuICAgIHZhciBhYnMkMSA9IE1hdGguYWJzO1xuXG4gICAgZnVuY3Rpb24gc2lnbih4KSB7XG4gICAgICAgIHJldHVybiAoKHggPiAwKSAtICh4IDwgMCkpIHx8ICt4O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRvSVNPU3RyaW5nJDEoKSB7XG4gICAgICAgIC8vIGZvciBJU08gc3RyaW5ncyB3ZSBkbyBub3QgdXNlIHRoZSBub3JtYWwgYnViYmxpbmcgcnVsZXM6XG4gICAgICAgIC8vICAqIG1pbGxpc2Vjb25kcyBidWJibGUgdXAgdW50aWwgdGhleSBiZWNvbWUgaG91cnNcbiAgICAgICAgLy8gICogZGF5cyBkbyBub3QgYnViYmxlIGF0IGFsbFxuICAgICAgICAvLyAgKiBtb250aHMgYnViYmxlIHVwIHVudGlsIHRoZXkgYmVjb21lIHllYXJzXG4gICAgICAgIC8vIFRoaXMgaXMgYmVjYXVzZSB0aGVyZSBpcyBubyBjb250ZXh0LWZyZWUgY29udmVyc2lvbiBiZXR3ZWVuIGhvdXJzIGFuZCBkYXlzXG4gICAgICAgIC8vICh0aGluayBvZiBjbG9jayBjaGFuZ2VzKVxuICAgICAgICAvLyBhbmQgYWxzbyBub3QgYmV0d2VlbiBkYXlzIGFuZCBtb250aHMgKDI4LTMxIGRheXMgcGVyIG1vbnRoKVxuICAgICAgICBpZiAoIXRoaXMuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVEYXRhKCkuaW52YWxpZERhdGUoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWNvbmRzID0gYWJzJDEodGhpcy5fbWlsbGlzZWNvbmRzKSAvIDEwMDA7XG4gICAgICAgIHZhciBkYXlzICAgICAgICAgPSBhYnMkMSh0aGlzLl9kYXlzKTtcbiAgICAgICAgdmFyIG1vbnRocyAgICAgICA9IGFicyQxKHRoaXMuX21vbnRocyk7XG4gICAgICAgIHZhciBtaW51dGVzLCBob3VycywgeWVhcnM7XG5cbiAgICAgICAgLy8gMzYwMCBzZWNvbmRzIC0+IDYwIG1pbnV0ZXMgLT4gMSBob3VyXG4gICAgICAgIG1pbnV0ZXMgICAgICAgICAgID0gYWJzRmxvb3Ioc2Vjb25kcyAvIDYwKTtcbiAgICAgICAgaG91cnMgICAgICAgICAgICAgPSBhYnNGbG9vcihtaW51dGVzIC8gNjApO1xuICAgICAgICBzZWNvbmRzICU9IDYwO1xuICAgICAgICBtaW51dGVzICU9IDYwO1xuXG4gICAgICAgIC8vIDEyIG1vbnRocyAtPiAxIHllYXJcbiAgICAgICAgeWVhcnMgID0gYWJzRmxvb3IobW9udGhzIC8gMTIpO1xuICAgICAgICBtb250aHMgJT0gMTI7XG5cblxuICAgICAgICAvLyBpbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vZG9yZGlsbGUvbW9tZW50LWlzb2R1cmF0aW9uL2Jsb2IvbWFzdGVyL21vbWVudC5pc29kdXJhdGlvbi5qc1xuICAgICAgICB2YXIgWSA9IHllYXJzO1xuICAgICAgICB2YXIgTSA9IG1vbnRocztcbiAgICAgICAgdmFyIEQgPSBkYXlzO1xuICAgICAgICB2YXIgaCA9IGhvdXJzO1xuICAgICAgICB2YXIgbSA9IG1pbnV0ZXM7XG4gICAgICAgIHZhciBzID0gc2Vjb25kcyA/IHNlY29uZHMudG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpIDogJyc7XG4gICAgICAgIHZhciB0b3RhbCA9IHRoaXMuYXNTZWNvbmRzKCk7XG5cbiAgICAgICAgaWYgKCF0b3RhbCkge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyB0aGUgc2FtZSBhcyBDIydzIChOb2RhKSBhbmQgcHl0aG9uIChpc29kYXRlKS4uLlxuICAgICAgICAgICAgLy8gYnV0IG5vdCBvdGhlciBKUyAoZ29vZy5kYXRlKVxuICAgICAgICAgICAgcmV0dXJuICdQMEQnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRvdGFsU2lnbiA9IHRvdGFsIDwgMCA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgeW1TaWduID0gc2lnbih0aGlzLl9tb250aHMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgZGF5c1NpZ24gPSBzaWduKHRoaXMuX2RheXMpICE9PSBzaWduKHRvdGFsKSA/ICctJyA6ICcnO1xuICAgICAgICB2YXIgaG1zU2lnbiA9IHNpZ24odGhpcy5fbWlsbGlzZWNvbmRzKSAhPT0gc2lnbih0b3RhbCkgPyAnLScgOiAnJztcblxuICAgICAgICByZXR1cm4gdG90YWxTaWduICsgJ1AnICtcbiAgICAgICAgICAgIChZID8geW1TaWduICsgWSArICdZJyA6ICcnKSArXG4gICAgICAgICAgICAoTSA/IHltU2lnbiArIE0gKyAnTScgOiAnJykgK1xuICAgICAgICAgICAgKEQgPyBkYXlzU2lnbiArIEQgKyAnRCcgOiAnJykgK1xuICAgICAgICAgICAgKChoIHx8IG0gfHwgcykgPyAnVCcgOiAnJykgK1xuICAgICAgICAgICAgKGggPyBobXNTaWduICsgaCArICdIJyA6ICcnKSArXG4gICAgICAgICAgICAobSA/IGhtc1NpZ24gKyBtICsgJ00nIDogJycpICtcbiAgICAgICAgICAgIChzID8gaG1zU2lnbiArIHMgKyAnUycgOiAnJyk7XG4gICAgfVxuXG4gICAgdmFyIHByb3RvJDIgPSBEdXJhdGlvbi5wcm90b3R5cGU7XG5cbiAgICBwcm90byQyLmlzVmFsaWQgICAgICAgID0gaXNWYWxpZCQxO1xuICAgIHByb3RvJDIuYWJzICAgICAgICAgICAgPSBhYnM7XG4gICAgcHJvdG8kMi5hZGQgICAgICAgICAgICA9IGFkZCQxO1xuICAgIHByb3RvJDIuc3VidHJhY3QgICAgICAgPSBzdWJ0cmFjdCQxO1xuICAgIHByb3RvJDIuYXMgICAgICAgICAgICAgPSBhcztcbiAgICBwcm90byQyLmFzTWlsbGlzZWNvbmRzID0gYXNNaWxsaXNlY29uZHM7XG4gICAgcHJvdG8kMi5hc1NlY29uZHMgICAgICA9IGFzU2Vjb25kcztcbiAgICBwcm90byQyLmFzTWludXRlcyAgICAgID0gYXNNaW51dGVzO1xuICAgIHByb3RvJDIuYXNIb3VycyAgICAgICAgPSBhc0hvdXJzO1xuICAgIHByb3RvJDIuYXNEYXlzICAgICAgICAgPSBhc0RheXM7XG4gICAgcHJvdG8kMi5hc1dlZWtzICAgICAgICA9IGFzV2Vla3M7XG4gICAgcHJvdG8kMi5hc01vbnRocyAgICAgICA9IGFzTW9udGhzO1xuICAgIHByb3RvJDIuYXNRdWFydGVycyAgICAgPSBhc1F1YXJ0ZXJzO1xuICAgIHByb3RvJDIuYXNZZWFycyAgICAgICAgPSBhc1llYXJzO1xuICAgIHByb3RvJDIudmFsdWVPZiAgICAgICAgPSB2YWx1ZU9mJDE7XG4gICAgcHJvdG8kMi5fYnViYmxlICAgICAgICA9IGJ1YmJsZTtcbiAgICBwcm90byQyLmNsb25lICAgICAgICAgID0gY2xvbmUkMTtcbiAgICBwcm90byQyLmdldCAgICAgICAgICAgID0gZ2V0JDI7XG4gICAgcHJvdG8kMi5taWxsaXNlY29uZHMgICA9IG1pbGxpc2Vjb25kcztcbiAgICBwcm90byQyLnNlY29uZHMgICAgICAgID0gc2Vjb25kcztcbiAgICBwcm90byQyLm1pbnV0ZXMgICAgICAgID0gbWludXRlcztcbiAgICBwcm90byQyLmhvdXJzICAgICAgICAgID0gaG91cnM7XG4gICAgcHJvdG8kMi5kYXlzICAgICAgICAgICA9IGRheXM7XG4gICAgcHJvdG8kMi53ZWVrcyAgICAgICAgICA9IHdlZWtzO1xuICAgIHByb3RvJDIubW9udGhzICAgICAgICAgPSBtb250aHM7XG4gICAgcHJvdG8kMi55ZWFycyAgICAgICAgICA9IHllYXJzO1xuICAgIHByb3RvJDIuaHVtYW5pemUgICAgICAgPSBodW1hbml6ZTtcbiAgICBwcm90byQyLnRvSVNPU3RyaW5nICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvU3RyaW5nICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLnRvSlNPTiAgICAgICAgID0gdG9JU09TdHJpbmckMTtcbiAgICBwcm90byQyLmxvY2FsZSAgICAgICAgID0gbG9jYWxlO1xuICAgIHByb3RvJDIubG9jYWxlRGF0YSAgICAgPSBsb2NhbGVEYXRhO1xuXG4gICAgcHJvdG8kMi50b0lzb1N0cmluZyA9IGRlcHJlY2F0ZSgndG9Jc29TdHJpbmcoKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRvSVNPU3RyaW5nKCkgaW5zdGVhZCAobm90aWNlIHRoZSBjYXBpdGFscyknLCB0b0lTT1N0cmluZyQxKTtcbiAgICBwcm90byQyLmxhbmcgPSBsYW5nO1xuXG4gICAgLy8gU2lkZSBlZmZlY3QgaW1wb3J0c1xuXG4gICAgLy8gRk9STUFUVElOR1xuXG4gICAgYWRkRm9ybWF0VG9rZW4oJ1gnLCAwLCAwLCAndW5peCcpO1xuICAgIGFkZEZvcm1hdFRva2VuKCd4JywgMCwgMCwgJ3ZhbHVlT2YnKTtcblxuICAgIC8vIFBBUlNJTkdcblxuICAgIGFkZFJlZ2V4VG9rZW4oJ3gnLCBtYXRjaFNpZ25lZCk7XG4gICAgYWRkUmVnZXhUb2tlbignWCcsIG1hdGNoVGltZXN0YW1wKTtcbiAgICBhZGRQYXJzZVRva2VuKCdYJywgZnVuY3Rpb24gKGlucHV0LCBhcnJheSwgY29uZmlnKSB7XG4gICAgICAgIGNvbmZpZy5fZCA9IG5ldyBEYXRlKHBhcnNlRmxvYXQoaW5wdXQsIDEwKSAqIDEwMDApO1xuICAgIH0pO1xuICAgIGFkZFBhcnNlVG9rZW4oJ3gnLCBmdW5jdGlvbiAoaW5wdXQsIGFycmF5LCBjb25maWcpIHtcbiAgICAgICAgY29uZmlnLl9kID0gbmV3IERhdGUodG9JbnQoaW5wdXQpKTtcbiAgICB9KTtcblxuICAgIC8vIFNpZGUgZWZmZWN0IGltcG9ydHNcblxuXG4gICAgaG9va3MudmVyc2lvbiA9ICcyLjI0LjAnO1xuXG4gICAgc2V0SG9va0NhbGxiYWNrKGNyZWF0ZUxvY2FsKTtcblxuICAgIGhvb2tzLmZuICAgICAgICAgICAgICAgICAgICA9IHByb3RvO1xuICAgIGhvb2tzLm1pbiAgICAgICAgICAgICAgICAgICA9IG1pbjtcbiAgICBob29rcy5tYXggICAgICAgICAgICAgICAgICAgPSBtYXg7XG4gICAgaG9va3Mubm93ICAgICAgICAgICAgICAgICAgID0gbm93O1xuICAgIGhvb2tzLnV0YyAgICAgICAgICAgICAgICAgICA9IGNyZWF0ZVVUQztcbiAgICBob29rcy51bml4ICAgICAgICAgICAgICAgICAgPSBjcmVhdGVVbml4O1xuICAgIGhvb2tzLm1vbnRocyAgICAgICAgICAgICAgICA9IGxpc3RNb250aHM7XG4gICAgaG9va3MuaXNEYXRlICAgICAgICAgICAgICAgID0gaXNEYXRlO1xuICAgIGhvb2tzLmxvY2FsZSAgICAgICAgICAgICAgICA9IGdldFNldEdsb2JhbExvY2FsZTtcbiAgICBob29rcy5pbnZhbGlkICAgICAgICAgICAgICAgPSBjcmVhdGVJbnZhbGlkO1xuICAgIGhvb2tzLmR1cmF0aW9uICAgICAgICAgICAgICA9IGNyZWF0ZUR1cmF0aW9uO1xuICAgIGhvb2tzLmlzTW9tZW50ICAgICAgICAgICAgICA9IGlzTW9tZW50O1xuICAgIGhvb2tzLndlZWtkYXlzICAgICAgICAgICAgICA9IGxpc3RXZWVrZGF5cztcbiAgICBob29rcy5wYXJzZVpvbmUgICAgICAgICAgICAgPSBjcmVhdGVJblpvbmU7XG4gICAgaG9va3MubG9jYWxlRGF0YSAgICAgICAgICAgID0gZ2V0TG9jYWxlO1xuICAgIGhvb2tzLmlzRHVyYXRpb24gICAgICAgICAgICA9IGlzRHVyYXRpb247XG4gICAgaG9va3MubW9udGhzU2hvcnQgICAgICAgICAgID0gbGlzdE1vbnRoc1Nob3J0O1xuICAgIGhvb2tzLndlZWtkYXlzTWluICAgICAgICAgICA9IGxpc3RXZWVrZGF5c01pbjtcbiAgICBob29rcy5kZWZpbmVMb2NhbGUgICAgICAgICAgPSBkZWZpbmVMb2NhbGU7XG4gICAgaG9va3MudXBkYXRlTG9jYWxlICAgICAgICAgID0gdXBkYXRlTG9jYWxlO1xuICAgIGhvb2tzLmxvY2FsZXMgICAgICAgICAgICAgICA9IGxpc3RMb2NhbGVzO1xuICAgIGhvb2tzLndlZWtkYXlzU2hvcnQgICAgICAgICA9IGxpc3RXZWVrZGF5c1Nob3J0O1xuICAgIGhvb2tzLm5vcm1hbGl6ZVVuaXRzICAgICAgICA9IG5vcm1hbGl6ZVVuaXRzO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVJvdW5kaW5nICA9IGdldFNldFJlbGF0aXZlVGltZVJvdW5kaW5nO1xuICAgIGhvb2tzLnJlbGF0aXZlVGltZVRocmVzaG9sZCA9IGdldFNldFJlbGF0aXZlVGltZVRocmVzaG9sZDtcbiAgICBob29rcy5jYWxlbmRhckZvcm1hdCAgICAgICAgPSBnZXRDYWxlbmRhckZvcm1hdDtcbiAgICBob29rcy5wcm90b3R5cGUgICAgICAgICAgICAgPSBwcm90bztcblxuICAgIC8vIGN1cnJlbnRseSBIVE1MNSBpbnB1dCB0eXBlIG9ubHkgc3VwcG9ydHMgMjQtaG91ciBmb3JtYXRzXG4gICAgaG9va3MuSFRNTDVfRk1UID0ge1xuICAgICAgICBEQVRFVElNRV9MT0NBTDogJ1lZWVktTU0tRERUSEg6bW0nLCAgICAgICAgICAgICAvLyA8aW5wdXQgdHlwZT1cImRhdGV0aW1lLWxvY2FsXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfU0VDT05EUzogJ1lZWVktTU0tRERUSEg6bW06c3MnLCAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgREFURVRJTUVfTE9DQUxfTVM6ICdZWVlZLU1NLUREVEhIOm1tOnNzLlNTUycsICAgLy8gPGlucHV0IHR5cGU9XCJkYXRldGltZS1sb2NhbFwiIHN0ZXA9XCIwLjAwMVwiIC8+XG4gICAgICAgIERBVEU6ICdZWVlZLU1NLUREJywgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwiZGF0ZVwiIC8+XG4gICAgICAgIFRJTUU6ICdISDptbScsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIC8+XG4gICAgICAgIFRJTUVfU0VDT05EUzogJ0hIOm1tOnNzJywgICAgICAgICAgICAgICAgICAgICAgIC8vIDxpbnB1dCB0eXBlPVwidGltZVwiIHN0ZXA9XCIxXCIgLz5cbiAgICAgICAgVElNRV9NUzogJ0hIOm1tOnNzLlNTUycsICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ0aW1lXCIgc3RlcD1cIjAuMDAxXCIgLz5cbiAgICAgICAgV0VFSzogJ0dHR0ctW1ddV1cnLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJ3ZWVrXCIgLz5cbiAgICAgICAgTU9OVEg6ICdZWVlZLU1NJyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gPGlucHV0IHR5cGU9XCJtb250aFwiIC8+XG4gICAgfTtcblxuICAgIHJldHVybiBob29rcztcblxufSkpKTtcbiIsImV4cG9ydCB7ZGVmYXVsdCBhcyBuYW1lc3BhY2VzfSBmcm9tICcuL3NyYy9uYW1lc3BhY2VzJztcbmV4cG9ydCB7ZGVmYXVsdCBhcyBjb252ZXJ0ZXJzfSBmcm9tICcuL3NyYy9mb3JtYXRzL2NvbnZlcnRlcnMnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIEdyYXBofSBmcm9tICcuL3NyYy9HcmFwaCc7XG5leHBvcnQge2RlZmF1bHQgYXMgU3RhdGVtZW50fSBmcm9tICcuL3NyYy9TdGF0ZW1lbnQnO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHV0aWxzfSBmcm9tICcuL3NyYy91dGlscyc7XG5leHBvcnQge2RlZmF1bHQgYXMgcHJpbnR9IGZyb20gJy4vc3JjL3ByaW50JztcbiIsImltcG9ydCByZGZqc29uVXRpbCBmcm9tICcuL2Zvcm1hdHMvcmRmanNvbi91dGlsJztcbmltcG9ydCBucyBmcm9tICcuL25hbWVzcGFjZXMnO1xuaW1wb3J0IFN0YXRlbWVudCBmcm9tICcuL1N0YXRlbWVudCc7XG5pbXBvcnQgdXRpbHMgZnJvbSAnLi91dGlscyc7XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheX0gYXJyXG4gKiBAcmV0dXJucyB7Kn1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHplcm9Pck9uZSA9IGFyciA9PiAoYXJyLmxlbmd0aCA9PT0gMCA/IGFyciA6IFthcnJbMF1dKTtcblxuLyoqXG4gKiBAcGFyYW0ge3JkZmpzb24vR3JhcGh9IGdyYXBoXG4gKiBAcGFyYW0ge3JkZmpzb24vU3RhdGVtZW50W119IHN0YXRlbWVudHMgYW4gYXJyYXlcbiAqIEBwYXJhbSB7Qm9vbGVhbj19IHBlclN1YmplY3QgaWYgdHJ1ZSBtZWFucyB0aGF0IGFsbCBjb25zZWN1dGl2ZSBjYWxscyB3aWxsIGJlIGZvY3VzZWQgb25cbiAqIGFsbCB0aGUgc3ViamVjdHMgb2YgdGhlIHNwZWNpZmllZCBzdGF0bWVudHMsIG90aGVyd2lzZSB0aGUgcmVzb3VyY2Ugb2JqZWN0cyBvZiB0aGUgc3RhdGVtZW50c1xuICogd2lsbCBiZSB0aGUgZm9jdXMuIEFzc3VtZWQgdG8gYmUgZmFsc2UgdW5sZXNzIGV4cGxpY2l0bHkgc2V0IHRvIHRydWUuXG4gKlxuICogQHJldHVybnMge3tvYmplY3Q6IEZ1bmN0aW9uLCBvYmplY3RzOiBGdW5jdGlvbiwgY29uc3RyOiBGdW5jdGlvbiwgZWFjaDogRnVuY3Rpb24sIG5vZGVzOlxuICogRnVuY3Rpb24sIHZhbHVlczogRnVuY3Rpb24sIGZpcnN0VmFsdWU6IEZ1bmN0aW9ufX1cbiAqIEBwcml2YXRlXG4gKi9cbmNvbnN0IHBlclN0YXRlbWVudCA9IChncmFwaCwgc3RhdGVtZW50cywgcGVyU3ViamVjdCkgPT4gKHtcbiAgb2JqZWN0KHByZWRpY2F0ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHN1Ymo7XG4gICAgICBpZiAocGVyU3ViamVjdCkge1xuICAgICAgICBzdWJqID0gc3RhdGVtZW50c1tpXS5nZXRTdWJqZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0ID0gc3RhdGVtZW50c1tpXS5nZXRUeXBlKCk7XG4gICAgICAgIGlmICh0ID09PSAndXJpJyB8fCB0ID09PSAnYm5vZGUnKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnRpbnVlXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgc3ViaiA9IHN0YXRlbWVudHNbaV0uZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0bXRzID0gZ3JhcGguZmluZChzdWJqLCBwcmVkaWNhdGUpO1xuICAgICAgaWYgKHN0bXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgcGVyU3RhdGVtZW50KGdyYXBoLCBbc3RtdHNbMF1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBlclN0YXRlbWVudChncmFwaCwgW10pO1xuICB9LFxuICBvYmplY3RzKHByZWRpY2F0ZSkge1xuICAgIGxldCBuc3RhdHMgPSBbXTtcbiAgICBsZXQgaTtcbiAgICBpZiAocGVyU3ViamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbnN0YXRzID0gbnN0YXRzLmNvbmNhdChncmFwaC5maW5kKHN0YXRlbWVudHNbaV0uZ2V0U3ViamVjdCgpLCBwcmVkaWNhdGUpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdCA9IHN0YXRlbWVudHNbaV0uZ2V0VHlwZSgpO1xuICAgICAgICBpZiAodCA9PT0gJ3VyaScgfHwgdCA9PT0gJ2Jub2RlJykge1xuICAgICAgICAgIG5zdGF0cyA9IG5zdGF0cy5jb25jYXQoZ3JhcGguZmluZChzdGF0ZW1lbnRzW2ldLmdldFZhbHVlKCksIHByZWRpY2F0ZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwZXJTdGF0ZW1lbnQoZ3JhcGgsIG5zdGF0cyk7XG4gIH0sXG4gIGNvbnN0cihwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIGxldCBfb2JqZWN0ID0gb2JqZWN0O1xuICAgIGlmIChyZGZqc29uVXRpbC5pc1N0cmluZyhfb2JqZWN0KSkge1xuICAgICAgX29iamVjdCA9IHsgdHlwZTogJ3VyaScsIHZhbHVlOiBfb2JqZWN0IH07XG4gICAgfVxuICAgIGNvbnN0IG5zdGF0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3ViaiA9IHBlclN1YmplY3QgPyBzdGF0ZW1lbnRzW2ldLmdldFN1YmplY3QoKSA6IHN0YXRlbWVudHNbaV0uZ2V0VmFsdWUoKTtcbiAgICAgIGlmIChncmFwaC5maW5kKHN1YmosIHByZWRpY2F0ZSwgX29iamVjdCkubGVuZ3RoID4gMCkge1xuICAgICAgICBuc3RhdHMucHVzaChzdGF0ZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBlclN0YXRlbWVudChncmFwaCwgbnN0YXRzLCBwZXJTdWJqZWN0KTtcbiAgfSxcbiAgLyoqXG4gICAqIEZvciBlYWNoIG1hdGNoIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGEgZm9jdXNlZCBpdGVyYXRvci5cbiAgICovXG4gIGVhY2goY2FsbGJhY2ssIHR5cGUpIHtcbiAgICBpZiAocGVyU3ViamVjdCA9PT0gdHJ1ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHN1YmogPSBzdGF0ZW1lbnRzW2ldLmdldFN1YmplY3QoKTtcbiAgICAgICAgY29uc3QgdCA9IHN1Ymouc3Vic3RyaW5nKDAsIDIpID09PSAnXzonID8gJ2Jub2RlJyA6ICd1cmknO1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsIHx8IHR5cGUgPT09IHQpIHtcbiAgICAgICAgICBjYWxsYmFjayhwZXJTdGF0ZW1lbnQoZ3JhcGgsIHN0YXRlbWVudHNbaV0sIHBlclN1YmplY3QpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY2FsbGJhY2socGVyU3RhdGVtZW50KGdyYXBoLCBzdGF0ZW1lbnRzW2pdLCBwZXJTdWJqZWN0KSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBub2Rlcyh0eXBlKSB7XG4gICAgY29uc3QgcmVzID0gW107XG4gICAgaWYgKHBlclN1YmplY3QgPT09IHRydWUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdWJqID0gc3RhdGVtZW50c1tpXS5nZXRTdWJqZWN0KCk7XG4gICAgICAgIGNvbnN0IHQgPSBzdWJqLnN1YnN0cmluZygwLCAyKSA9PT0gJ186JyA/ICdibm9kZScgOiAndXJpJztcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCB8fCB0eXBlID09PSB0KSB7XG4gICAgICAgICAgcmVzLnB1c2goeyB0eXBlOiB0LCB2YWx1ZTogc3RhdGVtZW50c1tpXS5nZXRTdWJqZWN0KCkgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzdGF0ZW1lbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICh0eXBlID09IG51bGwgfHwgdHlwZSA9PT0gc3RhdGVtZW50c1tqXS5nZXRUeXBlKCkpIHtcbiAgICAgICAgICByZXMucHVzaChzdGF0ZW1lbnRzW2pdLmdldE9iamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9LFxuICB2YWx1ZXModHlwZSkge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGlmIChwZXJTdWJqZWN0ID09PSB0cnVlKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0YXRlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc3ViaiA9IHN0YXRlbWVudHNbaV0uZ2V0U3ViamVjdCgpO1xuICAgICAgICBjb25zdCB0ID0gc3Viai5zdWJzdHJpbmcoMCwgMikgPT09ICdfOicgPyAnYm5vZGUnIDogJ3VyaSc7XG4gICAgICAgIGlmICh0eXBlID09IG51bGwgfHwgdHlwZSA9PT0gdCkge1xuICAgICAgICAgIHJlcy5wdXNoKHN0YXRlbWVudHNbaV0uZ2V0U3ViamVjdCgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHN0YXRlbWVudHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCB8fCB0eXBlID09PSBzdGF0ZW1lbnRzW2pdLmdldFR5cGUoKSkge1xuICAgICAgICAgIHJlcy5wdXNoKHN0YXRlbWVudHNbal0uZ2V0VmFsdWUoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfSxcbiAgZmlyc3RWYWx1ZSh0eXBlKSB7XG4gICAgaWYgKHBlclN1YmplY3QgPT09IHRydWUpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzdWJqID0gc3RhdGVtZW50c1tpXS5nZXRTdWJqZWN0KCk7XG4gICAgICAgIGNvbnN0IHQgPSBzdWJqLnN1YnN0cmluZygwLCAyKSA9PT0gJ186JyA/ICdibm9kZScgOiAndXJpJztcbiAgICAgICAgaWYgKHR5cGUgPT0gbnVsbCB8fCB0eXBlID09PSB0KSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHNbaV0uZ2V0U3ViamVjdCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc3RhdGVtZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICBpZiAodHlwZSA9PSBudWxsIHx8IHR5cGUgPT09IHN0YXRlbWVudHNbal0uZ2V0VHlwZSgpKSB7XG4gICAgICAgICAgcmV0dXJuIHN0YXRlbWVudHNbal0uZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9LFxufSk7XG5cbi8qKlxuICogUHJvdmlkZXMgYW4gQVBJIGZvciBhY2Nlc3NpbmcgYW5kIG1hbmlwdWxhdGluZyBhbiBSREYgR3JhcGguXG4gKlxuICogVGhlIEdyYXBoIEFQSSB3cmFwcyBhIHB1cmUgUkRGIEpTT04gb2JqZWN0IHRvIG1ha2UgaXQgZWFzeSB0byBhY2Nlc3MgYW5kIG1hbmlwdWxhdGUgb24gdGhlXG4gKiBsZXZlbCBvZiByZGZqc29uL1N0YXRlbWVudHMuXG4gKiBOb3RlIHRoYXQgZm9yIGVmZmljaWVuY3kgcmVhc29ucyB0aGUgUkRGIEpTT04gb2JqZWN0IHdpbGwgYmUgZXh0ZW5kZWQsIGhlbmNlIGl0IHdpbGxcbiAqIGNvbnRhaW4gYXR0cmlidXRlcyB0aGF0IGdvZXMgYmV5b25kIHRoZSBzcGVjaWZpY2F0aW9uLlxuICpcbiAqIFRoZSBwdXJlIFJERiBKU09OIG9iamVjdDpcbiAqIDx1bD48bGk+Y2FuIHN0aWxsIGJlIGluc3BlY3RlZCBpbmRlcGVuZGVudGx5LCBpdCB3aWxsIGNvbnRhaW4gdGhlIGNvcnJlY3QgUkRGIGV4cHJlc3Npb24uXG4gKiAgICAgPC9saT5cbiAqICAgICA8bGk+Y2Fubm90IGJlIG1vZGlmaWVkIGRpcmVjdGx5IHNpbmNlIGl0IHdpbGwgY29uZmxpY3Qgd2l0aCBtYW5pcHVsYXRpb25zIHZpYSB0aGlzXG4gKiAgICAgY2xhc3MsIHRoZSBleGNlcHRpb24gaXMgdGhlIHN0YXRlbWVudCBvYmplY3QgYXR0cmlidXRlcyB3aGljaCBjYW4gYmUgdXBkYXRlZC48L2xpPlxuICogICAgIDxsaT5pcyBub3cgdW5zdWl0YWJsZSB0byBiZSBjb21tdW5pY2F0ZWQgZm9yIGluc3RhbmNlIGJhY2sgdG8gYSBzZXJ2ZXIgc3RvcmFnZVxuICogICAgICBkdWUgdG8gdGhlIGV4dHJhIGF0dHJpYnV0ZXMuIFVzZSB0aGUgZXhwb3J0UkRGSlNPTiBmdW5jdGlvbiB0byBnZXQgYSBjbGVhbiBSREZcbiAqICAgICAgSlNPTiBvYmplY3QuPC9saT48L3VsPlxuICpcbiAqIEBleHBvcnRzIHJkZmpzb24vR3JhcGhcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JhcGgge1xuICAvKipcbiAgICogVGhlIGNvbnN0cnVjdG9yIGlzIHNoZWFwLCBubyBpbmRleGVzIG9yIGFkZGl0aW9uYWwgc3RhdGVtZW50cyBhcmUgY3JlYXRlZCB1bnRpbCByZXF1ZXN0ZWRcbiAgICogb3IgY3JlYXRlZC5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBncmFwaCBhIHB1cmUgUkRGIEpTT04gb2JqZWN0IGFjY29yZGluZyB0byB0aGUgc3BlY2lmaWNhdGlvbiB0aGF0IHdpbGwgYmVcbiAgICogbWFuaXB1bGF0ZWQgaW50ZXJuYWxseS5cbiAgICogQHBhcmFtIHtCb29sZWFuPX0gdmFsaWRhdGUgaW5kaWNhdGVzIHdldGhlciB0byB2YWxpZGF0ZSB0aGUgZ3JhcGggZGlyZWN0bHkgb3Igbm90LlxuICAgKi9cbiAgY29uc3RydWN0b3IoZ3JhcGggPSBudWxsLCB2YWxpZGF0ZSkge1xuICAgIHRoaXMuX2dyYXBoID0gZ3JhcGggfHwge307XG4gICAgLyoqXG4gICAgICogSW50ZXJuYWwgaW5kZXggb2YgYm5vZGVzLCB3aWxsIG5ldmVyIHNocmluayBhZnRlciBjcmVhdGlvbiBvZiB0aGlzIGdyYXBoIGluc3RhbmNlLlxuICAgICAqIE5ldyBibm9kZXMgd2lsbCBiZSBhZGRlZCBidXQgYm5vZGVzIGNvbnRhaW5lZCBpbiByZW1vdmVkIHN0YXRlbWVudHMgd2lsbCBiZSBrZXB0XG4gICAgICogaW4gY2FzZSB0aGUgc3RhdGVtZW50IGlzIG9ubHkgdGVtcG9yYXJpbHkgdW5hc3NlcnRlZC5cbiAgICAgKi9cbiAgICB0aGlzLl9ibm9kZXMgPSB7fTtcbiAgICAvKipcbiAgICAgKiBJZiB0cnVlIHRoZSBncmFwaCBoYXMgYmVlbiBpdGVyYXRlZCB0aHJvdWdoIGFuZCBhbGwgZm91bmQgYm5vZGVzIGhhdmUgYmVlbiBhZGRlZCB0byBpbmRleC5cbiAgICAgKi9cbiAgICB0aGlzLl9ibm9kZXNJbmRleGVkID0gZmFsc2U7XG5cbiAgICBpZiAodmFsaWRhdGUgIT09IGZhbHNlKSB7XG4gICAgICB0aGlzLnZhbGlkYXRlKCk7XG4gICAgfVxuICAgIHRoaXMuX2NoYW5nZWQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBncmFwaCBjb250YWlucyBubyBhc3NlcnRlZCBzdGF0ZW1lbnRzLlxuICAgKi9cbiAgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gIU9iamVjdC5rZXlzKHRoaXMuX2dyYXBoKS5maW5kKChzKSA9PiB7XG4gICAgICBjb25zdCBwcm9wcyA9IHRoaXMuX2dyYXBoW3NdO1xuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHByb3BzKS5maW5kKHAgPT5cbiAgICAgICAgcHJvcHNbcF0uZmluZChvID0+IG8uX3N0YXRlbWVudCA9PSBudWxsIHx8IG8uX3N0YXRlbWVudC5pc0Fzc2VydGVkKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjbGFzcy1tZXRob2RzLXVzZS10aGlzXG4gIG9uQ2hhbmdlKCkge1xuICB9XG5cbiAgc2V0Q2hhbmdlZChjaGFuZ2VkKSB7XG4gICAgdGhpcy5fY2hhbmdlZCA9ICEhKGNoYW5nZWQgPT09IHRydWUgfHwgY2hhbmdlZCA9PSBudWxsKTtcbiAgICBpZiAodGhpcy5fY2hhbmdlZCkge1xuICAgICAgdGhpcy5vbkNoYW5nZSgpO1xuICAgIH1cbiAgfVxuXG4gIGlzQ2hhbmdlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2hhbmdlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFsbCBzdGF0ZW1lbnRzIG9mIGEgZ3JhcGggdG8gdGhlIGN1cnJlbnQgZ3JhcGguXG4gICAqIFdpbGwgY3JlYXRlIG5ldyBibGFuayBub2RlcyBpZHMgaW4gdGhlIHNvdXJjZSBncmFwaCB0byBhdm9pZCBjbGFzaGVzIHdpdGggdGFyZ2V0IGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0gZ3JhcGhcbiAgICovXG4gIGFkZEFsbChncmFwaCwgbmcpIHtcbiAgICBjb25zdCBibm9kZUlkeCA9IHt9O1xuICAgIGxldCBibjtcbiAgICBjb25zdCBzdG10cyA9IGdyYXBoLmZpbmQoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0bXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdG10ID0gc3RtdHNbaV07XG4gICAgICBsZXQgcyA9IHN0bXQuZ2V0U3ViamVjdCgpO1xuICAgICAgbGV0IHAgPSBzdG10LmdldFByZWRpY2F0ZSgpO1xuICAgICAgY29uc3QgbyA9IHN0bXQuZ2V0Q2xlYW5PYmplY3QoKTtcbiAgICAgIGlmIChuZykge1xuICAgICAgICBvLm5nID0gbmc7XG4gICAgICB9XG5cbiAgICAgIGlmIChzLmluZGV4T2YoJ186JykgPT09IDApIHtcbiAgICAgICAgYm4gPSBibm9kZUlkeFtzXSB8fCB0aGlzLl9uZXdCTm9kZSgpO1xuICAgICAgICBibm9kZUlkeFtzXSA9IGJuO1xuICAgICAgICBzID0gYm47XG4gICAgICB9XG4gICAgICBpZiAocC5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICAgIGJuID0gYm5vZGVJZHhbcF0gfHwgdGhpcy5fbmV3Qk5vZGUoKTtcbiAgICAgICAgYm5vZGVJZHhbcF0gPSBibjtcbiAgICAgICAgcCA9IGJuO1xuICAgICAgfVxuICAgICAgaWYgKG8udHlwZSA9PT0gJ2Jub2RlJykge1xuICAgICAgICBibiA9IGJub2RlSWR4W28udmFsdWVdIHx8IHRoaXMuX25ld0JOb2RlKCk7XG4gICAgICAgIGJub2RlSWR4W28udmFsdWVdID0gYm47XG4gICAgICAgIG8udmFsdWUgPSBibjtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkKHMsIHAsIG8pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgc3RhdGVtZW50IHRvIHRoZSBncmFwaCwgZWl0aGVyIGFuIGV4aXN0aW5nIHN0YXRlbWVudCBvciBjcmVhdGVzIGFuIG5ldyBvbmUgZnJvbSB0aGVcbiAgICogdHJpcGxlIHBhdHRlcm4uIElmIGEgc3RhdGVtZW50IGluc3RhbmNlIGlzIHVzZWQgaXQgbWF5IG9yaWdpbmF0ZSBmcm9tIGFub3RoZXIgZ3JhcGgsIGFsdGhvdWdoXG4gICAqIHBvdGVudGlhbCBibm9kZXMgYXJlIG5vdCByZW5hbWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge3JkZmpzb24vU3RhdGVtZW50fHN0cmluZ30gcyBlaXRoZXIgdGhlIHN1YmplY3QgaW4gYSB0cmlwbGUgcGF0dGVybiBvciBhIFN0YXRlbWVudFxuICAgKiBpbnN0YW5jZSB0byBhZGQsXG4gICAqIGluIHRoZSBsYXR0ZXIgY2FzZSB0aGUgb3RoZXIgcGFyYW1ldGVycyBtdXN0IGJlIHVuZGVmaW5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gcCB0aGUgcHJlZGljYXRlIG9mIHRoZSB0cmlwbGUgdG8gYWRkLlxuICAgKiBAcGFyYW0ge09iamVjdHxzdHJpbmd9IG8gdGhlIG9iamVjdCB3aGVyZSB0aGUgYXR0cmlidXRlcyB0eXBlLCB2YWx1ZSwgbGFuZyBhbmQgZGF0YXR5cGUgYXJlXG4gICAqIHVzZWQgdG8gZGVzY3JpYmUgdGhlIG9iamVjdC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbc2lsZW50PWZhbHNlXSBzaWxlbnQgaWYgdGhlIGNoYW5nZSBzaG91bGQgbWFyayB0aGUgZ3JhcGggYXMgY2hhbmdlZFxuICAgKiBAcmV0dXJucyB7cmRmanNvbi9TdGF0ZW1lbnR9XG4gICAqL1xuICBhZGQocywgcCA9IG51bGwsIG8gPSBudWxsLCBzaWxlbnQgPSBmYWxzZSkge1xuICAgIGlmIChzIGluc3RhbmNlb2YgU3RhdGVtZW50KSB7XG4gICAgICBjb25zdCBfcCA9IHMuZ2V0UHJlZGljYXRlKCk7XG4gICAgICBjb25zdCBfbyA9IHMuZ2V0T2JqZWN0KCk7XG4gICAgICBjb25zdCBfcyA9IHMuZ2V0U3ViamVjdCgpO1xuICAgICAgdGhpcy5fdHJhY2tCTm9kZXMoX3MsIF9wLCBfbyk7XG4gICAgICBjb25zdCBvMSA9IHRoaXMuX2dyYXBoT2JqZWN0KF9vKTtcbiAgICAgIGNvbnN0IG8yID0gcmRmanNvblV0aWwuYWRkKHRoaXMuX2dyYXBoLCBfcywgX3AsIG8xKTtcbiAgICAgIGlmIChzaWxlbnQgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5zZXRDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fZ2V0KF9zLCBfcCwgbzIsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGUocywgcCwgbywgdHJ1ZSwgc2lsZW50KTtcbiAgfVxuXG4gIGFkZEwocywgcCwgdmFsdWUsIGxhbmcpIHtcbiAgICBjb25zdCBvID0geyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlIH07XG4gICAgaWYgKHR5cGVvZiBsYW5nID09PSAnc3RyaW5nJykge1xuICAgICAgby5sYW5nID0gbGFuZztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlKHMsIHAsIG8sIHRydWUpO1xuICB9XG5cbiAgYWRkRChzLCBwLCB2YWx1ZSwgZGF0YXR5cGUpIHtcbiAgICBjb25zdCBvID0geyB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlIH07XG4gICAgaWYgKHR5cGVvZiBkYXRhdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG8uZGF0YXR5cGUgPSBucy5leHBhbmQoZGF0YXR5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jcmVhdGUocywgcCwgbywgdHJ1ZSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBzdGF0ZW1lbnQgYW5kIGFzc29jaWF0ZXMgaXQgdG8gdGhlIGdyYXBoLCB1bmxlc3MgYXNzZXJ0IGlzIGV4cGxpY2l0bHkgc2V0IHRvXG4gICAqIGZhbHNlIGl0IGlzIGFsc28gYWRkZWQgdG8gdGhlIGdyYXBoLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IHMgdGhlIHN1YmplY3QgYXMgYSB1cmksIGlmIHVuZGVmaW5lZCBhIG5ldyBibGFuayBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwIHRoZSBwcmVkaWNhdGUgYXMgYSB1cmksIGlmIHVuZGVmaW5lZCBhIG5ldyBibGFuayBub2RlIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvIHRoZSBvYmplY3QgaW4gdGhlIGZvcm0gb2YgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGF0dHJpYnV0ZXM6XG4gICAqICd0eXBlJywgJ3ZhbHVlJywgJ2xhbmcnLCBhbmQgJ2RhdGF0eXBlJy4gSWYgdW5kZWZpbmVkIGEgbmV3IGJsYW5rIG5vZGUgaXMgY3JlYXRlZC5cbiAgICogIElmIGEgc3RyaW5nIGlzIHByb3ZpZGVkIGl0IGlzIGFzc3VtZWQgdG8gYmUgYSB1cmwsIGkuZS4gc2VuZGluZyBpbiBcInRoZSB1cmxcIiBpcyB0aGUgc2FtZSBhc1xuICAgKiAgc2VuZGluZyBpbiB7dHlwZTogXCJ1cmlcIiwgdmFsdWU6IFwidGhlIHVybFwifS5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbYXNzZXJ0PXRydWVdIGluZGljYXRlZCBpZiB0aGUgc3RhdGVtZW50IHNob3VsZCBiZSBhZGRlZCB0byB0aGUgZ3JhcGggZGlyZWN0bHkuXG4gICAqIElmIG5vdCBzcGVjaWZpZWQgdHJ1ZSBpcyBhc3N1bWVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHNpbGVudCBpZiB0aGUgY2hhbmdlIHNob3VsZCBtYXJrIHRoZSBncmFwaCBhcyBjaGFuZ2VkXG4gICAqIEByZXR1cm5zIHtyZGZqc29uL1N0YXRlbWVudH1cbiAgICogQHNlZSByZGZqc29uL3JkZmpzb24jYWRkXG4gICAqL1xuICBjcmVhdGUocyA9IG51bGwsIHAgPSBudWxsLCBvID0gbnVsbCwgYXNzZXJ0ID0gdHJ1ZSwgc2lsZW50ID0gZmFsc2UpIHtcbiAgICBsZXQgX3MgPSBzO1xuICAgIGxldCBfcCA9IHA7XG4gICAgbGV0IF9vID0gbztcbiAgICBpZiAoX3MgPT0gbnVsbCkge1xuICAgICAgX3MgPSB0aGlzLl9uZXdCTm9kZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBfcyA9IG5zLmV4cGFuZChfcyk7XG4gICAgfVxuICAgIGlmIChfcCA9PSBudWxsKSB7XG4gICAgICBfcCA9IHRoaXMuX25ld0JOb2RlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wID0gbnMuZXhwYW5kKF9wKTtcbiAgICB9XG5cbiAgICBpZiAoX28gPT0gbnVsbCkge1xuICAgICAgX28gPSB7IHR5cGU6ICdibm9kZScsIHZhbHVlOiB0aGlzLl9uZXdCTm9kZSgpIH07XG4gICAgfSBlbHNlIGlmIChyZGZqc29uVXRpbC5pc1N0cmluZyhfbykpIHtcbiAgICAgIF9vID0geyB0eXBlOiAndXJpJywgdmFsdWU6IG5zLmV4cGFuZChfbykgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG9iamVjdCBpcyBjb3BpZWQgdG8gYXZvaWQgcmV1c2Ugb2Ygc2FtZSBvYmplY3QgaW4gbXVsdGlwbGUgcGxhY2VzIG9mIHRoZSBncmFwaFxuICAgICAgLy8gbGVhZGluZyB0byBzdHJhbmdlIHVwZGF0ZXMuXG4gICAgICBfbyA9IHsgdHlwZTogX28udHlwZSwgdmFsdWU6IF9vLnZhbHVlLCBsYW5nOiBfby5sYW5nLCBkYXRhdHlwZTogX28uZGF0YXR5cGUgfTtcbiAgICAgIGlmIChfby50eXBlID09PSAndXJpJyAmJiBfby52YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIF9vLnZhbHVlID0gbnMuZXhwYW5kKF9vLnZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChfby5kYXRhdHlwZSkge1xuICAgICAgICBfby5kYXRhdHlwZSA9IG5zLmV4cGFuZChfby5kYXRhdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChhc3NlcnQgIT09IGZhbHNlKSB7XG4gICAgICBjb25zdCBvMSA9IHJkZmpzb25VdGlsLmFkZCh0aGlzLl9ncmFwaCwgX3MsIF9wLCBfbyk7XG4gICAgICBpZiAoc2lsZW50ICE9PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuc2V0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2dldE9yQ3JlYXRlKF9zLCBfcCwgbzEsIHRydWUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFN0YXRlbWVudCh0aGlzLCBfcywgX3AsIF9vLCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgZnVuY3Rpb24gdGhhdCBjb21iaW5lcyB0aGUgZmluZCBhbmQgcmVtb3ZlIGZ1bmN0aW9ucy5cbiAgICogQHBhcmFtIHtTdHJpbmc9fSBzIHRoZSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gcCB0aGUgcHJlZGljYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gbyB0aGUgb2JqZWN0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gc2lsZW50IGlmIHRoZSBjaGFuZ2Ugc2hvdWxkIG1hcmsgdGhlIGdyYXBoIGFzIGNoYW5nZWRcbiAgICogQHNlZSByZGZqc29uL0dyYXBoI2ZpbmRcbiAgICogQHNlZSByZGZqc29uL0dyYXBoI3JlbW92ZVxuICAgKi9cbiAgZmluZEFuZFJlbW92ZShzLCBwLCBvLCBzaWxlbnQgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0bXRzID0gdGhpcy5maW5kKHMsIHAsIG8pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RtdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMucmVtb3ZlKHN0bXRzW2ldLCBzaWxlbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBzdGF0ZW1lbnQgZnJvbSB0aGUgZ3JhcGguXG4gICAqIElmIHlvdSBwbGFuIHRvIGtlZXAgdGhlIHN0YXRlbWVudCBhcm91bmQgYW5kIGFzc2VydCBpdCBsYXRlcixcbiAgICogaXQgaXMgcmVjb21tZW5kZWQgdG8gb25seSB1c2UgdGhlIHJkZmpzb24vU3RhdGVtZW50I3NldEFzc2VydGVkIG1ldGhvZCBpbnN0ZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge3JkZmpzb24vU3RhdGVtZW50fSBzdGF0ZW1lbnQgdGhlIHN0YXRlbWVudCB0byByZW1vdmUgZnJvbSB0aGUgZ3JhcGguXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3NpbGVudD1mYWxzZV0gc2lsZW50IGlmIHRoZSBjaGFuZ2Ugc2hvdWxkIG1hcmsgdGhlIGdyYXBoIGFzIGNoYW5nZWRcbiAgICogQHNlZSByZGZqc29uL1N0YXRlbWVudCNzZXRBc3NlcnRlZFxuICAgKi9cbiAgcmVtb3ZlKHN0YXRlbWVudCwgc2lsZW50ID0gZmFsc2UpIHtcbiAgICBjb25zdCBzID0gc3RhdGVtZW50LmdldFN1YmplY3QoKTtcbiAgICBjb25zdCBwID0gc3RhdGVtZW50LmdldFByZWRpY2F0ZSgpO1xuICAgIGNvbnN0IG8gPSBzdGF0ZW1lbnQuZ2V0T2JqZWN0KCk7XG4gICAgdGhpcy5fdHJhY2tCTm9kZXMocywgcCwgbyk7XG4gICAgaWYgKHJkZmpzb25VdGlsLnJlbW92ZSh0aGlzLl9ncmFwaCwgcywgcCwgbykgIT0gbnVsbCkge1xuICAgICAgaWYgKHNpbGVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnNldENoYW5nZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIHN0YXRlbWVudHMgdGhhdCBmdWxmaWxscyB0aGUgZ2l2ZW4gcGF0dGVybi4gQW55IGNvbWJpbmF0aW9uIG9mIHRoZSBhcmd1bWVudHMgbWF5XG4gICAqIGJlIGxlZnQgb3V0LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IHMgdGhlIHN1YmplY3QgaW4gdGhlIHN0YXRlbWVudHMgdG8gYmUgcmV0dXJuZWQsIHVuZGVmaW5lZCBpbmRpY2F0ZXMgdGhhdFxuICAgKiBhbnkgc3ViamVjdCBpcyBvay5cbiAgICogQHBhcmFtIHtTdHJpbmc9fSBwIHRoZSBwcmVkaWNhdGUgaW4gdGhlIHN0YXRlbWVudHMgdG8gYmUgcmV0dXJuZWQsIHVuZGVmaW5lZCBpbmRpY2F0ZXNcbiAgICogdGhhdCBhbnkgcHJlZGljYXRlIGlzIG9rLlxuICAgKiBAcGFyYW0ge09iamVjdD19IG8gdGhlIG9iamVjdCBpbiB0aGUgc3RhdGVtZW50cyB0byBiZSByZXR1cm5lZCwgdW5kZWZpbmVkIGluZGljYXRlcyB0aGF0XG4gICAqIGFueSBvYmplY3QgaXMgb2suXG4gICAqIE9iamV0cyBvZiBtYXRjaGluZyBzdGF0ZW1lbnRzIGhhdmUgdG8gYmUgZXF1YWwgYWNjb3JkaW5nIHRvIHRoZSBvYmplY3RFcXVhbHMgbWV0aG9kLlxuICAgKiBAcmV0dXJuIHtyZGZqc29uL1N0YXRlbWVudFtdfVxuICAgKiBAc2VlIHJkZmpzb24vcmRmanNvbiNvYmplY3RFcXVhbHNcbiAgICovXG4gIGZpbmQocywgcCwgbykge1xuICAgIGxldCBfcyA9IHM7XG4gICAgbGV0IF9wID0gcDtcbiAgICBsZXQgX28gPSBvO1xuICAgIC8vIG5vbmUsIHMsIHAsIHMmcFxuICAgIGlmICh0eXBlb2YgX3MgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfcyA9IG5zLmV4cGFuZChfcyk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICBfcCA9IG5zLmV4cGFuZChfcCk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgX28gPT09ICdvYmplY3QnICYmIF9vICE9PSBudWxsICYmIF9vLnR5cGUgPT09ICd1cmknKSB7XG4gICAgICBfby52YWx1ZSA9IG5zLmV4cGFuZChfby52YWx1ZSk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgX28gPT09ICdzdHJpbmcnKSB7XG4gICAgICBfbyA9IHsgdHlwZTogJ3VyaScsIHZhbHVlOiBucy5leHBhbmQoX28pIH07XG4gICAgfVxuICAgIGlmIChfbyA9PSBudWxsKSB7XG4gICAgICAvLyBub25lLCBzXG4gICAgICBpZiAoX3AgPT0gbnVsbCkge1xuICAgICAgICBpZiAoX3MgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9maW5kKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRTKF9zKTtcblxuICAgICAgICAvLyBwLCBzJnBcbiAgICAgIH1cbiAgICAgIC8vIHBcbiAgICAgIGlmIChfcyA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9maW5kUChfcCk7XG4gICAgICAgIC8vIHMmcFxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRTUChfcywgX3ApO1xuICAgIH1cbiAgICAvLyBvLCBzJm9cbiAgICBpZiAoX3AgPT0gbnVsbCkge1xuICAgICAgaWYgKF9zID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRPKF9vKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9maW5kU08oX3MsIF9vKTtcbiAgICB9XG5cbiAgICAvLyBwJm9cbiAgICBpZiAoX3MgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRQTyhfcCwgX28pO1xuICAgIH1cblxuICAgIC8vIHMmcCZvXG4gICAgY29uc3Qgc3RtdCA9IHRoaXMuX2dldChfcywgX3AsIHJkZmpzb25VdGlsLmNvbnRhaW5zKHRoaXMuX2dyYXBoLCBfcywgX3AsIF9vKSwgdHJ1ZSk7XG4gICAgaWYgKHN0bXQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gW3N0bXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IHJldHVybnMgdGhlIHZhbHVlIG9mIG9iamVjdCBvZiB0aGUgZmlyc3QgbWF0Y2hpbmcgU3RhdGVtZW50XG4gICAqIGZvciB0aGUgZ2l2ZW4gc3ViamVjdCBhbmQgcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZz19IHMgdGhlIHN1YmplY3RcbiAgICogQHBhcmFtIHtTdHJpbmc9fSBwIHRoZSBwcmVkaWNhdGVcbiAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgdmFsdWUsIG1heSBiZSBhIGxpdGVyYWwgb3IgYSBVUkksIGlmIHVuZGVmaW5lZCBubyBtYXRjaGluZyBzdGF0ZW1lbnRcbiAgICogKGFuZCB2YWx1ZSkgY291bGQgYmUgZm91bmQuXG4gICAqIEBzZWUgcmRmanNvbi9HcmFwaCNmaW5kXG4gICAqL1xuICBmaW5kRmlyc3RWYWx1ZShzLCBwKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5maW5kKHMsIHApO1xuICAgIGlmIChhcnIubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGFyclswXS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIHByb2plY3Rpb24sIGEgcGxhaW4gb2JqZWN0IHdpdGggc2ltcGxlIGF0dHJpYnV0ZSB2YWx1ZSBwYWlycyBnaXZlbiBhIHN1YmplY3RcbiAgICogYW5kIGEgbWFwcGluZy5cbiAgICogVGhlIG1hcHBpbmcgaXMgYW4gb2JqZWN0IHdoZXJlIHRoZSBzYW1lIGF0dHJpYnV0ZXMgYXBwZWFyIGJ1dCB3aXRoIHRoZSBwcmVkaWNhdGVzIGFyZSB2YWx1ZXMuXG4gICAqIEhlbmNlLCBlYWNoIGF0dHJpYnV0ZSBnaXZlcyByaXNlIHRvIGEgc2VhcmNoIGZvciBhbGwgc3RhdGVtZW50cyB3aXRoIHRoZSBnaXZlbiBzdWJqZWN0IGFuZFxuICAgKiB0aGUgcHJlZGljYXRlIHNwZWNpZmllZCBieSB0aGUgYXR0cmlidXRlLlxuICAgKiBUaGUgcmVzdWx0IG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIG1hcHBpbmcgYXR0cmlidXRlcyB3aXRoIHZhbHVlcyBmcm9tIHRoZSB0aGUgZmlyc3RcbiAgICogbWF0Y2hlZCBzdGF0ZW1lbnRzIG9iamVjdCB2YWx1ZSBpZiB0aGVyZSBhcmUgYW55LlxuICAgKiBUbyBhY2Nlc3MgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiBsaWtlIG11bHRpcGxlIHN0YXRlbWVudCBvciB0aGUgc3RhdGVtZW50c1xuICAgKiAodHlwZSwgbGFuZ3VhZ2UsIGRhdGF0eXBlKSBhIFwiKlwiIHByZXBlbmRlZCB2ZXJzaW9uIG9mIGVhY2ggYXR0cmlidXRlIGNhbiBiZSBwcm92aWRlZCB0aGF0XG4gICAqIGNvbnRhaW5zIGEgbGlzdCBvZiBtYXRjaGluZyBTdGF0ZW1lbnRzIGlmIHNvIGluZGljYXRlZCBieSB0aGUgbXVsdGlwbGVWYWx1ZVN0eWxlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHMgdGhlIHN1YmplY3QgdG8gdXNlIGZvciB0aGUgcHJvamVjdGlvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IG1hcHBpbmcgdGhlIG1hcHBpbmcgY29uZmlndXJhdGlvblxuICAgKiBAcGFyYW0ge1N0cmluZ30gbXVsdGlwbGVWYWx1ZVN0eWxlIGlmIHByb3ZpZGVkIGFuIGFycmF5IGlzIHByb3ZpZGVkIGZvciB0aGF0IHByb3BlcnR5XG4gICAqIHByZWZpeGVkIHdpdGggXCIqXCIsIHRoZSBhcnJheSBzaG91bGQgYmUgaW5kaWNhdGVkIHRvIGJlIGVpdGhlclxuICAgKiBcInN0YXRlbWVudHNcIiwgXCJ2YWx1ZXNcIiBvciBcIm9iamVjdHNcIi5cbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICogQGV4YW1wbGVcbiAgICogdmFyIHByb2ogPSBncmFwaC5wcm9qZWN0aW9uKFwiaHR0cDovL2V4YW1wbGUuY29tXCIsIHtcbiAgICogICAgIFwidGl0bGVcIjogICAgICAgXCJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvdGl0bGVcIixcbiAgICogICAgIFwiZGVzY3JpcHRpb25cIjogXCJodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvZGVzY3JpcHRpb25cIlxuICAgKiB9KTtcbiAgICogLy8gVGhlIG9iamVjdCBwcm9qIG5vdyBoYXMgdGhlIGF0dHJpYnV0ZXMgdGl0bGUsICp0aXRsZSwgZGVzY3JpcHRpb24sIGFuZCAqZGVzY3JpcHRpb24uXG4gICAqXG4gICAqIC8vIEFjY2Vzc2luZyB0aGUgdGl0bGUgb2YgaHR0cDovL2V4YW1wbGUuY29tXG4gICAqIGNvbnNvbGUubG9nKHByb2oudGl0bGUpO1xuICAgKlxuICAgKiAvLyBUbyBnZXQgaG9sZCBvZiBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIGF2YWlsYWJsZSBpbiB0aGUgc3RhdGVtZW50LFxuICAgKiAvLyBmb3IgaW5zdGFuY2UgdGhlIGxhbmd1YWdlIG9mIGEgbGl0ZXJhbDpcbiAgICogY29uc29sZS5sb2cocHJvaltcIip0aXRsZVwiXVswXS5nZXRMYW5ndWFnZSgpKVxuICAgKlxuICAgKi9cbiAgcHJvamVjdGlvbihzLCBtYXBwaW5nLCBtdWx0aXBsZVZhbHVlU3R5bGUpIHtcbiAgICBjb25zdCBtYXBwZWQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhtYXBwaW5nKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGNvbnN0IHByb3AgPSBtYXBwaW5nW2tleV07XG4gICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLmZpbmQocywgcHJvcCk7XG4gICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgaWYgKGtleVswXSA9PT0gJyonKSB7XG4gICAgICAgICAgbWFwcGVkW2tleS5zdWJzdHIoMSldID0gdmFsdWVzLm1hcCh2YWwgPT4gdmFsLmdldFZhbHVlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hcHBlZFtrZXldID0gdmFsdWVzWzBdLmdldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChtdWx0aXBsZVZhbHVlU3R5bGUgfHwgJ25vbmUnKSB7XG4gICAgICAgICAgY2FzZSAnc3RhdGVtZW50JzpcbiAgICAgICAgICAgIG1hcHBlZFtgKiR7a2V5fWBdID0gdmFsdWVzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnb2JqZWN0cyc6XG4gICAgICAgICAgICBtYXBwZWRbYCoke2tleX1gXSA9IHZhbHVlcy5tYXAodiA9PiB2LmdldENsZWFuT2JqZWN0KCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndmFsdWVzJzpcbiAgICAgICAgICAgIG1hcHBlZFtgKiR7a2V5fWBdID0gdmFsdWVzLm1hcCh2ID0+IHYuZ2V0VmFsdWUoKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcHBlZDtcbiAgfVxuXG4gIHN1YmplY3RzKHAsIG8pIHtcbiAgICByZXR1cm4gcGVyU3RhdGVtZW50KHRoaXMsIHRoaXMuZmluZChudWxsLCBwLCBvKSwgdHJ1ZSk7XG4gIH1cblxuICBzdWJqZWN0KHAsIG8pIHtcbiAgICByZXR1cm4gcGVyU3RhdGVtZW50KHRoaXMsIHplcm9Pck9uZSh0aGlzLmZpbmQobnVsbCwgcCwgbykpLCB0cnVlKTtcbiAgfVxuXG4gIG9iamVjdHMocywgcCkge1xuICAgIHJldHVybiBwZXJTdGF0ZW1lbnQodGhpcywgdGhpcy5maW5kKHMsIHAsIG51bGwpKTtcbiAgfVxuXG4gIG9iamVjdChzLCBwKSB7XG4gICAgcmV0dXJuIHBlclN0YXRlbWVudCh0aGlzLCB6ZXJvT3JPbmUodGhpcy5maW5kKHMsIHAsIG51bGwpKSk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgcmRmOkxpc3QgZm9yIHRoZSBwcm92aWRlZCBhcnJheS5cbiAgICogQHBhcmFtIHthcnJheX0gbGlzdCBhbiBhcnJheSBvZiBvYmplY3RzLCBzYW1lIGFzIHRoZSBvYmplY3QgcGFyYW1ldGVyIHRvIHRoZSBhZGQgbWV0aG9kLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgYmxhbmsgbm9kZSBpZCwgb3IgcmRmOm5pbCBpZiB0aGUgbGlzdCBpcyBlbXB0eVxuICAgKi9cbiAgYWRkTGlzdChsaXN0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2FkZExpc3QobGlzdCwgJ2FkZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSByZGY6TGlzdCBmb3IgdGhlIHByb3ZpZGVkIGFycmF5IG9mIGxpdGVyYWxzIHdpdGggdGhlIGNvbW1vbiBsYW5ndWFnZS5cbiAgICogQHBhcmFtIHthcnJheVtzdHJpbmddfSBhbiBhcnJheSBvZiBsaXRlcmFscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRoZSBsYW5ndWFnZSBjb21tb24gdG8gYWxsIHRoZSBsaXRlcmFscyBpbiB0aGUgYXJyYXlcbiAgICogKGlmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQgeW91IGhhdmUgdG8gdXNlIHRoZSBhZGRMaXN0IG1ldGhvZCB3aXRoIG9iamVjdHMgaW5zdGVhZCkuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBibGFuayBub2RlIGlkLCBvciByZGY6bmlsIGlmIHRoZSBsaXN0IGlzIGVtcHR5XG4gICAqL1xuICBhZGRMaXN0TChsaXN0LCBsYW5ndWFnZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRMaXN0KGxpc3QsICdhZGRMJywgbGFuZ3VhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSByZGY6TGlzdCBmb3IgdGhlIHByb3ZpZGVkIGFycmF5IG9mIGxpdGVyYWxzIHdpdGggdGhlIGNvbW1vbiBkYXRhdHlwZS5cbiAgICogQHBhcmFtIHthcnJheVtzdHJpbmddfSBhbiBhcnJheSBvZiBsaXRlcmFscy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRoZSBkYXRhdHlwZSBjb21tb24gdG8gYWxsIHRoZSBsaXRlcmFscyBpbiB0aGUgYXJyYXlcbiAgICogKGlmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQgeW91IGhhdmUgdG8gdXNlIHRoZSBhZGRMaXN0IG1ldGhvZCB3aXRoIG9iamVjdHMgaW5zdGVhZCkuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBibGFuayBub2RlIGlkLCBvciByZGY6bmlsIGlmIHRoZSBsaXN0IGlzIGVtcHR5XG4gICAqL1xuICBhZGRMaXN0RChsaXN0LCBkYXRhdHlwZSkge1xuICAgIHJldHVybiB0aGlzLl9hZGRMaXN0KGxpc3QsICdhZGREJywgZGF0YXR5cGUpO1xuICB9XG5cbiAgX2FkZExpc3QobGlzdCwgbWV0aG9kLCBsYW5nb3JEYXRhdHlwZSkge1xuICAgIGxldCBsaXN0bm9kZTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkgfHwgbGlzdC5sZW5ndGggPT09IDApIHtcbiAgICAgIGxpc3Rub2RlID0gbnMuZXhwYW5kKCdyZGY6bmlsJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Rub2RlID0gdGhpcy5fbmV3Qk5vZGUoKTtcbiAgICAgIGxldCBjdXJzb3IgPSBsaXN0bm9kZTtcbiAgICAgIGNvbnN0IG5pbFBvc2l0aW9uID0gbGlzdC5sZW5ndGggLSAxO1xuICAgICAgbGlzdC5mb3JFYWNoKChtZW1iZXIsIGlkeCkgPT4ge1xuICAgICAgICB0aGlzW21ldGhvZF0oY3Vyc29yLCAncmRmOmZpcnN0JywgbWVtYmVyLCBsYW5nb3JEYXRhdHlwZSk7XG4gICAgICAgIGlmIChpZHggIT09IG5pbFBvc2l0aW9uKSB7XG4gICAgICAgICAgY3Vyc29yID0gdGhpcy5hZGQoY3Vyc29yLCAncmRmOnJlc3QnKS5nZXRWYWx1ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkKGN1cnNvciwgJ3JkZjpyZXN0JywgJ3JkZjpuaWwnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0bm9kZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCB0cmlwcGxlcyB0aGF0IG1ha2VzIHVwIHRoZSBsaXN0IHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIHJlc291cmNlLlxuICAgKiBAcGFyYW0gbyAtIHRoZSByZXNvdXJjZSBmcm9tIHdoaWNoIHRoZSBsaXN0IHN0YXJ0cy5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgbGlzdCB3YXMgaWRlbnRpZmVkIGFzIGEgdmFsaWQgbGlzdCBhbmQgcmVtb3ZlZC5cbiAgICovXG4gIHJlbW92ZUxpc3Qobykge1xuICAgIGxldCBsaXN0Rm91bmQgPSBmYWxzZTtcbiAgICBsZXQgY3Vyc29yID0gdHlwZW9mIG8gPT09ICdvYmplY3QnID8gby52YWx1ZSA6IG87XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5pbCA9IG5zLmV4cGFuZCgncmRmOm5pbCcpO1xuICAgICAgbGlzdEZvdW5kID0gY3Vyc29yID09PSBuaWw7XG4gICAgICB3aGlsZSAoY3Vyc29yICE9PSBuaWwgJiYgY3Vyc29yICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuZmluZEZpcnN0VmFsdWUoY3Vyc29yLCAncmRmOnJlc3QnKTtcbiAgICAgICAgdGhpcy5maW5kQW5kUmVtb3ZlKGN1cnNvcik7XG4gICAgICAgIGN1cnNvciA9IG5leHQ7XG4gICAgICAgIGxpc3RGb3VuZCA9IGN1cnNvciAhPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBsaXN0IGZvciBvYmplY3Q6ICR7Y3Vyc29yfWApO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdEZvdW5kO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSByZGY6TGlzdCBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG8gLSB0aGUgZmlyc3QgcmVzb3VyY2Ugbm9kZSBvZiB0aGUgKGxpbmtlZCkgbGlzdC5cbiAgICogQHJldHVybnMge0FycmF5fSBvZiBvYmplY3RzICh0aGUgc2FtZSBhcyBpcyByZXR1cm5lZCBmcm9tIFN0YXRlbWVudC5nZXRPYmplY3QoKSlcbiAgICovXG4gIGdldExpc3Qobykge1xuICAgIGxldCBjdXJzb3IgPSB0eXBlb2YgbyA9PT0gJ29iamVjdCcgPyBvLnZhbHVlIDogbztcbiAgICBjb25zdCBsaXN0ID0gW107XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IG5pbCA9IG5zLmV4cGFuZCgncmRmOm5pbCcpO1xuICAgICAgd2hpbGUgKGN1cnNvciAhPT0gbmlsICYmIGN1cnNvciAhPSBudWxsKSB7XG4gICAgICAgIGxpc3QucHVzaCh0aGlzLmZpbmQoY3Vyc29yLCAncmRmOmZpcnN0JylbMF0uZ2V0T2JqZWN0KCkpO1xuICAgICAgICBjdXJzb3IgPSB0aGlzLmZpbmRGaXJzdFZhbHVlKGN1cnNvciwgJ3JkZjpyZXN0Jyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS53YXJuKGBJbnZhbGlkIGxpc3QgZm9yIG9iamVjdDogJHtjdXJzb3J9YCk7XG4gICAgfVxuICAgIHJldHVybiBsaXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBmaXJzdCBsaXN0IHRvIGJlIGZvdW5kIGdpdmVuIGEgc3ViamVjdCBhbmQgcHJlZGljYXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcyAtIHRoZSBzdWJqZWN0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwIC0gdGhlIHByZWRpY2F0ZVxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119IGFycmF5IG9mIHN0cmluZ3MsIGFzc3VtaW5nIHRoZSBub2RldHlwZSwgZGF0YXR5cGUgb3JcbiAgICogbGFuZ3VhZ2UgaXMgZWl0aGVyIG5vdCBwcmVzZW50IG9yIHZpdGFsLlxuICAgKi9cbiAgZmluZEZpcnN0TGlzdEFzVmFsdWVzKHMsIHApIHtcbiAgICByZXR1cm4gdGhpcy5nZXRMaXN0KHRoaXMuZmluZEZpcnN0VmFsdWUocywgcCkpLm1hcChvYmogPT4gb2JqLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbmQgcmVtb3ZlcyBhbGwgbWF0Y2hlZCBsaXN0cyBpbmNsdWRpbmcgdGhlIHRyaXBsZXMgcG9pbnRpbmcgdG8gdGhlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHMgLSB0aGUgc3ViamVjdFxuICAgKiBAcGFyYW0ge3N0cmluZ30gcCAtIHRoZSBwcmVkaWNhdGVcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiBhdCBsZWFzdCBvbmUgbGlzdCB3YXMgcmVtb3ZlZFxuICAgKi9cbiAgZmluZEFuZFJlbW92ZUxpc3RzKHMsIHApIHtcbiAgICBsZXQgcmVtb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuZmluZChzLCBwKS5mb3JFYWNoKChzdG10KSA9PiB7XG4gICAgICBpZiAodGhpcy5yZW1vdmVMaXN0KHN0bXQuZ2V0VmFsdWUoKSkpIHtcbiAgICAgICAgdGhpcy5yZW1vdmUoc3RtdCk7XG4gICAgICAgIHJlbW92ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZW1vdmVkO1xuICB9XG5cblxuICAvKipcbiAgICogQHJldHVybiB7T2JqZWN0fSBhIHBsYWluIFJERiBKU09OIG9iamVjdCB3aXRob3V0IHRoZSBhZGRpdGlvbmFsIGFydGlmYWN0cyBjcmVhdGVkIGJ5IHRoaXNcbiAgICogR3JhcGggY2xhc3MuXG4gICAqIFRoZSByZXR1cm5lZCBvYmplY3QgaXMgc3VpdGFibGUgZm9yIHNlcmlsaXphdGlvbiBhbmQgY29tbXVuaWNhdGVkIHdpdGggb3RoZXIgc3lzdGVtcy5cbiAgICovXG4gIGV4cG9ydFJERkpTT04oKSB7XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLl9ncmFwaDtcbiAgICBjb25zdCBuZ3JhcGggPSB7fTtcbiAgICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3Qgc3ViaiA9IGdyYXBoW3NdO1xuICAgICAgbmdyYXBoW3NdID0ge307XG4gICAgICBPYmplY3Qua2V5cyhzdWJqKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICAgIGNvbnN0IG5PYmpBcnIgPSBbXTtcbiAgICAgICAgbmdyYXBoW3NdW3BdID0gbk9iakFycjtcbiAgICAgICAgc3VialtwXS5mb3JFYWNoKChvKSA9PiB7XG4gICAgICAgICAgY29uc3Qgbm8gPSB7IHR5cGU6IG8udHlwZSwgdmFsdWU6IG8udmFsdWUgfTtcbiAgICAgICAgICBpZiAoby5uZyAhPSBudWxsKSB7XG4gICAgICAgICAgICBuby5uZyA9IG8ubmc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvLmxhbmcgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm8ubGFuZyA9IG8ubGFuZztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG8uZGF0YXR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgbm8uZGF0YXR5cGUgPSBvLmRhdGF0eXBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBuT2JqQXJyLnB1c2gobm8pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBuZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBVUkkgaW4gc3ViamVjdCBwb3NpdGlvbiB3aXRoIGFub3RoZXIsXG4gICAqIGFzc3VtaW5nIHRoZSB0YXJnZXQgVVJJIGRvZXMgbm90IGV4aXN0IGluIHRoZSBncmFwaCBhbHJlYWR5LlxuICAgKlxuICAgKiBAcGFyYW0gc291cmNlVVJJXG4gICAqIEBwYXJhbSB0YXJnZXRVUklcbiAgICogQHJldHVybnMge0dyYXBofVxuICAgKiBAZGVwcmVjYXRlZCBVc2UgcmVwbGFjZVVSSSBpbnN0ZWFkLlxuICAgKi9cbiAgcmVwbGFjZVN1YmplY3Qoc291cmNlVVJJLCB0YXJnZXRVUkkpIHtcbiAgICByZXR1cm4gdGhpcy5yZXBsYWNlVVJJKHNvdXJjZVVSSSwgdGFyZ2V0VVJJKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2NjdXJlbmNlcyBvZiBhIFVSSSBpbiB0aGUgZ3JhcGggd2l0aCBhbm90aGVyIFVSSS5cbiAgICogQXNzdW1lcyB0aGUgdGFyZ2V0IFVSSSBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZ3JhcGggYWxyZWFkeS5cbiAgICpcbiAgICogQHBhcmFtIHNvdXJjZVVSSVxuICAgKiBAcGFyYW0gdGFyZ2V0VVJJXG4gICAqIEByZXR1cm5zIHtHcmFwaH1cbiAgICovXG4gIHJlcGxhY2VVUkkoc291cmNlVVJJLCB0YXJnZXRVUkkpIHtcbiAgICBjb25zdCBncmFwaCA9IHRoaXMuX2dyYXBoO1xuICAgIGlmIChncmFwaC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VVUkkpKSB7XG4gICAgICBpZiAoIWdyYXBoLmhhc093blByb3BlcnR5KCh0YXJnZXRVUkkpKSkge1xuICAgICAgICBncmFwaFt0YXJnZXRVUkldID0gZ3JhcGhbc291cmNlVVJJXTtcbiAgICAgICAgZGVsZXRlIGdyYXBoW3NvdXJjZVVSSV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXBsYWNlIHN1YmplY3Qgd2l0aCB0YXJnZXQgVVJJIHNpbmNlIGl0IGFscmVhZHkgZXhpc3RzLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvckVhY2goKHMsIHAsIG8pID0+IHtcbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ3VyaScgJiYgby52YWx1ZSA9PT0gc291cmNlVVJJKSB7XG4gICAgICAgICAgby52YWx1ZSA9IHRhcmdldFVSSTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocyA9PT0gdGFyZ2V0VVJJICYmIG8uX3N0YXRlbWVudCkge1xuICAgICAgICAgIG8uX3N0YXRlbWVudC5fcyA9IHRhcmdldFVSSTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICByZXBsYWNlQmxhbmtXaXRoVVJJKHNvdXJjZUJsYW5rLCB0YXJnZXRVUkkpIHtcbiAgICBjb25zdCBncmFwaCA9IHRoaXMuX2dyYXBoO1xuICAgIGlmIChncmFwaC5oYXNPd25Qcm9wZXJ0eShzb3VyY2VCbGFuaykpIHtcbiAgICAgIGlmICghZ3JhcGguaGFzT3duUHJvcGVydHkoKHRhcmdldFVSSSkpKSB7XG4gICAgICAgIGdyYXBoW3RhcmdldFVSSV0gPSBncmFwaFtzb3VyY2VCbGFua107XG4gICAgICAgIGRlbGV0ZSBncmFwaFtzb3VyY2VCbGFua107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCByZXBsYWNlIHN1YmplY3Qgd2l0aCB0YXJnZXQgVVJJIHNpbmNlIGl0IGFscmVhZHkgZXhpc3RzLicpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmZvckVhY2goKHMsIHAsIG8pID0+IHtcbiAgICAgICAgaWYgKG8udHlwZSA9PT0gJ2Jub2RlJyAmJiBvLnZhbHVlID09PSBzb3VyY2VCbGFuaykge1xuICAgICAgICAgIG8udmFsdWUgPSB0YXJnZXRVUkk7XG4gICAgICAgICAgby50eXBlID0gJ3VyaSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMgPT09IHRhcmdldFVSSSAmJiBvLl9zdGF0ZW1lbnQpIHtcbiAgICAgICAgICBvLl9zdGF0ZW1lbnQuX3MgPSB0YXJnZXRVUkk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZWxldGUgdGhpcy5fYm5vZGVzW3NvdXJjZUJsYW5rXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsb25lcyB0aGlzIGdyYXBoLlxuICAgKiBAcmV0dXJucyB7cmRmanNvbi9HcmFwaH1cbiAgICovXG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgR3JhcGgodGhpcy5leHBvcnRSREZKU09OKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBwcm9wZXJ0aWVzIGZvciBhIGdpdmVuIHN1YmplY3QuXG4gICAqIE5vdGU6IE9wdGltYWwuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzIHRoZSBzdWJqZWN0IHRvIGZpbmQgcHJvcGVydGllcyBmb3JcbiAgICogQHJldHVybiB7QXJyYXlbU3RyaW5nXX0gb2Ygc3RyaW5nc1xuICAgKi9cbiAgZmluZFByb3BlcnRpZXMocykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9ncmFwaFtzXSB8fCB7fSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGVzIHRoZSBncmFwaCBhbmQgcmV0dXJucyBhIHJlcG9ydC5cbiAgICogSWYgZXJyb3JzIGFyZSBkZXRlY3RlZCBhbiBleGNlcHRpb24gaXMgdGhyb3duLlxuICAgKiBUaGUgdmFsaWRhdGlvbiByZXBvcnQgaXMgYSBvYmplY3Qgd2l0aCBhIHZhbGlkIGF0dHJpYnV0ZSB3aGljaCBpcyBlaXRoZXIgZmFsc2Ugb3IgdHJ1ZS5cbiAgICogSWYgaXQgaXMgZmFsc2UgYW4gYXJyYXkgb2YgZXJyb3JzIGFyZSBwcm92aWRlZCB3aGVyZSBlYWNoIGVycm9yIGlzIGFuIG9iamVjdCBjb250YWluaW5nXG4gICAqIGEgbWVzc2FnZSBhbmQgaW5mb3JtYXRpb24gcmVnYXJkaW5nIHdoaWNoIHN1YmplY3QscHJlZGljYXRlIGFuZCBvYmplY3QgaW5kZXggaW4gdGhlXG4gICAqIHJkanNvbiBqYXZhc2NyaXB0IG9iamVjdCB0aGF0IGNhdXNlZCB0aGUgZXJyb3IuLlxuICAgKlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfSBpZiB0aGVyZSB3aGVyZSBubyBlcnJvcnNcbiAgICogQHRocm93cyB7T2JqZWN0fSB0aGUgdmFsaWRhdGlvbiByZXBvcnQuXG4gICAqL1xuICB2YWxpZGF0ZSgpIHtcbiAgICB0aGlzLnJlcG9ydCA9IHRoaXMuX3ZhbGlkYXRlKCk7XG4gICAgaWYgKCF0aGlzLnJlcG9ydC52YWxpZCkge1xuICAgICAgdGhyb3cgKHRoaXMucmVwb3J0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVwb3J0O1xuICB9XG5cbiAgLyoqXG4gICAqIFlvdSBzaG91bGQgbm90IHVzZSB0aGlzIGZ1bmN0aW9uIHVubGVzcyB5b3UgYXJlIFZFUlkgY2VydGFpbiBvZiB3aGF0IHlvdSBhcmUgZG9pbmcuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBiTm9kZUlkXG4gICAqL1xuICByZWdpc3RlckJOb2RlKGJOb2RlSWQpIHtcbiAgICB0aGlzLl9ibm9kZXNbYk5vZGVJZF0gPSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIHN0YXRlbWVudHMgb2YgdGhlIGdyYXBoIGFuZCBjYWxscyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb24gdGhlbS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBhcmUgY2FsbGVkIGZvciBlYWNoIHN0YXRlbWVudCB3aXRoIHRoZSB0aHJlZSBhcmd1bWVudHNcbiAgICogIChpbiBvcmRlcikgc3ViamVjdCwgcHJlZGljYXRlLCBhbmQgb2JqZWN0LlxuICAgKi9cbiAgZm9yRWFjaChmKSB7XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLl9ncmFwaDtcbiAgICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3Qgc3ViaiA9IGdyYXBoW3NdO1xuICAgICAgT2JqZWN0LmtleXMoc3ViaikuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBzdWJqW3BdLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICBmKHMsIHAsIG8pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIHN0YXRlbWVudHMgb2YgdGhlIGdyYXBoIGFuZCBjYWxscyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gb24gdGhlbSBhbmRcbiAgICogcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgcmVzdWx0cy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZiBhcmUgY2FsbGVkIGZvciBlYWNoIHN0YXRlbWVudCB3aXRoIHRoZSB0aHJlZSBhcmd1bWVudHNcbiAgICogIChpbiBvcmRlcikgc3ViamVjdCwgcHJlZGljYXRlLCBhbmQgb2JqZWN0LCBmIHNob3VsZCByZXR1cm4gYSB2YWx1ZSB0aGF0IGlzIGFkZGVkIHRvIHRoZVxuICAgKiAgYXJyYXlcbiAgICogQHJldHVybiB7YXJyYXl9IGFuIGFycmF5IHdpdGggdGhlIHZhbHVlIG9mIHRoZSBmdW5jdGlvbiBhcHBsaWVkIGZvciBlYWNoIHN0YXRlbWVudC5cbiAgICovXG4gIG1hcChmKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgdGhpcy5mb3JFYWNoKChzdG10KSA9PiB7XG4gICAgICBhcnIucHVzaChmKHN0bXQpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXBhcmVzIHRoaXMgZ3JhcGggd2l0aCBhbm90aGVyLCB0cnVlIGlmIHRoZXkgYXJlIGlzb21vcnBoaWMuXG4gICAqIENvbXBhcmlzaW9uIGlzIGRvbmUgdXNpbmcgdGhlIGZpbmdlcnByaW50IG1lY2hhbmlzbS4gSGVuY2UsIHRoaXMgbWV0aG9kIGlzIG5vdCBmdWxscHJvb2YuXG4gICAqXG4gICAqIEBwYXJhbSB7cmRmanNvbi9HcmFwaH0gZ3JhcGggdG8gY29tcGFyZSB0b1xuICAgKiBAcGFyYW0ge2FycmF5fSBleGNsdWRlUHJvcGVydGllcyBhbiBhcnJheSBvZiBwcm9wZXJ0aWVzIHRvIGV4Y2x1ZGUgaW4gY29tcGFyaXNpb24gY2hlY2tcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gdHJ1ZSBpZiB0aGUgZ3JhcGhzIGFyZSBpc29tb3JwaGljIGRpc3JlZ2FyZGluZyB0aGUgZXhjbHVkZWQgcHJvcGVydGllcy5cbiAgICogQHNlZSB7cmRmanNvbi91dGlscyNmaW5nZXJwcmludH1cbiAgICovXG4gIGVxdWFscyhncmFwaCwgZXhjbHVkZVByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4gdXRpbHMuZmluZ2VycHJpbnQodGhpcywgZXhjbHVkZVByb3BlcnRpZXMpID09PSB1dGlscy5maW5nZXJwcmludChncmFwaCwgZXhjbHVkZVByb3BlcnRpZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIGFtb3VudHMgb2YgdHJpcGxlcyBpbiB0aGUgZ3JhcGguXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBzaXplKCkge1xuICAgIGxldCBzaXplID0gMDtcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuX2dyYXBoKS5mb3JFYWNoKChzdWJqT2JqKSA9PiB7XG4gICAgICBPYmplY3QudmFsdWVzKHN1YmpPYmopLmZvckVhY2goKG9iamVjdHMpID0+IHtcbiAgICAgICAgc2l6ZSArPSBvYmplY3RzLmxlbmd0aDtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBzaXplO1xuICB9XG5cbiAgLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gIC8vIFByaXZhdGUgbWV0aG9kc1xuICAvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuICAvKipcbiAgICogSWYgdGhlIG9iamVjdCBhbHJlYWR5IGNvbnRhaW5zIGEgc3RhdGVtZW50IHRoYXQgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBhIG5ldyBpcyBjcmVhdGVkLlxuICAgKiBJZiB0aGUgb2JqZWN0IGlzIG5vdCBzcGVjaWZpZWQgdW5kZWZpbmVkIGlzIHJldHVybmVkLlxuICAgKiBAcmV0dXJuIHtTdGF0ZW1lbnR8dW5kZWZpbmVkfSBhIHN0YXRlbWVudCB0aGF0IGJlbG9uZ3MgdG8gdGhpcyBncmFwaC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXQocywgcCwgbywgYXNzZXJ0ZWQpIHtcbiAgICBpZiAobyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9nZXRPckNyZWF0ZShzLCBwLCBvLCBhc3NlcnRlZCk7XG4gIH1cblxuICAvKipcbiAgICogSWYgdGhlIG9iamVjdCBhbHJlYWR5IGNvbnRhaW5zIGEgc3RhdGVtZW50IHRoYXQgaXMgcmV0dXJuZWQsIG90aGVyd2lzZSBhIG5ldyBpcyBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtyZGZqc29uL1N0YXRlbWVudH0gYSBzdGF0ZW1lbnQgdGhhdCBiZWxvbmdzIHRvIHRoaXMgZ3JhcGguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0T3JDcmVhdGUocywgcCwgbywgYXNzZXJ0ZWQpIHtcbiAgICBpZiAoby5fc3RhdGVtZW50ID09IG51bGwpIHtcbiAgICAgIG8uX3N0YXRlbWVudCA9IG5ldyBTdGF0ZW1lbnQodGhpcywgcywgcCwgbywgYXNzZXJ0ZWQpO1xuICAgIH1cbiAgICByZXR1cm4gby5fc3RhdGVtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge09iamVjdH0gaWYgdGhlIG9iamVjdCBvcmlnaW5hdGVzIGZyb20gYW5vdGhlciBncmFwaCBhIGNvcHkgaXMgbWFkZS5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9ncmFwaE9iamVjdChvKSB7XG4gICAgaWYgKG8uX3N0YXRlbWVudCA9PSBudWxsIHx8XG4gICAgICBvLl9zdGF0ZW1lbnQuX2dyYXBoID09PSB0aGlzKSB7XG4gICAgICByZXR1cm4gbztcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogby50eXBlLCB2YWx1ZTogby52YWx1ZSwgbGFuZzogby5sYW5nLCBkYXRhdHlwZTogby5kYXRhdHlwZSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBzdGF0ZW1lbnRzIHdpdGggYSBnaXZlbiBzdWJqZWN0IGFuZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwXG4gICAqIEByZXR1cm5zIHtyZGZqc29uL1N0YXRlbWVudFtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmRTUChzLCBwKSB7XG4gICAgaWYgKHRoaXMuX2dyYXBoW3NdID09IG51bGwgfHwgdGhpcy5fZ3JhcGhbc11bcF0gPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZ3JhcGhbc11bcF0ubWFwKG8gPT4gdGhpcy5fZ2V0KHMsIHAsIG8sIHRydWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbGwgc3RhdGVtZW50cyB3aXRoIGEgZ2l2ZW4gc3ViamVjdC5cbiAgICogTm90ZTogT3B0aW1hbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNcbiAgICogQHJldHVybnMge3JkZmpzb24vU3RhdGVtZW50W119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZmluZFMocykge1xuICAgIGNvbnN0IHN1YmogPSB0aGlzLl9ncmFwaFtzXTtcbiAgICBjb25zdCBzcEFycnMgPSBPYmplY3Qua2V5cyhzdWJqIHx8IHt9KS5tYXAocCA9PiB0aGlzLl9maW5kU1AocywgcCkpO1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUuY29uY2F0LmFwcGx5KFtdLCBzcEFycnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBzdGF0ZW1lbnRzIGZvciB0aGUgZW50aXJlIGdyYXBoLlxuICAgKiBOb3RlOiBPcHRpbWFsLlxuICAgKiBAcmV0dXJucyB7cmRmanNvbi9TdGF0ZW1lbnRbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9maW5kKCkge1xuICAgIGNvbnN0IGFyciA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaCgoczEsIHAxLCBvMSkgPT4ge1xuICAgICAgYXJyLnB1c2godGhpcy5fZ2V0KHMxLCBwMSwgbzEsIHRydWUpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFsbCBzdGF0ZW1lbnRzIHdpdGggYSBnaXZlbiBwcmVkaWNhdGUuXG4gICAqIE5vdGU6IENsb3NlIHRvIG9wdGltYWwgd2l0aG91dCBmdXJ0aGVyIGluZGV4aW5nLCB0byBtYW55IGNoZWNrcyBkdWUgdG8gaXRlcmF0aW9uIHZpYSBfbWFwLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcFxuICAgKiBAcmV0dXJucyB7cmRmanNvbi9TdGF0ZW1lbnRbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9maW5kUChwKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgdGhpcy5mb3JFYWNoKChzMSwgcDEsIG8xKSA9PiB7XG4gICAgICBpZiAocCA9PT0gcDEpIHtcbiAgICAgICAgYXJyLnB1c2godGhpcy5fZ2V0KHMxLCBwMSwgbzEsIHRydWUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYXJyO1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIHRocm91Z2ggYWxsIHN0YXRlbWVudHMgdG8gZmluZCB0aG9zZSB3aXRoIHNwZWNpZmllZCBvYmplY3QuXG4gICAqIE5vdGU6IE9wdGltYWwgd2l0aG91dCBhZGRpdGlvbmFsIGluZGV4aW5nLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb1xuICAgKiBAcmV0dXJucyB7cmRmanNvbi9TdGF0ZW1lbnRbXX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9maW5kTyhvKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgdGhpcy5mb3JFYWNoKChzMSwgcDEsIG8xKSA9PiB7XG4gICAgICBpZiAocmRmanNvblV0aWwub2JqZWN0RXF1YWxzKG8sIG8xKSkge1xuICAgICAgICBhcnIucHVzaCh0aGlzLl9nZXQoczEsIHAxLCBvMSwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIHN0YXRlbWVudHMgd2l0aCBhIGdpdmVuIHN1YmplY3QgYW5kIG9iamVjdC5cbiAgICogTm90ZTogQ2xvc2UgdG8gb3B0aW1hbCB3aXRob3V0IGZ1cnRoZXIgaW5kZXhpbmcsIHRvIG1hbnkgY2hlY2tzIGR1ZSB0byBpdGVyYXRpb24gdmlhIF9tYXAuXG4gICAqIEByZXR1cm5zIHtyZGZqc29uL1N0YXRlbWVudFtdfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmRTTyhzLCBvKSB7XG4gICAgY29uc3QgYXJyID0gW107XG4gICAgdGhpcy5mb3JFYWNoKChzMSwgcDEsIG8xKSA9PiB7XG4gICAgICBpZiAocyA9PT0gczEgJiYgcmRmanNvblV0aWwub2JqZWN0RXF1YWxzKG8sIG8xKSkge1xuICAgICAgICBhcnIucHVzaCh0aGlzLl9nZXQoczEsIHAxLCBvMSwgdHJ1ZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBhcnI7XG4gIH1cblxuICAvKipcbiAgICogRmluZHMgYWxsIHN0YXRlbWVudHMgd2l0aCBhIGdpdmVuIHByZWRpY2F0ZSBhbmQgb2JqZWN0LlxuICAgKiBOb3RlOiBDbG9zZSB0byBvcHRpbWFsIHdpdGhvdXQgZnVydGhlciBpbmRleGluZywgdG8gbWFueSBjaGVja3MgZHVlIHRvIGl0ZXJhdGlvbiB2aWEgX21hcC5cbiAgICogQHJldHVybnMge3JkZmpzb24vU3RhdGVtZW50W119XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZmluZFBPKHAsIG8pIHtcbiAgICBjb25zdCBhcnIgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goKHMxLCBwMSwgbzEpID0+IHtcbiAgICAgIGlmIChwID09PSBwMSAmJiByZGZqc29uVXRpbC5vYmplY3RFcXVhbHMobywgbzEpKSB7XG4gICAgICAgIGFyci5wdXNoKHRoaXMuX2dldChzMSwgcDEsIG8xLCB0cnVlKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3ZhbGlkYXRlKCkge1xuICAgIGNvbnN0IGdyYXBoID0gdGhpcy5fZ3JhcGg7XG4gICAgY29uc3QgcmVwb3J0ID0geyB2YWxpZDogdHJ1ZSwgZXJyb3JzOiBbXSwgbnI6IDAgfTtcbiAgICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgY29uc3Qgc3ViaiA9IGdyYXBoW3NdO1xuICAgICAgaWYgKHJkZmpzb25VdGlsLmlzT2JqZWN0KHN1YmopKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHN1YmopLmZvckVhY2goKHApID0+IHtcbiAgICAgICAgICBjb25zdCBvYmpBcnIgPSBzdWJqW3BdO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9iakFycikpIHtcbiAgICAgICAgICAgIG9iakFyci5mb3JFYWNoKChvLCBvaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHJkZmpzb25VdGlsLmlzT2JqZWN0KG8pKSB7XG4gICAgICAgICAgICAgICAgaWYgKG8udHlwZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBpZiAocmRmanNvblV0aWwuaXNTdHJpbmcoby52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0Lm5yICs9IDE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXBvcnQuZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICAgICAgcCxcbiAgICAgICAgICAgICAgICAgICAgICBvaW5kZXg6IChvaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgT2JqZWN0ICR7b2luZGV4ICsgMX0gaW4gb2JqZWN0IGFycmF5IG11c3QgaGF2ZSB0aGUgJ3ZhbHVlJyBhdHRyaWJ1dGUgcG9pbnRpbmcgdG8gYSBzdHJpbmcuYFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmVwb3J0LnZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlcG9ydC5lcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICAgIHAsXG4gICAgICAgICAgICAgICAgICAgIG9pbmRleDogKG9pbmRleCArIDEpLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgT2JqZWN0ICR7b2luZGV4ICsgMX0gaW4gb2JqZWN0IGFycmF5IGxhY2tzIHRoZSBhdHRyaWJ1dGUgdHlwZSwgbXVzdCBiZSBlaXRoZXIgJ2xpdGVyYWwnLCAncmVzb3VyY2UnIG9yICdibm9kZScuYFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICByZXBvcnQudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVwb3J0LmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHMsXG4gICAgICAgICAgICAgICAgICBwLFxuICAgICAgICAgICAgICAgICAgb2luZGV4OiAob2luZGV4ICsgMSksXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiBgRWxlbWVudCAke29pbmRleCArIDF9IGluIG9iamVjdCBhcnJheSBpcyBub3QgYW4gb2JqZWN0LmBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXBvcnQudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlcG9ydC5lcnJvcnMucHVzaCh7IHMsIHAsIG1lc3NhZ2U6ICdQcmVkaWNhdGUgbXVzdCBwb2ludCB0byBhbiBhcnJheSBvZiBvYmplY3RzLicgfSk7XG4gICAgICAgICAgICByZXBvcnQudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVwb3J0LmVycm9ycy5wdXNoKHsgcywgbWVzc2FnZTogJ1N1YmplY3QgbXVzdCBwb2ludCB0byBhbiBvYmplY3QuJyB9KTtcbiAgICAgICAgcmVwb3J0LnZhbGlkID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlcG9ydDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGJub2RlIHRoYXQgaXMgdW5pcXVlIGluIHRoZSBjdXJyZW50IGdyYXBoLlxuICAgKiBCbm9kZXMgaW4gdGVtcG9yYXJpbHkgdW5hc3NlcnRlZCBzdGF0ZW1lbnRzIChjdXJyZW50bHkgcmVtb3ZlZCBmcm9tIHRoZSBncmFwaClcbiAgICogYXJlIGF2b2lkZWQgYXMgd2VsbC5cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9uZXdCTm9kZSgpIHtcbiAgICB0aGlzLl9pbmRleEJOb2RlcygpO1xuICAgIGxldCBwO1xuICAgIGxldCBuO1xuICAgIGxldCBibm9kZTtcbiAgICBmb3IgKHAgPSAxOyBwIDwgMjA7IHArKykge1xuICAgICAgZm9yIChuID0gMTsgbiA8PSBwOyBuKyspIHtcbiAgICAgICAgYm5vZGUgPSBgXzoke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChNYXRoLnBvdygxMCwgcCkgKyAxKSl9YDtcbiAgICAgICAgaWYgKHRoaXMuX2Jub2Rlc1tibm9kZV0gIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLl9ibm9kZXNbYm5vZGVdID0gdHJ1ZTtcbiAgICAgICAgICByZXR1cm4gYm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgY3JlYXRpbmcgYSBuZXcgYmxhbmsgbm9kZSwgaW5jcmVhZGlibGUgdW5wcm9iYWJsZS4uLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGhlIGJub2RlcyBpbiB0aGUgZ3JhcGggdG8gdGhlIGJub2RlIGluZGV4LlxuICAgKiBUaGUgaW5kZXggY2FuIGJlIGNhbGN1bGF0ZWQgbGF0ZSwganVzdCBiZWZvcmUgdGhlIGZpcnN0IGNhbGwgdG8gY3JlYXRlLlxuICAgKiAoQm5vZGVzIGluIHN0YXRlbWVudHMgdGhhdCBhcmUgcmVtb3ZlZCBhcmUgYWRkZWQgaW4gYWR2YW5jZSB0byB0aGUgaW5kZXggYXNcbiAgICogdGhleSBtYXkgYmUgb25seSB0ZW1wb3JhcmlseSB1bmFzc2VydGVkIGFuZCB3aGVuIHRoZXkgYXJlIGFzc2VydGVkIGFnYWluXG4gICAqIHRoZXkgc2hvdWxkIG5vdCBvdmVybGFwIHdpdGggbmV3bHkgY3JlYXRlZCBibm9kZXMuKVxuICAgKiBBZnRlciB0aGUgaW5kZXggaXMgY3JlYXRlZCBhbGwgc3RhdGVtbnRzIGFkZGVkIHVwZGF0ZSB0aGUgaW5kZXguXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfaW5kZXhCTm9kZXMoKSB7XG4gICAgaWYgKHRoaXMuX2Jub2Rlc0luZGV4ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZ3JhcGggPSB0aGlzLl9ncmFwaDtcbiAgICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaCgocykgPT4ge1xuICAgICAgaWYgKHMuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9ibm9kZXNbc10gPSB0cnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3ViaiA9IGdyYXBoW3NdO1xuICAgICAgT2JqZWN0LmtleXMoc3ViaikuZm9yRWFjaCgocCkgPT4ge1xuICAgICAgICBpZiAocC5pbmRleE9mKCdfOicpID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fYm5vZGVzW3BdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdWJqW3BdLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICBpZiAoby50eXBlID09PSAnYm5vZGUnKSB7XG4gICAgICAgICAgICB0aGlzLl9ibm9kZXNbby52YWx1ZV0gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9ibm9kZXNJbmRleGVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGFueSBibm9kZXMgaW4gdGhlIGdpdmVuIHBhcmFtZXRlcnMgdG8gdGhlIGluZGV4ICh0aGUgaW5kZXggbWF5IHN0aWxsIGJlIGluY29tcGxldGUpLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcyB0aGUgc3ViamVjdCBpbiBhIHN0YXRlbWVudC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHAgdGhlIHByZWRpY2F0ZSBpbiBhIHN0YXRlbWVudC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG8gdGhlIG9iamVjdCBpbiBhIHN0YXRlbWVudC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF90cmFja0JOb2RlcyhzLCBwLCBvKSB7XG4gICAgaWYgKHMuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgdGhpcy5fYm5vZGVzW3NdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHAuaW5kZXhPZignXzonKSA9PT0gMCkge1xuICAgICAgdGhpcy5fYm5vZGVzW3BdID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG8udHlwZSA9PT0gJ2Jub2RlJykge1xuICAgICAgdGhpcy5fYm5vZGVzW28udmFsdWVdID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG4iLCJpbXBvcnQgbnMgZnJvbSAnLi9uYW1lc3BhY2VzJztcblxuLyoqXG4gKiByZGZqc29uLlN0YXRlbWVudCBSZXByZXNlbnRzIGEgc3RhdGVtZW50IGluIGEgZ3JhcGguXG4gKiBOZXZlciBjcmVhdGUgZGlyZWN0bHksIHVzZSB0aGUgbWV0aG9kcyBpbiByZGZqc29uLkdyYXBoLlxuICogQ29uc3RydWN0cyBhIHN0YXRlbWVudCBmcm9tIHRoZSBwcm92aWRlZCBwYXJ0cywgdGhlIG9iamVjdCBpcyBhc3N1bWVkIHRvIGJlIHRoZSBzYW1lXG4gKiBhY3R1YWwgamF2YXNjcmlwdCBvYmplY3QgYXMgaXMgdXNlZCBpbiB0aGUgZ3JhcGguXG4gKlxuICogQGV4cG9ydHMgcmRmanNvbi9TdGF0bWVudFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0ZW1lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHtyZGZqc29uL0dyYXBofSBncmFwaCB0aGUgcmRmanNvbi5HcmFwaCB3ZSB3aWxsIG1hbmlwdWxhdGUuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzIHRoZSBzdWJqZWN0IGluIHRoZSBzdGF0ZW1lbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHAgdGhlIHByZWRpY2F0ZSBpbiB0aGUgc3RhdGVtZW50LlxuICAgKiBAcGFyYW0ge09iamVjdH0gbyB0aGUgb2JqZWN0IGluIHRoZSBzdGF0ZW1lbnQuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNzZXJ0ZWQgaW5kaWNhdGVzIGlmIHRoZSBzdGF0ZW1lbnQgaXMgYXNzZXJ0ZWQgaW4gdGhlIGFjY29tcGFuaWVkIGdyYXBoLlxuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGNvbnN0cnVjdG9yKGdyYXBoLCBzLCBwLCBvLCBhc3NlcnRlZCkge1xuICAgIHRoaXMuX2dyYXBoID0gZ3JhcGg7XG4gICAgdGhpcy5fcyA9IHM7XG4gICAgdGhpcy5fcCA9IHA7XG4gICAgdGhpcy5fbyA9IG87XG4gICAgdGhpcy5fby5fc3RhdGVtZW50ID0gdGhpcztcbiAgICB0aGlzLl9hc3NlcnRlZCA9IGFzc2VydGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBHcmFwaCB0aGlzIFN0YXRlbWVudCBpcyBhc3NvY2lhdGVkIHdpdGguXG4gICAqIEByZXR1cm5zIHtyZGZqc29uLkdyYXBofVxuICAgKi9cbiAgZ2V0R3JhcGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIEFuIGFzc2VydGVkIHN0YXRlbWVudCBpcyBwcmVzZW50IGluIGl0cyBhc3NvY2lhdGVkIEdyYXBoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gYXNzZXJ0ZWRcbiAgICovXG4gIHNldEFzc2VydGVkKGFzc2VydGVkKSB7XG4gICAgaWYgKGFzc2VydGVkICE9PSB0aGlzLl9hc3NlcnRlZCkge1xuICAgICAgaWYgKGFzc2VydGVkKSB7XG4gICAgICAgIHRoaXMuX2dyYXBoLmFkZCh0aGlzLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdGhpcy5fc2lsZW50VmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZ3JhcGgucmVtb3ZlKHRoaXMsIHRoaXMuX3NpbGVudFZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2Fzc2VydGVkID0gYXNzZXJ0ZWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRydWUgaWYgdGhlIFN0YXRlbWVudCBpcyBhc3NlcnRlZCBpbiB0aGUgR3JhcGguXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgaXNBc3NlcnRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXNzZXJ0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN1YmplY3Qgb2YgdGhpcyBzdGF0ZW1lbnQuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRTdWJqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLl9zO1xuICB9XG5cbiAgaXNTdWJqZWN0QmxhbmsoKSB7XG4gICAgaWYgKHRoaXMuX3NJc0JsYW5rICE9PSB0cnVlICYmIHRoaXMuX3NJc0JsYW5rICE9PSBmYWxzZSkge1xuICAgICAgdGhpcy5fc0lzQmxhbmsgPSB0aGlzLl9zLmluZGV4T2YoJ186JykgPT09IDA7XG4gICAgICAvLyB0aGlzLl9zSXNCbGFuayA9IHRoaXMuX2dyYXBoLl9ibm9kZXNbdGhpcy5fc10gPT09IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9zSXNCbGFuaztcbiAgfVxuXG4gIGlzT2JqZWN0QmxhbmsoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpID09PSAnYm5vZGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHN1YmplY3Qgb2YgdGhpcyBzdGF0ZW1lbnQsIG90aGVyIFN0YXRlbWVudHMgd2l0aCB0aGlzIHJlc291cmNlIGFzIHN1YmplY3Qgb3Igb2JqZWN0XG4gICAqIGlzIG5vdCBhZmZlY3RlZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHMgbXVzdCBiZSBhIHZhbGlkIFVSSS5cbiAgICovXG4gIHNldFN1YmplY3Qocykge1xuICAgIHRoaXMuX3NpbGVudFZhbHVlID0gZmFsc2U7XG4gICAgY29uc3QgX3MgPSBucy5leHBhbmQocyk7XG4gICAgaWYgKHRoaXMuX2Fzc2VydGVkKSB7XG4gICAgICB0aGlzLl9ncmFwaC5yZW1vdmUodGhpcyk7XG4gICAgICB0aGlzLl9zID0gX3M7XG4gICAgICB0aGlzLl9ncmFwaC5hZGQodGhpcyk7XG4gICAgICBkZWxldGUgdGhpcy5fc0lzQmxhbms7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3MgPSBfcztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHByZWRpY2F0ZSBvZiB0aGlzIFN0YXRlbWVudC5cbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldFByZWRpY2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVkaWNhdGUgb2YgdGhpcyBzdGF0ZW1lbnQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwIG11c3QgYmUgYSB2YWxpZCBVUkkuXG4gICAqL1xuICBzZXRQcmVkaWNhdGUocCkge1xuICAgIHRoaXMuX3NpbGVudFZhbHVlID0gZmFsc2U7XG4gICAgY29uc3QgX3AgPSBucy5leHBhbmQocCk7XG4gICAgaWYgKHRoaXMuX2Fzc2VydGVkKSB7XG4gICAgICB0aGlzLl9ncmFwaC5yZW1vdmUodGhpcyk7XG4gICAgICB0aGlzLl9wID0gX3A7XG4gICAgICB0aGlzLl9ncmFwaC5hZGQodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3AgPSBfcDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9XG4gICAqL1xuICBnZXROYW1lZEdyYXBoKCkge1xuICAgIHJldHVybiB0aGlzLl9vLm5nO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBuZ1xuICAgKi9cbiAgc2V0TmFtZWRHcmFwaChuZykge1xuICAgIHRoaXMuX28ubmcgPSBuZztcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb2JqZWN0IG9mIHRoZSBTdGF0ZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXRPYmplY3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX287XG4gIH1cblxuXG5cbiAgLyoqXG4gICAqIFRoZSBvYmplY3Qgb2YgdGhlIFN0YXRlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIGdldENsZWFuT2JqZWN0KCkge1xuICAgIGNvbnN0IF9vID0gdGhpcy5fbztcbiAgICBjb25zdCBvID0ge1xuICAgICAgdmFsdWU6IF9vLnZhbHVlLFxuICAgICAgdHlwZTogX28udHlwZSxcbiAgICB9O1xuICAgIGlmICh0aGlzLl9vLm5nKSB7XG4gICAgICBvLm5nID0gX28ubmc7XG4gICAgfVxuICAgIGlmIChfby5sYW5nKSB7XG4gICAgICBvLmxhbmcgPSBfby5sYW5nO1xuICAgIH1cbiAgICBpZiAodGhpcy5fby5kYXRhdHlwZSkge1xuICAgICAgby5kYXRhdHlwZSA9IF9vLmRhdGF0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBvbmUgb2YgdXJpLCBibm9kZSBhbmQgbGl0ZXJhbFxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fby50eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIG11c3QgYmUgb25lIG9mIHVyaSwgYm5vZGUgYW5kIGxpdGVyYWwuXG4gICAqL1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzLGNsYXNzLW1ldGhvZHMtdXNlLXRoaXNcbiAgc2V0VHlwZSh0eXBlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDaGFuZ2luZyB0aGUgdHlwZSBvZiBhbiBvYmplY3QgaXMgbm90IHN1cHBvcnRlZCwgY3JlYXRlIGEgbmV3JyArXG4gICAgICAnIHN0YXRlbWVudCBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHR5cGUgaXMgdXJpIGl0IGlzIGEgVVJJLCBpZiB0eXBlIGlzIGEgbGl0ZXJhbCBpdCBpcyB0aGUgbGl0ZXJhbCBzdHJpbmcuXG4gICAqIElmIHR5cGUgaXMgYSBibm9kZSB0aGUgdmFsdWUgaXMgYSBpbnRlcm5hbCBibm9kZSBpZGVudGl0eSwgc2hvdWxkIG9ubHkgYmUgdXNlZCBmb3JcbiAgICogcmVmZXJlbmNlcyB3aXRoaW4gdGhlIGN1cnJlbnQgZ3JhcGguXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fby52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSB1cmksIGxpdGVyYWwgb3IgYm5vZGUgb2YgdGhlIGN1cnJlbnQgU3RhdGVtZW50IGRlcGVuZGluZyBvbiB0aGUgdHlwZS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIG11c3QgYmUgYSB1cmkgaWYgdGhlIHR5cGUgc28gaW5kaWNhdGVzLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtzaWxlbnQ9ZmFsc2VdIHRoZSBncmFwaCBpcyBub3QgbWFya2VkIGFzIFwiY2hhbmdlZFwiIGlmIHNldCB0byB0cnVlXG4gICAqL1xuICBzZXRWYWx1ZSh2YWx1ZSwgc2lsZW50ID0gZmFsc2UpIHtcbiAgICB0aGlzLl9zaWxlbnRWYWx1ZSA9IHNpbGVudCA9PT0gdHJ1ZTtcbiAgICBpZiAodmFsdWUgIT09IHRoaXMuX28udmFsdWUpIHtcbiAgICAgIHRoaXMuX28udmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLmlzQXNzZXJ0ZWQoKSAmJiBzaWxlbnQgIT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5fZ3JhcGguc2V0Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBhIGxhbmd1YWdlIGV4cHJlc3NlZCB1c2luZyBSRkMtMzA2NlxuICAgKi9cbiAgZ2V0TGFuZ3VhZ2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX28ubGFuZztcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBsYW5ndWFnZSBvZiB0aGUgb2JqZWN0LCBvbmx5IGFjY2VwdGFibGUgaWYgdGhlIHR5cGUgaXMgbGl0ZXJhbC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGxhbmcgdGhlIGxhbmd1YWdlIGV4cHJlc3NlZCB1c2luZyBSRkMtMzAtNjZcbiAgICovXG4gIHNldExhbmd1YWdlKGxhbmcsIHNpbGVudCkge1xuICAgIHRoaXMuX3NpbGVudFZhbHVlID0gc2lsZW50ID09PSB0cnVlO1xuICAgIGlmICh0aGlzLl9vLnR5cGUgIT09ICdsaXRlcmFsJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc2V0IHRoZSBsYW5ndWFnZSBmb3IgYSByZXNvdXJjZSwgaGFzIHRvIGJlIGEgbGl0ZXJhbCcpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fby5sYW5nICE9PSBsYW5nKSB7XG4gICAgICB0aGlzLl9vLmxhbmcgPSBsYW5nO1xuICAgICAgaWYgKHRoaXMuaXNBc3NlcnRlZCgpICYmIHNpbGVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9ncmFwaC5zZXRDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkYXRhdHlwZSBvZiB0aGlzIG9iamVjdCwgb25seSBhY2NlcHRhYmxlIGlmIHRoZSB0eXBlIGlzIGxpdGVyYWwuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBkYXRhdHlwZSBpcyBhbHdheXMgcmVwcmVzZW50ZWQgdmlhIGEgVVJJLlxuICAgKi9cbiAgZ2V0RGF0YXR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX28uZGF0YXR5cGU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSBkYXRhdHlwZSwgb25seSBhY2NlcHRhYmxlIGlmIHRoZSB0eXBlIGlzIGxpdGVyYWwgYW5kIG5vIGxhbmd1YWdlIGlzIHNldC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGF0eXBlIHRoZSBkYXRhdHlwZSBleHByZXNzZWQgYXMgYSBVUkkuXG4gICAqL1xuICBzZXREYXRhdHlwZShkYXRhdHlwZSwgc2lsZW50KSB7XG4gICAgdGhpcy5fc2lsZW50VmFsdWUgPSBzaWxlbnQgPT09IHRydWU7XG4gICAgaWYgKHRoaXMuX28udHlwZSAhPT0gJ2xpdGVyYWwnIHx8IHRoaXMuX28ubGFuZyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgdGhlIGRhdGF0eXBlIGZvciBhIHJlc291cmNlLCBoYXMgdG8gYmUgYSBsaXRlcmFsJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vLmRhdGF0eXBlICE9PSBkYXRhdHlwZSkge1xuICAgICAgdGhpcy5fby5kYXRhdHlwZSA9IGRhdGF0eXBlO1xuICAgICAgaWYgKHRoaXMuaXNBc3NlcnRlZCgpICYmIHNpbGVudCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLl9ncmFwaC5zZXRDaGFuZ2VkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuIiwiaW1wb3J0IHhtbGRvbSBmcm9tICd4bWxkb20nO1xuaW1wb3J0IEdyYXBoIGZyb20gJy4uL0dyYXBoJztcbmltcG9ydCBucyBmcm9tICcuLi9uYW1lc3BhY2VzJztcbmltcG9ydCB1dGlsIGZyb20gJy4vcmRmanNvbi91dGlsJztcbmltcG9ydCBSZGZwYXJzZXIgZnJvbSAnLi9yZGZ4bWwvUmRmcGFyc2VyJztcbmltcG9ydCB7IFJERkJsYW5rTm9kZSwgUkRGRm9ybXVsYSwgUkRGTGl0ZXJhbCwgUkRGU3ltYm9sIH0gZnJvbSAnLi9yZGZ4bWwvdGVybXMnO1xuXG5jb25zdCBzcCA9ICcgICc7XG5jb25zdCBzcDIgPSAnICAgICc7XG5cbmxldCB4bWwyc3RyaW5nO1xubGV0IHN0cmluZzJ4bWw7XG5cbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiAodHlwZW9mIHdpbmRvdy5ET01QYXJzZXIgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBBY3RpdmVYT2JqZWN0ICE9PSAndW5kZWZpbmVkJykpIHsgLy8gSW4gYnJvd3NlclxuICB4bWwyc3RyaW5nID0geG1sID0+IHhtbC54bWw7XG5cbiAgc3RyaW5nMnhtbCA9ICh0ZXh0KSA9PiB7XG4gICAgbGV0IGRvYztcbiAgICB0cnkge1xuICAgICAgaWYgKHdpbmRvdy5ET01QYXJzZXIpIHtcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpO1xuICAgICAgICBkb2MgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHRleHQsICd0ZXh0L3htbCcpO1xuICAgICAgfSBlbHNlIHsgLy8gSW50ZXJuZXQgRXhwbG9yZXJcbiAgICAgICAgZG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ01pY3Jvc29mdC5YTUxET00nKTtcbiAgICAgICAgZG9jLmFzeW5jID0gJ2ZhbHNlJztcbiAgICAgICAgZG9jLmxvYWRYTUwodGV4dCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZG9jID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFkb2MgfHwgIWRvYy5kb2N1bWVudEVsZW1lbnQgfHwgZG9jLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwYXJzZXJlcnJvcicpLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcGFyc2UgdGV4dCBhcyB4bWwnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZG9jO1xuICB9O1xufSBlbHNlIHsgLy8gTm90IGluIGJyb3dzZXJcbiAgICAgICAgIC8vIE5vbi1icm93c2VyIGVudmlyb25tZW50LCByZXF1aXJlcyB0aGUgWE1MU2VyaWFsaXplciBhbmQgeG1sZG9tIGxpYnJhcmllcy5cbiAgeG1sMnN0cmluZyA9IHhtbCA9PiBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHhtbCk7XG5cbiAgY29uc3QgRE9NUGFyc2VyID0geG1sZG9tLkRPTVBhcnNlcjtcbiAgc3RyaW5nMnhtbCA9IHRleHQgPT4gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyh0ZXh0LCAndGV4dC94bWwnKTtcbn1cblxuY29uc3QgdGhyb3dJZlJlbGF0aXZlID0gKHVybCkgPT4ge1xuICAvLyBSZW1vdmVkIHRlc3QgZm9yIFxcIHRlbXBvcmFyeVxuICBpZiAoL1tcIjw+XmB7fH1dL2kudGVzdCh1cmwpKSB7XG4gICAgdGhyb3cgRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYFVSTCBcIiR7dXJsfVwiIGlzIG5vdCBhbGxvd2VkIHRvIGNvbnRhaW4gc3BlY2lhbCBjaGFyYWN0ZXJzIFwiIDwgPiBcXFxcIF4gXFxgIHsgfCBvciB9LmAsXG4gICAgICBjaGFyYWN0ZXI6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICAvLyBpZiAoLyAvaS50ZXN0KHVybCkpIHtcbiAgLy8gdGhyb3cge21lc3NhZ2U6IGBTcGFjZXMgaW5zaWRlIG9mIFVSTCBub3Qgc3VwcG9ydGVkOiAke3VybH1gLCBzcGFjZTogdHJ1ZX07XG4gIC8vIH1cbiAgaWYgKCEvXig/OlthLXpdW2EtejAtOSsuLV0qOikvaS50ZXN0KHVybCkpIHtcbiAgICB0aHJvdyBFcnJvcih7IG1lc3NhZ2U6IGBSZWxhdGl2ZSBVUkwgbm90IHN1cHBvcnRlZDogJHt1cmx9YCwgcmVsYXRpdmU6IHRydWUgfSk7XG4gIH1cbiAgaWYgKC8gL2kudGVzdCh1cmwpKSB7XG4gICAgaWYgKGV4cG9ydHMuY29udmVydFNwYWNlc0luVVJJcykge1xuICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC8gL2csICclMjAnKTtcbiAgICB9XG4gICAgdGhyb3cgRXJyb3IoeyBtZXNzYWdlOiBgU3BhY2VzIGluc2lkZSBvZiBVUkwgbm90IHN1cHBvcnRlZDogJHt1cmx9YCwgc3BhY2U6IHRydWUgfSk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn07XG4vKipcbiAqXG4gKiBJbXBvcnRzIFJERi9YTUwgaW50byBhIEdyYXBoXG4gKlxuICogQHBhcmFtIHtOb2RlfFN0cmluZ30geG1sIHRoaXMgaXMgdGhlIFhNTCBkb2N1bWVudCBvciBYTUwgc3RyaW5nIGZyb20gd2hlcmUgdGhlIFJERiB3aWxsXG4gKiBiZSBwYXJzZWQuXG4gKiBAcGFyYW0ge3JkZmpzb24uR3JhcGh8bnVsbH0gZ3JhcGggV2hlcmUgYWxsIHRyaXBwbGVzIHdpbGwgYmUgYWRkZWQsIGlmIG51bGwgYSBuZXcgZ3JhcGhcbiAqIHdpbGwgYmUgY3JlYXRlZC5cbiAqIEByZXR1cm5zIHtyZGZqc29uLkdyYXBofSB3aGVyZSBhbGwgZm91bmQgdHJpcHBsZXMgaGF2ZSBiZWVuIGFkZGVkLlxuICovXG5jb25zdCByZGZ4bWwyZ3JhcGggPSAoeG1sLCBncmFwaCA9IG51bGwpID0+IHtcbiAgbGV0IF94bWwgPSB4bWw7XG4gIGlmICh1dGlsLmlzU3RyaW5nKF94bWwpKSB7XG4gICAgX3htbCA9IHN0cmluZzJ4bWwoX3htbCk7XG4gIH1cbiAgLyoqXG4gICAqIEB0eXBlIHtyZGZqc29uLkdyYXBofVxuICAgKi9cbiAgY29uc3QgZyA9IGdyYXBoIHx8IG5ldyBHcmFwaCh7fSk7XG4gIGNvbnN0IHN0b3JlID0gbmV3IFJERkZvcm11bGEoKTtcbiAgc3RvcmUuYWRkID0gKHMsIHAsIG8pID0+IHtcbiAgICBsZXQgc3ViajtcbiAgICBsZXQgcHJlZDtcbiAgICBjb25zdCBvYmogPSB7fTtcbiAgICAvLyBTdWJqZWN0XG4gICAgaWYgKHMgaW5zdGFuY2VvZiBSREZCbGFua05vZGUpIHtcbiAgICAgIHN1YmogPSBzLnRvU3RyaW5nKCk7XG4gICAgICBnLnJlZ2lzdGVyQk5vZGUoc3Viaik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHMudXJpID0gdGhyb3dJZlJlbGF0aXZlKHMudXJpKTtcbiAgICAgIHN1YmogPSBzLnVyaTtcbiAgICB9XG5cbiAgICAvLyBQcmVkaWNhdGVcbiAgICBpZiAocCBpbnN0YW5jZW9mIFJERkJsYW5rTm9kZSkge1xuICAgICAgcHJlZCA9IHAudG9TdHJpbmcoKTtcbiAgICAgIGcucmVnaXN0ZXJCTm9kZShwcmVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC51cmkgPSB0aHJvd0lmUmVsYXRpdmUocC51cmkpO1xuICAgICAgcHJlZCA9IHAudXJpO1xuICAgIH1cblxuICAgIC8vIE9iamVjdFxuICAgIGlmIChvIGluc3RhbmNlb2YgUkRGTGl0ZXJhbCkge1xuICAgICAgb2JqLnR5cGUgPSAnbGl0ZXJhbCc7XG4gICAgICBvYmoudmFsdWUgPSBvLnZhbHVlO1xuICAgICAgaWYgKG8ubGFuZykge1xuICAgICAgICBvYmoubGFuZyA9IG8ubGFuZztcbiAgICAgIH1cbiAgICAgIGlmIChvLmRhdGF0eXBlKSB7XG4gICAgICAgIG9iai5kYXRhdHlwZSA9IG8uZGF0YXR5cGUudXJpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFJERlN5bWJvbCkge1xuICAgICAgby51cmkgPSB0aHJvd0lmUmVsYXRpdmUoby51cmkpO1xuICAgICAgb2JqLnR5cGUgPSAndXJpJztcbiAgICAgIG9iai52YWx1ZSA9IG8udXJpO1xuICAgIH0gZWxzZSBpZiAobyBpbnN0YW5jZW9mIFJERkJsYW5rTm9kZSkge1xuICAgICAgb2JqLnZhbHVlID0gby50b1N0cmluZygpO1xuICAgICAgZy5yZWdpc3RlckJOb2RlKG9iai52YWx1ZSk7XG4gICAgICBvYmoudHlwZSA9ICdibm9kZSc7XG4gICAgfVxuICAgIGcuY3JlYXRlKHN1YmosIHByZWQsIG9iaiwgdHJ1ZSk7XG4gIH07XG4gIGNvbnN0IHBhcnNlciA9IG5ldyBSZGZwYXJzZXIoc3RvcmUpO1xuICBwYXJzZXIucGFyc2UoX3htbCwgJycsICcnKTtcbiAgcmV0dXJuIGc7XG59O1xuXG5jb25zdCB4bWxFbmNvZGUgPSB1cmwgPT4gZW5jb2RlVVJJKGRlY29kZVVSSSh1cmwpKS5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xuXG5jb25zdCByZGZqc29uMnJkZnhtbCA9IChncmFwaCkgPT4ge1xuICBjb25zdCBnID0gZ3JhcGggaW5zdGFuY2VvZiBHcmFwaCA/IGdyYXBoLl9ncmFwaCA6IGdyYXBoIHx8IHt9O1xuICBjb25zdCBuc1VzZWQgPSBbXTtcbiAgY29uc3QgbnNBZGRlZCA9IHt9O1xuICBjb25zdCBuc2lmeSA9IGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgY29uc3QgX28gPSBucy5uc2lmeShwcm9wKTtcbiAgICBpZiAoIW5zQWRkZWRbX28uYWJicmV2XSkge1xuICAgICAgbnNVc2VkLnB1c2goX28uYWJicmV2KTtcbiAgICAgIG5zQWRkZWRbX28uYWJicmV2XSA9IF9vLm5zO1xuICAgIH1cbiAgICByZXR1cm4gX28ucHJldHR5O1xuICB9O1xuXG4gIGNvbnN0IHN0cnMgPSBbXTtcbiAgT2JqZWN0LmtleXMoZykuZm9yRWFjaCgocykgPT4ge1xuICAgIGlmIChzLnN1YnN0cigwLCAyKSA9PT0gJ186Jykge1xuICAgICAgc3Rycy5wdXNoKGAke3NwfTxyZGY6RGVzY3JpcHRpb24gcmRmOm5vZGVJRD1cIl8ke3Muc3Vic3RyaW5nKDIpfVwiPlxcbmApO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHJzLnB1c2goYCR7c3B9PHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9XCIke3htbEVuY29kZShzKX1cIj5cXG5gKTtcbiAgICB9XG4gICAgY29uc3QgcHJvcHMgPSBnW3NdO1xuICAgIE9iamVjdC5rZXlzKHByb3BzKS5mb3JFYWNoKChwKSA9PiB7XG4gICAgICBjb25zdCBuc3AgPSBuc2lmeShwKTtcbiAgICAgIHByb3BzW3BdLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgbGV0IHY7XG4gICAgICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnbGl0ZXJhbCc6XG4gICAgICAgICAgICB2ID0gby52YWx1ZS5yZXBsYWNlKCcmJywgJyZhbXA7JykucmVwbGFjZSgnPCcsICcmbHQ7Jyk7XG4gICAgICAgICAgICBpZiAoby5sYW5nICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc3Rycy5wdXNoKGAke3NwMn08JHtuc3B9IHhtbDpsYW5nPVwiJHtvLmxhbmd9XCI+JHt2fTwvJHtuc3B9PlxcbmApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChvLmRhdGF0eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc3Rycy5wdXNoKGAke3NwMn08JHtuc3B9IHJkZjpkYXRhdHlwZT1cIiR7by5kYXRhdHlwZX1cIj4ke3Z9PC8ke25zcH0+XFxuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJzLnB1c2goYCR7c3AyfTwke25zcH0+JHt2fTwvJHtuc3B9PlxcbmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndXJpJzpcbiAgICAgICAgICAgIHN0cnMucHVzaChgJHtzcDJ9PCR7bnNwfSByZGY6cmVzb3VyY2U9XCIke3htbEVuY29kZShvLnZhbHVlKX1cIi8+XFxuYCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdibm9kZSc6XG4gICAgICAgICAgICBpZiAoby52YWx1ZS5zdWJzdHIoMCwgMikgPT09ICdfOicpIHtcbiAgICAgICAgICAgICAgc3Rycy5wdXNoKGAke3NwMn08JHtuc3B9IHJkZjpub2RlSUQ9XCJfJHtvLnZhbHVlLnN1YnN0cmluZygyKX1cIi8+XFxuYCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHJzLnB1c2goYCR7c3AyfTwke25zcH0gcmRmOm5vZGVJRD1cIiR7by52YWx1ZX1cIi8+XFxuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBzdHJzLnB1c2goYCR7c3B9PC9yZGY6RGVzY3JpcHRpb24+XFxuYCk7XG4gIH0pO1xuICBjb25zdCBpbml0aWFsU3RycyA9IFsnPD94bWwgdmVyc2lvbj1cIjEuMFwiPz5cXG48cmRmOlJERiB4bWxuczpyZGY9XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjXCInXTtcbiAgZm9yIChsZXQgaiA9IDA7IGogPCBuc1VzZWQubGVuZ3RoOyBqKyspIHtcbiAgICBpZiAobnNVc2VkW2pdICE9PSAncmRmJykge1xuICAgICAgaW5pdGlhbFN0cnMucHVzaChgXFxuXFx0eG1sbnM6JHtuc1VzZWRbal19PVwiJHtuc0FkZGVkW25zVXNlZFtqXV19XCJgKTtcbiAgICB9XG4gIH1cbiAgaW5pdGlhbFN0cnMucHVzaCgnPlxcbicpO1xuICBzdHJzLnVuc2hpZnQoaW5pdGlhbFN0cnMuam9pbignJykpO1xuICBzdHJzLnB1c2goJzwvcmRmOlJERj4nKTtcbiAgcmV0dXJuIHN0cnMuam9pbignJyk7XG59O1xuXG4vKipcbiAqIERldGVjdHMgUkRGIGFzIGEgc3RyaW5nIGluIHRoZSBSREYvWE1MLCBhcyBhbiBpbnN0YW5jZSBvZiBHcmFwaCBvciBhcyBhIG9iamVjdCBsaXRlcmFsXG4gKiBjb3JyZXNwb25kaW5nIHRvIGEgUkRGL0pTT04gc3RydWN0dXJlLlxuICogTGltaXRhdGlvbjogUGFyc2UgSlNPTiBzdHJpbmdzIGludG8gb2JqZWN0IGxpdGVyYWxzIGlmIHRoZSBKU09OLnBhcnNlIGlzIGF2YWlsYWJsZSBpbiB0aGVcbiAqIGVudmlyb25tZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmRmIGluIFJERi9YTUwsIFJERi9KU09OIG9yIGEgb2JqZWN0IGxpdGVyYWwgY29ycmVzcG9uZGluZyB0byBhbHJlYWR5XG4gKiBwYXJzZWQgUkRGL0pTT04uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhIHJlcG9ydCB3aXRoIHRoZSBhdHRyaWJ1dGVzOiBncmFwaCwgZm9ybWF0IGFuZCBwb3RlbnRpYWxseSBhbiBlcnJvci5cbiAqL1xuY29uc3QgZGV0ZWN0ID0gKHJkZikgPT4ge1xuICBjb25zdCByZXBvcnQgPSB7fTtcbiAgaWYgKHR5cGVvZiByZGYgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgdGFzdGUgPSByZGYuc3Vic3RyKDAsIDIwMCk7XG4gICAgaWYgKHRhc3RlLnRvTG93ZXJDYXNlKCkuaW5kZXhPZignPHJkZjpyZGYnKSAhPT0gLTEpIHtcbiAgICAgIHJlcG9ydC5mb3JtYXQgPSAncmRmL3htbCc7XG4gICAgICB0cnkge1xuICAgICAgICByZXBvcnQuZ3JhcGggPSByZGZ4bWwyZ3JhcGgocmRmKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaWYgKGUucmVsYXRpdmUgfHwgZS5zcGFjZSB8fCBlLmNoYXJhY3Rlcikge1xuICAgICAgICAgIHJlcG9ydC5lcnJvciA9IGUubWVzc2FnZTtcbiAgICAgICAgICByZXBvcnQuZXJyb3JDb2RlID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXBvcnQuZXJyb3IgPSAnSW52YWxpZCByZGYveG1sJztcbiAgICAgICAgICByZXBvcnQuZXJyb3JDb2RlID0gMjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmRmLnN1YnN0cmluZygwLCAyKSA9PT0gJ3tcIicpIHtcbiAgICAgIHJlcG9ydC5mb3JtYXQgPSAncmRmL2pzb24nO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QganNvbnJkZiA9IEpTT04ucGFyc2UodGhpcy5yZGZqc29uKTtcbiAgICAgICAgcmVwb3J0LmdyYXBoID0gbmV3IEdyYXBoKGpzb25yZGYpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXBvcnQuZXJyb3IgPSAnSW52YWxpZCBqc29uLic7XG4gICAgICAgIHJlcG9ydC5lcnJvckNvZGUgPSAzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXBvcnQuZXJyb3IgPSAnTm8gUkRGIGRldGVjdGVkLic7XG4gICAgICByZXBvcnQuZXJyb3JDb2RlID0gNDtcbiAgICB9XG4gIH0gZWxzZSBpZiAocmRmIGluc3RhbmNlb2YgR3JhcGgpIHtcbiAgICByZXBvcnQuZm9ybWF0ID0gJ3JkZi9qc29uJztcbiAgICByZXBvcnQuZ3JhcGggPSByZGY7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJkZiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXBvcnQuZm9ybWF0ID0gJ3JkZi9qc29uJztcbiAgICByZXBvcnQuZ3JhcGggPSBuZXcgR3JhcGgocmRmKTtcbiAgfSBlbHNlIHtcbiAgICByZXBvcnQuZXJyb3IgPSAndW5rbm93biBmb3JtYXQnO1xuICAgIHJlcG9ydC5lcnJvckNvZGUgPSA1O1xuICB9XG4gIGlmICghcmVwb3J0LmVycm9yKSB7XG4gICAgY29uc3QgciA9IHJlcG9ydC5ncmFwaC52YWxpZGF0ZSgpO1xuICAgIGlmICghci52YWxpZCkge1xuICAgICAgcmVwb3J0LmVycm9yID0gJ1JERi9KU09OIGlzIG5vdCB2YWxpZC4nO1xuICAgICAgcmVwb3J0LmVycm9yQ29kZSA9IDY7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXBvcnQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIHhtbDJzdHJpbmcsXG4gIHN0cmluZzJ4bWwsXG4gIHJkZnhtbDJncmFwaCxcbiAgcmRmanNvbjJyZGZ4bWwsXG4gIGRldGVjdCxcbn07XG4iLCIvLyBGb3VyIGhlbHBlciBtZXRob2RzLCBmcm9tIGRvam8uXG5jb25zdCBpc09iamVjdCA9IGl0ID0+IGl0ICE9PSB1bmRlZmluZWQgJiZcbiAgKGl0ID09PSBudWxsIHx8IHR5cGVvZiBpdCA9PT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShpdCkgfHwgdHlwZW9mIGl0ID09PSAnZnVuY3Rpb24nKTtcblxuY29uc3QgaXNTdHJpbmcgPSBpdCA9PiAodHlwZW9mIGl0ID09PSAnc3RyaW5nJyB8fCBpdCBpbnN0YW5jZW9mIFN0cmluZyk7XG5cbmNvbnN0IGlzRnVuY3Rpb24gPSBpdCA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoaXQpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xuXG5jb25zdCBzdGF0ZW1lbnRFcXVhbHMgPSAoczEsIHMyKSA9PlxuICBzMS5zID09PSBzMi5zICYmIHMxLnAgPT09IHMyLnAgJiYgb2JqZWN0RXF1YWxzKHMxLm8sIHMyLm8pO1xuXG4vKipcbiAqIEFkZHMgYSBzdGF0ZW1lbnQgdG8gYSBncmFwaCBvYmplY3QgYWNjb3JkaW5nIHRvIHRoZSByZGYvanNvbiBzcGVjaWZpY2F0aW9uLlxuICogRHVwbGljYXRlcyBvZiB0aGUgc2FtZSBzdGF0ZW1lbnQgYXJlIG5vdCBhbGxvd2VkIGluIGEgZ3JhcGgsXG4gKiBoZW5jZSB0aGV5IGFyZSBub3QgYWxsb3dlZCB0byBiZSBhZGRlZC5cbiAqXG4gKiBUaGUgb2JqZWN0IGluIHRoZSBzdGF0ZW1lbnQgYXJlIHJlcHJlc2VudGVkIHZpYSBhbiBqYXZhc2NyaXB0IG9iamVjdCBjb250YWluaW5nOlxuICogPHVsPjxsaT50eXBlIC0gb25lIG9mICd1cmknLCAnbGl0ZXJhbCcgb3IgJ2Jub2RlJyAoPGI+cmVxdWlyZWQ8L2I+IGFuZCBtdXN0IGJlIGxvd2VyY2FzZSkuPC9saT5cbiAqIDxsaT52YWx1ZSAtIHRoZSBsZXhpY2FsIHZhbHVlIG9mIHRoZSBvYmplY3QgKDxiPnJlcXVpcmVkPC9iPiwgZnVsbCBVUklzIHNob3VsZCBiZSB1c2VkLFxuICogbm90IG5hbWVzcGFjZWQgdXNpbmcgYWJicmV2aWF0aW9ucyk8L2xpPlxuICogPGxpPmxhbmcgLSB0aGUgbGFuZ3VhZ2Ugb2YgYSBsaXRlcmFsIHZhbHVlICg8Yj5vcHRpb25hbDwvYj5cbiAqIGJ1dCBpZiBzdXBwbGllZCBpdCBtdXN0IG5vdCBiZSBlbXB0eSk8L2xpPlxuICogPGxpPmRhdGF0eXBlIC0gdGhlIGRhdGF0eXBlIFVSSSBvZiB0aGUgbGl0ZXJhbCB2YWx1ZSAoPGI+b3B0aW9uYWw8L2I+KTwvbGk+XG4gKiBUaGUgJ2xhbmcnIGFuZCAnZGF0YXR5cGUnIGtleXMgc2hvdWxkIG9ubHkgYmUgdXNlZCBpZiB0aGUgdmFsdWUgb2YgdGhlICd0eXBlJyBrZXkgaXMgXCJsaXRlcmFsXCIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoIGFjY29yZGluZyB0byB0aGUgcmRmL2pzb24gc3BlY2lmaWNhdGlvbi5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzIGEgVVJJIHJlcHJlc2VudGluZyB0aGUgc3ViamVjdCBpbiBhIHN0YXRlbWVudC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBwIGEgVVJJIHJlcHJlc2VudGluZyB0aGUgcHJlZGljYXRlIGluIGEgc3RhdGVtZW50LlxuICogQHBhcmFtIHtPYmplY3R9IG8gYW4gb2JqZWN0IHJlcHJlc2VudGluZyBlaXRoZXIgYSByZXNvdXJjZSBvciBhIGxpdGVyYWwsXG4gKiAgc2VlIGZvcm1hdCBkZXNjcmliZWQgYWJvdmUuXG4gKiBAcmV0dXJuIHtPYmplY3R9IHRoZSBqYXZhc2NyaXB0IG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSBzdGF0ZW1lbnRzIG9iamVjdCBqdXN0IGFkZGVkLFxuICogIG5vdGUgdGhhdCBpdCBtaWdodCBiZSBhIGNsb25lIG9mIHRoZSBvYmplY3QgZ2l2ZW4gaW4gdGhlIHBhcmFtZXRlciBvXG4gKiAoZm9yIGluc3RhbmNlIHdoZW4gdGhlIHN0YXRlbWVudCBhbHJlYWR5IGV4aXN0cyBpbiB0aGUgZ3JhcGgpLlxuICogQHRocm93cyB7U3RyaW5nfSBhbiBlcnJvciBtZXNzYWdlIGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCB2YWxpZC5cbiAqIEBzZWUgVGhlIDxhIGhyZWY9XCJodHRwOi8vbjIudGFsaXMuY29tL3dpa2kvUkRGX0pTT05fU3BlY2lmaWNhdGlvblwiPlJERiBKU09OIFNwZWNpZmljYXRpb248L2E+LlxuICovXG5jb25zdCBhZGQgPSAoZ3JhcGgsIHMsIHAsIG8pID0+IHtcbiAgY2hlY2tGb3JXcm9uZ0FyZ3MoW2dyYXBoLCBzLCBwLCBvXSk7XG4gIGlmIChncmFwaFtzXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZ3JhcGhbc10gPSB7fTtcbiAgICBncmFwaFtzXVtwXSA9IFtvXTtcbiAgICByZXR1cm4gbztcbiAgfVxuICBpZiAoZ3JhcGhbc11bcF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGdyYXBoW3NdW3BdID0gW29dO1xuICAgIHJldHVybiBvO1xuICB9XG4gIGxldCBpO1xuICBjb25zdCBvYmpzID0gZ3JhcGhbc11bcF07XG4gIGZvciAoaSA9IG9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAob2JqZWN0RXF1YWxzKG8sIG9ianNbaV0pKSB7XG4gICAgICByZXR1cm4gb2Jqc1tpXTtcbiAgICB9XG4gIH1cbiAgb2Jqcy5wdXNoKG8pO1xuICByZXR1cm4gbztcbn07XG5cbi8qKlxuICogVHJpZXMgdG8gcmVtb3ZlIHRoZSBzcGVjaWZpZWQgc3RhdGVtZW50IGZyb20gdGhlIGdpdmVuIGdyYXBoLlxuICogSWYgaXQgaXMgc3VjY2Vzc2Z1bCBpdCByZXR1cm5zIHRoZSBvYmplY3Qgb2YgdGhlIHN0YXRtZW50IHJlbW92ZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGdyYXBoXG4gKiBAcGFyYW0ge09iamVjdH0gc1xuICogQHBhcmFtIHtPYmplY3R9IHBcbiAqIEBwYXJhbSB7T2JqZWN0fSBvXG4gKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfSB0aGUgb2JqZWN0IG9mIHRoZSBzdGF0ZW1lbnQgcmVtb3ZlZCxcbiAqICB1bmRlZmluZWQgaWYgbm8gbWF0Y2hpbmcgc3RhdGVtZW50IGNvdWxkIGJlIHJlbW92ZWQuXG4gKiBAdGhyb3dzIHtTdHJpbmd9IGFuIGVycm9yIG1lc3NhZ2UgaWYgdGhlIGFyZ3VtZW50cyBhcmUgbm90IHZhbGlkLlxuICogQHNlZSBleHBvcnRzLmFkZCBmb3IgYSBsb25nZXIgdHJlYXRtZW50IG9mIHRoZSBhbGxvd2VkIGFyZ3VtZW50cy5cbiAqL1xuY29uc3QgcmVtb3ZlID0gKGdyYXBoLCBzLCBwLCBvKSA9PiB7XG4gIGNoZWNrRm9yV3JvbmdBcmdzKFtncmFwaCwgcywgcCwgb10pO1xuICBpZiAoZ3JhcGhbc10gPT09IHVuZGVmaW5lZCB8fCBncmFwaFtzXVtwXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgaTtcbiAgY29uc3Qgb2JqcyA9IGdyYXBoW3NdW3BdO1xuICBmb3IgKGkgPSBvYmpzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKG9iamVjdEVxdWFscyhvLCBvYmpzW2ldKSkge1xuICAgICAgY29uc3QgX28gPSBvYmpzW2ldO1xuICAgICAgb2Jqcy5zcGxpY2UoaSwgMSk7XG4gICAgICBjbGVhbnVwKGdyYXBoLCBzLCBwKTtcbiAgICAgIHJldHVybiBfbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBncmFwaCBjb250YWlucyB0aGUgc3BlY2lmaWVkIHN0YXRlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JhcGhcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcGFyYW0ge1N0cmluZ30gcFxuICogQHBhcmFtIHtPYmplY3R9IG9cbiAqIEByZXR1cm4ge09iamVjdHx1bmRlZmluZWR9IHRoZSBvYmplY3Qgb2YgdGhlIGZvdW5kIHN0YXRlbWVudCBpZiB0aGUgZ3JhcGggY29udGFpbnMgdGhlXG4gKiBzcGVjaWZpZWQgc3RhdGVtZW50LCB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICogQHRocm93cyB7U3RyaW5nfSBhbiBlcnJvciBtZXNzYWdlIGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCB2YWxpZC5cbiAqL1xuY29uc3QgY29udGFpbnMgPSAoZ3JhcGgsIHMsIHAsIG8pID0+IHtcbiAgY2hlY2tGb3JXcm9uZ0FyZ3MoW2dyYXBoLCBzLCBwLCBvXSk7XG4gIGlmIChncmFwaFtzXSA9PT0gdW5kZWZpbmVkIHx8IGdyYXBoW3NdW3BdID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBpO1xuICBjb25zdCBvYmpzID0gZ3JhcGhbc11bcF07XG4gIGZvciAoaSA9IG9ianMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAob2JqZWN0RXF1YWxzKG8sIG9ianNbaV0pKSB7XG4gICAgICByZXR1cm4gb2Jqc1tpXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBlbXB0eSBzdHJ1Y3R1cmVzIGluIHRoZSBncmFwaCBmb3IgdGhlIGdpdmVuIHN1YmplY3QgYW5kIHByZWRpY2F0ZS5cbiAqIEl0IGNoZWNrcyBpZiB0aGVyZSBhcmUgc3ViamVjdHMgd2l0aG91dCBvdXRnb2luZyBwcm9wZXJ0aWVzIG9yXG4gKiBpZiB0aGVyZSBhcmUgcHJvcGVydGllcyB3aXRoIG5vIG9iamVjdHMuXG4gKlxuICogTm90ZSB0aGF0IHRoZSBuZWVkIGZvciB0aGlzIGZ1bmN0aW9uIGlzIGEgY29uc2VxdWVuY2Ugb2YgdGhlIG5vcm1hbGl6ZWQgY2hhcmFjdGVyXG4gKiBvZiB0aGUgUkRGIEpTT04gZm9ybWF0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBncmFwaFxuICogQHBhcmFtIHtPYmplY3R9IHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwXG4gKi9cbmNvbnN0IGNsZWFudXAgPSAoZ3JhcGgsIHMsIHApID0+IHtcbiAgaWYgKGdyYXBoW3NdW3BdLmxlbmd0aCA9PT0gMCkge1xuICAgIGRlbGV0ZSBncmFwaFtzXVtwXTtcbiAgICBpZiAoT2JqZWN0LmtleXMoZ3JhcGhbc10pLmxlbmd0aCA9PT0gMCkge1xuICAgICAgZGVsZXRlIGdyYXBoW3NdO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBDaGVja3MgdGhlIGFyZ3VtZW50cyBmb3IgdGhlIGFkZCBmdW5jdGlvbiBhcmUgdmFsaWRcbiAqIChhbmQgYWxsIG90aGVyIGZ1bmN0aW9ucyB0aGF0IGhhdmUgdGhlIHNhbWUgc2lnbmF0dXJlKS5cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBhcmdzIGFuIGFycmF5IG9mIHRoZSBhcmd1bWVudHMgZm9yIHRoZSBhZGQgZnVuY3Rpb24uXG4gKiBAdGhyb3dzIHtTdHJpbmd9IHdpdGggYSBtZXNzYWdlIGlmIHRoZSBhcmd1bWVudHMgYXJlIG5vdCB2YWxpZC5cbiAqIEBzZWUgZXhwb3J0cy5hZGRcbiAqL1xuY29uc3QgY2hlY2tGb3JXcm9uZ0FyZ3MgPSAoYXJncykgPT4ge1xuICBpZiAoIWlzT2JqZWN0KGFyZ3NbMF0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdHcmFwaCBpcyBub3QgYSBvYmplY3QuJyk7XG4gIH0gZWxzZSBpZiAoIWlzU3RyaW5nKGFyZ3NbMV0pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdWJqZWN0IGlzIG5vdCBhIHN0cmluZy4nKTtcbiAgfSBlbHNlIGlmICghaXNTdHJpbmcoYXJnc1syXSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1ByZWRpY2F0ZSBpcyBub3QgYSBzdHJpbmcuJyk7XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0KGFyZ3NbM10pKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdPYmplY3QgaXMgbm90IGEgb2JqZWN0LicpO1xuICB9IGVsc2UgaWYgKGFyZ3NbM10udHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0IGhhcyBubyB0eXBlIGF0dHJpYnV0ZSwgbXVzdCBiZSBvbmUgb2YgJ3VyaScsICdsaXRlcmFsJywgb3JcIiArXG4gICAgICBcIiAnYm5vZGUnXCIpO1xuICB9IGVsc2UgaWYgKGFyZ3NbM10udmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignT2JqZWN0IGhhcyBubyB2YWx1ZSBhdHRyaWJ1dGUgY29ycmVzcG9uZGluZyB0byB0aGUgbGV4aWNhbCB2YWx1ZSAnICtcbiAgICAgICdvZiB0aGUgb2JqZWN0LicpO1xuICB9XG4gIC8vIFRPRE8gY2hlY2sgdGhhdCBzdWJqZWN0LCBwcmVkaWNhdGUgYW5kIG9iamVjdC5kYXRhdHlwZSBhcmUgdXJpcy5cbiAgLy8gVE9ETyBBbHNvIGNoZWNrIHRoYXQgb2JqZWN0LnZhbHVlIGlzIGEgVVJJIGlmIHRoZSB0eXBlIGlzIHVyaS5cbn07XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIHN0YXRlbWVudCBvYmplY3RzIGFjY29yZGluZyB0byB0aGUgUkRGIEpTT04gU3BlY2lmaWNhdGlvbi5cbiAqIElmIGJvdGggbzEgYW5kIG8yIGFyZSBzdHJpbmdzIHRoZXkgYXJlIHNpbXBseSBjb21wYXJlZC5cbiAqIElmIG9uZSBvZiBvMSBhbmQgbzIgYXJlIGEgc3RyaW5nIGFuZCB0aGUgb3RoZXIgaXMgYW4gb2JqZWN0IHRoZSBzdHJpbmcgaXMgY29tcGFyZWQgd2l0aCB0aGVcbiAqIHZhbHVlIG9mIHRoZSBvYmplY3QgaWdub3JpbmcgYW55IG90aGVyIGF0dHJpYnV0ZXMgb2YgdGhlIG9iamVjdC5cbiAqIElmIGJvdGggbzEgYW5kIG8yIGFyZSBudWxsIG9yIHVuZGVmaW5lZCB0aGV5IGFyZSBjb25zaWRlcmVkIGVxdWFsLlxuICpcbiAqIEBwYXJhbSB7Kn0gbzFcbiAqIEBwYXJhbSB7Kn0gbzJcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgdGhleSBoYXZlIHRoZSBzYW1lIHR5cGUsIGxleGljYWwgdmFsdWUsIGxhbmd1YWdlLCBhbmQgZGF0YXR5cGUuXG4gKi9cbmNvbnN0IG9iamVjdEVxdWFscyA9IChvMSwgbzIpID0+IHtcbiAgaWYgKG8xID09PSBvMiB8fCAobzEgPT0gbnVsbCAmJiBvMSA9PT0gbzIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gTm90ZSwgdXNpbmdcbiAgaWYgKGlzU3RyaW5nKG8xKSkge1xuICAgIGlmIChpc1N0cmluZyhvMikpIHtcbiAgICAgIHJldHVybiBvMSA9PT0gbzI7XG4gICAgfVxuICAgIHJldHVybiBvMSA9PT0gbzIudmFsdWU7XG4gIH0gZWxzZSBpZiAoaXNTdHJpbmcobzIpKSB7XG4gICAgcmV0dXJuIG8xLnZhbHVlID09PSBvMjtcbiAgfVxuICByZXR1cm4gbzEudHlwZSA9PT0gbzIudHlwZSAmJiBvMS52YWx1ZSA9PT0gbzIudmFsdWUgJiYgbzEubGFuZyA9PT0gbzIubGFuZyAmJlxuICAgIG8xLmRhdGF0eXBlID09PSBvMi5kYXRhdHlwZTtcbn07XG5cbmNvbnN0IGZpbmREaXJlY3RPclJERlZhbHVlID0gKGdyYXBoLCBzdWJqZWN0LCBwcmVkaWNhdGUpID0+IHtcbiAgY29uc3QgYXJyID0gZ3JhcGguZmluZChzdWJqZWN0LCBwcmVkaWNhdGUpO1xuICBpZiAoYXJyLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoYXJyWzBdLmdldFR5cGUoKSAhPT0gJ2Jub2RlJykge1xuICAgICAgcmV0dXJuIGFyclswXS5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gZ3JhcGguZmluZEZpcnN0VmFsdWUoYXJyWzBdLmdldFZhbHVlKCksICdodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjdmFsdWUnKTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBpc09iamVjdCxcbiAgaXNTdHJpbmcsXG4gIGlzRnVuY3Rpb24sXG4gIHN0YXRlbWVudEVxdWFscyxcbiAgYWRkLFxuICByZW1vdmUsXG4gIGNvbnRhaW5zLFxuICBjbGVhbnVwLFxuICBjaGVja0Zvcldyb25nQXJncyxcbiAgb2JqZWN0RXF1YWxzLFxuICBmaW5kRGlyZWN0T3JSREZWYWx1ZSxcbn1cbiIsImltcG9ydCB7am9pbn0gZnJvbSAnLi91cmknO1xuXG4vKipcbiAqIEBmaWxlb3ZlcnZpZXdcbiAqIFRBQlVMQVRPUiBSREYgUEFSU0VSXG4gKlxuICogVmVyc2lvbiAwLjFcbiAqICBQYXJzZXIgYmVsaWV2ZWQgdG8gYmUgaW4gZnVsbCBwb3NpdGl2ZSBSREYvWE1MIHBhcnNpbmcgY29tcGxpYW5jZVxuICogIHdpdGggdGhlIHBvc3NpYmxlIGV4Y2VwdGlvbiBvZiBoYW5kbGluZyBkZXByZWNhdGVkIFJERiBhdHRyaWJ1dGVzXG4gKiAgYXBwcm9wcmlhdGVseS4gUGFyc2VyIGlzIGJlbGlldmVkIHRvIGNvbXBseSBmdWxseSB3aXRoIG90aGVyIFczQ1xuICogIGFuZCBpbmR1c3RyeSBzdGFuZGFyZHMgd2hlcmUgYXBwcm9wcmlhdGUgKERPTSwgRUNNQVNjcmlwdCwgJmMuKVxuICpcbiAqICBBdXRob3I6IERhdmlkIFNoZWV0cyA8ZHNoZWV0c0BtaXQuZWR1PlxuICogIFNWTiBJRDogJElkJFxuICpcbiAqIFczQ8KuIFNPRlRXQVJFIE5PVElDRSBBTkQgTElDRU5TRVxuICogaHR0cDovL3d3dy53My5vcmcvQ29uc29ydGl1bS9MZWdhbC8yMDAyL2NvcHlyaWdodC1zb2Z0d2FyZS0yMDAyMTIzMVxuICogVGhpcyB3b3JrIChhbmQgaW5jbHVkZWQgc29mdHdhcmUsIGRvY3VtZW50YXRpb24gc3VjaCBhcyBSRUFETUVzLCBvclxuICogb3RoZXIgcmVsYXRlZCBpdGVtcykgaXMgYmVpbmcgcHJvdmlkZWQgYnkgdGhlIGNvcHlyaWdodCBob2xkZXJzIHVuZGVyXG4gKiB0aGUgZm9sbG93aW5nIGxpY2Vuc2UuIEJ5IG9idGFpbmluZywgdXNpbmcgYW5kL29yIGNvcHlpbmcgdGhpcyB3b3JrLFxuICogeW91ICh0aGUgbGljZW5zZWUpIGFncmVlIHRoYXQgeW91IGhhdmUgcmVhZCwgdW5kZXJzdG9vZCwgYW5kIHdpbGxcbiAqIGNvbXBseSB3aXRoIHRoZSBmb2xsb3dpbmcgdGVybXMgYW5kIGNvbmRpdGlvbnMuXG4gKlxuICogUGVybWlzc2lvbiB0byBjb3B5LCBtb2RpZnksIGFuZCBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgYW5kIGl0c1xuICogZG9jdW1lbnRhdGlvbiwgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbiwgZm9yIGFueSBwdXJwb3NlIGFuZFxuICogd2l0aG91dCBmZWUgb3Igcm95YWx0eSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB5b3UgaW5jbHVkZVxuICogdGhlIGZvbGxvd2luZyBvbiBBTEwgY29waWVzIG9mIHRoZSBzb2Z0d2FyZSBhbmQgZG9jdW1lbnRhdGlvbiBvclxuICogcG9ydGlvbnMgdGhlcmVvZiwgaW5jbHVkaW5nIG1vZGlmaWNhdGlvbnM6XG4gKlxuICogMS4gVGhlIGZ1bGwgdGV4dCBvZiB0aGlzIE5PVElDRSBpbiBhIGxvY2F0aW9uIHZpZXdhYmxlIHRvIHVzZXJzIG9mXG4gKiB0aGUgcmVkaXN0cmlidXRlZCBvciBkZXJpdmF0aXZlIHdvcmsuXG4gKiAyLiBBbnkgcHJlLWV4aXN0aW5nIGludGVsbGVjdHVhbCBwcm9wZXJ0eSBkaXNjbGFpbWVycywgbm90aWNlcywgb3IgdGVybXMgYW5kXG4gKiBjb25kaXRpb25zLiBJZiBub25lIGV4aXN0LCB0aGUgVzNDIFNvZnR3YXJlIFNob3J0IE5vdGljZSBzaG91bGQgYmVcbiAqIGluY2x1ZGVkIChoeXBlcnRleHQgaXMgcHJlZmVycmVkLCB0ZXh0IGlzIHBlcm1pdHRlZCkgd2l0aGluIHRoZSBib2R5XG4gKiBvZiBhbnkgcmVkaXN0cmlidXRlZCBvciBkZXJpdmF0aXZlIGNvZGUuXG4gKiAzLiBOb3RpY2Ugb2YgYW55IGNoYW5nZXMgb3IgbW9kaWZpY2F0aW9ucyB0byB0aGUgZmlsZXMsIGluY2x1ZGluZyB0aGVcbiAqIGRhdGUgY2hhbmdlcyB3ZXJlIG1hZGUuIChXZSByZWNvbW1lbmQgeW91IHByb3ZpZGUgVVJJcyB0byB0aGUgbG9jYXRpb25cbiAqIGZyb20gd2hpY2ggdGhlIGNvZGUgaXMgZGVyaXZlZC4pXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBBTkQgRE9DVU1FTlRBVElPTiBJUyBQUk9WSURFRCBcIkFTIElTLFwiIEFORCBDT1BZUklHSFRcbiAqIEhPTERFUlMgTUFLRSBOTyBSRVBSRVNFTlRBVElPTlMgT1IgV0FSUkFOVElFUywgRVhQUkVTUyBPUiBJTVBMSUVELFxuICogSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTywgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgT1IgRklUTkVTU1xuICogRk9SIEFOWSBQQVJUSUNVTEFSIFBVUlBPU0UgT1IgVEhBVCBUSEUgVVNFIE9GIFRIRSBTT0ZUV0FSRSBPUlxuICogRE9DVU1FTlRBVElPTiBXSUxMIE5PVCBJTkZSSU5HRSBBTlkgVEhJUkQgUEFSVFkgUEFURU5UUywgQ09QWVJJR0hUUyxcbiAqIFRSQURFTUFSS1MgT1IgT1RIRVIgUklHSFRTLlxuICpcbiAqIENPUFlSSUdIVCBIT0xERVJTIFdJTEwgTk9UIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIFNQRUNJQUxcbiAqIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBBUklTSU5HIE9VVCBPRiBBTlkgVVNFIE9GIFRIRSBTT0ZUV0FSRSBPUlxuICogRE9DVU1FTlRBVElPTi5cbiAqXG4gKiBUaGUgbmFtZSBhbmQgdHJhZGVtYXJrcyBvZiBjb3B5cmlnaHQgaG9sZGVycyBtYXkgTk9UIGJlIHVzZWQgaW5cbiAqIGFkdmVydGlzaW5nIG9yIHB1YmxpY2l0eSBwZXJ0YWluaW5nIHRvIHRoZSBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljLFxuICogd3JpdHRlbiBwcmlvciBwZXJtaXNzaW9uLiBUaXRsZSB0byBjb3B5cmlnaHQgaW4gdGhpcyBzb2Z0d2FyZSBhbmQgYW55XG4gKiBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gd2lsbCBhdCBhbGwgdGltZXMgcmVtYWluIHdpdGggY29weXJpZ2h0XG4gKiBob2xkZXJzLlxuICovXG4vKipcbiAqIEBjbGFzcyBDbGFzcyBkZWZpbmluZyBhbiBSREZQYXJzZXIgcmVzb3VyY2Ugb2JqZWN0IHRpZWQgdG8gYW4gUkRGU3RvcmVcbiAqXG4gKiBAYXV0aG9yIERhdmlkIFNoZWV0cyA8ZHNoZWV0c0BtaXQuZWR1PlxuICogQHZlcnNpb24gMC4xXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc3RvcmUgQW4gUkRGU3RvcmUgb2JqZWN0XG4gKi9cbnZhciBSREZQYXJzZXI7XG5SREZQYXJzZXIgPSBmdW5jdGlvbiAoc3RvcmUpIHtcbiAgLyoqIFN0YW5kYXJkIG5hbWVzcGFjZXMgdGhhdCB3ZSBrbm93IGhvdyB0byBoYW5kbGUgQGZpbmFsXG4gICAqICBAbWVtYmVyIFJERlBhcnNlclxuICAgKi9cbiAgUkRGUGFyc2VyWyducyddID0ge1xuICAgICdSREYnOiBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyNcIixcbiAgICAnUkRGUyc6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hI1wiXG4gIH07XG4gIC8qKiBET00gTGV2ZWwgMiBub2RlIHR5cGUgbWFnaWMgbnVtYmVycyBAZmluYWxcbiAgICogIEBtZW1iZXIgUkRGUGFyc2VyXG4gICAqL1xuICBSREZQYXJzZXJbJ25vZGVUeXBlJ10gPSB7XG4gICAgJ0VMRU1FTlQnOiAxLCAnQVRUUklCVVRFJzogMiwgJ1RFWFQnOiAzLFxuICAgICdDREFUQV9TRUNUSU9OJzogNCwgJ0VOVElUWV9SRUZFUkVOQ0UnOiA1LFxuICAgICdFTlRJVFknOiA2LCAnUFJPQ0VTU0lOR19JTlNUUlVDVElPTic6IDcsXG4gICAgJ0NPTU1FTlQnOiA4LCAnRE9DVU1FTlQnOiA5LCAnRE9DVU1FTlRfVFlQRSc6IDEwLFxuICAgICdET0NVTUVOVF9GUkFHTUVOVCc6IDExLCAnTk9UQVRJT04nOiAxMlxuICB9O1xuXG4gIC8qKlxuICAgKiBGcmFtZSBjbGFzcyBmb3IgbmFtZXNwYWNlIGFuZCBiYXNlIFVSSSBsb29rdXBzXG4gICAqIEJhc2UgbG9va3VwcyB3aWxsIGFsd2F5cyByZXNvbHZlIGJlY2F1c2UgdGhlIHBhcnNlciBrbm93c1xuICAgKiB0aGUgZGVmYXVsdCBiYXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpc1snZnJhbWVGYWN0b3J5J10gPSBmdW5jdGlvbiAocGFyc2VyLCBwYXJlbnQsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ05PREUnOiAxLFxuICAgICAgJ0FSQyc6IDIsXG4gICAgICAncGFyZW50JzogcGFyZW50LFxuICAgICAgJ3BhcnNlcic6IHBhcnNlcixcbiAgICAgICdzdG9yZSc6IHBhcnNlclsnc3RvcmUnXSxcbiAgICAgICdlbGVtZW50JzogZWxlbWVudCxcbiAgICAgICdsYXN0Q2hpbGQnOiAwLFxuICAgICAgJ2Jhc2UnOiBudWxsLFxuICAgICAgJ2xhbmcnOiBudWxsLFxuICAgICAgJ25vZGUnOiBudWxsLFxuICAgICAgJ25vZGVUeXBlJzogbnVsbCxcbiAgICAgICdsaXN0SW5kZXgnOiAxLFxuICAgICAgJ3JkZmlkJzogbnVsbCxcbiAgICAgICdkYXRhdHlwZSc6IG51bGwsXG4gICAgICAnY29sbGVjdGlvbic6IGZhbHNlLFxuXG4gICAgICAvKiogVGVybWluYXRlIHRoZSBmcmFtZSBhbmQgbm90aWZ5IHRoZSBzdG9yZSB0aGF0IHdlJ3JlIGRvbmUgKi9cbiAgICAgICd0ZXJtaW5hdGVGcmFtZSc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXNbJ2NvbGxlY3Rpb24nXSkge1xuICAgICAgICAgIHRoaXNbJ25vZGUnXVsnY2xvc2UnXSgpXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAgIC8qKiBBZGQgYSBzeW1ib2wgb2YgYSBjZXJ0YWluIHR5cGUgdG8gdGhlIHRoaXMgZnJhbWUgKi9cbiAgICAgICdhZGRTeW1ib2wnOiBmdW5jdGlvbiAodHlwZSwgdXJpKSB7XG4gICAgICAgIHVyaSA9IGpvaW4odXJpLCB0aGlzWydiYXNlJ10pO1xuICAgICAgICB0aGlzWydub2RlJ10gPSB0aGlzWydzdG9yZSddWydzeW0nXSh1cmkpO1xuICAgICAgICB0aGlzWydub2RlVHlwZSddID0gdHlwZVxuICAgICAgfSxcblxuICAgICAgLyoqIExvYWQgYW55IGNvbnN0cnVjdGVkIHRyaXBsZXMgaW50byB0aGUgc3RvcmUgKi9cbiAgICAgICdsb2FkVHJpcGxlJzogZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpc1sncGFyZW50J11bJ3BhcmVudCddWydjb2xsZWN0aW9uJ10pIHtcbiAgICAgICAgICB0aGlzWydwYXJlbnQnXVsncGFyZW50J11bJ25vZGUnXVsnYXBwZW5kJ10odGhpc1snbm9kZSddKVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXNbJ3N0b3JlJ11bJ2FkZCddKHRoaXNbJ3BhcmVudCddWydwYXJlbnQnXVsnbm9kZSddLFxuICAgICAgICAgICAgdGhpc1sncGFyZW50J11bJ25vZGUnXSxcbiAgICAgICAgICAgIHRoaXNbJ25vZGUnXSxcbiAgICAgICAgICAgIHRoaXNbJ3BhcnNlciddWyd3aHknXSlcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpc1sncGFyZW50J11bJ3JkZmlkJ10gIT0gbnVsbCkgeyAvLyByZWlmeVxuICAgICAgICAgIHZhciB0cmlwbGUgPSB0aGlzWydzdG9yZSddWydzeW0nXShcbiAgICAgICAgICAgIGpvaW4oXCIjXCIgKyB0aGlzWydwYXJlbnQnXVsncmRmaWQnXSxcbiAgICAgICAgICAgICAgdGhpc1snYmFzZSddKSk7XG4gICAgICAgICAgdGhpc1snc3RvcmUnXVsnYWRkJ10odHJpcGxlLFxuICAgICAgICAgICAgdGhpc1snc3RvcmUnXVsnc3ltJ10oXG4gICAgICAgICAgICAgIFJERlBhcnNlclsnbnMnXVsnUkRGJ11cbiAgICAgICAgICAgICAgKyBcInR5cGVcIiksXG4gICAgICAgICAgICB0aGlzWydzdG9yZSddWydzeW0nXShcbiAgICAgICAgICAgICAgUkRGUGFyc2VyWyducyddWydSREYnXVxuICAgICAgICAgICAgICArIFwiU3RhdGVtZW50XCIpLFxuICAgICAgICAgICAgdGhpc1sncGFyc2VyJ11bJ3doeSddKTtcbiAgICAgICAgICB0aGlzWydzdG9yZSddWydhZGQnXSh0cmlwbGUsXG4gICAgICAgICAgICB0aGlzWydzdG9yZSddWydzeW0nXShcbiAgICAgICAgICAgICAgUkRGUGFyc2VyWyducyddWydSREYnXVxuICAgICAgICAgICAgICArIFwic3ViamVjdFwiKSxcbiAgICAgICAgICAgIHRoaXNbJ3BhcmVudCddWydwYXJlbnQnXVsnbm9kZSddLFxuICAgICAgICAgICAgdGhpc1sncGFyc2VyJ11bJ3doeSddKTtcbiAgICAgICAgICB0aGlzWydzdG9yZSddWydhZGQnXSh0cmlwbGUsXG4gICAgICAgICAgICB0aGlzWydzdG9yZSddWydzeW0nXShcbiAgICAgICAgICAgICAgUkRGUGFyc2VyWyducyddWydSREYnXVxuICAgICAgICAgICAgICArIFwicHJlZGljYXRlXCIpLFxuICAgICAgICAgICAgdGhpc1sncGFyZW50J11bJ25vZGUnXSxcbiAgICAgICAgICAgIHRoaXNbJ3BhcnNlciddWyd3aHknXSk7XG4gICAgICAgICAgdGhpc1snc3RvcmUnXVsnYWRkJ10odHJpcGxlLFxuICAgICAgICAgICAgdGhpc1snc3RvcmUnXVsnc3ltJ10oXG4gICAgICAgICAgICAgIFJERlBhcnNlclsnbnMnXVsnUkRGJ11cbiAgICAgICAgICAgICAgKyBcIm9iamVjdFwiKSxcbiAgICAgICAgICAgIHRoaXNbJ25vZGUnXSxcbiAgICAgICAgICAgIHRoaXNbJ3BhcnNlciddWyd3aHknXSlcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqIENoZWNrIGlmIGl0J3MgT0sgdG8gbG9hZCBhIHRyaXBsZSAqL1xuICAgICAgJ2lzVHJpcGxlVG9Mb2FkJzogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKHRoaXNbJ3BhcmVudCddICE9IG51bGxcbiAgICAgICAgICAmJiB0aGlzWydwYXJlbnQnXVsncGFyZW50J10gIT0gbnVsbFxuICAgICAgICAgICYmIHRoaXNbJ25vZGVUeXBlJ10gPT0gdGhpc1snTk9ERSddXG4gICAgICAgICAgJiYgdGhpc1sncGFyZW50J11bJ25vZGVUeXBlJ10gPT0gdGhpc1snQVJDJ11cbiAgICAgICAgICAmJiB0aGlzWydwYXJlbnQnXVsncGFyZW50J11bJ25vZGVUeXBlJ11cbiAgICAgICAgICA9PSB0aGlzWydOT0RFJ10pXG4gICAgICB9LFxuXG4gICAgICAvKiogQWRkIGEgc3ltYm9saWMgbm9kZSB0byB0aGlzIGZyYW1lICovXG4gICAgICAnYWRkTm9kZSc6IGZ1bmN0aW9uICh1cmkpIHtcbiAgICAgICAgdGhpc1snYWRkU3ltYm9sJ10odGhpc1snTk9ERSddLCB1cmkpO1xuICAgICAgICBpZiAodGhpc1snaXNUcmlwbGVUb0xvYWQnXSgpKSB7XG4gICAgICAgICAgdGhpc1snbG9hZFRyaXBsZSddKClcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgICAgLyoqIEFkZCBhIGNvbGxlY3Rpb24gbm9kZSB0byB0aGlzIGZyYW1lICovXG4gICAgICAnYWRkQ29sbGVjdGlvbic6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpc1snbm9kZVR5cGUnXSA9IHRoaXNbJ05PREUnXTtcbiAgICAgICAgdGhpc1snbm9kZSddID0gdGhpc1snc3RvcmUnXVsnY29sbGVjdGlvbiddKCk7XG4gICAgICAgIHRoaXNbJ2NvbGxlY3Rpb24nXSA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzWydpc1RyaXBsZVRvTG9hZCddKCkpIHtcbiAgICAgICAgICB0aGlzWydsb2FkVHJpcGxlJ10oKVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKiogQWRkIGEgY29sbGVjdGlvbiBhcmMgdG8gdGhpcyBmcmFtZSAqL1xuICAgICAgJ2FkZENvbGxlY3Rpb25BcmMnOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXNbJ25vZGVUeXBlJ10gPSB0aGlzWydBUkMnXVxuICAgICAgfSxcblxuICAgICAgLyoqIEFkZCBhIGJub2RlIHRvIHRoaXMgZnJhbWUgKi9cbiAgICAgICdhZGRCTm9kZSc6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgIGlmICh0aGlzWydwYXJzZXInXVsnYm5vZGVzJ11baWRdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXNbJ25vZGUnXSA9IHRoaXNbJ3BhcnNlciddWydibm9kZXMnXVtpZF1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1snbm9kZSddID0gdGhpc1sncGFyc2VyJ11bJ2Jub2RlcyddW2lkXSA9IHRoaXNbJ3N0b3JlJ11bJ2Jub2RlJ10oKVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzWydub2RlJ10gPSB0aGlzWydzdG9yZSddWydibm9kZSddKClcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbJ25vZGVUeXBlJ10gPSB0aGlzWydOT0RFJ107XG4gICAgICAgIGlmICh0aGlzWydpc1RyaXBsZVRvTG9hZCddKCkpIHtcbiAgICAgICAgICB0aGlzWydsb2FkVHJpcGxlJ10oKVxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKiogQWRkIGFuIGFyYyBvciBwcm9wZXJ0eSB0byB0aGlzIGZyYW1lICovXG4gICAgICAnYWRkQXJjJzogZnVuY3Rpb24gKHVyaSkge1xuICAgICAgICBpZiAodXJpID09IFJERlBhcnNlclsnbnMnXVsnUkRGJ10gKyBcImxpXCIpIHtcbiAgICAgICAgICB1cmkgPSBSREZQYXJzZXJbJ25zJ11bJ1JERiddICsgXCJfXCIgKyB0aGlzWydwYXJlbnQnXVsnbGlzdEluZGV4J10rK1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbJ2FkZFN5bWJvbCddKHRoaXNbJ0FSQyddLCB1cmkpXG4gICAgICB9LFxuXG4gICAgICAvKiogQWRkIGEgbGl0ZXJhbCB0byB0aGlzIGZyYW1lICovXG4gICAgICAnYWRkTGl0ZXJhbCc6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodGhpc1sncGFyZW50J11bJ2RhdGF0eXBlJ10pIHtcbiAgICAgICAgICB0aGlzWydub2RlJ10gPSB0aGlzWydzdG9yZSddWydsaXRlcmFsJ10oXG4gICAgICAgICAgICB2YWx1ZSwgXCJcIiwgdGhpc1snc3RvcmUnXVsnc3ltJ10oXG4gICAgICAgICAgICAgIHRoaXNbJ3BhcmVudCddWydkYXRhdHlwZSddKSlcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aGlzWydub2RlJ10gPSB0aGlzWydzdG9yZSddWydsaXRlcmFsJ10oXG4gICAgICAgICAgICB2YWx1ZSwgdGhpc1snbGFuZyddKVxuICAgICAgICB9XG4gICAgICAgIHRoaXNbJ25vZGVUeXBlJ10gPSB0aGlzWydOT0RFJ107XG4gICAgICAgIGlmICh0aGlzWydpc1RyaXBsZVRvTG9hZCddKCkpIHtcbiAgICAgICAgICB0aGlzWydsb2FkVHJpcGxlJ10oKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKiBPdXIgdHJpcGxlIHN0b3JlIHJlZmVyZW5jZSBAcHJpdmF0ZSAqL1xuICB0aGlzWydzdG9yZSddID0gc3RvcmU7XG4gIC8qKiBPdXIgaWRlbnRpZmllZCBibGFuayBub2RlcyBAcHJpdmF0ZSAqL1xuICB0aGlzWydibm9kZXMnXSA9IHt9O1xuICAvKiogQSBjb250ZXh0IGZvciBjb250ZXh0LWF3YXJlIHN0b3JlcyBAcHJpdmF0ZSAqL1xuICB0aGlzWyd3aHknXSA9IG51bGw7XG4gIC8qKiBSZWlmaWNhdGlvbiBmbGFnICovXG4gIHRoaXNbJ3JlaWZ5J10gPSBmYWxzZTtcblxuICAvKipcbiAgICogQnVpbGQgb3VyIGluaXRpYWwgc2NvcGUgZnJhbWUgYW5kIHBhcnNlIHRoZSBET00gaW50byB0cmlwbGVzXG4gICAqIEBwYXJhbSBkb2N1bWVudCBUaGUgRE9NIHRvIHBhcnNlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlIFRoZSBiYXNlIFVSTCB0byB1c2VcbiAgICogQHBhcmFtIHtPYmplY3R9IHdoeSBUaGUgY29udGV4dCB0byB3aGljaCB0aGlzIHJlc291cmNlIGJlbG9uZ3NcbiAgICovXG4gIHRoaXNbJ3BhcnNlJ10gPSBmdW5jdGlvbiAoZG9jdW1lbnQsIGJhc2UsIHdoeSkge1xuICAgIHZhciBjaGlsZHJlbiA9IGRvY3VtZW50WydjaGlsZE5vZGVzJ10sIHJvb3Q7XG5cbiAgICAvLyBjbGVhbiB1cCBmb3IgdGhlIG5leHQgcnVuXG4gICAgdGhpc1snY2xlYW5QYXJzZXInXSgpO1xuXG4gICAgLy8gZmlndXJlIG91dCB0aGUgcm9vdCBlbGVtZW50XG4gICAgaWYgKGRvY3VtZW50Wydub2RlVHlwZSddID09IFJERlBhcnNlclsnbm9kZVR5cGUnXVsnRE9DVU1FTlQnXSkge1xuICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjaGlsZHJlblsnbGVuZ3RoJ107IGMrKykge1xuICAgICAgICBpZiAoY2hpbGRyZW5bY11bJ25vZGVUeXBlJ11cbiAgICAgICAgICA9PSBSREZQYXJzZXJbJ25vZGVUeXBlJ11bJ0VMRU1FTlQnXSkge1xuICAgICAgICAgIHJvb3QgPSBjaGlsZHJlbltjXTtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGRvY3VtZW50Wydub2RlVHlwZSddID09IFJERlBhcnNlclsnbm9kZVR5cGUnXVsnRUxFTUVOVCddKSB7XG4gICAgICByb290ID0gZG9jdW1lbnRcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSREZQYXJzZXI6IGNhbid0IGZpbmQgcm9vdCBpbiBcIiArIGJhc2VcbiAgICAgICAgKyBcIi4gSGFsdGluZy4gXCIpO1xuICAgIH1cblxuICAgIHRoaXNbJ3doeSddID0gd2h5O1xuXG4gICAgLy8gb3VyIHRvcG1vc3QgZnJhbWVcblxuICAgIHZhciBmID0gdGhpc1snZnJhbWVGYWN0b3J5J10odGhpcyk7XG4gICAgZlsnYmFzZSddID0gYmFzZTtcbiAgICBmWydsYW5nJ10gPSAnJztcblxuICAgIHRoaXNbJ3BhcnNlRE9NJ10odGhpc1snYnVpbGRGcmFtZSddKGYsIHJvb3QpKTtcbiAgICByZXR1cm4gdHJ1ZVxuICB9O1xuICB0aGlzWydwYXJzZURPTSddID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgLy8gYSBET00gdXRpbGl0eSBmdW5jdGlvbiB1c2VkIGluIHBhcnNpbmdcbiAgICB2YXIgZWxlbWVudFVSSSA9IGZ1bmN0aW9uIChlbCkge1xuICAgICAgcmV0dXJuIGVsWyduYW1lc3BhY2VVUkknXSArIGVsWydsb2NhbE5hbWUnXVxuICAgIH07XG4gICAgdmFyIGRpZyA9IHRydWU7IC8vIGlmIHdlJ2xsIGRpZyBkb3duIGluIHRoZSB0cmVlIG9uIHRoZSBuZXh0IGl0ZXJcblxuICAgIHdoaWxlIChmcmFtZVsncGFyZW50J10pIHtcbiAgICAgIHZhciByZGZpZCwgYm5pZDtcbiAgICAgIHZhciBkb20gPSBmcmFtZVsnZWxlbWVudCddO1xuICAgICAgdmFyIGF0dHJzID0gZG9tWydhdHRyaWJ1dGVzJ107XG5cbiAgICAgIGlmIChkb21bJ25vZGVUeXBlJ11cbiAgICAgICAgPT0gUkRGUGFyc2VyWydub2RlVHlwZSddWydURVhUJ11cbiAgICAgICAgfHwgZG9tWydub2RlVHlwZSddXG4gICAgICAgID09IFJERlBhcnNlclsnbm9kZVR5cGUnXVsnQ0RBVEFfU0VDVElPTiddKSB7Ly93ZSBoYXZlIGEgbGl0ZXJhbFxuICAgICAgICBmcmFtZVsnYWRkTGl0ZXJhbCddKGRvbVsnbm9kZVZhbHVlJ10pXG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbGVtZW50VVJJKGRvbSlcbiAgICAgICAgIT0gUkRGUGFyc2VyWyducyddWydSREYnXSArIFwiUkRGXCIpIHsgLy8gbm90IHJvb3RcbiAgICAgICAgaWYgKGZyYW1lWydwYXJlbnQnXSAmJiBmcmFtZVsncGFyZW50J11bJ2NvbGxlY3Rpb24nXSkge1xuICAgICAgICAgIC8vIHdlJ3JlIGEgY29sbGVjdGlvbiBlbGVtZW50XG4gICAgICAgICAgZnJhbWVbJ2FkZENvbGxlY3Rpb25BcmMnXSgpO1xuICAgICAgICAgIGZyYW1lID0gdGhpc1snYnVpbGRGcmFtZSddKGZyYW1lLCBmcmFtZVsnZWxlbWVudCddKTtcbiAgICAgICAgICBmcmFtZVsncGFyZW50J11bJ2VsZW1lbnQnXSA9IG51bGxcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZyYW1lWydwYXJlbnQnXSB8fCAhZnJhbWVbJ3BhcmVudCddWydub2RlVHlwZSddXG4gICAgICAgICAgfHwgZnJhbWVbJ3BhcmVudCddWydub2RlVHlwZSddID09IGZyYW1lWydBUkMnXSkge1xuICAgICAgICAgIC8vIHdlIG5lZWQgYSBub2RlXG4gICAgICAgICAgdmFyIGFib3V0ID0gZG9tWydnZXRBdHRyaWJ1dGVOb2RlTlMnXShcbiAgICAgICAgICAgIFJERlBhcnNlclsnbnMnXVsnUkRGJ10sIFwiYWJvdXRcIik7XG4gICAgICAgICAgcmRmaWQgPSBkb21bJ2dldEF0dHJpYnV0ZU5vZGVOUyddKFxuICAgICAgICAgICAgUkRGUGFyc2VyWyducyddWydSREYnXSwgXCJJRFwiKTtcbiAgICAgICAgICBpZiAoYWJvdXQgJiYgcmRmaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJERlBhcnNlcjogXCIgKyBkb21bJ25vZGVOYW1lJ11cbiAgICAgICAgICAgICAgKyBcIiBoYXMgYm90aCByZGY6aWQgYW5kIHJkZjphYm91dC5cIlxuICAgICAgICAgICAgICArIFwiIEhhbHRpbmcuIE9ubHkgb25lIG9mIHRoZXNlXCJcbiAgICAgICAgICAgICAgKyBcIiBwcm9wZXJ0aWVzIG1heSBiZSBzcGVjaWZpZWQgb24gYVwiXG4gICAgICAgICAgICAgICsgXCIgbm9kZS5cIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhYm91dCA9PSBudWxsICYmIHJkZmlkKSB7XG4gICAgICAgICAgICBmcmFtZVsnYWRkTm9kZSddKFwiI1wiICsgcmRmaWRbJ25vZGVWYWx1ZSddKTtcbiAgICAgICAgICAgIGRvbVsncmVtb3ZlQXR0cmlidXRlTm9kZSddKHJkZmlkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChhYm91dCA9PSBudWxsICYmIHJkZmlkID09IG51bGwpIHtcbiAgICAgICAgICAgIGJuaWQgPSBkb21bJ2dldEF0dHJpYnV0ZU5vZGVOUyddKFxuICAgICAgICAgICAgICBSREZQYXJzZXJbJ25zJ11bJ1JERiddLCBcIm5vZGVJRFwiKTtcbiAgICAgICAgICAgIGlmIChibmlkKSB7XG4gICAgICAgICAgICAgIGZyYW1lWydhZGRCTm9kZSddKGJuaWRbJ25vZGVWYWx1ZSddKTtcbiAgICAgICAgICAgICAgZG9tWydyZW1vdmVBdHRyaWJ1dGVOb2RlJ10oYm5pZClcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyYW1lWydhZGRCTm9kZSddKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmcmFtZVsnYWRkTm9kZSddKGFib3V0Wydub2RlVmFsdWUnXSk7XG4gICAgICAgICAgICBkb21bJ3JlbW92ZUF0dHJpYnV0ZU5vZGUnXShhYm91dClcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUeXBlZCBub2Rlc1xuICAgICAgICAgIHZhciByZGZ0eXBlID0gZG9tWydnZXRBdHRyaWJ1dGVOb2RlTlMnXShcbiAgICAgICAgICAgIFJERlBhcnNlclsnbnMnXVsnUkRGJ10sIFwidHlwZVwiKTtcbiAgICAgICAgICBpZiAoUkRGUGFyc2VyWyducyddWydSREYnXSArIFwiRGVzY3JpcHRpb25cIlxuICAgICAgICAgICAgIT0gZWxlbWVudFVSSShkb20pKSB7XG4gICAgICAgICAgICByZGZ0eXBlID0geyAnbm9kZVZhbHVlJzogZWxlbWVudFVSSShkb20pIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJkZnR5cGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpc1snc3RvcmUnXVsnYWRkJ10oZnJhbWVbJ25vZGUnXSxcbiAgICAgICAgICAgICAgdGhpc1snc3RvcmUnXVsnc3ltJ10oXG4gICAgICAgICAgICAgICAgUkRGUGFyc2VyWyducyddWydSREYnXSArIFwidHlwZVwiKSxcbiAgICAgICAgICAgICAgdGhpc1snc3RvcmUnXVsnc3ltJ10oXG4gICAgICAgICAgICAgICAgam9pbihcbiAgICAgICAgICAgICAgICAgIHJkZnR5cGVbJ25vZGVWYWx1ZSddLFxuICAgICAgICAgICAgICAgICAgZnJhbWVbJ2Jhc2UnXSkpLFxuICAgICAgICAgICAgICB0aGlzWyd3aHknXSk7XG4gICAgICAgICAgICBpZiAocmRmdHlwZVsnbm9kZU5hbWUnXSkge1xuICAgICAgICAgICAgICBkb21bJ3JlbW92ZUF0dHJpYnV0ZU5vZGUnXShyZGZ0eXBlKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFByb3BlcnR5IEF0dHJpYnV0ZXNcbiAgICAgICAgICBmb3IgKHZhciB4ID0gYXR0cnNbJ2xlbmd0aCddIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgICAgIHRoaXNbJ3N0b3JlJ11bJ2FkZCddKGZyYW1lWydub2RlJ10sXG4gICAgICAgICAgICAgIHRoaXNbJ3N0b3JlJ11bJ3N5bSddKFxuICAgICAgICAgICAgICAgIGVsZW1lbnRVUkkoYXR0cnNbeF0pKSxcbiAgICAgICAgICAgICAgdGhpc1snc3RvcmUnXVsnbGl0ZXJhbCddKFxuICAgICAgICAgICAgICAgIGF0dHJzW3hdWydub2RlVmFsdWUnXSxcbiAgICAgICAgICAgICAgICBmcmFtZVsnbGFuZyddKSxcbiAgICAgICAgICAgICAgdGhpc1snd2h5J10pXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyB3ZSBzaG91bGQgYWRkIGFuIGFyYyAob3IgaW1wbGljaXQgYm5vZGUrYXJjKVxuICAgICAgICAgIGZyYW1lWydhZGRBcmMnXShlbGVtZW50VVJJKGRvbSkpO1xuXG4gICAgICAgICAgLy8gc2F2ZSB0aGUgYXJjJ3MgcmRmOklEIGlmIGl0IGhhcyBvbmVcbiAgICAgICAgICBpZiAodGhpc1sncmVpZnknXSkge1xuICAgICAgICAgICAgcmRmaWQgPSBkb21bJ2dldEF0dHJpYnV0ZU5vZGVOUyddKFxuICAgICAgICAgICAgICBSREZQYXJzZXJbJ25zJ11bJ1JERiddLCBcIklEXCIpO1xuICAgICAgICAgICAgaWYgKHJkZmlkKSB7XG4gICAgICAgICAgICAgIGZyYW1lWydyZGZpZCddID0gcmRmaWRbJ25vZGVWYWx1ZSddO1xuICAgICAgICAgICAgICBkb21bJ3JlbW92ZUF0dHJpYnV0ZU5vZGUnXShyZGZpZClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGFyc2V0eXBlID0gZG9tWydnZXRBdHRyaWJ1dGVOb2RlTlMnXShcbiAgICAgICAgICAgIFJERlBhcnNlclsnbnMnXVsnUkRGJ10sIFwicGFyc2VUeXBlXCIpO1xuICAgICAgICAgIHZhciBkYXRhdHlwZSA9IGRvbVsnZ2V0QXR0cmlidXRlTm9kZU5TJ10oXG4gICAgICAgICAgICBSREZQYXJzZXJbJ25zJ11bJ1JERiddLCBcImRhdGF0eXBlXCIpO1xuICAgICAgICAgIGlmIChkYXRhdHlwZSkge1xuICAgICAgICAgICAgZnJhbWVbJ2RhdGF0eXBlJ10gPSBkYXRhdHlwZVsnbm9kZVZhbHVlJ107XG4gICAgICAgICAgICBkb21bJ3JlbW92ZUF0dHJpYnV0ZU5vZGUnXShkYXRhdHlwZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocGFyc2V0eXBlKSB7XG4gICAgICAgICAgICB2YXIgbnYgPSBwYXJzZXR5cGVbJ25vZGVWYWx1ZSddO1xuICAgICAgICAgICAgaWYgKG52ID09IFwiTGl0ZXJhbFwiKSB7XG4gICAgICAgICAgICAgIGZyYW1lWydkYXRhdHlwZSddXG4gICAgICAgICAgICAgICAgPSBSREZQYXJzZXJbJ25zJ11bJ1JERiddICsgXCJYTUxMaXRlcmFsXCI7XG4gICAgICAgICAgICAgIC8vICh0aGlzLmJ1aWxkRnJhbWUoZnJhbWUpKS5hZGRMaXRlcmFsKGRvbSlcbiAgICAgICAgICAgICAgLy8gc2hvdWxkIHdvcmsgYnV0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzWydidWlsZEZyYW1lJ10oZnJhbWUpO1xuICAgICAgICAgICAgICBmcmFtZVsnYWRkTGl0ZXJhbCddKGRvbSk7XG4gICAgICAgICAgICAgIGRpZyA9IGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChudiA9PSBcIlJlc291cmNlXCIpIHtcbiAgICAgICAgICAgICAgZnJhbWUgPSB0aGlzWydidWlsZEZyYW1lJ10oZnJhbWUsIGZyYW1lWydlbGVtZW50J10pO1xuICAgICAgICAgICAgICBmcmFtZVsncGFyZW50J11bJ2VsZW1lbnQnXSA9IG51bGw7XG4gICAgICAgICAgICAgIGZyYW1lWydhZGRCTm9kZSddKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG52ID09IFwiQ29sbGVjdGlvblwiKSB7XG4gICAgICAgICAgICAgIGZyYW1lID0gdGhpc1snYnVpbGRGcmFtZSddKGZyYW1lLCBmcmFtZVsnZWxlbWVudCddKTtcbiAgICAgICAgICAgICAgZnJhbWVbJ3BhcmVudCddWydlbGVtZW50J10gPSBudWxsO1xuICAgICAgICAgICAgICBmcmFtZVsnYWRkQ29sbGVjdGlvbiddKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbVsncmVtb3ZlQXR0cmlidXRlTm9kZSddKHBhcnNldHlwZSlcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYXR0cnNbJ2xlbmd0aCddICE9IDApIHtcbiAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IGRvbVsnZ2V0QXR0cmlidXRlTm9kZU5TJ10oXG4gICAgICAgICAgICAgIFJERlBhcnNlclsnbnMnXVsnUkRGJ10sIFwicmVzb3VyY2VcIik7XG4gICAgICAgICAgICBibmlkID0gZG9tWydnZXRBdHRyaWJ1dGVOb2RlTlMnXShcbiAgICAgICAgICAgICAgUkRGUGFyc2VyWyducyddWydSREYnXSwgXCJub2RlSURcIik7XG5cbiAgICAgICAgICAgIGZyYW1lID0gdGhpc1snYnVpbGRGcmFtZSddKGZyYW1lKTtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZSkge1xuICAgICAgICAgICAgICBmcmFtZVsnYWRkTm9kZSddKHJlc291cmNlWydub2RlVmFsdWUnXSk7XG4gICAgICAgICAgICAgIGRvbVsncmVtb3ZlQXR0cmlidXRlTm9kZSddKHJlc291cmNlKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGJuaWQpIHtcbiAgICAgICAgICAgICAgICBmcmFtZVsnYWRkQk5vZGUnXShibmlkWydub2RlVmFsdWUnXSk7XG4gICAgICAgICAgICAgICAgZG9tWydyZW1vdmVBdHRyaWJ1dGVOb2RlJ10oYm5pZClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmcmFtZVsnYWRkQk5vZGUnXSgpXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh4ID0gYXR0cnNbJ2xlbmd0aCddIC0gMTsgeCA+PSAwOyB4LS0pIHtcbiAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzWydidWlsZEZyYW1lJ10oZnJhbWUpO1xuICAgICAgICAgICAgICBmWydhZGRBcmMnXShlbGVtZW50VVJJKGF0dHJzW3hdKSk7XG4gICAgICAgICAgICAgIGlmIChlbGVtZW50VVJJKGF0dHJzW3hdKVxuICAgICAgICAgICAgICAgID09IFJERlBhcnNlclsnbnMnXVsnUkRGJ10gKyBcInR5cGVcIikge1xuICAgICAgICAgICAgICAgICh0aGlzWydidWlsZEZyYW1lJ10oZikpWydhZGROb2RlJ10oXG4gICAgICAgICAgICAgICAgICBhdHRyc1t4XVsnbm9kZVZhbHVlJ10pXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgKHRoaXNbJ2J1aWxkRnJhbWUnXShmKSlbJ2FkZExpdGVyYWwnXShcbiAgICAgICAgICAgICAgICAgIGF0dHJzW3hdWydub2RlVmFsdWUnXSlcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChkb21bJ2NoaWxkTm9kZXMnXVsnbGVuZ3RoJ10gPT0gMCkge1xuICAgICAgICAgICAgKHRoaXNbJ2J1aWxkRnJhbWUnXShmcmFtZSkpWydhZGRMaXRlcmFsJ10oXCJcIilcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gcmRmOlJERlxuXG4gICAgICAvLyBkaWcgZHVnXG4gICAgICBkb20gPSBmcmFtZVsnZWxlbWVudCddO1xuICAgICAgd2hpbGUgKGZyYW1lWydwYXJlbnQnXSkge1xuICAgICAgICB2YXIgcGZyYW1lID0gZnJhbWU7XG4gICAgICAgIHdoaWxlIChkb20gPT0gbnVsbCkge1xuICAgICAgICAgIGZyYW1lID0gZnJhbWVbJ3BhcmVudCddO1xuICAgICAgICAgIGRvbSA9IGZyYW1lWydlbGVtZW50J11cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2ggPSBkb21bJ2NoaWxkTm9kZXMnXTtcbiAgICAgICAgdmFyIGNhbmRpZGF0ZSA9IGNoICE9IG51bGwgPyBjaFtmcmFtZVsnbGFzdENoaWxkJ11dIDogbnVsbDtcbiAgICAgICAgaWYgKGNhbmRpZGF0ZSA9PSBudWxsIHx8ICFkaWcpIHtcbiAgICAgICAgICBmcmFtZVsndGVybWluYXRlRnJhbWUnXSgpO1xuICAgICAgICAgIGlmICghKGZyYW1lID0gZnJhbWVbJ3BhcmVudCddKSkge1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9IC8vIGRvbmVcbiAgICAgICAgICBkb20gPSBmcmFtZVsnZWxlbWVudCddO1xuICAgICAgICAgIGRpZyA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2FuZGlkYXRlWydub2RlVHlwZSddXG4gICAgICAgICAgICAhPSBSREZQYXJzZXJbJ25vZGVUeXBlJ11bJ0VMRU1FTlQnXVxuICAgICAgICAgICAgJiYgY2FuZGlkYXRlWydub2RlVHlwZSddXG4gICAgICAgICAgICAhPSBSREZQYXJzZXJbJ25vZGVUeXBlJ11bJ1RFWFQnXVxuICAgICAgICAgICAgJiYgY2FuZGlkYXRlWydub2RlVHlwZSddXG4gICAgICAgICAgICAhPSBSREZQYXJzZXJbJ25vZGVUeXBlJ11bJ0NEQVRBX1NFQ1RJT04nXSlcbiAgICAgICAgICB8fCAoKGNhbmRpZGF0ZVsnbm9kZVR5cGUnXVxuICAgICAgICAgICAgPT0gUkRGUGFyc2VyWydub2RlVHlwZSddWydURVhUJ11cbiAgICAgICAgICAgIHx8IGNhbmRpZGF0ZVsnbm9kZVR5cGUnXVxuICAgICAgICAgICAgPT0gUkRGUGFyc2VyWydub2RlVHlwZSddWydDREFUQV9TRUNUSU9OJ10pXG4gICAgICAgICAgICAmJiBkb21bJ2NoaWxkTm9kZXMnXVsnbGVuZ3RoJ10gIT0gMSkpIHtcbiAgICAgICAgICBmcmFtZVsnbGFzdENoaWxkJ10rK1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBub3QgYSBsZWFmXG4gICAgICAgICAgZnJhbWVbJ2xhc3RDaGlsZCddKys7XG4gICAgICAgICAgZnJhbWUgPSB0aGlzWydidWlsZEZyYW1lJ10ocGZyYW1lLFxuICAgICAgICAgICAgZG9tWydjaGlsZE5vZGVzJ11bZnJhbWVbJ2xhc3RDaGlsZCddIC0gMV0pO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIHdoaWxlXG4gIH07XG5cbiAgLyoqXG4gICAqIENsZWFucyBvdXQgc3RhdGUgZnJvbSBhIHByZXZpb3VzIHBhcnNlIHJ1blxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgdGhpc1snY2xlYW5QYXJzZXInXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzWydibm9kZXMnXSA9IHt9O1xuICAgIHRoaXNbJ3doeSddID0gbnVsbFxuICB9O1xuXG4gIC8qKlxuICAgKiBCdWlsZHMgc2NvcGUgZnJhbWVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHRoaXNbJ2J1aWxkRnJhbWUnXSA9IGZ1bmN0aW9uIChwYXJlbnQsIGVsZW1lbnQpIHtcbiAgICB2YXIgZnJhbWUgPSB0aGlzWydmcmFtZUZhY3RvcnknXSh0aGlzLCBwYXJlbnQsIGVsZW1lbnQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgIGZyYW1lWydiYXNlJ10gPSBwYXJlbnRbJ2Jhc2UnXTtcbiAgICAgIGZyYW1lWydsYW5nJ10gPSBwYXJlbnRbJ2xhbmcnXVxuICAgIH1cbiAgICBpZiAoZWxlbWVudCA9PSBudWxsXG4gICAgICB8fCBlbGVtZW50Wydub2RlVHlwZSddID09IFJERlBhcnNlclsnbm9kZVR5cGUnXVsnVEVYVCddXG4gICAgICB8fCBlbGVtZW50Wydub2RlVHlwZSddID09IFJERlBhcnNlclsnbm9kZVR5cGUnXVsnQ0RBVEFfU0VDVElPTiddKSB7XG4gICAgICByZXR1cm4gZnJhbWVcbiAgICB9XG5cbiAgICB2YXIgYXR0cnMgPSBlbGVtZW50WydhdHRyaWJ1dGVzJ107XG5cbiAgICB2YXIgYmFzZSA9IGVsZW1lbnRbJ2dldEF0dHJpYnV0ZU5vZGUnXShcInhtbDpiYXNlXCIpO1xuICAgIGlmIChiYXNlICE9IG51bGwpIHtcbiAgICAgIGZyYW1lWydiYXNlJ10gPSBiYXNlWydub2RlVmFsdWUnXTtcbiAgICAgIGVsZW1lbnRbJ3JlbW92ZUF0dHJpYnV0ZSddKFwieG1sOmJhc2VcIilcbiAgICB9XG4gICAgdmFyIGxhbmcgPSBlbGVtZW50WydnZXRBdHRyaWJ1dGVOb2RlJ10oXCJ4bWw6bGFuZ1wiKTtcbiAgICBpZiAobGFuZyAhPSBudWxsKSB7XG4gICAgICBmcmFtZVsnbGFuZyddID0gbGFuZ1snbm9kZVZhbHVlJ107XG4gICAgICBlbGVtZW50WydyZW1vdmVBdHRyaWJ1dGUnXShcInhtbDpsYW5nXCIpXG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGFsbCBleHRyYW5lb3VzIHhtbCBhbmQgeG1sbnMgYXR0cmlidXRlc1xuICAgIGZvciAodmFyIHggPSBhdHRyc1snbGVuZ3RoJ10gLSAxOyB4ID49IDA7IHgtLSkge1xuICAgICAgaWYgKGF0dHJzW3hdWydub2RlTmFtZSddWydzdWJzdHInXSgwLCAzKSA9PSBcInhtbFwiKSB7XG4gICAgICAgIGVsZW1lbnRbJ3JlbW92ZUF0dHJpYnV0ZU5vZGUnXShhdHRyc1t4XSlcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZyYW1lXG4gIH1cbn07XG5leHBvcnQgZGVmYXVsdCBSREZQYXJzZXI7XG4iLCJpbXBvcnQgeyBqb2luIH0gZnJvbSAnLi91cmknO1xuLy8gVGhlc2UgYXJlIHRoZSBjbGFzc2VzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIFJERiBhbmQgTjMgZGF0YSBtb2RlbHNcbi8vXG4vLyBEZXNpZ25lZCB0byBsb29rIGxpa2UgcmRmbGliIGFuZCBjd20gZGVzaWducy5cbi8vXG4vLyBJc3N1ZXM6IFNob3VsZCB0aGUgbmFtZXMgc3RhcnQgd2l0aCBSREYgdG8gbWFrZSB0aGVtXG4vLyAgICAgIHVuaXF1ZSBhcyBwcm9ncmFtLXdpZGUgc3ltYm9scz9cbi8vXG4vLyBXM0Mgb3BlbiBzb3VyY2UgbGljZW5jZSAyMDA1LlxuLy9cblxuY29uc3QgUkRGVHJhY2tpbmcgPSAwO1xuLy8gQXJlIHdlIHJlcXVpcmluZyByZWFzb25zIGZvciBzdGF0ZW1lbnRzP1xuXG4vL3Rha2VzIGluIGFuIG9iamVjdCBhbmQgbWFrZXMgaXQgYW4gb2JqZWN0IGlmIGl0J3MgYSBsaXRlcmFsXG5jb25zdCBtYWtlVGVybSA9ICh2YWwpID0+IHtcbiAgLy8gIGZ5aShcIk1ha2luZyB0ZXJtIGZyb20gXCIgKyB2YWwpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG5ldyBSREZMaXRlcmFsKHZhbCk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBhbGVydChgQ2FuJ3QgbWFrZSB0ZXJtIGZyb20gJHt2YWx9IG9mIHR5cGUgJHt0eXBlb2YgdmFsfWApOyAvLyBAQCBhZGQgbnVtYmVyc1xufTtcblxuLy9cdFN5bWJvbFxuY29uc3QgUkRGRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUkRGRW1wdHkucHJvdG90eXBlLnRlcm1UeXBlID0gJ2VtcHR5JztcblxuUkRGRW1wdHkucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gJyc7XG59O1xuXG5SREZFbXB0eS5wcm90b3R5cGUudG9OVCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICcnXG59O1xuXG4vKipcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgUkRGU3ltYm9sX3RvTlQgPSBmdW5jdGlvbiAoeCkge1xuICByZXR1cm4gKCc8JyArIHgudXJpICsgJz4nKTtcbn07XG5cbmNvbnN0IHRvTlQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBSREZTeW1ib2xfdG9OVCh0aGlzKTtcbn07XG5cbmNvbnN0IFJERlN5bWJvbCA9IGZ1bmN0aW9uICh1cmkpIHtcbiAgdGhpcy51cmkgPSB1cmk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUkRGU3ltYm9sLnByb3RvdHlwZS50ZXJtVHlwZSA9ICdzeW1ib2wnO1xuXG5SREZTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nID0gdG9OVDtcblxuUkRGU3ltYm9sLnByb3RvdHlwZS50b05UID0gdG9OVDtcblxuLy9cdEJsYW5rIE5vZGVcblxubGV0IFJERk5leHRJZCA9IDA7ICAvLyBHb2JhbCBnZW5pZFxuY29uc3QgTlRBbm9ueW1vdXNOb2RlUHJlZml4ID0gJ186bic7XG5cbmNvbnN0IFJERkJsYW5rTm9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5pZCA9IFJERk5leHRJZCsrO1xuICByZXR1cm4gdGhpcztcbn07XG5cblJERkJsYW5rTm9kZS5wcm90b3R5cGUudGVybVR5cGUgPSAnYm5vZGUnO1xuXG5SREZCbGFua05vZGUucHJvdG90eXBlLnRvTlQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBOVEFub255bW91c05vZGVQcmVmaXggKyB0aGlzLmlkO1xufTtcblJERkJsYW5rTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBSREZCbGFua05vZGUucHJvdG90eXBlLnRvTlQ7XG5cbi8vXHRMaXRlcmFsXG5cbmNvbnN0IFJERkxpdGVyYWwgPSBmdW5jdGlvbiAodmFsdWUsIC8qU3RyaW5nPSovIGxhbmcsIC8qU3RyaW5nPSovZGF0YXR5cGUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmxhbmcgPSBsYW5nO1x0ICAvLyBzdHJpbmdcbiAgdGhpcy5kYXRhdHlwZSA9IGRhdGF0eXBlOyAgLy8gdGVybVxuICByZXR1cm4gdGhpcztcbn07XG5cblJERkxpdGVyYWwucHJvdG90eXBlLnRlcm1UeXBlID0gJ2xpdGVyYWwnO1xuXG5SREZMaXRlcmFsLnByb3RvdHlwZS50b05UID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBzdHIgPSB0aGlzLnZhbHVlO1xuICBpZiAodHlwZW9mIHN0ciAhPSAnc3RyaW5nJykge1xuICAgIHRocm93IEVycm9yKCdWYWx1ZSBvZiBSREYgbGl0ZXJhbCBpcyBub3Qgc3RyaW5nOiAnICsgc3RyKTtcbiAgfVxuICBzdHIgPSBzdHIucmVwbGFjZSgvXFxcXC9nLCAnXFxcXFxcXFwnKTsgIC8vIGVzY2FwZVxuICBzdHIgPSBzdHIucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpO1xuICBzdHIgPSAnXCInICsgc3RyICsgJ1wiJztcblxuICBpZiAodGhpcy5kYXRhdHlwZSkge1xuICAgIC8vYWxlcnQodGhpcy5kYXRhdHlwZS50ZXJtVHlwZStcIiAgIFwiK3R5cGVvZiB0aGlzLmRhdGF0eXBlKVxuICAgIHN0ciA9IHN0ciArICdeXicgKyB0aGlzLmRhdGF0eXBlOy8vLnRvTlQoKVxuICB9XG4gIGlmICh0aGlzLmxhbmcpIHtcbiAgICBzdHIgPSBzdHIgKyAnQCcgKyB0aGlzLmxhbmc7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07XG5cblJERkxpdGVyYWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cbmNvbnN0IFJERkNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuaWQgPSBSREZOZXh0SWQrKztcbiAgdGhpcy5lbGVtZW50cyA9IFtdO1xuICB0aGlzLmNsb3NlZCA9IGZhbHNlO1xufTtcblxuUkRGQ29sbGVjdGlvbi5wcm90b3R5cGUudGVybVR5cGUgPSAnY29sbGVjdGlvbic7XG5cblJERkNvbGxlY3Rpb24ucHJvdG90eXBlLnRvTlQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBOVEFub255bW91c05vZGVQcmVmaXggKyB0aGlzLmlkO1xufTtcblJERkNvbGxlY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nID0gUkRGQ29sbGVjdGlvbi5wcm90b3R5cGUudG9OVDtcblxuUkRGQ29sbGVjdGlvbi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGVsKSB7XG4gIHRoaXMuZWxlbWVudHMucHVzaChlbCk7XG59O1xuXG5SREZDb2xsZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5jbG9zZWQgPSB0cnVlO1xufTtcblxuLy9cdFN0YXRlbWVudFxuLy9cbi8vICBUaGlzIGlzIGEgdHJpcGxlIHdpdGggYW4gb3B0aW9uYWwgcmVhc29uLlxuLy9cbi8vICAgVGhlIHJlYXNvbiBjYW4gcG9pbnQgdG8gcHJvdmVuZWNlIG9yIGluZmVyZW5jZVxuLy9cbi8qKlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBSREZTdGF0ZW1lbnRfdG9OVCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICh0aGlzLnN1YmplY3QudG9OVCgpICsgJyAnXG4gICAgKyB0aGlzLnByZWRpY2F0ZS50b05UKCkgKyAnICdcbiAgICArIHRoaXMub2JqZWN0LnRvTlQoKSArICcgLicpO1xufTtcblxuY29uc3QgUkRGU3RhdGVtZW50ID0gZnVuY3Rpb24gKHN1YmplY3QsIHByZWRpY2F0ZSwgb2JqZWN0LCB3aHkpIHtcbiAgdGhpcy5zdWJqZWN0ID0gbWFrZVRlcm0oc3ViamVjdCk7XG4gIHRoaXMucHJlZGljYXRlID0gbWFrZVRlcm0ocHJlZGljYXRlKTtcbiAgdGhpcy5vYmplY3QgPSBtYWtlVGVybShvYmplY3QpO1xuICBpZiAodHlwZW9mIHdoeSAhPSAndW5kZWZpbmVkJykge1xuICAgIHRoaXMud2h5ID0gd2h5O1xuICB9IGVsc2UgaWYgKFJERlRyYWNraW5nKSB7XG4gICAgY29uc29sZS5sb2coJ1dBUk5JTkc6IE5vIHJlYXNvbiBvbiAnICsgc3ViamVjdCArICcgJyArIHByZWRpY2F0ZSArICcgJyArIG9iamVjdCk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SREZTdGF0ZW1lbnQucHJvdG90eXBlLnRvTlQgPSBSREZTdGF0ZW1lbnRfdG9OVDtcblJERlN0YXRlbWVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBSREZTdGF0ZW1lbnRfdG9OVDtcblxuLy9cdEZvcm11bGFcbi8vXG4vL1x0U2V0IG9mIHN0YXRlbWVudHMuXG5cbmNvbnN0IFJERkZvcm11bGEgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuc3RhdGVtZW50cyA9IFtdO1xuICB0aGlzLmNvbnN0cmFpbnRzID0gW107XG4gIHRoaXMuaW5pdEJpbmRpbmdzID0gW107XG4gIHRoaXMub3B0aW9uYWwgPSBbXTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKmZ1bmN0aW9uIFJERlF1ZXJ5Rm9ybXVsYSgpIHtcbiAgdGhpcy5zdGF0ZW1lbnRzID0gW11cbiAgdGhpcy5jb25zdHJhaW50cyA9IFtdXG4gIHRoaXMuaW5pdEJpbmRpbmdzID0gW11cbiAgdGhpcy5vcHRpb25hbCA9IFtdXG4gIHJldHVybiB0aGlzXG59Ki9cblxuLyoqXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IFJERkZvcm11bGFfdG9OVCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuICd7XFxuJyArIHRoaXMuc3RhdGVtZW50cy5qb2luKCdcXG4nKSArICd9Jztcbn07XG5cbi8vUkRGUXVlcnlGb3JtdWxhLnByb3RvdHlwZSA9IG5ldyBSREZGb3JtdWxhKClcbi8vUkRGUXVlcnlGb3JtdWxhLnRlcm1UeXBlID0gJ3F1ZXJ5Rm9ybXVsYSdcblJERkZvcm11bGEucHJvdG90eXBlLnRlcm1UeXBlID0gJ2Zvcm11bGEnO1xuUkRGRm9ybXVsYS5wcm90b3R5cGUudG9OVCA9IFJERkZvcm11bGFfdG9OVDtcblJERkZvcm11bGEucHJvdG90eXBlLnRvU3RyaW5nID0gUkRGRm9ybXVsYV90b05UO1xuXG5SREZGb3JtdWxhLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoc3ViaiwgcHJlZCwgb2JqLCB3aHkpIHtcbiAgdGhpcy5zdGF0ZW1lbnRzLnB1c2gobmV3IFJERlN0YXRlbWVudChzdWJqLCBwcmVkLCBvYmosIHdoeSkpO1xufTtcblxuLy8gQ29udmVuaWVuY2UgbWV0aG9kcyBvbiBhIGZvcm11bGEgYWxsb3cgdGhlIGNyZWF0aW9uIG9mIG5ldyBSREYgdGVybXM6XG5cblJERkZvcm11bGEucHJvdG90eXBlLnN5bSA9IGZ1bmN0aW9uICh1cmksIG5hbWUpIHtcbiAgaWYgKG5hbWUgIT0gbnVsbCkge1xuICAgIHVyaSA9IHRoaXMubmFtZXNwYWNlc1t1cmldICsgbmFtZTtcbiAgfVxuICByZXR1cm4gbmV3IFJERlN5bWJvbCh1cmkpO1xufTtcblxuUkRGRm9ybXVsYS5wcm90b3R5cGUubGl0ZXJhbCA9IGZ1bmN0aW9uICh2YWwsIGxhbmcsIGR0KSB7XG4gIHJldHVybiBuZXcgUkRGTGl0ZXJhbCh2YWwudG9TdHJpbmcoKSwgbGFuZywgZHQpO1xufTtcblxuUkRGRm9ybXVsYS5wcm90b3R5cGUuYm5vZGUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUkRGQmxhbmtOb2RlKCk7XG59O1xuXG5SREZGb3JtdWxhLnByb3RvdHlwZS5mb3JtdWxhID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbmV3IFJERkZvcm11bGEoKTtcbn07XG5cblJERkZvcm11bGEucHJvdG90eXBlLmNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBuZXcgUkRGQ29sbGVjdGlvbigpO1xufTtcblxuLypSREZGb3JtdWxhLnByb3RvdHlwZS5xdWVyeUZvcm11bGEgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBSREZRdWVyeUZvcm11bGEoKVxufSovXG5cbmNvbnN0IFJERlZhcmlhYmxlQmFzZSA9ICd2YXJpZDonOyAvLyBXZSBkZWVtIHZhcmlhYmUgeCB0byBiZSB0aGUgc3ltYm9sIHZhcmlkOnhcblxuLy9BbiBSREZWYXJpYWJsZSBpcyBhIHR5cGUgb2Ygcy9wL28gdGhhdCdzIG5vdCBsaXRlcmFsLiBBbGwgaXQgaG9sZHMgaXMgaXQncyBVUkkuXG4vL0l0IGhhcyB0eXBlICd2YXJpYWJsZScsIGFuZCBhIGZ1bmN0aW9uIHRvTlQgdGhhdCB0dXJucyBpdCBpbnRvIE5UcmlwbGUgZm9ybVxuY29uc3QgUkRGVmFyaWFibGUgPSBmdW5jdGlvbiAocmVsKSB7XG4gIHRoaXMudXJpID0gam9pbihyZWwsIFJERlZhcmlhYmxlQmFzZSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUkRGVmFyaWFibGUucHJvdG90eXBlLnRlcm1UeXBlID0gJ3ZhcmlhYmxlJztcblJERlZhcmlhYmxlLnByb3RvdHlwZS50b05UID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy51cmkuc2xpY2UoMCwgUkRGVmFyaWFibGVCYXNlLmxlbmd0aCkgPT0gUkRGVmFyaWFibGVCYXNlKSB7XG4gICAgcmV0dXJuIGA/JHt0aGlzLnVyaS5zbGljZShSREZWYXJpYWJsZUJhc2UubGVuZ3RoKX1gO1xuICB9IC8vIEBAIHBvb3IgbWFuJ3MgcmVmVG9cbiAgcmV0dXJuIGA/JHt0aGlzLnVyaX1gO1xufTtcblxuUkRGVmFyaWFibGUucHJvdG90eXBlLnRvU3RyaW5nID0gUkRGVmFyaWFibGUucHJvdG90eXBlLnRvTlQ7XG5SREZWYXJpYWJsZS5wcm90b3R5cGUuY2xhc3NPcmRlciA9IDc7XG5cblJERkZvcm11bGEucHJvdG90eXBlLnZhcmlhYmxlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIG5ldyBSREZWYXJpYWJsZShuYW1lKTtcbn07XG5cblJERlZhcmlhYmxlLnByb3RvdHlwZS5oYXNoU3RyaW5nID0gUkRGVmFyaWFibGUucHJvdG90eXBlLnRvTlQ7XG5cbi8vIFBhcnNlIGEgc2luZ2xlIHRva2VuXG4vL1xuLy8gVGhlIGJub2RlIGJpdCBzaG91bGQgbm90IGJlIHVzZWQgb24gcHJvZ3JhbS1leHRlcm5hbCB2YWx1ZXM7IGRlc2lnbmVkXG4vLyBmb3IgaW50ZXJuYWwgd29yayBzdWNoIGFzIHN0b3JpbmcgYSBibm9kZSBpZCBpbiBhbiBIVE1MIGF0dHJpYnV0ZS5cbi8vIE5vdCBjb2RlZCBmb3IgbGl0ZXJhbHMuXG5cblJERkZvcm11bGEucHJvdG90eXBlLmZyb21OVCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgY29uc3QgbGVuID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgY2ggPSBzdHIuc2xpY2UoMCwgMSk7XG4gIGlmIChjaCA9PT0gJzwnKSB7XG4gICAgcmV0dXJuIHRoaXMuc3ltKHN0ci5zbGljZSgxLCBsZW4gLSAxKSk7XG4gIH1cbiAgaWYgKGNoID09PSAnXycpIHtcbiAgICBjb25zdCB4ID0gbmV3IFJERkJsYW5rTm9kZSgpO1xuICAgIHguaWQgPSBwYXJzZUludChzdHIuc2xpY2UoMykpO1xuICAgIFJERk5leHRJZC0tO1xuICAgIHJldHVybiB4XG4gIH1cbiAgYWxlcnQoYENhbid0IHlldCBjb252ZXJ0IGZyb20gTlQ6ICcke3N0cn0nLCAke3N0clswXX1gKTtcbn07XG5cbmV4cG9ydCB7XG4gIFJERlN5bWJvbCxcbiAgUkRGRm9ybXVsYSxcbiAgUkRGQmxhbmtOb2RlLFxuICBSREZMaXRlcmFsLFxufTtcbiIsIi8vICBJbXBsZW1lbnRpbmcgVVJJLXNwZWNpZmljIGZ1bmN0aW9uc1xuLy9cbi8vXHRTZWUgUkZDIDIzODZcbi8vXG4vLyBUaGlzIGlzIG9yIHdhcyAgIGh0dHA6Ly93d3cudzMub3JnLzIwMDUvMTAvYWphdy91cmkuanNcbi8vIDIwMDUgVzNDIG9wZW4gc291cmNlIGxpY2VuY2Vcbi8vXG4vL1xuLy8gIFRha2UgYSBVUkkgZ2l2ZW4gaW4gcmVsYXRpdmUgb3IgYWJzb2x1dGUgZm9ybSBhbmQgYSBiYXNlXG4vLyAgVVJJLCBhbmQgcmV0dXJuIGFuIGFic29sdXRlIFVSSVxuLy9cbi8vICBTZWUgYWxzbyBodHRwOi8vd3d3LnczLm9yZy8yMDAwLzEwL3N3YXAvdXJpcGF0aC5weVxuLy9cblxuY29uc3Qgam9pbiA9IChnaXZlbiwgYmFzZSkgPT4ge1xuICAvLyBpZiAodHlwZW9mIGZ5aSAhPSAndW5kZWZpbmVkJykgZnlpKFwiICAgVVJJIGdpdmVuPVwiK2dpdmVuK1wiIGJhc2U9XCIrYmFzZSlcbiAgdmFyIGJhc2VIYXNoID0gYmFzZS5pbmRleE9mKCcjJyk7XG4gIGlmIChiYXNlSGFzaCA+IDApIGJhc2UgPSBiYXNlLnNsaWNlKDAsIGJhc2VIYXNoKTtcbiAgaWYgKGdpdmVuLmxlbmd0aCA9PSAwKSByZXR1cm4gYmFzZTsgLy8gYmVmb3JlIGNob3BwaW5nIGl0cyBmaWxlbmFtZSBvZmZcbiAgaWYgKGdpdmVuLmluZGV4T2YoJyMnKSA9PSAwKSByZXR1cm4gYmFzZSArIGdpdmVuO1xuICB2YXIgY29sb24gPSBnaXZlbi5pbmRleE9mKCc6Jyk7XG4gIGlmIChjb2xvbiA+PSAwKSByZXR1cm4gZ2l2ZW47XHQvLyBBYnNvbHV0ZSBVUkkgZm9ybSBvdmVycmlkZXMgYmFzZSBVUklcbiAgdmFyIGJhc2VDb2xvbiA9IGJhc2UuaW5kZXhPZignOicpO1xuICBpZiAoYmFzZUNvbG9uIDwgMCkge1xuICAgIGNvbnNvbGUubG9nKFwiSW52YWxpZCBiYXNlIFVSTCBcIiArIGJhc2UpO1xuICAgIHJldHVybiBnaXZlbjtcbiAgfVxuICB2YXIgYmFzZVNjaGVtZSA9IGJhc2Uuc2xpY2UoMCwgYmFzZUNvbG9uICsgMSk7ICAvLyBlZyBodHRwOlxuICBpZiAoZ2l2ZW4uaW5kZXhPZihcIi8vXCIpID09IDApIHsgICAgLy8gU3RhcnRzIHdpdGggLy9cbiAgICByZXR1cm4gYmFzZVNjaGVtZSArIGdpdmVuO1xuICB9XG4gIHZhciBiYXNlU2luZ2xlO1xuICBpZiAoYmFzZS5pbmRleE9mKCcvLycsIGJhc2VDb2xvbikgPT0gYmFzZUNvbG9uICsgMSkgeyAgLy8gQW55IGhvc3RwYXJ0P1xuICAgIGJhc2VTaW5nbGUgPSBiYXNlLmluZGV4T2YoXCIvXCIsIGJhc2VDb2xvbiArIDMpO1xuICAgIGlmIChiYXNlU2luZ2xlIDwgMCkge1xuICAgICAgaWYgKGJhc2UubGVuZ3RoIC0gYmFzZUNvbG9uIC0gMyA+IDApIHtcbiAgICAgICAgcmV0dXJuIGJhc2UgKyBcIi9cIiArIGdpdmVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGJhc2VTY2hlbWUgKyBnaXZlbjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYmFzZVNpbmdsZSA9IGJhc2UuaW5kZXhPZihcIi9cIiwgYmFzZUNvbG9uICsgMSk7XG4gICAgaWYgKGJhc2VTaW5nbGUgPCAwKSB7XG4gICAgICBpZiAoYmFzZS5sZW5ndGggLSBiYXNlQ29sb24gLSAxID4gMCkge1xuICAgICAgICByZXR1cm4gYmFzZSArIFwiL1wiICsgZ2l2ZW47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYmFzZVNjaGVtZSArIGdpdmVuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAoZ2l2ZW4uaW5kZXhPZignLycpID09IDApIHtcdC8vIHN0YXJ0cyB3aXRoIC8gYnV0IG5vdCAvL1xuICAgIHJldHVybiBiYXNlLnNsaWNlKDAsIGJhc2VTaW5nbGUpICsgZ2l2ZW47XG4gIH1cblxuICB2YXIgcGF0aCA9IGJhc2Uuc2xpY2UoYmFzZVNpbmdsZSk7XG4gIHZhciBsYXN0U2xhc2ggPSBwYXRoLmxhc3RJbmRleE9mKCcvJyk7XG4gIGlmIChsYXN0U2xhc2ggPCAwKSByZXR1cm4gYmFzZVNjaGVtZSArIGdpdmVuO1xuICBpZiAoKGxhc3RTbGFzaCA+PSAwKSAmJiAobGFzdFNsYXNoIDwgKHBhdGgubGVuZ3RoIC0gMSkpKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgbGFzdFNsYXNoICsgMSk7IC8vIENob3AgdHJhaWxpbmcgZmlsZW5hbWUgZnJvbSBiYXNlXG4gIH1cblxuICBwYXRoID0gcGF0aCArIGdpdmVuO1xuICB3aGlsZSAocGF0aC5tYXRjaCgvW15cXC9dKlxcL1xcLlxcLlxcLy8pKSB7Ly8gbXVzdCBhcHBseSB0byByZXN1bHQgb2YgcHJldlxuICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL1teXFwvXSpcXC9cXC5cXC5cXC8vLCAnJyk7IC8vIEVDTUFzY3JpcHQgc3BlYyA3LjguNVxuICB9XG4gIHBhdGggPSBwYXRoLnJlcGxhY2UoL1xcLlxcLy9nLCAnJyk7IC8vIHNwZWMgdmFndWUgb24gZXNjYXBpbmdcbiAgcmV0dXJuIGJhc2Uuc2xpY2UoMCwgYmFzZVNpbmdsZSkgKyBwYXRoO1xufTtcblxuLyoqIHJldHVybnMgVVJJIHdpdGhvdXQgdGhlIGZyYWcgKiovXG5jb25zdCBkb2NwYXJ0ID0gKHVyaSkgPT4ge1xuICB2YXIgaSA9IHVyaS5pbmRleE9mKFwiI1wiKTtcbiAgaWYgKGkgPCAwKSByZXR1cm4gdXJpO1xuICByZXR1cm4gdXJpLnNsaWNlKDAsIGkpO1xufTtcblxuLyoqIHJldHVybiB0aGUgcHJvdG9jb2wgb2YgYSB1cmkgKiovXG5jb25zdCBwcm90b2NvbCA9IHVyaSA9PiB1cmkuc2xpY2UoMCwgdXJpLmluZGV4T2YoJzonKSlcblxuZXhwb3J0IHtcbiAgam9pbixcbiAgcHJvdG9jb2wsXG4gIGRvY3BhcnRcbn07XG4iLCJjb25zdCBuc3MgPSB7XG4gIGljYWw6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAyLzEyL2NhbC9pY2FsIycsXG4gIHZjYXJkOiAnaHR0cDovL3d3dy53My5vcmcvMjAwNi92Y2FyZC9ucyMnLFxuICBkY3Rlcm1zOiAnaHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zLycsXG4gIHNrb3M6ICdodHRwOi8vd3d3LnczLm9yZy8yMDA0LzAyL3Nrb3MvY29yZSMnLFxuICByZGZzOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hIycsXG4gIHJkZjogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnLFxuICBvd2w6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAyLzA3L293bCMnLFxuICB2czogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDMvMDYvc3ctdm9jYWItc3RhdHVzL25zIycsXG4gIGZvYWY6ICdodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xLycsXG4gIHdvdDogJ2h0dHA6Ly94bWxucy5jb20vd290LzAuMS8nLFxuICBkYzogJ2h0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvJyxcbiAgeHNkOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMS9YTUxTY2hlbWEjJyxcbiAgZGNhdDogJ2h0dHA6Ly93d3cudzMub3JnL25zL2RjYXQjJyxcbiAgb3JnOiAnaHR0cDovL3d3dy53My5vcmcvbnMvb3JnIycsXG4gIGduOiAnaHR0cDovL3d3dy5nZW9uYW1lcy5vcmcvb250b2xvZ3kjJyxcbiAgbG9jbjogJ2h0dHA6Ly93d3cudzMub3JnL25zL2xvY24jJyxcbiAgc2NoZW1hOiAnaHR0cDovL3NjaGVtYS5vcmcvJyxcbiAgZXg6ICdodHRwOi8vZXhhbXBsZS5jb20vJyxcbiAgZ3NwOiAnaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vbnQvZ2Vvc3BhcnFsIycsXG4gIG9kcnM6ICdodHRwOi8vc2NoZW1hLnRoZW9kaS5vcmcvb2RycyMnLFxufTtcbmxldCBuc2NvdW50ZXIgPSAwO1xuY29uc3QgX25zaWZ5ID0gKG5zLCBleHBhbmRlZCwgbG9jYWxuYW1lKSA9PiB7XG4gIGlmICghbnNzW25zXSkge1xuICAgIG5zc1tuc10gPSBleHBhbmRlZDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGFiYnJldjogbnMsXG4gICAgbnM6IGV4cGFuZGVkLFxuICAgIGxvY2FsbmFtZSxcbiAgICBmdWxsOiBleHBhbmRlZCArIGxvY2FsbmFtZSxcbiAgICBwcmV0dHk6IGAke25zfToke2xvY2FsbmFtZX1gLFxuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW4gdGhlIGZvbGxvd2luZyBhdHRyaWJ1dGVzOlxuICpcbiAqIGFiYnJldiAtIHRoZSBzaG9ydCBuYW1lc3BhY2VcbiAqIG5zIC0gd2hhdCB0aGUgc2hvcnQgbmFtZXNwYWNlIGFiYnJldmlhdGVzXG4gKiBsb2NhbG5hbWUgLSB0aGUgbG9jYWxuYW1lIG9mIHRoZSBVUkksIGdpdmVuIHRoZSBjdXJyZW50IG5hbWVzcGFjZVxuICogZnVsbCAtIHRoZSBvcmlnaW5hbCBVUklcbiAqIHByZXR0eSAtIHRoZSBzaG9ydGVuZWQgdmVyc2lvbiBvZiB0aGUgVVJJIHVzaW5nIHRoZSBhYmJyZXZpYXRpb24sIGUuZy4gZm9hZjpuYW1lXG4gKlxuICogQHBhcmFtIHVyaVxuICogQHJldHVybiB7e2FiYnJldiwgbnMsIGxvY2FsbmFtZSwgZnVsbCwgcHJldHR5fX1cbiAqL1xuY29uc3QgbnNpZnkgPSAodXJpKSA9PiB7XG4gIGNvbnN0IGVucyA9IE9iamVjdC5rZXlzKG5zcykuZmluZChucyA9PiB1cmkuaW5kZXhPZihuc3NbbnNdKSA9PT0gMCk7XG4gIGlmIChlbnMpIHtcbiAgICByZXR1cm4gX25zaWZ5KGVucywgbnNzW2Vuc10sIHVyaS5zdWJzdHJpbmcobnNzW2Vuc10ubGVuZ3RoKSk7XG4gIH1cblxuICBsZXQgc2xhc2ggPSB1cmkubGFzdEluZGV4T2YoJy8nKTtcbiAgY29uc3QgaGFzaCA9IHVyaS5sYXN0SW5kZXhPZignIycpO1xuICBpZiAoaGFzaCA+IHNsYXNoKSB7XG4gICAgc2xhc2ggPSBoYXNoO1xuICB9XG4gIG5zY291bnRlciArPSAxO1xuICByZXR1cm4gX25zaWZ5KGBucyR7bnNjb3VudGVyfWAsIHVyaS5zdWJzdHJpbmcoMCwgc2xhc2ggKyAxKSwgdXJpLnN1YnN0cmluZyhzbGFzaCArIDEpKTtcbn07XG5cbi8qKlxuICogT25seSBhYmJyZXZpYXRlcyBhIFVSSSBpZiBpdCBjYW4gYmUgbWF0Y2hlZCB0byBvbmUgb2YgdGhlIGFscmVhZHkgcmVnaXN0ZXJlZCBuYW1lc3BhY2VzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgZm9yIGV4YW1wbGU6IGh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvbmFtZVxuICogQHJldHVybiB7c3RyaW5nfSBpbiB0aGUgZm9ybSBcImZvYWY6bmFtZVwiXG4gKi9cbmNvbnN0IHNob3J0ZW5Lbm93biA9ICh1cmkpID0+IHtcbiAgY29uc3QgZW5zID0gT2JqZWN0LmtleXMobnNzKS5maW5kKG5zID0+IHVyaS5pbmRleE9mKG5zc1tuc10pID09PSAwKTtcbiAgaWYgKGVucykge1xuICAgIHJldHVybiBfbnNpZnkoZW5zLCBuc3NbZW5zXSwgdXJpLnN1YnN0cmluZyhuc3NbZW5zXS5sZW5ndGgpKS5wcmV0dHk7XG4gIH1cbiAgcmV0dXJuIHVyaTtcbn07XG5cbi8qKlxuICogQWJicmV2aWF0ZXMgYWxsIHVyaXMsIGlmIG5vIG1hdGNoaW5nIG5hbWVzcGFjZSBpcyBmb3VuZCBhIHN1aXRhYmxlIG9uZSBpcyBnZW5lcmF0ZWQgYW5kXG4gKiByZWdpc3RlcmVkIGF1dG9tYXRpY2FsbHkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSBmb3IgZXhhbXBsZTogaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9uYW1lXG4gKiBAcmV0dXJuIHtzdHJpbmd9IGluIHRoZSBmb3JtIFwiZm9hZjpuYW1lXCIgb3IgXCJuczE6bmFtZVwiIGlmIGZvYWYgd291bGQgbm90IGJlIHJlZ2lzdGVyZWQgYWxyZWFkeS5cbiAqL1xuY29uc3Qgc2hvcnRlbiA9IHVyaSA9PiBuc2lmeSh1cmkpLnByZXR0eTtcblxuLyoqXG4gKiBFeHBhbmRzIGFuIGFiYnJldmlhdGVkIFVSSSBmcm9tIHRoZSBsaXN0IG9mIHJlZ2lzdGVyZWQgbmFtZXNwYWNlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbnN1cmkgYSBuYW1lc3BhY2VkIHVyaSBsaWtlIFwiZm9hZjpuYW1lXCJcbiAqIEByZXR1cm4ge3N0cmluZ30gYSBmdWxsIFVSSSBsaWtlIFwiaHR0cDovL3htbG5zLmNvbS9mb2FmLzAuMS9uYW1lXCJcbiAqL1xuY29uc3QgZXhwYW5kID0gKG5zdXJpKSA9PiB7XG4gIGNvbnN0IGFyciA9IG5zdXJpLnNwbGl0KCc6Jyk7XG4gIGlmIChhcnIubGVuZ3RoID09PSAyICYmIG5zcy5oYXNPd25Qcm9wZXJ0eShhcnJbMF0pKSB7XG4gICAgcmV0dXJuIG5zc1thcnJbMF1dICsgYXJyWzFdO1xuICB9XG4gIHJldHVybiBuc3VyaTtcbn07XG5cbi8qKlxuICogUmVnaXN0ZXJzIGEgbmFtZXNwYWNlLCBib3RoIHRoZSBhYmJyZXZpYXRpb24gYW5kIGl0cyBleHBhbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5zIHRoZSBhYmJyZXZpYXRpb24sIGUuZy4gXCJmb2FmXCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBmdWxsIHRoZSBleHBhbnNpb24gZm9yIHRoZSBhYmJyZXZpYXRpb24sIGUuZy4gXCJodHRwOi8veG1sbnMuY29tL2ZvYWYvMC4xL25hbWVcIlxuICovXG5jb25zdCBhZGQgPSAobnMsIGZ1bGwpID0+IHtcbiAgaWYgKHR5cGVvZiBucyA9PT0gJ3N0cmluZycpIHtcbiAgICBuc3NbbnNdID0gZnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbnMgPT09ICdvYmplY3QnKSB7XG4gICAgT2JqZWN0LmtleXMobnMpLmZvckVhY2goKG5za2V5KSA9PiB7XG4gICAgICBuc3NbbnNrZXldID0gbnNbbnNrZXldO1xuICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIFByb3ZpZGVzIGFjY2VzcyB0byB0aGUgY3VycmVudGx5IHJlZ2lzdGVyZWQgbmFtZXNwYWNlcyBhcyBhbiBvYmplY3Qgd2l0aCBhYmJyZXZpYXRpb25zIGFzXG4gKiBrZXlzIGFuZCB0aGVpciBleHBhbnNpb25zIGFzIHRoZSB2YWx1ZXMuXG4gKlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5jb25zdCByZWdpc3RyeSA9ICgpID0+IG5zcztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIG5zaWZ5LFxuICAgIHNob3J0ZW5Lbm93bixcbiAgICBzaG9ydGVuLFxuICAgIGV4cGFuZCxcbiAgICBhZGQsXG4gICAgcmVnaXN0cnksXG59O1xuIiwiaW1wb3J0IG5zIGZyb20gJy4vbmFtZXNwYWNlcyc7XG5cbi8qKlxuICogQHBhcmFtIHtyZGZqc29uLkdyYXBofSBncmFwaFxuICogQHBhcmFtIHtTdHJpbmd9IHN1YmplY3QgYSBVUkkgZm9yIHRoZSBzdWJqZWN0IHRvIGZvY3VzIG9uXG4gKi9cbmNvbnN0IHByZXR0eSA9IChncmFwaCwgc3ViamVjdCkgPT4ge1xuICBjb25zdCBwcmV0dHkgPSB7fTtcbiAgY29uc3Qgc3RtdHMgPSBncmFwaC5maW5kKHN1YmplY3QpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0bXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3RtdCA9IHN0bXRzW2ldO1xuICAgIGlmIChzdG10LmdldFR5cGUoKSAhPT0gJ2Jub2RlJykge1xuICAgICAgcHJldHR5W25zLnNob3J0ZW4oc3RtdC5nZXRQcmVkaWNhdGUoKSldID0gc3RtdC5nZXRWYWx1ZSgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJldHR5O1xufTtcblxuY29uc3Qgc3RhdGVtZW50VHJlZSA9IChncmFwaCwgc3ViamVjdCwgdmlzaXRlZCkgPT4ge1xuICBjb25zdCBfdmlzaXRlZCA9IHZpc2l0ZWQgfHwge307XG4gIGNvbnN0IHN0bXRzID0gZ3JhcGggPyBncmFwaC5maW5kKHN1YmplY3QpIDogW107XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0bXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3Qgc3RtdCA9IHN0bXRzW2ldO1xuICAgIGlmIChzdG10LmdldFR5cGUoKSA9PT0gJ2xpdGVyYWwnKSB7XG4gICAgICBhcnIucHVzaCh7IHN0bXQgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJvdyA9IHsgc3RtdCB9O1xuICAgICAgY29uc3Qgb2JqID0gc3RtdC5nZXRWYWx1ZSgpO1xuICAgICAgaWYgKCFfdmlzaXRlZFtvYmpdKSB7XG4gICAgICAgIF92aXNpdGVkW29ial0gPSB0cnVlO1xuICAgICAgICByb3cuY2hpbGRyZW4gPSBzdGF0ZW1lbnRUcmVlKGdyYXBoLCBvYmosIF92aXNpdGVkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbmNvbnN0IHN0YXRlbWVudExpc3QgPSAoZ3JhcGgsIHN1YmplY3QpID0+IHtcbiAgY29uc3QgdHJlZSA9IHN0YXRlbWVudFRyZWUoZ3JhcGgsIHN1YmplY3QpO1xuICBjb25zdCBhcnIgPSBbXTtcbiAgY29uc3QgZiA9IChzdG10cywgbGV2ZWwpID0+IHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0bXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzdG10ID0gc3RtdHNbaV07XG4gICAgICBzdG10LmluZGVudCA9IGxldmVsO1xuICAgICAgYXJyLnB1c2goc3RtdCk7XG4gICAgICBpZiAoc3RtdC5jaGlsZHJlbikge1xuICAgICAgICBmKHN0bXQuY2hpbGRyZW4sIGxldmVsICsgMSk7XG4gICAgICAgIGRlbGV0ZSBzdG10LmNoaWxkcmVuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZih0cmVlLCAxKTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbmNvbnN0IHByZXR0eVRyZWUgPSAoZ3JhcGgsIHN1YmplY3QpID0+IHtcbiAgY29uc3QgZGVsZWdhdGVzID0gc3RhdGVtZW50TGlzdChncmFwaCwgc3ViamVjdCk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZWdhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZGVsZWdhdGUgPSBkZWxlZ2F0ZXNbaV07XG4gICAgY29uc3Qgc3RtdCA9IGRlbGVnYXRlLnN0bXQ7XG4gICAgaWYgKHN0bXQuaXNTdWJqZWN0QmxhbmsoKSkge1xuICAgICAgZGVsZWdhdGUucyA9IHN0bXQuZ2V0U3ViamVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxlZ2F0ZS5zID0gbnMuc2hvcnRlbihzdG10LmdldFN1YmplY3QoKSk7XG4gICAgfVxuICAgIGRlbGVnYXRlLnAgPSBucy5zaG9ydGVuKHN0bXQuZ2V0UHJlZGljYXRlKCkpO1xuICAgIGNvbnN0IHQgPSBzdG10LmdldFR5cGUoKTtcbiAgICBpZiAodCA9PT0gJ3VyaScpIHtcbiAgICAgIGRlbGVnYXRlLm8gPSBucy5zaG9ydGVuKHN0bXQuZ2V0VmFsdWUoKSk7XG4gICAgICBjb25zdCBsYW5nID0gc3RtdC5nZXRMYW5ndWFnZSgpO1xuICAgICAgY29uc3QgZHQgPSBzdG10LmdldERhdGF0eXBlKCk7XG4gICAgICBpZiAobGFuZyAhPSBudWxsKSB7XG4gICAgICAgIGRlbGVnYXRlLm8gKz0gYEBAJHtsYW5nfWA7XG4gICAgICB9IGVsc2UgaWYgKGR0ICE9IG51bGwpIHtcbiAgICAgICAgZGVsZWdhdGUubyArPSBgXl4ke2R0fWA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0ID09PSAnbGl0ZXJhbCcpIHtcbiAgICAgIGRlbGVnYXRlLm8gPSBgXCIke3N0bXQuZ2V0VmFsdWUoKX1cImA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGVnYXRlLm8gPSBgXCIke3N0bXQuZ2V0VmFsdWUoKX1cImA7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZWxlZ2F0ZXM7XG59O1xuXG5leHBvcnQge1xuICBwcmV0dHksXG4gIHN0YXRlbWVudExpc3QsXG4gIHN0YXRlbWVudFRyZWUsXG4gIHByZXR0eVRyZWVcbn1cblxuZXhwb3J0IGRlZmF1bHQge1xuICBwcmV0dHksXG4gIHN0YXRlbWVudExpc3QsXG4gIHN0YXRlbWVudFRyZWUsXG4gIHByZXR0eVRyZWVcbn0iLCJpbXBvcnQgR3JhcGggZnJvbSAnLi9HcmFwaCc7XG5pbXBvcnQgbnMgZnJvbSAnLi9uYW1lc3BhY2VzJztcbmltcG9ydCBtZDUgZnJvbSAnbWQ1JztcblxuLyoqXG4gKiBDb3BpZXMgb3ZlciBhIHN1YnNldCBvZiBzdGF0ZW1lbnRzIGZyb20gb25lIG1ldGFkYXRhIGdyYXBoIHRvIGFub3RoZXIuXG4gKiBUaGUgc3RhdGVtZW50cyBjb3BpZWQgYXJlIHRob3NlIHdpdGggdGhlIHByb3ZpZGVkIHVyaSBpbiBzdWJqZWN0IHBvc2l0aW9uLCBvclxuICogc3RhdGVtZW50cyByZWFjaGFibGUgdmlhIGludGVybWVkaWF0ZSBibGFuayBub2RlcyBmcm9tIHRoYXQgdXJpLlxuICogU3RhdGVtZW50cyBhcmUgbm90IGNvcGllZCBvdmVyIGlmIHRoZSBwcmVkaWNhdGUgaXMgbGlzdGVkIGluIHRoZSBpZ25vcmUgYXJyYXksXG4gKiB1bmxlc3MgdGhlIGV4Y2x1ZGVBZnRlcklnbm9yZSBpcyBzcGVjaWZpZWQgaW4gd2hpY2ggY2FzZSB0aGUgdHJpcGxlIGlzIGluY2x1ZGVkXG4gKiBidXQgbm8gZnVydGhlciB0cmlwbGVzIHJlYWNoYWJsZSB2aWEgdGhlIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0ge3JkZmpzb24vR3JhcGh9IGluR3JhcGggZ3JhcGggd2hpY2ggaG9sZHMgcmRmIGRhdGEgaW4gZ3JhcGggZm9ybWF0XG4gKiBAcGFyYW0ge3N0cmluZ30gdXJpIGEgc3RhcnRpbmcgcG9pbnQgdG8gZmluZCBhbGwgc3RhdGVtZW50cyB0byBpbmNsdWRlXG4gKiBAcGFyYW0ge29iamVjdD19IGlnbm9yZSBpcyBhbiBvYmplY3Qgd2l0aCBwcmVkaWNhdGVzIGFzIGF0dHJpYnV0ZXMsXG4gKiB3aGljaCBhcmUgdG8gYmUgaWdub3JlZCAoZXhjbHVkZWQpXG4gKiBAcGFyYW0ge3JkZmpzb24vR3JhcGg9fSBvdXRHcmFwaCBvcHRpb25hbCBncmFwaCB3aGljaCB3aWxsIGhvbGQgY29waWVkIHN0YXRlbWVudHMsXG4gKiAgaWYgbm8gb3V0R3JhcGggaXMgcHJvdmlkZWQgYSBuZXcgd2lsbCBiZSBjcmVhdGVkLlxuICogQHJldHVybiB7cmRmanNvbi9HcmFwaH0gc2FtZSBhcyB0aGUgcHJvdmlkZWQgb3V0R3JhcGhcbiAqL1xuY29uc3QgZXh0cmFjdCA9IChpbkdyYXBoLCBvdXRHcmFwaCwgdXJpLCBpZ25vcmUsIGV4Y2x1ZGVBZnRlcklnbm9yZSkgPT4ge1xuICBjb25zdCBfb3V0R3JhcGggPSBvdXRHcmFwaCB8fCBuZXcgR3JhcGgoKTtcbiAgY29uc3QgX2lnbm9yZSA9IGlnbm9yZSB8fCB7fTtcbiAgaW5HcmFwaC5maW5kKHVyaSwgbnVsbCwgbnVsbCkuZm9yRWFjaCgoc3RtdCkgPT4ge1xuICAgIGlmICghX2lnbm9yZVtzdG10LmdldFByZWRpY2F0ZSgpXSkge1xuICAgICAgb3V0R3JhcGguYWRkKHN0bXQpO1xuICAgICAgaWYgKHN0bXQuZ2V0VHlwZSgpID09PSAnYm5vZGUnKSB7XG4gICAgICAgIGV4dHJhY3QoaW5HcmFwaCwgb3V0R3JhcGgsIHN0bXQuZ2V0VmFsdWUoKSwgX2lnbm9yZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleGNsdWRlQWZ0ZXJJZ25vcmUpIHtcbiAgICAgIG91dEdyYXBoLmFkZChzdG10KTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gb3V0R3JhcGg7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYW4gZW50aXJlIHN1YmdyYXBoIGZyb20gYSBnaXZlbiBncmFwaC5cbiAqIFRoZSBzdWJncmFwaCBpcyBjYWxjdWxhdGVkIGJ5IHRyYXZlcnNpbmcgdHJpcGxlcyBpbiB0aGUgZm9yd2FyZCBkaXJlY3Rpb25cbiAqIGZyb20gYSBzdGFydGluZyByZXNvdXJjZS4gQSB0cmlwbGUgaXMgaW5jbHVkZWQgaW4gdGhlIHN1YmdyYXBoIGlmIGl0IGNhbiBiZSByZWFjaGVkXG4gKiB2aWEgYSBwYXRoIG9mIHRyaXBsZXMgZnJvbSB0aGUgc3RhcnRpbmcgcmVzb3VyY2UgdGhhdCBvbmx5IHBhc3NlcyB0cmlwbGVzIHRoYXQgaGF2ZVxuICogYmxhbmsgbm9kZXMgaW4gb2JqZWN0IHBvc2l0aW9uLiBUaGUgdHJpcGxlcyBpbiB0aGUgcGF0aCBtYXkgbm90IGluY2x1ZGUgcHJlZGljYXRlc1xuICogaW4gdGhlIGlnbm9yZSBsaXN0IGV4Y2VwdCB0aGUgbGFzdCB0cmlwbGUgaW4gdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIHtyZGZqc29uL0dyYXBofSBncmFwaCB0aGUgZ3JhcGggdG8gcmVtb3ZlIHRyaXBsZXMgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IHVyaSB0aGUgc3RhcnRpbmcgcmVzb3VyY2UgdG8gY2FsY3VsYXRlIHRoZSBzdWJncmFwaCBmcm9tXG4gKiBAcGFyYW0ge29iamVjdH0gaWdub3JlIGFuIGhhc2ggb2YgcHJlZGljYXRlcyAod2l0aCB0aGUgYm9vbGVhbiB0cnVlIGFzIHZhbHVlKVxuICogdG8gaWdub3JlIHdoZW4gY2FsY3VsYXRpbmcgdGhlIHN1YmdyYXBoIHRvIHJlbW92ZSwgc2VlIGV4cGxhbmF0aW9uIGFib3ZlLlxuICovXG5jb25zdCByZW1vdmUgPSAoZ3JhcGgsIHVyaSwgaWdub3JlKSA9PiB7XG4gIGNvbnN0IF9pZ25vcmUgPSBpZ25vcmUgfHwge307XG4gIGdyYXBoLmZpbmQodXJpLCBudWxsLCBudWxsKS5mb3JFYWNoKChzdG10KSA9PiB7XG4gICAgZ3JhcGgucmVtb3ZlKHN0bXQpO1xuICAgIGlmICghX2lnbm9yZVtzdG10LmdldFByZWRpY2F0ZSgpXSkge1xuICAgICAgaWYgKHN0bXQuZ2V0VHlwZSgpID09PSAnYm5vZGUnKSB7XG4gICAgICAgIHJlbW92ZShncmFwaCwgc3RtdC5nZXRWYWx1ZSgpLCBfaWdub3JlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZmluZ2VycHJpbnQgb2YgYSBncmFwaCBieSBpbmNsdWRpbmcgYWxsIHN0YXRlbWVudHMnIHN1YmplY3RzLCBwcmVkaWNhdGVzXG4gKiBhbmQgb2JqZWN0cyBidXQgZXhjbHVkaW5nIGJsYW5rIG5vZGVzIHdoZXJldmVyIHRoZXkgb2NjdXIuIFRoZSByZXN1bHQgaXMgc29ydGVkIGFuZCBhXG4gKiBtZDUtc3VtIGlzIGNhbGN1bGF0ZWQuXG4gKlxuICogVHdvIGlzb21vcnBoaWMgZ3JhcGhzIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgZmluZ2VycHJpbnQsIGkuZS4gZ3JhcGhzIHRoYXQgYXJlIHNpbWlsYXJcbiAqIHdoZW4gZGlzcmVnYXJkaW5nIG5hbWVzIG9mIGJsYW5rIG5vZGVzLlxuICpcbiAqIFVuZm9ydHVuYXRlbHksIHRoZXJlIGFyZSBmYWxzZSBwb3NpdGl2aWVzLCBpLmUuIHR3byBncmFwaHMgbWF5IHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlc1xuICogaGF2ZSB0aGUgc2FtZSBmaW5nZXJwcmludCBkZXNwaXRlIHRoZSBmYWN0IHRoYXQgdGhleSBhcmUgbm90IGlzb21vcnBoaWMuXG4gKiBUaGVyZSBhcmUgdHdvIHNpdHVhdGlvbnMgd2hlbiB0aGlzIGNhbiBvY2N1cjpcbiAqXG4gKiBNZDUgY29sbGlzaW9uczogRHVlIHRvIHRoZSB3YXkgbWQ1IHdvcmtzIHRoZXJlIGFyZSBzaXR1YXRpb25zIHdoZW4gdHdvIGRpZmZlcmVudFxuICogaW5wdXRzIGNhbiBnZW5lcmF0ZSB0aGUgc2FtZSBzdW0uIEhvd2V2ZXIsIHRoaXMgaXMgdmVyeSB1bmxpa2VseSB0byBoYXBwZW4gZm9yIHJlZ3VsYXIgUkRGXG4gKiBncmFwaHMuXG4gKlxuICogQWxnb3JpdGhtIGRlZmljaWVuY2llczogSWYgdGhlIGdyYXBoIGhhcyBibGFuayBub2RlcyB0aGF0IGFyZSBjb25uZWN0ZWQgdG8gZWFjaCBvdGhlcixcbiAqIHRoZSBmaW5nZXJwcmludCBhbGdvcml0aG0gbWF5IGZhaWwuXG4gKlxuICogQnJpZWZseSBhYm91dCB0aGUgYWxnb3JpdGhtOiBTaW5jZSBibGFuayBub2RlcyBhcmUgb2Z0ZW4gcmVuYW1lZCB1cG9uIHNlcmlhbGl6YXRpb24gYW5cbiAqIGRlLXNlcmlhbGl6YXRpb24gdGhlc2UgY2Fubm90IGJlIHVzZWQgaW4gdGhlIGZpbmdlcnByaW50aW5nIGFsZ29yaXRobS4gVG8gb3ZlcmNvbWUgdGhpc1xuICogcHJvYmxlbSB0aGUgYWxnb3JpdGhtIGdpdmVzIGVhY2ggYmxhbmsgbm9kZSBhbiBpZGVudGlmaWVyIHZpYSBhIGRldGVybWluaXN0aWMgcHJvY2Vzc1xuICogdGhhdCB0YWtlcyBhbGwgaW5jb21pbmcgYW5kIG91dGdvaW5nIHRyaXBsZXMgaW50byBhY2NvdW50LiBDbGVhcmx5IHRoaXMgYXBwcm9hY2ggd2lsbCBnaXZlXG4gKiB0d28gYmxhbmsgbm9kZXMgaW4gdHdvIGRpZmZlcmVudCBncmFwaHMgdGhlIHNhbWUgaWRlbnRpZmllciBpZiB0aGV5IGhhdmUgdGhlIHNhbWUgaW5jb21pbmdcbiAqIGFuZCBvdXRnb2luZyB0cmlwbGVzLiBCdXQsIHRoZXkgbWF5IHN0aWxsIGNvcnJlc3BvbmQgdG8gZGlmZmVyZW50IGJsYW5rIG5vZGVzXG4gKiAoaW4gdGhlIGlzb21vcnBoaWMgc2Vuc2UpIGlmIGxvbmdlciBibGFuayBub2RlIHRyYXZlcnNhbCBwYXRoIGFyZSB0YWtlbiBpbnRvIGFjY291bnQuXG4gKlxuICogTGV0cyBMb29rIGF0IHR3byBkaWZmZXJlbnQgZ3JhcGhzIHRoYXQgd2lsbCBoYXZlIHRoZSBzYW1lIGZpbmdlcnByaW50OlxuICogR3JhcGggMTogSm9obiBpbmRpcmVjdGx5IGtub3dzIEVyaWMgYW5kIEFubmEgaW5kaXJlY3RseSBrbm93cyBMaW5kYVxuICogXzpiMSAgICAgZm9hZjpuYW1lICAgICdKb2huJ1xuICogXzpiMSAgICAgZm9hZjprbm93cyAgIF86YjJcbiAqIF86YjIgICAgIGZvYWY6a25vd3MgICBfOmIzXG4gKiBfOmIzICAgICBmb2FmOm5hbWUgICAgXCJFcmljXCJcbiAqIF86YjQgICAgIGZvYWY6bmFtZSAgICAnQW5uYSdcbiAqIF86YjQgICAgIGZvYWY6a25vd3MgICBfOmI1XG4gKiBfOmI1ICAgICBmb2FmOmtub3dzICAgXzpiNlxuICogXzpiNiAgICAgZm9hZjpuYW1lICAgIFwiTGluZGFcIlxuICpcbiAqIEdyYXBoIDI6IEpvaG4gaW5kaXJlY3RseSBrbm93cyBMaW5kYSBhbmQgQW5uYSBpbmRpcmVjdGx5IGtub3dzIEVyaWNcbiAqIF86YjEgICAgIGZvYWY6bmFtZSAgICAnSm9obidcbiAqIF86YjEgICAgIGZvYWY6a25vd3MgICBfOmIyXG4gKiBfOmIyICAgICBmb2FmOmtub3dzICAgXzpiM1xuICogXzpiMyAgICAgZm9hZjpuYW1lICAgIFwiTGluZGFcIlxuICogXzpiNCAgICAgZm9hZjpuYW1lICAgICdBbm5hJ1xuICogXzpiNCAgICAgZm9hZjprbm93cyAgIF86YjVcbiAqIF86YjUgICAgIGZvYWY6a25vd3MgICBfOmI2XG4gKiBfOmI2ICAgICBmb2FmOm5hbWUgICAgXCJFcmljXCJcbiAqXG4gKiBJbiBwcmFjdGlzZSB0aGlzIHNpdHVhdGlvbiBvbmx5IG9jY3VycyB3aGVuIHlvdSBoYXZlIGxvbmdlciBwYXRocyBvZiBibGFuayBub2RlcyB3aXRob3V0XG4gKiBhZGRpdGlvbmFsIGRpc3Rpbmd1aXNoaW5nIHRyaXBsZXMuIEhvd2V2ZXIsIGZyb20gYSBtb2RlbGluZyBzdGFuZHBvaW50IHRoZXNlIGtpbmQgb2ZcbiAqIGV4cHJlc3Npb25zIHdpdGggbG9uZyBjaGFpbnMgb2Ygbm9kZXMgYXJlIHNlbGRvbSB1c2VkIGFuZCBpZiB0aGV5IGFyZSB1c2VkLCB0aGVyZSBhcmVcbiAqIGNlcnRhaW5seSBkaXN0aW5ndWlzaGluZyB0cmlwbGVzIGFsb25nIHRoZSB3YXkuXG4gKlxuICogVGhlIGNvbmNsdXNpb24gaXMgdGhhdCBjaGVja2luZyBpZiByZWFsIHdvcmxkIGdyYXBocyBhcmUgdGhlIHNhbWUgb3Igbm90IGNhbiBiZSBzYWZlbHlcbiAqIGRldGVybWluZWQgd2l0aCB0aGUgaGVscCBvZiB0aGlzIGZpbmdlcnByaW50IG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge3JkZmpzb24vR3JhcGh9IGdyYXBoIGlzIHRoZSBncmFwaCB0byBmaW5nZXJwcmludC5cbiAqIEBwYXJhbSB7YXJyYXl9IGV4Y2x1ZGVQcm9wZXJ0aWVzIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIHRvIGV4Y2x1ZGUgd2hlbiBjYWxjdWxhdGluZ1xuICogdGhlIGZpbmdlcnByaW50LlxuICogQHJldHVybiB7c3RyaW5nfSBhIG1kNSBzdW0gb2YgdGhlIGdyYXBoLlxuICovXG5jb25zdCBmaW5nZXJwcmludCA9IChncmFwaCwgZXhjbHVkZVByb3BlcnRpZXMpID0+IHtcbiAgY29uc3QgZnBnID0gW107XG4gIGNvbnN0IGV4Y2x1ZGUgPSBuZXcgU2V0KChleGNsdWRlUHJvcGVydGllcyB8fCBbXSkubWFwKHByb3AgPT4gbnMuZXhwYW5kKHByb3ApKSk7XG4gIGNvbnN0IGJsYW5rU3RtdHMgPSBbXTtcbiAgY29uc3QgYmxhbmtJZHggPSB7fTtcblxuICBjb25zdCBzZXJpYWxpemVPYmogPSAoc3RtdCkgPT4ge1xuICAgIGxldCB2YWwgPSBzdG10LmdldFZhbHVlKCk7XG4gICAgaWYgKHN0bXQuZ2V0TGFuZ3VhZ2UoKSkge1xuICAgICAgdmFsICs9IGBAJHtzdG10LmdldExhbmd1YWdlKCl9YDtcbiAgICB9XG4gICAgaWYgKHN0bXQuZ2V0RGF0YXR5cGUoKSkge1xuICAgICAgdmFsICs9IGBeXiR7c3RtdC5nZXREYXRhdHlwZSgpfWA7XG4gICAgfVxuICAgIHJldHVybiB2YWw7XG4gIH07XG4gIGNvbnN0IGFkZFRvQmxhbmtSZWxzID0gKGJuLCBzdHIpID0+IHtcbiAgICBjb25zdCBpZHggPSBibGFua0lkeFtibl0gfHwgeyByZWxzOiBbXSB9O1xuICAgIGJsYW5rSWR4W2JuXSA9IGlkeDtcbiAgICBpZHgucmVscy5wdXNoKHN0cik7XG4gIH07XG5cbiAgZ3JhcGguZmluZCgpLmZvckVhY2goKHN0bXQpID0+IHtcbiAgICBjb25zdCBzID0gc3RtdC5nZXRTdWJqZWN0KCk7XG4gICAgY29uc3QgcCA9IHN0bXQuZ2V0UHJlZGljYXRlKCk7XG4gICAgaWYgKGV4Y2x1ZGUuaGFzKHApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG9CbGFuayA9IHN0bXQuZ2V0VHlwZSgpID09PSAnYm5vZGUnO1xuICAgIGNvbnN0IHNCbGFuayA9IHN0bXQuaXNTdWJqZWN0QmxhbmsoKTtcbiAgICBpZiAoc0JsYW5rIHx8IG9CbGFuaykge1xuICAgICAgYmxhbmtTdG10cy5wdXNoKHN0bXQpO1xuICAgICAgaWYgKHNCbGFuaykge1xuICAgICAgICBhZGRUb0JsYW5rUmVscyhzdG10LmdldFN1YmplY3QoKSwgb0JsYW5rID8gcCA6IHAgKyBzZXJpYWxpemVPYmooc3RtdCkpO1xuICAgICAgfVxuICAgICAgaWYgKHN0bXQuZ2V0VHlwZSgpID09PSAnYm5vZGUnKSB7XG4gICAgICAgIGFkZFRvQmxhbmtSZWxzKHN0bXQuZ2V0VmFsdWUoKSwgc0JsYW5rID8gcCA6IHMgKyBwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBmcGcucHVzaChzICsgcCArIHNlcmlhbGl6ZU9iaihzdG10KSk7XG4gIH0pO1xuXG4gIC8vIENhbGN1bGF0ZSBhIHN0YWJsZSBoYXNoIGZvciBlYWNoIGJsYW5rIGJhc2VkIG9uIGluY29taW5nIGFuZCBvdXRnb2luZyB0cmlwcGxlcy5cbiAgT2JqZWN0LnZhbHVlcyhibGFua0lkeCkuZm9yRWFjaCgoYmxhbmspID0+IHtcbiAgICBibGFuay5yZWxzLnNvcnQoKTtcbiAgICBibGFuay5oYXNoID0gbWQ1KGJsYW5rLnJlbHMuam9pbignJykpO1xuICB9KTtcblxuICAvLyBBZGQgYWxsIHN0YXRlbWVudHMgd2l0aCBibGFua3MgaW4gdGhlbVxuICBibGFua1N0bXRzLmZvckVhY2goKHN0bXQpID0+IHtcbiAgICBjb25zdCBmcHMgPSBbXTtcbiAgICBmcHMucHVzaChzdG10LmlzU3ViamVjdEJsYW5rKCkgPyBibGFua0lkeFtzdG10LmdldFN1YmplY3QoKV0uaGFzaCA6IHN0bXQuZ2V0U3ViamVjdCgpKTtcbiAgICBmcHMucHVzaChzdG10LmdldFByZWRpY2F0ZSgpKTtcbiAgICBmcHMucHVzaChzdG10LmdldFR5cGUoKSA9PT0gJ2Jub2RlJyA/IGJsYW5rSWR4W3N0bXQuZ2V0VmFsdWUoKV0uaGFzaCA6IHNlcmlhbGl6ZU9iaihzdG10KSk7XG4gICAgZnBnLnB1c2goZnBzLmpvaW4oJycpKTtcbiAgfSk7XG5cbiAgZnBnLnNvcnQoKTtcbiAgcmV0dXJuIG1kNShmcGcuam9pbignJykpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICBleHRyYWN0LFxuICByZW1vdmUsXG4gIGZpbmdlcnByaW50LFxufTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxudmFyIHJ1bnRpbWUgPSAoZnVuY3Rpb24gKGV4cG9ydHMpIHtcbiAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgdmFyIE9wID0gT2JqZWN0LnByb3RvdHlwZTtcbiAgdmFyIGhhc093biA9IE9wLmhhc093blByb3BlcnR5O1xuICB2YXIgdW5kZWZpbmVkOyAvLyBNb3JlIGNvbXByZXNzaWJsZSB0aGFuIHZvaWQgMC5cbiAgdmFyICRTeW1ib2wgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgPyBTeW1ib2wgOiB7fTtcbiAgdmFyIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIjtcbiAgdmFyIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIjtcbiAgdmFyIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZVt0b1N0cmluZ1RhZ1N5bWJvbF0gPVxuICAgIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuXG4gIC8vIEhlbHBlciBmb3IgZGVmaW5pbmcgdGhlIC5uZXh0LCAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMgb2YgdGhlXG4gIC8vIEl0ZXJhdG9yIGludGVyZmFjZSBpbiB0ZXJtcyBvZiBhIHNpbmdsZSAuX2ludm9rZSBtZXRob2QuXG4gIGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgICAgIHByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIHZhciBjdG9yID0gdHlwZW9mIGdlbkZ1biA9PT0gXCJmdW5jdGlvblwiICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gY3RvclxuICAgICAgPyBjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fFxuICAgICAgICAvLyBGb3IgdGhlIG5hdGl2ZSBHZW5lcmF0b3JGdW5jdGlvbiBjb25zdHJ1Y3RvciwgdGhlIGJlc3Qgd2UgY2FuXG4gICAgICAgIC8vIGRvIGlzIHRvIGNoZWNrIGl0cyAubmFtZSBwcm9wZXJ0eS5cbiAgICAgICAgKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSA9PT0gXCJHZW5lcmF0b3JGdW5jdGlvblwiXG4gICAgICA6IGZhbHNlO1xuICB9O1xuXG4gIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uKGdlbkZ1bikge1xuICAgIGlmIChPYmplY3Quc2V0UHJvdG90eXBlT2YpIHtcbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICAgICAgaWYgKCEodG9TdHJpbmdUYWdTeW1ib2wgaW4gZ2VuRnVuKSkge1xuICAgICAgICBnZW5GdW5bdG9TdHJpbmdUYWdTeW1ib2xdID0gXCJHZW5lcmF0b3JGdW5jdGlvblwiO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCk7XG4gICAgcmV0dXJuIGdlbkZ1bjtcbiAgfTtcblxuICAvLyBXaXRoaW4gdGhlIGJvZHkgb2YgYW55IGFzeW5jIGZ1bmN0aW9uLCBgYXdhaXQgeGAgaXMgdHJhbnNmb3JtZWQgdG9cbiAgLy8gYHlpZWxkIHJlZ2VuZXJhdG9yUnVudGltZS5hd3JhcCh4KWAsIHNvIHRoYXQgdGhlIHJ1bnRpbWUgY2FuIHRlc3RcbiAgLy8gYGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIilgIHRvIGRldGVybWluZSBpZiB0aGUgeWllbGRlZCB2YWx1ZSBpc1xuICAvLyBtZWFudCB0byBiZSBhd2FpdGVkLlxuICBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICByZWplY3QocmVjb3JkLmFyZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZztcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuICAgICAgICBpZiAodmFsdWUgJiZcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSkge1xuICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24odW53cmFwcGVkKSB7XG4gICAgICAgICAgLy8gV2hlbiBhIHlpZWxkZWQgUHJvbWlzZSBpcyByZXNvbHZlZCwgaXRzIGZpbmFsIHZhbHVlIGJlY29tZXNcbiAgICAgICAgICAvLyB0aGUgLnZhbHVlIG9mIHRoZSBQcm9taXNlPHt2YWx1ZSxkb25lfT4gcmVzdWx0IGZvciB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IGl0ZXJhdGlvbi5cbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQ7XG4gICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICB9LCBmdW5jdGlvbihlcnJvcikge1xuICAgICAgICAgIC8vIElmIGEgcmVqZWN0ZWQgUHJvbWlzZSB3YXMgeWllbGRlZCwgdGhyb3cgdGhlIHJlamVjdGlvbiBiYWNrXG4gICAgICAgICAgLy8gaW50byB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBoYW5kbGVkIHRoZXJlLlxuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcblxuICAgIGZ1bmN0aW9uIGVucXVldWUobWV0aG9kLCBhcmcpIHtcbiAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9XG4gICAgICAgIC8vIElmIGVucXVldWUgaGFzIGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIHdhaXQgdW50aWxcbiAgICAgICAgLy8gYWxsIHByZXZpb3VzIFByb21pc2VzIGhhdmUgYmVlbiByZXNvbHZlZCBiZWZvcmUgY2FsbGluZyBpbnZva2UsXG4gICAgICAgIC8vIHNvIHRoYXQgcmVzdWx0cyBhcmUgYWx3YXlzIGRlbGl2ZXJlZCBpbiB0aGUgY29ycmVjdCBvcmRlci4gSWZcbiAgICAgICAgLy8gZW5xdWV1ZSBoYXMgbm90IGJlZW4gY2FsbGVkIGJlZm9yZSwgdGhlbiBpdCBpcyBpbXBvcnRhbnQgdG9cbiAgICAgICAgLy8gY2FsbCBpbnZva2UgaW1tZWRpYXRlbHksIHdpdGhvdXQgd2FpdGluZyBvbiBhIGNhbGxiYWNrIHRvIGZpcmUsXG4gICAgICAgIC8vIHNvIHRoYXQgdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBoYXMgdGhlIG9wcG9ydHVuaXR5IHRvIGRvXG4gICAgICAgIC8vIGFueSBuZWNlc3Nhcnkgc2V0dXAgaW4gYSBwcmVkaWN0YWJsZSB3YXkuIFRoaXMgcHJlZGljdGFiaWxpdHlcbiAgICAgICAgLy8gaXMgd2h5IHRoZSBQcm9taXNlIGNvbnN0cnVjdG9yIHN5bmNocm9ub3VzbHkgaW52b2tlcyBpdHNcbiAgICAgICAgLy8gZXhlY3V0b3IgY2FsbGJhY2ssIGFuZCB3aHkgYXN5bmMgZnVuY3Rpb25zIHN5bmNocm9ub3VzbHlcbiAgICAgICAgLy8gZXhlY3V0ZSBjb2RlIGJlZm9yZSB0aGUgZmlyc3QgYXdhaXQuIFNpbmNlIHdlIGltcGxlbWVudCBzaW1wbGVcbiAgICAgICAgLy8gYXN5bmMgZnVuY3Rpb25zIGluIHRlcm1zIG9mIGFzeW5jIGdlbmVyYXRvcnMsIGl0IGlzIGVzcGVjaWFsbHlcbiAgICAgICAgLy8gaW1wb3J0YW50IHRvIGdldCB0aGlzIHJpZ2h0LCBldmVuIHRob3VnaCBpdCByZXF1aXJlcyBjYXJlLlxuICAgICAgICBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihcbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZyxcbiAgICAgICAgICAvLyBBdm9pZCBwcm9wYWdhdGluZyBmYWlsdXJlcyB0byBQcm9taXNlcyByZXR1cm5lZCBieSBsYXRlclxuICAgICAgICAgIC8vIGludm9jYXRpb25zIG9mIHRoZSBpdGVyYXRvci5cbiAgICAgICAgICBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZ1xuICAgICAgICApIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICB9XG5cbiAgICAvLyBEZWZpbmUgdGhlIHVuaWZpZWQgaGVscGVyIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gaW1wbGVtZW50IC5uZXh0LFxuICAgIC8vIC50aHJvdywgYW5kIC5yZXR1cm4gKHNlZSBkZWZpbmVJdGVyYXRvck1ldGhvZHMpLlxuICAgIHRoaXMuX2ludm9rZSA9IGVucXVldWU7XG4gIH1cblxuICBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpO1xuICBBc3luY0l0ZXJhdG9yLnByb3RvdHlwZVthc3luY0l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcbiAgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvcjtcblxuICAvLyBOb3RlIHRoYXQgc2ltcGxlIGFzeW5jIGZ1bmN0aW9ucyBhcmUgaW1wbGVtZW50ZWQgb24gdG9wIG9mXG4gIC8vIEFzeW5jSXRlcmF0b3Igb2JqZWN0czsgdGhleSBqdXN0IHJldHVybiBhIFByb21pc2UgZm9yIHRoZSB2YWx1ZSBvZlxuICAvLyB0aGUgZmluYWwgcmVzdWx0IHByb2R1Y2VkIGJ5IHRoZSBpdGVyYXRvci5cbiAgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcihcbiAgICAgIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBHcFt0b1N0cmluZ1RhZ1N5bWJvbF0gPSBcIkdlbmVyYXRvclwiO1xuXG4gIC8vIEEgR2VuZXJhdG9yIHNob3VsZCBhbHdheXMgcmV0dXJuIGl0c2VsZiBhcyB0aGUgaXRlcmF0b3Igb2JqZWN0IHdoZW4gdGhlXG4gIC8vIEBAaXRlcmF0b3IgZnVuY3Rpb24gaXMgY2FsbGVkIG9uIGl0LiBTb21lIGJyb3dzZXJzJyBpbXBsZW1lbnRhdGlvbnMgb2YgdGhlXG4gIC8vIGl0ZXJhdG9yIHByb3RvdHlwZSBjaGFpbiBpbmNvcnJlY3RseSBpbXBsZW1lbnQgdGhpcywgY2F1c2luZyB0aGUgR2VuZXJhdG9yXG4gIC8vIG9iamVjdCB0byBub3QgYmUgcmV0dXJuZWQgZnJvbSB0aGlzIGNhbGwuIFRoaXMgZW5zdXJlcyB0aGF0IGRvZXNuJ3QgaGFwcGVuLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2lzc3Vlcy8yNzQgZm9yIG1vcmUgZGV0YWlscy5cbiAgR3BbaXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgR3AudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjtcbiAgfTtcblxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07XG5cbiAgICBpZiAoMSBpbiBsb2NzKSB7XG4gICAgICBlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV07XG4gICAgfVxuXG4gICAgaWYgKDIgaW4gbG9jcykge1xuICAgICAgZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl07XG4gICAgICBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM107XG4gICAgfVxuXG4gICAgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIjtcbiAgICBkZWxldGUgcmVjb3JkLmFyZztcbiAgICBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIC8vIFRoZSByb290IGVudHJ5IG9iamVjdCAoZWZmZWN0aXZlbHkgYSB0cnkgc3RhdGVtZW50IHdpdGhvdXQgYSBjYXRjaFxuICAgIC8vIG9yIGEgZmluYWxseSBibG9jaykgZ2l2ZXMgdXMgYSBwbGFjZSB0byBzdG9yZSB2YWx1ZXMgdGhyb3duIGZyb21cbiAgICAvLyBsb2NhdGlvbnMgd2hlcmUgdGhlcmUgaXMgbm8gZW5jbG9zaW5nIHRyeSBzdGF0ZW1lbnQuXG4gICAgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XTtcbiAgICB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyk7XG4gICAgdGhpcy5yZXNldCh0cnVlKTtcbiAgfVxuXG4gIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgfVxuICAgIGtleXMucmV2ZXJzZSgpO1xuXG4gICAgLy8gUmF0aGVyIHRoYW4gcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGEgbmV4dCBtZXRob2QsIHdlIGtlZXBcbiAgICAvLyB0aGluZ3Mgc2ltcGxlIGFuZCByZXR1cm4gdGhlIG5leHQgZnVuY3Rpb24gaXRzZWxmLlxuICAgIHJldHVybiBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgd2hpbGUgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgIG5leHQudmFsdWUgPSBrZXk7XG4gICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gVG8gYXZvaWQgY3JlYXRpbmcgYW4gYWRkaXRpb25hbCBvYmplY3QsIHdlIGp1c3QgaGFuZyB0aGUgLnZhbHVlXG4gICAgICAvLyBhbmQgLmRvbmUgcHJvcGVydGllcyBvZmYgdGhlIG5leHQgZnVuY3Rpb24gb2JqZWN0IGl0c2VsZi4gVGhpc1xuICAgICAgLy8gYWxzbyBlbnN1cmVzIHRoYXQgdGhlIG1pbmlmaWVyIHdpbGwgbm90IGFub255bWl6ZSB0aGUgZnVuY3Rpb24uXG4gICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfTtcbiAgfTtcblxuICBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHtcbiAgICBpZiAoaXRlcmFibGUpIHtcbiAgICAgIHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTtcbiAgICAgIGlmIChpdGVyYXRvck1ldGhvZCkge1xuICAgICAgICByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmFibGUubmV4dCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7XG4gICAgICAgIHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVyYWJsZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHtcbiAgICAgICAgICAgICAgbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldO1xuICAgICAgICAgICAgICBuZXh0LmRvbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbmV4dC52YWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBuZXh0LmRvbmUgPSB0cnVlO1xuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGFuIGl0ZXJhdG9yIHdpdGggbm8gdmFsdWVzLlxuICAgIHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTtcbiAgfVxuICBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcztcblxuICBmdW5jdGlvbiBkb25lUmVzdWx0KCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6IHRydWUgfTtcbiAgfVxuXG4gIENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb250ZXh0LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKHNraXBUZW1wUmVzZXQpIHtcbiAgICAgIHRoaXMucHJldiA9IDA7XG4gICAgICB0aGlzLm5leHQgPSAwO1xuICAgICAgLy8gUmVzZXR0aW5nIGNvbnRleHQuX3NlbnQgZm9yIGxlZ2FjeSBzdXBwb3J0IG9mIEJhYmVsJ3NcbiAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICB0aGlzLmRlbGVnYXRlID0gbnVsbDtcblxuICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgIHRoaXMuYXJnID0gdW5kZWZpbmVkO1xuXG4gICAgICB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KTtcblxuICAgICAgaWYgKCFza2lwVGVtcFJlc2V0KSB7XG4gICAgICAgIGZvciAodmFyIG5hbWUgaW4gdGhpcykge1xuICAgICAgICAgIC8vIE5vdCBzdXJlIGFib3V0IHRoZSBvcHRpbWFsIG9yZGVyIG9mIHRoZXNlIGNvbmRpdGlvbnM6XG4gICAgICAgICAgaWYgKG5hbWUuY2hhckF0KDApID09PSBcInRcIiAmJlxuICAgICAgICAgICAgICBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJlxuICAgICAgICAgICAgICAhaXNOYU4oK25hbWUuc2xpY2UoMSkpKSB7XG4gICAgICAgICAgICB0aGlzW25hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG5cbiAgICAgIHZhciByb290RW50cnkgPSB0aGlzLnRyeUVudHJpZXNbMF07XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHJvb3RFbnRyeS5jb21wbGV0aW9uO1xuICAgICAgaWYgKHJvb3RSZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHRocm93IHJvb3RSZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5ydmFsO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgIHRocm93IGV4Y2VwdGlvbjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7XG4gICAgICAgIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiO1xuICAgICAgICByZWNvcmQuYXJnID0gZXhjZXB0aW9uO1xuICAgICAgICBjb250ZXh0Lm5leHQgPSBsb2M7XG5cbiAgICAgICAgaWYgKGNhdWdodCkge1xuICAgICAgICAgIC8vIElmIHRoZSBkaXNwYXRjaGVkIGV4Y2VwdGlvbiB3YXMgY2F1Z2h0IGJ5IGEgY2F0Y2ggYmxvY2ssXG4gICAgICAgICAgLy8gdGhlbiBsZXQgdGhhdCBjYXRjaCBibG9jayBoYW5kbGUgdGhlIGV4Y2VwdGlvbiBub3JtYWxseS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICEhIGNhdWdodDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuXG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IFwicm9vdFwiKSB7XG4gICAgICAgICAgLy8gRXhjZXB0aW9uIHRocm93biBvdXRzaWRlIG9mIGFueSB0cnkgYmxvY2sgdGhhdCBjb3VsZCBoYW5kbGVcbiAgICAgICAgICAvLyBpdCwgc28gc2V0IHRoZSBjb21wbGV0aW9uIHZhbHVlIG9mIHRoZSBlbnRpcmUgZnVuY3Rpb24gdG9cbiAgICAgICAgICAvLyB0aHJvdyB0aGUgZXhjZXB0aW9uLlxuICAgICAgICAgIHJldHVybiBoYW5kbGUoXCJlbmRcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpO1xuICAgICAgICAgIHZhciBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTtcblxuICAgICAgICAgIGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykge1xuICAgICAgICAgICAgICByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCB0cnVlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSBpZiAoaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgYWJydXB0OiBmdW5jdGlvbih0eXBlLCBhcmcpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJlxuICAgICAgICAgICAgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJlxuICAgICAgICAgICAgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoZmluYWxseUVudHJ5ICYmXG4gICAgICAgICAgKHR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgICB0eXBlID09PSBcImNvbnRpbnVlXCIpICYmXG4gICAgICAgICAgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiZcbiAgICAgICAgICBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgLy8gSWdub3JlIHRoZSBmaW5hbGx5IGVudHJ5IGlmIGNvbnRyb2wgaXMgbm90IGp1bXBpbmcgdG8gYVxuICAgICAgICAvLyBsb2NhdGlvbiBvdXRzaWRlIHRoZSB0cnkvY2F0Y2ggYmxvY2suXG4gICAgICAgIGZpbmFsbHlFbnRyeSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmVjb3JkLnR5cGUgPSB0eXBlO1xuICAgICAgcmVjb3JkLmFyZyA9IGFyZztcblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSkge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwibmV4dFwiO1xuICAgICAgICB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYztcbiAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7XG4gICAgfSxcblxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbihyZWNvcmQsIGFmdGVyTG9jKSB7XG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwiYnJlYWtcIiB8fFxuICAgICAgICAgIHJlY29yZC50eXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gcmVjb3JkLmFyZztcbiAgICAgIH0gZWxzZSBpZiAocmVjb3JkLnR5cGUgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgdGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnO1xuICAgICAgICB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCI7XG4gICAgICAgIHRoaXMubmV4dCA9IFwiZW5kXCI7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiICYmIGFmdGVyTG9jKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IGFmdGVyTG9jO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICB9LFxuXG4gICAgZmluaXNoOiBmdW5jdGlvbihmaW5hbGx5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKTtcbiAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNhdGNoXCI6IGZ1bmN0aW9uKHRyeUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykge1xuICAgICAgICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uO1xuICAgICAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICB2YXIgdGhyb3duID0gcmVjb3JkLmFyZztcbiAgICAgICAgICAgIHJlc2V0VHJ5RW50cnkoZW50cnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhyb3duO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBjb250ZXh0LmNhdGNoIG1ldGhvZCBtdXN0IG9ubHkgYmUgY2FsbGVkIHdpdGggYSBsb2NhdGlvblxuICAgICAgLy8gYXJndW1lbnQgdGhhdCBjb3JyZXNwb25kcyB0byBhIGtub3duIGNhdGNoIGJsb2NrLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG5cbiAgICBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbihpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykge1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IHtcbiAgICAgICAgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksXG4gICAgICAgIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsXG4gICAgICAgIG5leHRMb2M6IG5leHRMb2NcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm1ldGhvZCA9PT0gXCJuZXh0XCIpIHtcbiAgICAgICAgLy8gRGVsaWJlcmF0ZWx5IGZvcmdldCB0aGUgbGFzdCBzZW50IHZhbHVlIHNvIHRoYXQgd2UgZG9uJ3RcbiAgICAgICAgLy8gYWNjaWRlbnRhbGx5IHBhc3MgaXQgb24gdG8gdGhlIGRlbGVnYXRlLlxuICAgICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGlzIHNjcmlwdCBpcyBleGVjdXRpbmcgYXMgYSBDb21tb25KUyBtb2R1bGVcbiAgLy8gb3Igbm90LCByZXR1cm4gdGhlIHJ1bnRpbWUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGRlY2xhcmUgdGhlIHZhcmlhYmxlXG4gIC8vIHJlZ2VuZXJhdG9yUnVudGltZSBpbiB0aGUgb3V0ZXIgc2NvcGUsIHdoaWNoIGFsbG93cyB0aGlzIG1vZHVsZSB0byBiZVxuICAvLyBpbmplY3RlZCBlYXNpbHkgYnkgYGJpbi9yZWdlbmVyYXRvciAtLWluY2x1ZGUtcnVudGltZSBzY3JpcHQuanNgLlxuICByZXR1cm4gZXhwb3J0cztcblxufShcbiAgLy8gSWYgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlLCB1c2UgbW9kdWxlLmV4cG9ydHNcbiAgLy8gYXMgdGhlIHJlZ2VuZXJhdG9yUnVudGltZSBuYW1lc3BhY2UuIE90aGVyd2lzZSBjcmVhdGUgYSBuZXcgZW1wdHlcbiAgLy8gb2JqZWN0LiBFaXRoZXIgd2F5LCB0aGUgcmVzdWx0aW5nIG9iamVjdCB3aWxsIGJlIHVzZWQgdG8gaW5pdGlhbGl6ZVxuICAvLyB0aGUgcmVnZW5lcmF0b3JSdW50aW1lIHZhcmlhYmxlIGF0IHRoZSB0b3Agb2YgdGhpcyBmaWxlLlxuICB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiID8gbW9kdWxlLmV4cG9ydHMgOiB7fVxuKSk7XG5cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICAvLyBUaGlzIG1vZHVsZSBzaG91bGQgbm90IGJlIHJ1bm5pbmcgaW4gc3RyaWN0IG1vZGUsIHNvIHRoZSBhYm92ZVxuICAvLyBhc3NpZ25tZW50IHNob3VsZCBhbHdheXMgd29yayB1bmxlc3Mgc29tZXRoaW5nIGlzIG1pc2NvbmZpZ3VyZWQuIEp1c3RcbiAgLy8gaW4gY2FzZSBydW50aW1lLmpzIGFjY2lkZW50YWxseSBydW5zIGluIHN0cmljdCBtb2RlLCB3ZSBjYW4gZXNjYXBlXG4gIC8vIHN0cmljdCBtb2RlIHVzaW5nIGEgZ2xvYmFsIEZ1bmN0aW9uIGNhbGwuIFRoaXMgY291bGQgY29uY2VpdmFibHkgZmFpbFxuICAvLyBpZiBhIENvbnRlbnQgU2VjdXJpdHkgUG9saWN5IGZvcmJpZHMgdXNpbmcgRnVuY3Rpb24sIGJ1dCBpbiB0aGF0IGNhc2VcbiAgLy8gdGhlIHByb3BlciBzb2x1dGlvbiBpcyB0byBmaXggdGhlIGFjY2lkZW50YWwgc3RyaWN0IG1vZGUgcHJvYmxlbS4gSWZcbiAgLy8geW91J3ZlIG1pc2NvbmZpZ3VyZWQgeW91ciBidW5kbGVyIHRvIGZvcmNlIHN0cmljdCBtb2RlIGFuZCBhcHBsaWVkIGFcbiAgLy8gQ1NQIHRvIGZvcmJpZCBGdW5jdGlvbiwgYW5kIHlvdSdyZSBub3Qgd2lsbGluZyB0byBmaXggZWl0aGVyIG9mIHRob3NlXG4gIC8vIHByb2JsZW1zLCBwbGVhc2UgZGV0YWlsIHlvdXIgdW5pcXVlIHByZWRpY2FtZW50IGluIGEgR2l0SHViIGlzc3VlLlxuICBGdW5jdGlvbihcInJcIiwgXCJyZWdlbmVyYXRvclJ1bnRpbWUgPSByXCIpKHJ1bnRpbWUpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgcmVtb3ZlQ2FsbGJhY2sgPSBmdW5jdGlvbiByZW1vdmVDYWxsYmFjayhfcmVmKSB7XG4gIHZhciBzY3JpcHQgPSBfcmVmLnNjcmlwdCxcbiAgICAgIGNhbGxiYWNrTmFtZSA9IF9yZWYuY2FsbGJhY2tOYW1lLFxuICAgICAgdGltZW91dCA9IF9yZWYudGltZW91dDtcblxuICBpZiAoc2NyaXB0ICYmIHNjcmlwdC5wYXJlbnROb2RlKSBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXG4gIGRlbGV0ZSB3aW5kb3dbY2FsbGJhY2tOYW1lXTtcblxuICBjbGVhclRpbWVvdXQodGltZW91dCk7IC8vIGNsZWFyIHRpbWVvdXQgKGZvciBvbmVycm9yIGV2ZW50IGxpc3RlbmVyKVxufTtcblxudmFyIGpzb25wID0gZnVuY3Rpb24ganNvbnAocmVxdWVzdE9yQ29uZmlnKSB7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiBlbmQoKSB7XG4gICAgdmFyIGNvbmZpZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIGNhbGxiYWNrUGFyYW0gPSBjb25maWcuY2FsbGJhY2tQYXJhbSB8fCAnY2FsbGJhY2snO1xuICAgICAgdmFyIGNhbGxiYWNrTmFtZSA9IGNvbmZpZy5jYWxsYmFja05hbWUgfHwgJ3N1cGVyYWdlbnRDYWxsYmFjaycgKyAobmV3IERhdGUoKS52YWx1ZU9mKCkgKyBwYXJzZUludChNYXRoLnJhbmRvbSgpICogMTAwMCwgMTApKTtcbiAgICAgIHZhciB0aW1lb3V0TGltaXQgPSBjb25maWcudGltZW91dCB8fCAxMDAwO1xuXG4gICAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoanNvbnAuZXJyb3JXcmFwcGVyLmJpbmQodGhpcyksIHRpbWVvdXRMaW1pdCk7XG5cbiAgICAgIHRoaXMuX2pzb25wID0ge1xuICAgICAgICBjYWxsYmFja05hbWU6IGNhbGxiYWNrTmFtZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICB0aW1lb3V0OiB0aW1lb3V0XG4gICAgICB9O1xuXG4gICAgICB3aW5kb3dbY2FsbGJhY2tOYW1lXSA9IGpzb25wLmNhbGxiYWNrV3JhcHBlci5iaW5kKHRoaXMpO1xuXG4gICAgICB0aGlzLl9xdWVyeS5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja1BhcmFtKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChjYWxsYmFja05hbWUpKTtcbiAgICAgIHZhciBxdWVyeVN0cmluZyA9IHRoaXMuX3F1ZXJ5LmpvaW4oJyYnKTtcblxuICAgICAgdmFyIHMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAgIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9IHRoaXMudXJsLmluZGV4T2YoJz8nKSA+IC0xID8gJyYnIDogJz8nO1xuICAgICAgICB2YXIgdXJsID0gdGhpcy51cmwgKyBzZXBhcmF0b3IgKyBxdWVyeVN0cmluZztcblxuICAgICAgICBzLnNyYyA9IHVybDtcblxuICAgICAgICAvLyBIYW5kbGUgc2NyaXB0IGxvYWQgZXJyb3IgIzI3XG4gICAgICAgIHMub25lcnJvciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAganNvbnAuZXJyb3JXcmFwcGVyLmNhbGwoX3RoaXMsIGUpO1xuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHMpO1xuICAgICAgdGhpcy5fanNvbnAuc2NyaXB0ID0gcztcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgfTtcblxuICB2YXIgcmVxRnVuYyA9IGZ1bmN0aW9uIHJlcUZ1bmMocmVxdWVzdCkge1xuICAgIC8vIEluIGNhc2UgdGhpcyBpcyBpbiBub2RlanMsIHJ1biB3aXRob3V0IG1vZGlmeWluZyByZXF1ZXN0XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSByZXR1cm4gcmVxdWVzdDtcblxuICAgIHJlcXVlc3QuZW5kID0gZW5kLmNhbGwocmVxdWVzdCwgcmVxdWVzdE9yQ29uZmlnKTtcbiAgICByZXR1cm4gcmVxdWVzdDtcbiAgfTtcblxuICAvLyBpZiByZXF1ZXN0T3JDb25maWcgaXMgcmVxdWVzdFxuICBpZiAodHlwZW9mIHJlcXVlc3RPckNvbmZpZy5lbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gcmVxRnVuYyhyZXF1ZXN0T3JDb25maWcpO1xuICB9XG5cbiAgcmV0dXJuIHJlcUZ1bmM7XG59O1xuXG5qc29ucC5jYWxsYmFja1dyYXBwZXIgPSBmdW5jdGlvbiBjYWxsYmFja1dyYXBwZXIoYm9keSkge1xuICB2YXIgZXJyID0gbnVsbDtcbiAgdmFyIHJlcyA9IHsgYm9keTogYm9keSB9O1xuXG4gIHJlbW92ZUNhbGxiYWNrKHRoaXMuX2pzb25wKTtcblxuICB0aGlzLl9qc29ucC5jYWxsYmFjay5jYWxsKHRoaXMsIGVyciwgcmVzKTtcbn07XG5cbmpzb25wLmVycm9yV3JhcHBlciA9IGZ1bmN0aW9uIGVycm9yV3JhcHBlcihlcnJvcikge1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCc0MDQgTm90IGZvdW5kJyk7XG4gIGlmIChlcnJvciAmJiBlcnJvciBpbnN0YW5jZW9mIEV2ZW50ICYmIGVycm9yLnR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBlcnIgPSBuZXcgRXJyb3IoJ0Nvbm5lY3Rpb24gaXNzdWUnKTtcbiAgfVxuXG4gIHJlbW92ZUNhbGxiYWNrKHRoaXMuX2pzb25wKTtcblxuICB0aGlzLl9qc29ucC5jYWxsYmFjay5jYWxsKHRoaXMsIGVyciwgbnVsbCk7XG59O1xuXG4vLyBQcmVmZXIgbm9kZS9icm93c2VyaWZ5IHN0eWxlIHJlcXVpcmVzXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGpzb25wO1xufSBlbHNlIGlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFtdLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHsganNvbnA6IGpzb25wIH07XG4gIH0pO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICB3aW5kb3cuc3VwZXJhZ2VudEpTT05QID0ganNvbnA7XG59IiwiZnVuY3Rpb24gQWdlbnQoKSB7XG4gIHRoaXMuX2RlZmF1bHRzID0gW107XG59XG5cbltcInVzZVwiLCBcIm9uXCIsIFwib25jZVwiLCBcInNldFwiLCBcInF1ZXJ5XCIsIFwidHlwZVwiLCBcImFjY2VwdFwiLCBcImF1dGhcIiwgXCJ3aXRoQ3JlZGVudGlhbHNcIiwgXCJzb3J0UXVlcnlcIiwgXCJyZXRyeVwiLCBcIm9rXCIsIFwicmVkaXJlY3RzXCIsXG4gXCJ0aW1lb3V0XCIsIFwiYnVmZmVyXCIsIFwic2VyaWFsaXplXCIsIFwicGFyc2VcIiwgXCJjYVwiLCBcImtleVwiLCBcInBmeFwiLCBcImNlcnRcIl0uZm9yRWFjaChmdW5jdGlvbihmbikge1xuICAvKiogRGVmYXVsdCBzZXR0aW5nIGZvciBhbGwgcmVxdWVzdHMgZnJvbSB0aGlzIGFnZW50ICovXG4gIEFnZW50LnByb3RvdHlwZVtmbl0gPSBmdW5jdGlvbigvKnZhcmFyZ3MqLykge1xuICAgIHRoaXMuX2RlZmF1bHRzLnB1c2goe2ZuOmZuLCBhcmd1bWVudHM6YXJndW1lbnRzfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn0pO1xuXG5BZ2VudC5wcm90b3R5cGUuX3NldERlZmF1bHRzID0gZnVuY3Rpb24ocmVxKSB7XG4gICAgdGhpcy5fZGVmYXVsdHMuZm9yRWFjaChmdW5jdGlvbihkZWYpIHtcbiAgICAgIHJlcVtkZWYuZm5dLmFwcGx5KHJlcSwgZGVmLmFyZ3VtZW50cyk7XG4gICAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFnZW50O1xuIiwiLyoqXG4gKiBSb290IHJlZmVyZW5jZSBmb3IgaWZyYW1lcy5cbiAqL1xuXG52YXIgcm9vdDtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyAvLyBCcm93c2VyIHdpbmRvd1xuICByb290ID0gd2luZG93O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHsgLy8gV2ViIFdvcmtlclxuICByb290ID0gc2VsZjtcbn0gZWxzZSB7IC8vIE90aGVyIGVudmlyb25tZW50c1xuICBjb25zb2xlLndhcm4oXCJVc2luZyBicm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGluIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuICByb290ID0gdGhpcztcbn1cblxudmFyIEVtaXR0ZXIgPSByZXF1aXJlKCdjb21wb25lbnQtZW1pdHRlcicpO1xudmFyIFJlcXVlc3RCYXNlID0gcmVxdWlyZSgnLi9yZXF1ZXN0LWJhc2UnKTtcbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG52YXIgUmVzcG9uc2VCYXNlID0gcmVxdWlyZSgnLi9yZXNwb25zZS1iYXNlJyk7XG52YXIgQWdlbnQgPSByZXF1aXJlKCcuL2FnZW50LWJhc2UnKTtcblxuLyoqXG4gKiBOb29wLlxuICovXG5cbmZ1bmN0aW9uIG5vb3AoKXt9O1xuXG4vKipcbiAqIEV4cG9zZSBgcmVxdWVzdGAuXG4gKi9cblxudmFyIHJlcXVlc3QgPSBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtZXRob2QsIHVybCkge1xuICAvLyBjYWxsYmFja1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgdXJsKSB7XG4gICAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QoJ0dFVCcsIG1ldGhvZCkuZW5kKHVybCk7XG4gIH1cblxuICAvLyB1cmwgZmlyc3RcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBuZXcgZXhwb3J0cy5SZXF1ZXN0KCdHRVQnLCBtZXRob2QpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBleHBvcnRzLlJlcXVlc3QobWV0aG9kLCB1cmwpO1xufVxuXG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuXG4vKipcbiAqIERldGVybWluZSBYSFIuXG4gKi9cblxucmVxdWVzdC5nZXRYSFIgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChyb290LlhNTEh0dHBSZXF1ZXN0XG4gICAgICAmJiAoIXJvb3QubG9jYXRpb24gfHwgJ2ZpbGU6JyAhPSByb290LmxvY2F0aW9uLnByb3RvY29sXG4gICAgICAgICAgfHwgIXJvb3QuQWN0aXZlWE9iamVjdCkpIHtcbiAgICByZXR1cm4gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICB9IGVsc2Uge1xuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTsgfSBjYXRjaChlKSB7fVxuICAgIHRyeSB7IHJldHVybiBuZXcgQWN0aXZlWE9iamVjdCgnTXN4bWwyLlhNTEhUVFAuNi4wJyk7IH0gY2F0Y2goZSkge31cbiAgICB0cnkgeyByZXR1cm4gbmV3IEFjdGl2ZVhPYmplY3QoJ01zeG1sMi5YTUxIVFRQLjMuMCcpOyB9IGNhdGNoKGUpIHt9XG4gICAgdHJ5IHsgcmV0dXJuIG5ldyBBY3RpdmVYT2JqZWN0KCdNc3htbDIuWE1MSFRUUCcpOyB9IGNhdGNoKGUpIHt9XG4gIH1cbiAgdGhyb3cgRXJyb3IoXCJCcm93c2VyLW9ubHkgdmVyc2lvbiBvZiBzdXBlcmFnZW50IGNvdWxkIG5vdCBmaW5kIFhIUlwiKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBsZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBhZGRlZCB0byBzdXBwb3J0IElFLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG52YXIgdHJpbSA9ICcnLnRyaW1cbiAgPyBmdW5jdGlvbihzKSB7IHJldHVybiBzLnRyaW0oKTsgfVxuICA6IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMucmVwbGFjZSgvKF5cXHMqfFxccyokKS9nLCAnJyk7IH07XG5cbi8qKlxuICogU2VyaWFsaXplIHRoZSBnaXZlbiBgb2JqYC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzZXJpYWxpemUob2JqKSB7XG4gIGlmICghaXNPYmplY3Qob2JqKSkgcmV0dXJuIG9iajtcbiAgdmFyIHBhaXJzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCBvYmpba2V5XSk7XG4gIH1cbiAgcmV0dXJuIHBhaXJzLmpvaW4oJyYnKTtcbn1cblxuLyoqXG4gKiBIZWxwcyAnc2VyaWFsaXplJyB3aXRoIHNlcmlhbGl6aW5nIGFycmF5cy5cbiAqIE11dGF0ZXMgdGhlIHBhaXJzIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzXG4gKiBAcGFyYW0ge1N0cmluZ30ga2V5XG4gKiBAcGFyYW0ge01peGVkfSB2YWxcbiAqL1xuXG5mdW5jdGlvbiBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2YWwpIHtcbiAgaWYgKHZhbCAhPSBudWxsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgdmFsLmZvckVhY2goZnVuY3Rpb24odikge1xuICAgICAgICBwdXNoRW5jb2RlZEtleVZhbHVlUGFpcihwYWlycywga2V5LCB2KTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoaXNPYmplY3QodmFsKSkge1xuICAgICAgZm9yKHZhciBzdWJrZXkgaW4gdmFsKSB7XG4gICAgICAgIHB1c2hFbmNvZGVkS2V5VmFsdWVQYWlyKHBhaXJzLCBrZXkgKyAnWycgKyBzdWJrZXkgKyAnXScsIHZhbFtzdWJrZXldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KVxuICAgICAgICArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodmFsID09PSBudWxsKSB7XG4gICAgcGFpcnMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFeHBvc2Ugc2VyaWFsaXphdGlvbiBtZXRob2QuXG4gKi9cblxucmVxdWVzdC5zZXJpYWxpemVPYmplY3QgPSBzZXJpYWxpemU7XG5cbi8qKlxuICAqIFBhcnNlIHRoZSBnaXZlbiB4LXd3dy1mb3JtLXVybGVuY29kZWQgYHN0cmAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqIEBhcGkgcHJpdmF0ZVxuICAqL1xuXG5mdW5jdGlvbiBwYXJzZVN0cmluZyhzdHIpIHtcbiAgdmFyIG9iaiA9IHt9O1xuICB2YXIgcGFpcnMgPSBzdHIuc3BsaXQoJyYnKTtcbiAgdmFyIHBhaXI7XG4gIHZhciBwb3M7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHBhaXJzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgcGFpciA9IHBhaXJzW2ldO1xuICAgIHBvcyA9IHBhaXIuaW5kZXhPZignPScpO1xuICAgIGlmIChwb3MgPT0gLTEpIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpcildID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZSgwLCBwb3MpKV0gPVxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQocGFpci5zbGljZShwb3MgKyAxKSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBFeHBvc2UgcGFyc2VyLlxuICovXG5cbnJlcXVlc3QucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcblxuLyoqXG4gKiBEZWZhdWx0IE1JTUUgdHlwZSBtYXAuXG4gKlxuICogICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICovXG5cbnJlcXVlc3QudHlwZXMgPSB7XG4gIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gIHhtbDogJ3RleHQveG1sJyxcbiAgdXJsZW5jb2RlZDogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcsXG4gICdmb3JtLWRhdGEnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuLyoqXG4gKiBEZWZhdWx0IHNlcmlhbGl6YXRpb24gbWFwLlxuICpcbiAqICAgICBzdXBlcmFnZW50LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihvYmope1xuICogICAgICAgcmV0dXJuICdnZW5lcmF0ZWQgeG1sIGhlcmUnO1xuICogICAgIH07XG4gKlxuICovXG5cbnJlcXVlc3Quc2VyaWFsaXplID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogc2VyaWFsaXplLFxuICAnYXBwbGljYXRpb24vanNvbic6IEpTT04uc3RyaW5naWZ5XG59O1xuXG4vKipcbiAgKiBEZWZhdWx0IHBhcnNlcnMuXG4gICpcbiAgKiAgICAgc3VwZXJhZ2VudC5wYXJzZVsnYXBwbGljYXRpb24veG1sJ10gPSBmdW5jdGlvbihzdHIpe1xuICAqICAgICAgIHJldHVybiB7IG9iamVjdCBwYXJzZWQgZnJvbSBzdHIgfTtcbiAgKiAgICAgfTtcbiAgKlxuICAqL1xuXG5yZXF1ZXN0LnBhcnNlID0ge1xuICAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJzogcGFyc2VTdHJpbmcsXG4gICdhcHBsaWNhdGlvbi9qc29uJzogSlNPTi5wYXJzZVxufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gaGVhZGVyIGBzdHJgIGludG9cbiAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBtYXBwZWQgZmllbGRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlSGVhZGVyKHN0cikge1xuICB2YXIgbGluZXMgPSBzdHIuc3BsaXQoL1xccj9cXG4vKTtcbiAgdmFyIGZpZWxkcyA9IHt9O1xuICB2YXIgaW5kZXg7XG4gIHZhciBsaW5lO1xuICB2YXIgZmllbGQ7XG4gIHZhciB2YWw7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxpbmVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgbGluZSA9IGxpbmVzW2ldO1xuICAgIGluZGV4ID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAgaWYgKGluZGV4ID09PSAtMSkgeyAvLyBjb3VsZCBiZSBlbXB0eSBsaW5lLCBqdXN0IHNraXAgaXRcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBmaWVsZCA9IGxpbmUuc2xpY2UoMCwgaW5kZXgpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFsID0gdHJpbShsaW5lLnNsaWNlKGluZGV4ICsgMSkpO1xuICAgIGZpZWxkc1tmaWVsZF0gPSB2YWw7XG4gIH1cblxuICByZXR1cm4gZmllbGRzO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGBtaW1lYCBpcyBqc29uIG9yIGhhcyAranNvbiBzdHJ1Y3R1cmVkIHN5bnRheCBzdWZmaXguXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1pbWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc0pTT04obWltZSkge1xuICAvLyBzaG91bGQgbWF0Y2ggL2pzb24gb3IgK2pzb25cbiAgLy8gYnV0IG5vdCAvanNvbi1zZXFcbiAgcmV0dXJuIC9bXFwvK11qc29uKCR8W14tXFx3XSkvLnRlc3QobWltZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUmVzcG9uc2VgIHdpdGggdGhlIGdpdmVuIGB4aHJgLlxuICpcbiAqICAtIHNldCBmbGFncyAoLm9rLCAuZXJyb3IsIGV0YylcbiAqICAtIHBhcnNlIGhlYWRlclxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICBBbGlhc2luZyBgc3VwZXJhZ2VudGAgYXMgYHJlcXVlc3RgIGlzIG5pY2U6XG4gKlxuICogICAgICByZXF1ZXN0ID0gc3VwZXJhZ2VudDtcbiAqXG4gKiAgV2UgY2FuIHVzZSB0aGUgcHJvbWlzZS1saWtlIEFQSSwgb3IgcGFzcyBjYWxsYmFja3M6XG4gKlxuICogICAgICByZXF1ZXN0LmdldCgnLycpLmVuZChmdW5jdGlvbihyZXMpe30pO1xuICogICAgICByZXF1ZXN0LmdldCgnLycsIGZ1bmN0aW9uKHJlcyl7fSk7XG4gKlxuICogIFNlbmRpbmcgZGF0YSBjYW4gYmUgY2hhaW5lZDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiAgT3IgcGFzc2VkIHRvIGAuc2VuZCgpYDpcbiAqXG4gKiAgICAgIHJlcXVlc3RcbiAqICAgICAgICAucG9zdCgnL3VzZXInKVxuICogICAgICAgIC5zZW5kKHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqICBPciBwYXNzZWQgdG8gYC5wb3N0KClgOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9KVxuICogICAgICAgIC5lbmQoZnVuY3Rpb24ocmVzKXt9KTtcbiAqXG4gKiBPciBmdXJ0aGVyIHJlZHVjZWQgdG8gYSBzaW5nbGUgY2FsbCBmb3Igc2ltcGxlIGNhc2VzOlxuICpcbiAqICAgICAgcmVxdWVzdFxuICogICAgICAgIC5wb3N0KCcvdXNlcicsIHsgbmFtZTogJ3RqJyB9LCBmdW5jdGlvbihyZXMpe30pO1xuICpcbiAqIEBwYXJhbSB7WE1MSFRUUFJlcXVlc3R9IHhoclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIFJlc3BvbnNlKHJlcSkge1xuICB0aGlzLnJlcSA9IHJlcTtcbiAgdGhpcy54aHIgPSB0aGlzLnJlcS54aHI7XG4gIC8vIHJlc3BvbnNlVGV4dCBpcyBhY2Nlc3NpYmxlIG9ubHkgaWYgcmVzcG9uc2VUeXBlIGlzICcnIG9yICd0ZXh0JyBhbmQgb24gb2xkZXIgYnJvd3NlcnNcbiAgdGhpcy50ZXh0ID0gKCh0aGlzLnJlcS5tZXRob2QgIT0nSEVBRCcgJiYgKHRoaXMueGhyLnJlc3BvbnNlVHlwZSA9PT0gJycgfHwgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndGV4dCcpKSB8fCB0eXBlb2YgdGhpcy54aHIucmVzcG9uc2VUeXBlID09PSAndW5kZWZpbmVkJylcbiAgICAgPyB0aGlzLnhoci5yZXNwb25zZVRleHRcbiAgICAgOiBudWxsO1xuICB0aGlzLnN0YXR1c1RleHQgPSB0aGlzLnJlcS54aHIuc3RhdHVzVGV4dDtcbiAgdmFyIHN0YXR1cyA9IHRoaXMueGhyLnN0YXR1cztcbiAgLy8gaGFuZGxlIElFOSBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTAwNDY5NzIvbXNpZS1yZXR1cm5zLXN0YXR1cy1jb2RlLW9mLTEyMjMtZm9yLWFqYXgtcmVxdWVzdFxuICBpZiAoc3RhdHVzID09PSAxMjIzKSB7XG4gICAgc3RhdHVzID0gMjA0O1xuICB9XG4gIHRoaXMuX3NldFN0YXR1c1Byb3BlcnRpZXMoc3RhdHVzKTtcbiAgdGhpcy5oZWFkZXIgPSB0aGlzLmhlYWRlcnMgPSBwYXJzZUhlYWRlcih0aGlzLnhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG4gIC8vIGdldEFsbFJlc3BvbnNlSGVhZGVycyBzb21ldGltZXMgZmFsc2VseSByZXR1cm5zIFwiXCIgZm9yIENPUlMgcmVxdWVzdHMsIGJ1dFxuICAvLyBnZXRSZXNwb25zZUhlYWRlciBzdGlsbCB3b3Jrcy4gc28gd2UgZ2V0IGNvbnRlbnQtdHlwZSBldmVuIGlmIGdldHRpbmdcbiAgLy8gb3RoZXIgaGVhZGVycyBmYWlscy5cbiAgdGhpcy5oZWFkZXJbJ2NvbnRlbnQtdHlwZSddID0gdGhpcy54aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtdHlwZScpO1xuICB0aGlzLl9zZXRIZWFkZXJQcm9wZXJ0aWVzKHRoaXMuaGVhZGVyKTtcblxuICBpZiAobnVsbCA9PT0gdGhpcy50ZXh0ICYmIHJlcS5fcmVzcG9uc2VUeXBlKSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy54aHIucmVzcG9uc2U7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5ib2R5ID0gdGhpcy5yZXEubWV0aG9kICE9ICdIRUFEJ1xuICAgICAgPyB0aGlzLl9wYXJzZUJvZHkodGhpcy50ZXh0ID8gdGhpcy50ZXh0IDogdGhpcy54aHIucmVzcG9uc2UpXG4gICAgICA6IG51bGw7XG4gIH1cbn1cblxuUmVzcG9uc2VCYXNlKFJlc3BvbnNlLnByb3RvdHlwZSk7XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGJvZHkgYHN0cmAuXG4gKlxuICogVXNlZCBmb3IgYXV0by1wYXJzaW5nIG9mIGJvZGllcy4gUGFyc2Vyc1xuICogYXJlIGRlZmluZWQgb24gdGhlIGBzdXBlcmFnZW50LnBhcnNlYCBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TWl4ZWR9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUuX3BhcnNlQm9keSA9IGZ1bmN0aW9uKHN0cikge1xuICB2YXIgcGFyc2UgPSByZXF1ZXN0LnBhcnNlW3RoaXMudHlwZV07XG4gIGlmICh0aGlzLnJlcS5fcGFyc2VyKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxLl9wYXJzZXIodGhpcywgc3RyKTtcbiAgfVxuICBpZiAoIXBhcnNlICYmIGlzSlNPTih0aGlzLnR5cGUpKSB7XG4gICAgcGFyc2UgPSByZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi9qc29uJ107XG4gIH1cbiAgcmV0dXJuIHBhcnNlICYmIHN0ciAmJiAoc3RyLmxlbmd0aCB8fCBzdHIgaW5zdGFuY2VvZiBPYmplY3QpXG4gICAgPyBwYXJzZShzdHIpXG4gICAgOiBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gYW4gYEVycm9yYCByZXByZXNlbnRhdGl2ZSBvZiB0aGlzIHJlc3BvbnNlLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZS5wcm90b3R5cGUudG9FcnJvciA9IGZ1bmN0aW9uKCl7XG4gIHZhciByZXEgPSB0aGlzLnJlcTtcbiAgdmFyIG1ldGhvZCA9IHJlcS5tZXRob2Q7XG4gIHZhciB1cmwgPSByZXEudXJsO1xuXG4gIHZhciBtc2cgPSAnY2Fubm90ICcgKyBtZXRob2QgKyAnICcgKyB1cmwgKyAnICgnICsgdGhpcy5zdGF0dXMgKyAnKSc7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gbWV0aG9kO1xuICBlcnIudXJsID0gdXJsO1xuXG4gIHJldHVybiBlcnI7XG59O1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VgLlxuICovXG5cbnJlcXVlc3QuUmVzcG9uc2UgPSBSZXNwb25zZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0YCB3aXRoIHRoZSBnaXZlbiBgbWV0aG9kYCBhbmQgYHVybGAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0KG1ldGhvZCwgdXJsKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdGhpcy5fcXVlcnkgPSB0aGlzLl9xdWVyeSB8fCBbXTtcbiAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gIHRoaXMudXJsID0gdXJsO1xuICB0aGlzLmhlYWRlciA9IHt9OyAvLyBwcmVzZXJ2ZXMgaGVhZGVyIG5hbWUgY2FzZVxuICB0aGlzLl9oZWFkZXIgPSB7fTsgLy8gY29lcmNlcyBoZWFkZXIgbmFtZXMgdG8gbG93ZXJjYXNlXG4gIHRoaXMub24oJ2VuZCcsIGZ1bmN0aW9uKCl7XG4gICAgdmFyIGVyciA9IG51bGw7XG4gICAgdmFyIHJlcyA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgcmVzID0gbmV3IFJlc3BvbnNlKHNlbGYpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgZXJyID0gbmV3IEVycm9yKCdQYXJzZXIgaXMgdW5hYmxlIHRvIHBhcnNlIHRoZSByZXNwb25zZScpO1xuICAgICAgZXJyLnBhcnNlID0gdHJ1ZTtcbiAgICAgIGVyci5vcmlnaW5hbCA9IGU7XG4gICAgICAvLyBpc3N1ZSAjNjc1OiByZXR1cm4gdGhlIHJhdyByZXNwb25zZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgaWYgKHNlbGYueGhyKSB7XG4gICAgICAgIC8vIGllOSBkb2Vzbid0IGhhdmUgJ3Jlc3BvbnNlJyBwcm9wZXJ0eVxuICAgICAgICBlcnIucmF3UmVzcG9uc2UgPSB0eXBlb2Ygc2VsZi54aHIucmVzcG9uc2VUeXBlID09ICd1bmRlZmluZWQnID8gc2VsZi54aHIucmVzcG9uc2VUZXh0IDogc2VsZi54aHIucmVzcG9uc2U7XG4gICAgICAgIC8vIGlzc3VlICM4NzY6IHJldHVybiB0aGUgaHR0cCBzdGF0dXMgY29kZSBpZiB0aGUgcmVzcG9uc2UgcGFyc2luZyBmYWlsc1xuICAgICAgICBlcnIuc3RhdHVzID0gc2VsZi54aHIuc3RhdHVzID8gc2VsZi54aHIuc3RhdHVzIDogbnVsbDtcbiAgICAgICAgZXJyLnN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzOyAvLyBiYWNrd2FyZHMtY29tcGF0IG9ubHlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVyci5yYXdSZXNwb25zZSA9IG51bGw7XG4gICAgICAgIGVyci5zdGF0dXMgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc2VsZi5jYWxsYmFjayhlcnIpO1xuICAgIH1cblxuICAgIHNlbGYuZW1pdCgncmVzcG9uc2UnLCByZXMpO1xuXG4gICAgdmFyIG5ld19lcnI7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghc2VsZi5faXNSZXNwb25zZU9LKHJlcykpIHtcbiAgICAgICAgbmV3X2VyciA9IG5ldyBFcnJvcihyZXMuc3RhdHVzVGV4dCB8fCAnVW5zdWNjZXNzZnVsIEhUVFAgcmVzcG9uc2UnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGN1c3RvbV9lcnIpIHtcbiAgICAgIG5ld19lcnIgPSBjdXN0b21fZXJyOyAvLyBvaygpIGNhbGxiYWNrIGNhbiB0aHJvd1xuICAgIH1cblxuICAgIC8vICMxMDAwIGRvbid0IGNhdGNoIGVycm9ycyBmcm9tIHRoZSBjYWxsYmFjayB0byBhdm9pZCBkb3VibGUgY2FsbGluZyBpdFxuICAgIGlmIChuZXdfZXJyKSB7XG4gICAgICBuZXdfZXJyLm9yaWdpbmFsID0gZXJyO1xuICAgICAgbmV3X2Vyci5yZXNwb25zZSA9IHJlcztcbiAgICAgIG5ld19lcnIuc3RhdHVzID0gcmVzLnN0YXR1cztcbiAgICAgIHNlbGYuY2FsbGJhY2sobmV3X2VyciwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5jYWxsYmFjayhudWxsLCByZXMpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogTWl4aW4gYEVtaXR0ZXJgIGFuZCBgUmVxdWVzdEJhc2VgLlxuICovXG5cbkVtaXR0ZXIoUmVxdWVzdC5wcm90b3R5cGUpO1xuUmVxdWVzdEJhc2UoUmVxdWVzdC5wcm90b3R5cGUpO1xuXG4vKipcbiAqIFNldCBDb250ZW50LVR5cGUgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMueG1sID0gJ2FwcGxpY2F0aW9uL3htbCc7XG4gKlxuICogICAgICByZXF1ZXN0LnBvc3QoJy8nKVxuICogICAgICAgIC50eXBlKCd4bWwnKVxuICogICAgICAgIC5zZW5kKHhtbHN0cmluZylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiAgICAgIHJlcXVlc3QucG9zdCgnLycpXG4gKiAgICAgICAgLnR5cGUoJ2FwcGxpY2F0aW9uL3htbCcpXG4gKiAgICAgICAgLnNlbmQoeG1sc3RyaW5nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUudHlwZSA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQ29udGVudC1UeXBlJywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBY2NlcHQgdG8gYHR5cGVgLCBtYXBwaW5nIHZhbHVlcyBmcm9tIGByZXF1ZXN0LnR5cGVzYC5cbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgIHN1cGVyYWdlbnQudHlwZXMuanNvbiA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAqXG4gKiAgICAgIHJlcXVlc3QuZ2V0KCcvYWdlbnQnKVxuICogICAgICAgIC5hY2NlcHQoJ2pzb24nKVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqICAgICAgcmVxdWVzdC5nZXQoJy9hZ2VudCcpXG4gKiAgICAgICAgLmFjY2VwdCgnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFjY2VwdFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmFjY2VwdCA9IGZ1bmN0aW9uKHR5cGUpe1xuICB0aGlzLnNldCgnQWNjZXB0JywgcmVxdWVzdC50eXBlc1t0eXBlXSB8fCB0eXBlKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBBdXRob3JpemF0aW9uIGZpZWxkIHZhbHVlIHdpdGggYHVzZXJgIGFuZCBgcGFzc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcGFzc10gb3B0aW9uYWwgaW4gY2FzZSBvZiB1c2luZyAnYmVhcmVyJyBhcyB0eXBlXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB3aXRoICd0eXBlJyBwcm9wZXJ0eSAnYXV0bycsICdiYXNpYycgb3IgJ2JlYXJlcicgKGRlZmF1bHQgJ2Jhc2ljJylcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5hdXRoID0gZnVuY3Rpb24odXNlciwgcGFzcywgb3B0aW9ucyl7XG4gIGlmICgxID09PSBhcmd1bWVudHMubGVuZ3RoKSBwYXNzID0gJyc7XG4gIGlmICh0eXBlb2YgcGFzcyA9PT0gJ29iamVjdCcgJiYgcGFzcyAhPT0gbnVsbCkgeyAvLyBwYXNzIGlzIG9wdGlvbmFsIGFuZCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBvcHRpb25zXG4gICAgb3B0aW9ucyA9IHBhc3M7XG4gICAgcGFzcyA9ICcnO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7XG4gICAgICB0eXBlOiAnZnVuY3Rpb24nID09PSB0eXBlb2YgYnRvYSA/ICdiYXNpYycgOiAnYXV0bycsXG4gICAgfTtcbiAgfVxuXG4gIHZhciBlbmNvZGVyID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgaWYgKCdmdW5jdGlvbicgPT09IHR5cGVvZiBidG9hKSB7XG4gICAgICByZXR1cm4gYnRvYShzdHJpbmcpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgYmFzaWMgYXV0aCwgYnRvYSBpcyBub3QgYSBmdW5jdGlvbicpO1xuICB9O1xuXG4gIHJldHVybiB0aGlzLl9hdXRoKHVzZXIsIHBhc3MsIG9wdGlvbnMsIGVuY29kZXIpO1xufTtcblxuLyoqXG4gKiBBZGQgcXVlcnktc3RyaW5nIGB2YWxgLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgcmVxdWVzdC5nZXQoJy9zaG9lcycpXG4gKiAgICAgLnF1ZXJ5KCdzaXplPTEwJylcbiAqICAgICAucXVlcnkoeyBjb2xvcjogJ2JsdWUnIH0pXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5xdWVyeSA9IGZ1bmN0aW9uKHZhbCl7XG4gIGlmICgnc3RyaW5nJyAhPSB0eXBlb2YgdmFsKSB2YWwgPSBzZXJpYWxpemUodmFsKTtcbiAgaWYgKHZhbCkgdGhpcy5fcXVlcnkucHVzaCh2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUXVldWUgdGhlIGdpdmVuIGBmaWxlYCBhcyBhbiBhdHRhY2htZW50IHRvIHRoZSBzcGVjaWZpZWQgYGZpZWxkYCxcbiAqIHdpdGggb3B0aW9uYWwgYG9wdGlvbnNgIChvciBmaWxlbmFtZSkuXG4gKlxuICogYGBgIGpzXG4gKiByZXF1ZXN0LnBvc3QoJy91cGxvYWQnKVxuICogICAuYXR0YWNoKCdjb250ZW50JywgbmV3IEJsb2IoWyc8YSBpZD1cImFcIj48YiBpZD1cImJcIj5oZXkhPC9iPjwvYT4nXSwgeyB0eXBlOiBcInRleHQvaHRtbFwifSkpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGZpZWxkXG4gKiBAcGFyYW0ge0Jsb2J8RmlsZX0gZmlsZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBvcHRpb25zXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdC5wcm90b3R5cGUuYXR0YWNoID0gZnVuY3Rpb24oZmllbGQsIGZpbGUsIG9wdGlvbnMpe1xuICBpZiAoZmlsZSkge1xuICAgIGlmICh0aGlzLl9kYXRhKSB7XG4gICAgICB0aHJvdyBFcnJvcihcInN1cGVyYWdlbnQgY2FuJ3QgbWl4IC5zZW5kKCkgYW5kIC5hdHRhY2goKVwiKTtcbiAgICB9XG5cbiAgICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChmaWVsZCwgZmlsZSwgb3B0aW9ucyB8fCBmaWxlLm5hbWUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdC5wcm90b3R5cGUuX2dldEZvcm1EYXRhID0gZnVuY3Rpb24oKXtcbiAgaWYgKCF0aGlzLl9mb3JtRGF0YSkge1xuICAgIHRoaXMuX2Zvcm1EYXRhID0gbmV3IHJvb3QuRm9ybURhdGEoKTtcbiAgfVxuICByZXR1cm4gdGhpcy5fZm9ybURhdGE7XG59O1xuXG4vKipcbiAqIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBgZXJyYCBhbmQgYHJlc2BcbiAqIGFuZCBoYW5kbGUgYXJpdHkgY2hlY2suXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gKiBAcGFyYW0ge1Jlc3BvbnNlfSByZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNhbGxiYWNrID0gZnVuY3Rpb24oZXJyLCByZXMpe1xuICBpZiAodGhpcy5fc2hvdWxkUmV0cnkoZXJyLCByZXMpKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JldHJ5KCk7XG4gIH1cblxuICB2YXIgZm4gPSB0aGlzLl9jYWxsYmFjaztcbiAgdGhpcy5jbGVhclRpbWVvdXQoKTtcblxuICBpZiAoZXJyKSB7XG4gICAgaWYgKHRoaXMuX21heFJldHJpZXMpIGVyci5yZXRyaWVzID0gdGhpcy5fcmV0cmllcyAtIDE7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICBmbihlcnIsIHJlcyk7XG59O1xuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHgtZG9tYWluIGVycm9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3QucHJvdG90eXBlLmNyb3NzRG9tYWluRXJyb3IgPSBmdW5jdGlvbigpe1xuICB2YXIgZXJyID0gbmV3IEVycm9yKCdSZXF1ZXN0IGhhcyBiZWVuIHRlcm1pbmF0ZWRcXG5Qb3NzaWJsZSBjYXVzZXM6IHRoZSBuZXR3b3JrIGlzIG9mZmxpbmUsIE9yaWdpbiBpcyBub3QgYWxsb3dlZCBieSBBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4sIHRoZSBwYWdlIGlzIGJlaW5nIHVubG9hZGVkLCBldGMuJyk7XG4gIGVyci5jcm9zc0RvbWFpbiA9IHRydWU7XG5cbiAgZXJyLnN0YXR1cyA9IHRoaXMuc3RhdHVzO1xuICBlcnIubWV0aG9kID0gdGhpcy5tZXRob2Q7XG4gIGVyci51cmwgPSB0aGlzLnVybDtcblxuICB0aGlzLmNhbGxiYWNrKGVycik7XG59O1xuXG4vLyBUaGlzIG9ubHkgd2FybnMsIGJlY2F1c2UgdGhlIHJlcXVlc3QgaXMgc3RpbGwgbGlrZWx5IHRvIHdvcmtcblJlcXVlc3QucHJvdG90eXBlLmJ1ZmZlciA9IFJlcXVlc3QucHJvdG90eXBlLmNhID0gUmVxdWVzdC5wcm90b3R5cGUuYWdlbnQgPSBmdW5jdGlvbigpe1xuICBjb25zb2xlLndhcm4oXCJUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gVGhpcyB0aHJvd3MsIGJlY2F1c2UgaXQgY2FuJ3Qgc2VuZC9yZWNlaXZlIGRhdGEgYXMgZXhwZWN0ZWRcblJlcXVlc3QucHJvdG90eXBlLnBpcGUgPSBSZXF1ZXN0LnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKCl7XG4gIHRocm93IEVycm9yKFwiU3RyZWFtaW5nIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlciB2ZXJzaW9uIG9mIHN1cGVyYWdlbnRcIik7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGBvYmpgIGlzIGEgaG9zdCBvYmplY3QsXG4gKiB3ZSBkb24ndCB3YW50IHRvIHNlcmlhbGl6ZSB0aGVzZSA6KVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuUmVxdWVzdC5wcm90b3R5cGUuX2lzSG9zdCA9IGZ1bmN0aW9uIF9pc0hvc3Qob2JqKSB7XG4gIC8vIE5hdGl2ZSBvYmplY3RzIHN0cmluZ2lmeSB0byBbb2JqZWN0IEZpbGVdLCBbb2JqZWN0IEJsb2JdLCBbb2JqZWN0IEZvcm1EYXRhXSwgZXRjLlxuICByZXR1cm4gb2JqICYmICdvYmplY3QnID09PSB0eXBlb2Ygb2JqICYmICFBcnJheS5pc0FycmF5KG9iaikgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgIT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIEluaXRpYXRlIHJlcXVlc3QsIGludm9raW5nIGNhbGxiYWNrIGBmbihyZXMpYFxuICogd2l0aCBhbiBpbnN0YW5jZW9mIGBSZXNwb25zZWAuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0LnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbihmbil7XG4gIGlmICh0aGlzLl9lbmRDYWxsZWQpIHtcbiAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiAuZW5kKCkgd2FzIGNhbGxlZCB0d2ljZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGluIHN1cGVyYWdlbnRcIik7XG4gIH1cbiAgdGhpcy5fZW5kQ2FsbGVkID0gdHJ1ZTtcblxuICAvLyBzdG9yZSBjYWxsYmFja1xuICB0aGlzLl9jYWxsYmFjayA9IGZuIHx8IG5vb3A7XG5cbiAgLy8gcXVlcnlzdHJpbmdcbiAgdGhpcy5fZmluYWxpemVRdWVyeVN0cmluZygpO1xuXG4gIHJldHVybiB0aGlzLl9lbmQoKTtcbn07XG5cblJlcXVlc3QucHJvdG90eXBlLl9lbmQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuICB2YXIgeGhyID0gKHRoaXMueGhyID0gcmVxdWVzdC5nZXRYSFIoKSk7XG4gIHZhciBkYXRhID0gdGhpcy5fZm9ybURhdGEgfHwgdGhpcy5fZGF0YTtcblxuICB0aGlzLl9zZXRUaW1lb3V0cygpO1xuXG4gIC8vIHN0YXRlIGNoYW5nZVxuICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXtcbiAgICB2YXIgcmVhZHlTdGF0ZSA9IHhoci5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID49IDIgJiYgc2VsZi5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dChzZWxmLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIGlmICg0ICE9IHJlYWR5U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJbiBJRTksIHJlYWRzIHRvIGFueSBwcm9wZXJ0eSAoZS5nLiBzdGF0dXMpIG9mZiBvZiBhbiBhYm9ydGVkIFhIUiB3aWxsXG4gICAgLy8gcmVzdWx0IGluIHRoZSBlcnJvciBcIkNvdWxkIG5vdCBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGR1ZSB0byBlcnJvciBjMDBjMDIzZlwiXG4gICAgdmFyIHN0YXR1cztcbiAgICB0cnkgeyBzdGF0dXMgPSB4aHIuc3RhdHVzIH0gY2F0Y2goZSkgeyBzdGF0dXMgPSAwOyB9XG5cbiAgICBpZiAoIXN0YXR1cykge1xuICAgICAgaWYgKHNlbGYudGltZWRvdXQgfHwgc2VsZi5fYWJvcnRlZCkgcmV0dXJuO1xuICAgICAgcmV0dXJuIHNlbGYuY3Jvc3NEb21haW5FcnJvcigpO1xuICAgIH1cbiAgICBzZWxmLmVtaXQoJ2VuZCcpO1xuICB9O1xuXG4gIC8vIHByb2dyZXNzXG4gIHZhciBoYW5kbGVQcm9ncmVzcyA9IGZ1bmN0aW9uKGRpcmVjdGlvbiwgZSkge1xuICAgIGlmIChlLnRvdGFsID4gMCkge1xuICAgICAgZS5wZXJjZW50ID0gZS5sb2FkZWQgLyBlLnRvdGFsICogMTAwO1xuICAgIH1cbiAgICBlLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICBzZWxmLmVtaXQoJ3Byb2dyZXNzJywgZSk7XG4gIH07XG4gIGlmICh0aGlzLmhhc0xpc3RlbmVycygncHJvZ3Jlc3MnKSkge1xuICAgIHRyeSB7XG4gICAgICB4aHIub25wcm9ncmVzcyA9IGhhbmRsZVByb2dyZXNzLmJpbmQobnVsbCwgJ2Rvd25sb2FkJyk7XG4gICAgICBpZiAoeGhyLnVwbG9hZCkge1xuICAgICAgICB4aHIudXBsb2FkLm9ucHJvZ3Jlc3MgPSBoYW5kbGVQcm9ncmVzcy5iaW5kKG51bGwsICd1cGxvYWQnKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIEFjY2Vzc2luZyB4aHIudXBsb2FkIGZhaWxzIGluIElFIGZyb20gYSB3ZWIgd29ya2VyLCBzbyBqdXN0IHByZXRlbmQgaXQgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFJlcG9ydGVkIGhlcmU6XG4gICAgICAvLyBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzgzNzI0NS94bWxodHRwcmVxdWVzdC11cGxvYWQtdGhyb3dzLWludmFsaWQtYXJndW1lbnQtd2hlbi11c2VkLWZyb20td2ViLXdvcmtlci1jb250ZXh0XG4gICAgfVxuICB9XG5cbiAgLy8gaW5pdGlhdGUgcmVxdWVzdFxuICB0cnkge1xuICAgIGlmICh0aGlzLnVzZXJuYW1lICYmIHRoaXMucGFzc3dvcmQpIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSwgdGhpcy51c2VybmFtZSwgdGhpcy5wYXNzd29yZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHhoci5vcGVuKHRoaXMubWV0aG9kLCB0aGlzLnVybCwgdHJ1ZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBzZWUgIzExNDlcbiAgICByZXR1cm4gdGhpcy5jYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgLy8gQ09SU1xuICBpZiAodGhpcy5fd2l0aENyZWRlbnRpYWxzKSB4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcblxuICAvLyBib2R5XG4gIGlmICghdGhpcy5fZm9ybURhdGEgJiYgJ0dFVCcgIT0gdGhpcy5tZXRob2QgJiYgJ0hFQUQnICE9IHRoaXMubWV0aG9kICYmICdzdHJpbmcnICE9IHR5cGVvZiBkYXRhICYmICF0aGlzLl9pc0hvc3QoZGF0YSkpIHtcbiAgICAvLyBzZXJpYWxpemUgc3R1ZmZcbiAgICB2YXIgY29udGVudFR5cGUgPSB0aGlzLl9oZWFkZXJbJ2NvbnRlbnQtdHlwZSddO1xuICAgIHZhciBzZXJpYWxpemUgPSB0aGlzLl9zZXJpYWxpemVyIHx8IHJlcXVlc3Quc2VyaWFsaXplW2NvbnRlbnRUeXBlID8gY29udGVudFR5cGUuc3BsaXQoJzsnKVswXSA6ICcnXTtcbiAgICBpZiAoIXNlcmlhbGl6ZSAmJiBpc0pTT04oY29udGVudFR5cGUpKSB7XG4gICAgICBzZXJpYWxpemUgPSByZXF1ZXN0LnNlcmlhbGl6ZVsnYXBwbGljYXRpb24vanNvbiddO1xuICAgIH1cbiAgICBpZiAoc2VyaWFsaXplKSBkYXRhID0gc2VyaWFsaXplKGRhdGEpO1xuICB9XG5cbiAgLy8gc2V0IGhlYWRlciBmaWVsZHNcbiAgZm9yICh2YXIgZmllbGQgaW4gdGhpcy5oZWFkZXIpIHtcbiAgICBpZiAobnVsbCA9PSB0aGlzLmhlYWRlcltmaWVsZF0pIGNvbnRpbnVlO1xuXG4gICAgaWYgKHRoaXMuaGVhZGVyLmhhc093blByb3BlcnR5KGZpZWxkKSlcbiAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGZpZWxkLCB0aGlzLmhlYWRlcltmaWVsZF0pO1xuICB9XG5cbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVHlwZSkge1xuICAgIHhoci5yZXNwb25zZVR5cGUgPSB0aGlzLl9yZXNwb25zZVR5cGU7XG4gIH1cblxuICAvLyBzZW5kIHN0dWZmXG4gIHRoaXMuZW1pdCgncmVxdWVzdCcsIHRoaXMpO1xuXG4gIC8vIElFMTEgeGhyLnNlbmQodW5kZWZpbmVkKSBzZW5kcyAndW5kZWZpbmVkJyBzdHJpbmcgYXMgUE9TVCBwYXlsb2FkIChpbnN0ZWFkIG9mIG5vdGhpbmcpXG4gIC8vIFdlIG5lZWQgbnVsbCBoZXJlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gIHhoci5zZW5kKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJyA/IGRhdGEgOiBudWxsKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5yZXF1ZXN0LmFnZW50ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgQWdlbnQoKTtcbn07XG5cbltcIkdFVFwiLCBcIlBPU1RcIiwgXCJPUFRJT05TXCIsIFwiUEFUQ0hcIiwgXCJQVVRcIiwgXCJERUxFVEVcIl0uZm9yRWFjaChmdW5jdGlvbihtZXRob2QpIHtcbiAgQWdlbnQucHJvdG90eXBlW21ldGhvZC50b0xvd2VyQ2FzZSgpXSA9IGZ1bmN0aW9uKHVybCwgZm4pIHtcbiAgICB2YXIgcmVxID0gbmV3IHJlcXVlc3QuUmVxdWVzdChtZXRob2QsIHVybCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdHMocmVxKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJlcS5lbmQoZm4pO1xuICAgIH1cbiAgICByZXR1cm4gcmVxO1xuICB9O1xufSk7XG5cbkFnZW50LnByb3RvdHlwZS5kZWwgPSBBZ2VudC5wcm90b3R5cGVbJ2RlbGV0ZSddO1xuXG4vKipcbiAqIEdFVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QuZ2V0ID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnR0VUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnF1ZXJ5KGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBIRUFEIGB1cmxgIHdpdGggb3B0aW9uYWwgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5oZWFkID0gZnVuY3Rpb24odXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnSEVBRCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5xdWVyeShkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogT1BUSU9OUyBxdWVyeSB0byBgdXJsYCB3aXRoIG9wdGlvbmFsIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfEZ1bmN0aW9ufSBbZGF0YV0gb3IgZm5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3Qub3B0aW9ucyA9IGZ1bmN0aW9uKHVybCwgZGF0YSwgZm4pIHtcbiAgdmFyIHJlcSA9IHJlcXVlc3QoJ09QVElPTlMnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG5cbi8qKlxuICogREVMRVRFIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZWwodXJsLCBkYXRhLCBmbikge1xuICB2YXIgcmVxID0gcmVxdWVzdCgnREVMRVRFJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59XG5cbnJlcXVlc3RbJ2RlbCddID0gZGVsO1xucmVxdWVzdFsnZGVsZXRlJ10gPSBkZWw7XG5cbi8qKlxuICogUEFUQ0ggYHVybGAgd2l0aCBvcHRpb25hbCBgZGF0YWAgYW5kIGNhbGxiYWNrIGBmbihyZXMpYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge01peGVkfSBbZGF0YV1cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtmbl1cbiAqIEByZXR1cm4ge1JlcXVlc3R9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbnJlcXVlc3QucGF0Y2ggPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQQVRDSCcsIHVybCk7XG4gIGlmICgnZnVuY3Rpb24nID09IHR5cGVvZiBkYXRhKSAoZm4gPSBkYXRhKSwgKGRhdGEgPSBudWxsKTtcbiAgaWYgKGRhdGEpIHJlcS5zZW5kKGRhdGEpO1xuICBpZiAoZm4pIHJlcS5lbmQoZm4pO1xuICByZXR1cm4gcmVxO1xufTtcblxuLyoqXG4gKiBQT1NUIGB1cmxgIHdpdGggb3B0aW9uYWwgYGRhdGFgIGFuZCBjYWxsYmFjayBgZm4ocmVzKWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtNaXhlZH0gW2RhdGFdXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbZm5dXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5yZXF1ZXN0LnBvc3QgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQT1NUJywgdXJsKTtcbiAgaWYgKCdmdW5jdGlvbicgPT0gdHlwZW9mIGRhdGEpIChmbiA9IGRhdGEpLCAoZGF0YSA9IG51bGwpO1xuICBpZiAoZGF0YSkgcmVxLnNlbmQoZGF0YSk7XG4gIGlmIChmbikgcmVxLmVuZChmbik7XG4gIHJldHVybiByZXE7XG59O1xuXG4vKipcbiAqIFBVVCBgdXJsYCB3aXRoIG9wdGlvbmFsIGBkYXRhYCBhbmQgY2FsbGJhY2sgYGZuKHJlcylgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7TWl4ZWR8RnVuY3Rpb259IFtkYXRhXSBvciBmblxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxucmVxdWVzdC5wdXQgPSBmdW5jdGlvbih1cmwsIGRhdGEsIGZuKSB7XG4gIHZhciByZXEgPSByZXF1ZXN0KCdQVVQnLCB1cmwpO1xuICBpZiAoJ2Z1bmN0aW9uJyA9PSB0eXBlb2YgZGF0YSkgKGZuID0gZGF0YSksIChkYXRhID0gbnVsbCk7XG4gIGlmIChkYXRhKSByZXEuc2VuZChkYXRhKTtcbiAgaWYgKGZuKSByZXEuZW5kKGZuKTtcbiAgcmV0dXJuIHJlcTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ2hlY2sgaWYgYG9iamAgaXMgYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc09iamVjdChvYmopIHtcbiAgcmV0dXJuIG51bGwgIT09IG9iaiAmJiAnb2JqZWN0JyA9PT0gdHlwZW9mIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc09iamVjdDtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgb2YgbWl4ZWQtaW4gZnVuY3Rpb25zIHNoYXJlZCBiZXR3ZWVuIG5vZGUgYW5kIGNsaWVudCBjb2RlXG4gKi9cbnZhciBpc09iamVjdCA9IHJlcXVpcmUoJy4vaXMtb2JqZWN0Jyk7XG5cbi8qKlxuICogRXhwb3NlIGBSZXF1ZXN0QmFzZWAuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBSZXF1ZXN0QmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXF1ZXN0QmFzZWAuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBSZXF1ZXN0QmFzZShvYmopIHtcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XG59XG5cbi8qKlxuICogTWl4aW4gdGhlIHByb3RvdHlwZSBwcm9wZXJ0aWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIG1peGluKG9iaikge1xuICBmb3IgKHZhciBrZXkgaW4gUmVxdWVzdEJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGVba2V5XTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIENsZWFyIHByZXZpb3VzIHRpbWVvdXQuXG4gKlxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiBfY2xlYXJUaW1lb3V0KCl7XG4gIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcik7XG4gIGNsZWFyVGltZW91dCh0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lcik7XG4gIGRlbGV0ZSB0aGlzLl90aW1lcjtcbiAgZGVsZXRlIHRoaXMuX3Jlc3BvbnNlVGltZW91dFRpbWVyO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogT3ZlcnJpZGUgZGVmYXVsdCByZXNwb25zZSBib2R5IHBhcnNlclxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgdG8gY29udmVydCBpbmNvbWluZyBkYXRhIGludG8gcmVxdWVzdC5ib2R5XG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UoZm4pe1xuICB0aGlzLl9wYXJzZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBmb3JtYXQgb2YgYmluYXJ5IHJlc3BvbnNlIGJvZHkuXG4gKiBJbiBicm93c2VyIHZhbGlkIGZvcm1hdHMgYXJlICdibG9iJyBhbmQgJ2FycmF5YnVmZmVyJyxcbiAqIHdoaWNoIHJldHVybiBCbG9iIGFuZCBBcnJheUJ1ZmZlciwgcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEluIE5vZGUgYWxsIHZhbHVlcyByZXN1bHQgaW4gQnVmZmVyLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnJlc3BvbnNlVHlwZSgnYmxvYicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXNwb25zZVR5cGUgPSBmdW5jdGlvbih2YWwpe1xuICB0aGlzLl9yZXNwb25zZVR5cGUgPSB2YWw7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZSBkZWZhdWx0IHJlcXVlc3QgYm9keSBzZXJpYWxpemVyXG4gKlxuICogVGhpcyBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB0byBjb252ZXJ0IGRhdGEgc2V0IHZpYSAuc2VuZCBvciAuYXR0YWNoIGludG8gcGF5bG9hZCB0byBzZW5kXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uIHNlcmlhbGl6ZShmbil7XG4gIHRoaXMuX3NlcmlhbGl6ZXIgPSBmbjtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCB0aW1lb3V0cy5cbiAqXG4gKiAtIHJlc3BvbnNlIHRpbWVvdXQgaXMgdGltZSBiZXR3ZWVuIHNlbmRpbmcgcmVxdWVzdCBhbmQgcmVjZWl2aW5nIHRoZSBmaXJzdCBieXRlIG9mIHRoZSByZXNwb25zZS4gSW5jbHVkZXMgRE5TIGFuZCBjb25uZWN0aW9uIHRpbWUuXG4gKiAtIGRlYWRsaW5lIGlzIHRoZSB0aW1lIGZyb20gc3RhcnQgb2YgdGhlIHJlcXVlc3QgdG8gcmVjZWl2aW5nIHJlc3BvbnNlIGJvZHkgaW4gZnVsbC4gSWYgdGhlIGRlYWRsaW5lIGlzIHRvbyBzaG9ydCBsYXJnZSBmaWxlcyBtYXkgbm90IGxvYWQgYXQgYWxsIG9uIHNsb3cgY29ubmVjdGlvbnMuXG4gKlxuICogVmFsdWUgb2YgMCBvciBmYWxzZSBtZWFucyBubyB0aW1lb3V0LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfE9iamVjdH0gbXMgb3Ige3Jlc3BvbnNlLCBkZWFkbGluZX1cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uIHRpbWVvdXQob3B0aW9ucyl7XG4gIGlmICghb3B0aW9ucyB8fCAnb2JqZWN0JyAhPT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICB0aGlzLl90aW1lb3V0ID0gb3B0aW9ucztcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSAwO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZm9yKHZhciBvcHRpb24gaW4gb3B0aW9ucykge1xuICAgIHN3aXRjaChvcHRpb24pIHtcbiAgICAgIGNhc2UgJ2RlYWRsaW5lJzpcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IG9wdGlvbnMuZGVhZGxpbmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVzcG9uc2UnOlxuICAgICAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXQgPSBvcHRpb25zLnJlc3BvbnNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNvbnNvbGUud2FybihcIlVua25vd24gdGltZW91dCBvcHRpb25cIiwgb3B0aW9uKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldCBudW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHMgb24gZXJyb3IuXG4gKlxuICogRmFpbGVkIHJlcXVlc3RzIHdpbGwgYmUgcmV0cmllZCAnY291bnQnIHRpbWVzIGlmIHRpbWVvdXQgb3IgZXJyLmNvZGUgPj0gNTAwLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb3VudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2ZuXVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uIHJldHJ5KGNvdW50LCBmbil7XG4gIC8vIERlZmF1bHQgdG8gMSBpZiBubyBjb3VudCBwYXNzZWQgb3IgdHJ1ZVxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCB8fCBjb3VudCA9PT0gdHJ1ZSkgY291bnQgPSAxO1xuICBpZiAoY291bnQgPD0gMCkgY291bnQgPSAwO1xuICB0aGlzLl9tYXhSZXRyaWVzID0gY291bnQ7XG4gIHRoaXMuX3JldHJpZXMgPSAwO1xuICB0aGlzLl9yZXRyeUNhbGxiYWNrID0gZm47XG4gIHJldHVybiB0aGlzO1xufTtcblxudmFyIEVSUk9SX0NPREVTID0gW1xuICAnRUNPTk5SRVNFVCcsXG4gICdFVElNRURPVVQnLFxuICAnRUFERFJJTkZPJyxcbiAgJ0VTT0NLRVRUSU1FRE9VVCdcbl07XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgcmVxdWVzdCBzaG91bGQgYmUgcmV0cmllZC5cbiAqIChCb3Jyb3dlZCBmcm9tIHNlZ21lbnRpby9zdXBlcmFnZW50LXJldHJ5KVxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICogQHBhcmFtIHtSZXNwb25zZX0gW3Jlc11cbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX3Nob3VsZFJldHJ5ID0gZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgaWYgKCF0aGlzLl9tYXhSZXRyaWVzIHx8IHRoaXMuX3JldHJpZXMrKyA+PSB0aGlzLl9tYXhSZXRyaWVzKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0aGlzLl9yZXRyeUNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBvdmVycmlkZSA9IHRoaXMuX3JldHJ5Q2FsbGJhY2soZXJyLCByZXMpO1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmIChvdmVycmlkZSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgIC8vIHVuZGVmaW5lZCBmYWxscyBiYWNrIHRvIGRlZmF1bHRzXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICBpZiAocmVzICYmIHJlcy5zdGF0dXMgJiYgcmVzLnN0YXR1cyA+PSA1MDAgJiYgcmVzLnN0YXR1cyAhPSA1MDEpIHJldHVybiB0cnVlO1xuICBpZiAoZXJyKSB7XG4gICAgaWYgKGVyci5jb2RlICYmIH5FUlJPUl9DT0RFUy5pbmRleE9mKGVyci5jb2RlKSkgcmV0dXJuIHRydWU7XG4gICAgLy8gU3VwZXJhZ2VudCB0aW1lb3V0XG4gICAgaWYgKGVyci50aW1lb3V0ICYmIGVyci5jb2RlID09ICdFQ09OTkFCT1JURUQnKSByZXR1cm4gdHJ1ZTtcbiAgICBpZiAoZXJyLmNyb3NzRG9tYWluKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHJ5IHJlcXVlc3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fcmV0cnkgPSBmdW5jdGlvbigpIHtcblxuICB0aGlzLmNsZWFyVGltZW91dCgpO1xuXG4gIC8vIG5vZGVcbiAgaWYgKHRoaXMucmVxKSB7XG4gICAgdGhpcy5yZXEgPSBudWxsO1xuICAgIHRoaXMucmVxID0gdGhpcy5yZXF1ZXN0KCk7XG4gIH1cblxuICB0aGlzLl9hYm9ydGVkID0gZmFsc2U7XG4gIHRoaXMudGltZWRvdXQgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcy5fZW5kKCk7XG59O1xuXG4vKipcbiAqIFByb21pc2Ugc3VwcG9ydFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtyZWplY3RdXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgaWYgKCF0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodGhpcy5fZW5kQ2FsbGVkKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJXYXJuaW5nOiBzdXBlcmFnZW50IHJlcXVlc3Qgd2FzIHNlbnQgdHdpY2UsIGJlY2F1c2UgYm90aCAuZW5kKCkgYW5kIC50aGVuKCkgd2VyZSBjYWxsZWQuIE5ldmVyIGNhbGwgLmVuZCgpIGlmIHlvdSB1c2UgcHJvbWlzZXNcIik7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxmaWxsZWRQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24oaW5uZXJSZXNvbHZlLCBpbm5lclJlamVjdCkge1xuICAgICAgc2VsZi5lbmQoZnVuY3Rpb24oZXJyLCByZXMpIHtcbiAgICAgICAgaWYgKGVycikgaW5uZXJSZWplY3QoZXJyKTtcbiAgICAgICAgZWxzZSBpbm5lclJlc29sdmUocmVzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB0aGlzLl9mdWxsZmlsbGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGVbJ2NhdGNoJ10gPSBmdW5jdGlvbihjYikge1xuICByZXR1cm4gdGhpcy50aGVuKHVuZGVmaW5lZCwgY2IpO1xufTtcblxuLyoqXG4gKiBBbGxvdyBmb3IgZXh0ZW5zaW9uXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVzZSA9IGZ1bmN0aW9uIHVzZShmbikge1xuICBmbih0aGlzKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUub2sgPSBmdW5jdGlvbihjYikge1xuICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIGNiKSB0aHJvdyBFcnJvcihcIkNhbGxiYWNrIHJlcXVpcmVkXCIpO1xuICB0aGlzLl9va0NhbGxiYWNrID0gY2I7XG4gIHJldHVybiB0aGlzO1xufTtcblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl9pc1Jlc3BvbnNlT0sgPSBmdW5jdGlvbihyZXMpIHtcbiAgaWYgKCFyZXMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fb2tDYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9va0NhbGxiYWNrKHJlcyk7XG4gIH1cblxuICByZXR1cm4gcmVzLnN0YXR1cyA+PSAyMDAgJiYgcmVzLnN0YXR1cyA8IDMwMDtcbn07XG5cbi8qKlxuICogR2V0IHJlcXVlc3QgaGVhZGVyIGBmaWVsZGAuXG4gKiBDYXNlLWluc2Vuc2l0aXZlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICByZXR1cm4gdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xufTtcblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBoZWFkZXIgYGZpZWxkYCB2YWx1ZS5cbiAqIFRoaXMgaXMgYSBkZXByZWNhdGVkIGludGVybmFsIEFQSS4gVXNlIGAuZ2V0KGZpZWxkKWAgaW5zdGVhZC5cbiAqXG4gKiAoZ2V0SGVhZGVyIGlzIG5vIGxvbmdlciB1c2VkIGludGVybmFsbHkgYnkgdGhlIHN1cGVyYWdlbnQgY29kZSBiYXNlKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKiBAZGVwcmVjYXRlZFxuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5nZXRIZWFkZXIgPSBSZXF1ZXN0QmFzZS5wcm90b3R5cGUuZ2V0O1xuXG4vKipcbiAqIFNldCBoZWFkZXIgYGZpZWxkYCB0byBgdmFsYCwgb3IgbXVsdGlwbGUgZmllbGRzIHdpdGggb25lIG9iamVjdC5cbiAqIENhc2UtaW5zZW5zaXRpdmUuXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpXG4gKiAgICAgICAgLnNldCgnWC1BUEktS2V5JywgJ2Zvb2JhcicpXG4gKiAgICAgICAgLmVuZChjYWxsYmFjayk7XG4gKlxuICogICAgICByZXEuZ2V0KCcvJylcbiAqICAgICAgICAuc2V0KHsgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsICdYLUFQSS1LZXknOiAnZm9vYmFyJyB9KVxuICogICAgICAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZmllbGRcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWxcbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oZmllbGQsIHZhbCl7XG4gIGlmIChpc09iamVjdChmaWVsZCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZmllbGQpIHtcbiAgICAgIHRoaXMuc2V0KGtleSwgZmllbGRba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHRoaXMuX2hlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXSA9IHZhbDtcbiAgdGhpcy5oZWFkZXJbZmllbGRdID0gdmFsO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGhlYWRlciBgZmllbGRgLlxuICogQ2FzZS1pbnNlbnNpdGl2ZS5cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAgcmVxLmdldCgnLycpXG4gKiAgICAgICAgLnVuc2V0KCdVc2VyLUFnZW50JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKTtcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZmllbGRcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLnVuc2V0ID0gZnVuY3Rpb24oZmllbGQpe1xuICBkZWxldGUgdGhpcy5faGVhZGVyW2ZpZWxkLnRvTG93ZXJDYXNlKCldO1xuICBkZWxldGUgdGhpcy5oZWFkZXJbZmllbGRdO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogV3JpdGUgdGhlIGZpZWxkIGBuYW1lYCBhbmQgYHZhbGAsIG9yIG11bHRpcGxlIGZpZWxkcyB3aXRoIG9uZSBvYmplY3RcbiAqIGZvciBcIm11bHRpcGFydC9mb3JtLWRhdGFcIiByZXF1ZXN0IGJvZGllcy5cbiAqXG4gKiBgYGAganNcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCgnZm9vJywgJ2JhcicpXG4gKiAgIC5lbmQoY2FsbGJhY2spO1xuICpcbiAqIHJlcXVlc3QucG9zdCgnL3VwbG9hZCcpXG4gKiAgIC5maWVsZCh7IGZvbzogJ2JhcicsIGJhejogJ3F1eCcgfSlcbiAqICAgLmVuZChjYWxsYmFjayk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IG5hbWVcbiAqIEBwYXJhbSB7U3RyaW5nfEJsb2J8RmlsZXxCdWZmZXJ8ZnMuUmVhZFN0cmVhbX0gdmFsXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fSBmb3IgY2hhaW5pbmdcbiAqIEBhcGkgcHVibGljXG4gKi9cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5maWVsZCA9IGZ1bmN0aW9uKG5hbWUsIHZhbCkge1xuICAvLyBuYW1lIHNob3VsZCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYW4gb2JqZWN0LlxuICBpZiAobnVsbCA9PT0gbmFtZSB8fCB1bmRlZmluZWQgPT09IG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJy5maWVsZChuYW1lLCB2YWwpIG5hbWUgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG5cbiAgaWYgKHRoaXMuX2RhdGEpIHtcbiAgICBjb25zb2xlLmVycm9yKFwiLmZpZWxkKCkgY2FuJ3QgYmUgdXNlZCBpZiAuc2VuZCgpIGlzIHVzZWQuIFBsZWFzZSB1c2Ugb25seSAuc2VuZCgpIG9yIG9ubHkgLmZpZWxkKCkgJiAuYXR0YWNoKClcIik7XG4gIH1cblxuICBpZiAoaXNPYmplY3QobmFtZSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuICAgICAgdGhpcy5maWVsZChrZXksIG5hbWVba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgIGZvciAodmFyIGkgaW4gdmFsKSB7XG4gICAgICB0aGlzLmZpZWxkKG5hbWUsIHZhbFtpXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdmFsIHNob3VsZCBiZSBkZWZpbmVkIG5vd1xuICBpZiAobnVsbCA9PT0gdmFsIHx8IHVuZGVmaW5lZCA9PT0gdmFsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCcuZmllbGQobmFtZSwgdmFsKSB2YWwgY2FuIG5vdCBiZSBlbXB0eScpO1xuICB9XG4gIGlmICgnYm9vbGVhbicgPT09IHR5cGVvZiB2YWwpIHtcbiAgICB2YWwgPSAnJyArIHZhbDtcbiAgfVxuICB0aGlzLl9nZXRGb3JtRGF0YSgpLmFwcGVuZChuYW1lLCB2YWwpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWJvcnQgdGhlIHJlcXVlc3QsIGFuZCBjbGVhciBwb3RlbnRpYWwgdGltZW91dC5cbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0fVxuICogQGFwaSBwdWJsaWNcbiAqL1xuUmVxdWVzdEJhc2UucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICB0aGlzLl9hYm9ydGVkID0gdHJ1ZTtcbiAgdGhpcy54aHIgJiYgdGhpcy54aHIuYWJvcnQoKTsgLy8gYnJvd3NlclxuICB0aGlzLnJlcSAmJiB0aGlzLnJlcS5hYm9ydCgpOyAvLyBub2RlXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XG4gIHRoaXMuZW1pdCgnYWJvcnQnKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2F1dGggPSBmdW5jdGlvbih1c2VyLCBwYXNzLCBvcHRpb25zLCBiYXNlNjRFbmNvZGVyKSB7XG4gIHN3aXRjaCAob3B0aW9ucy50eXBlKSB7XG4gICAgY2FzZSAnYmFzaWMnOlxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIGJhc2U2NEVuY29kZXIodXNlciArICc6JyArIHBhc3MpKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnYXV0byc6XG4gICAgICB0aGlzLnVzZXJuYW1lID0gdXNlcjtcbiAgICAgIHRoaXMucGFzc3dvcmQgPSBwYXNzO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdiZWFyZXInOiAvLyB1c2FnZSB3b3VsZCBiZSAuYXV0aChhY2Nlc3NUb2tlbiwgeyB0eXBlOiAnYmVhcmVyJyB9KVxuICAgICAgdGhpcy5zZXQoJ0F1dGhvcml6YXRpb24nLCAnQmVhcmVyICcgKyB1c2VyKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBFbmFibGUgdHJhbnNtaXNzaW9uIG9mIGNvb2tpZXMgd2l0aCB4LWRvbWFpbiByZXF1ZXN0cy5cbiAqXG4gKiBOb3RlIHRoYXQgZm9yIHRoaXMgdG8gd29yayB0aGUgb3JpZ2luIG11c3Qgbm90IGJlXG4gKiB1c2luZyBcIkFjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpblwiIHdpdGggYSB3aWxkY2FyZCxcbiAqIGFuZCBhbHNvIG11c3Qgc2V0IFwiQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHNcIlxuICogdG8gXCJ0cnVlXCIuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUud2l0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24ob24pIHtcbiAgLy8gVGhpcyBpcyBicm93c2VyLW9ubHkgZnVuY3Rpb25hbGl0eS4gTm9kZSBzaWRlIGlzIG5vLW9wLlxuICBpZiAob24gPT0gdW5kZWZpbmVkKSBvbiA9IHRydWU7XG4gIHRoaXMuX3dpdGhDcmVkZW50aWFscyA9IG9uO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBtYXggcmVkaXJlY3RzIHRvIGBuYC4gRG9lcyBub3RpbmcgaW4gYnJvd3NlciBYSFIgaW1wbGVtZW50YXRpb24uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUucmVkaXJlY3RzID0gZnVuY3Rpb24obil7XG4gIHRoaXMuX21heFJlZGlyZWN0cyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNYXhpbXVtIHNpemUgb2YgYnVmZmVyZWQgcmVzcG9uc2UgYm9keSwgaW4gYnl0ZXMuIENvdW50cyB1bmNvbXByZXNzZWQgc2l6ZS5cbiAqIERlZmF1bHQgMjAwTUIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5cbiAqIEByZXR1cm4ge1JlcXVlc3R9IGZvciBjaGFpbmluZ1xuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUubWF4UmVzcG9uc2VTaXplID0gZnVuY3Rpb24obil7XG4gIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIG4pIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoXCJJbnZhbGlkIGFyZ3VtZW50XCIpO1xuICB9XG4gIHRoaXMuX21heFJlc3BvbnNlU2l6ZSA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0IHRvIGEgcGxhaW4gamF2YXNjcmlwdCBvYmplY3QgKG5vdCBKU09OIHN0cmluZykgb2Ygc2NhbGFyIHByb3BlcnRpZXMuXG4gKiBOb3RlIGFzIHRoaXMgbWV0aG9kIGlzIGRlc2lnbmVkIHRvIHJldHVybiBhIHVzZWZ1bCBub24tdGhpcyB2YWx1ZSxcbiAqIGl0IGNhbm5vdCBiZSBjaGFpbmVkLlxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVzY3JpYmluZyBtZXRob2QsIHVybCwgYW5kIGRhdGEgb2YgdGhpcyByZXF1ZXN0XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgIHVybDogdGhpcy51cmwsXG4gICAgZGF0YTogdGhpcy5fZGF0YSxcbiAgICBoZWFkZXJzOiB0aGlzLl9oZWFkZXIsXG4gIH07XG59O1xuXG4vKipcbiAqIFNlbmQgYGRhdGFgIGFzIHRoZSByZXF1ZXN0IGJvZHksIGRlZmF1bHRpbmcgdGhlIGAudHlwZSgpYCB0byBcImpzb25cIiB3aGVuXG4gKiBhbiBvYmplY3QgaXMgZ2l2ZW4uXG4gKlxuICogRXhhbXBsZXM6XG4gKlxuICogICAgICAgLy8gbWFudWFsIGpzb25cbiAqICAgICAgIHJlcXVlc3QucG9zdCgnL3VzZXInKVxuICogICAgICAgICAudHlwZSgnanNvbicpXG4gKiAgICAgICAgIC5zZW5kKCd7XCJuYW1lXCI6XCJ0alwifScpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gYXV0byBqc29uXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnNlbmQoeyBuYW1lOiAndGonIH0pXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gbWFudWFsIHgtd3d3LWZvcm0tdXJsZW5jb2RlZFxuICogICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgIC50eXBlKCdmb3JtJylcbiAqICAgICAgICAgLnNlbmQoJ25hbWU9dGonKVxuICogICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqICAgICAgIC8vIGF1dG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gKiAgICAgICByZXF1ZXN0LnBvc3QoJy91c2VyJylcbiAqICAgICAgICAgLnR5cGUoJ2Zvcm0nKVxuICogICAgICAgICAuc2VuZCh7IG5hbWU6ICd0aicgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0cyB0byB4LXd3dy1mb3JtLXVybGVuY29kZWRcbiAqICAgICAgcmVxdWVzdC5wb3N0KCcvdXNlcicpXG4gKiAgICAgICAgLnNlbmQoJ25hbWU9dG9iaScpXG4gKiAgICAgICAgLnNlbmQoJ3NwZWNpZXM9ZmVycmV0JylcbiAqICAgICAgICAuZW5kKGNhbGxiYWNrKVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gZGF0YVxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSl7XG4gIHZhciBpc09iaiA9IGlzT2JqZWN0KGRhdGEpO1xuICB2YXIgdHlwZSA9IHRoaXMuX2hlYWRlclsnY29udGVudC10eXBlJ107XG5cbiAgaWYgKHRoaXMuX2Zvcm1EYXRhKSB7XG4gICAgY29uc29sZS5lcnJvcihcIi5zZW5kKCkgY2FuJ3QgYmUgdXNlZCBpZiAuYXR0YWNoKCkgb3IgLmZpZWxkKCkgaXMgdXNlZC4gUGxlYXNlIHVzZSBvbmx5IC5zZW5kKCkgb3Igb25seSAuZmllbGQoKSAmIC5hdHRhY2goKVwiKTtcbiAgfVxuXG4gIGlmIChpc09iaiAmJiAhdGhpcy5fZGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0gW107XG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgICB0aGlzLl9kYXRhID0ge307XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEgJiYgdGhpcy5fZGF0YSAmJiB0aGlzLl9pc0hvc3QodGhpcy5fZGF0YSkpIHtcbiAgICB0aHJvdyBFcnJvcihcIkNhbid0IG1lcmdlIHRoZXNlIHNlbmQgY2FsbHNcIik7XG4gIH1cblxuICAvLyBtZXJnZVxuICBpZiAoaXNPYmogJiYgaXNPYmplY3QodGhpcy5fZGF0YSkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgdGhpcy5fZGF0YVtrZXldID0gZGF0YVtrZXldO1xuICAgIH1cbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PSB0eXBlb2YgZGF0YSkge1xuICAgIC8vIGRlZmF1bHQgdG8geC13d3ctZm9ybS11cmxlbmNvZGVkXG4gICAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2Zvcm0nKTtcbiAgICB0eXBlID0gdGhpcy5faGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgICBpZiAoJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcgPT0gdHlwZSkge1xuICAgICAgdGhpcy5fZGF0YSA9IHRoaXMuX2RhdGFcbiAgICAgICAgPyB0aGlzLl9kYXRhICsgJyYnICsgZGF0YVxuICAgICAgICA6IGRhdGE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2RhdGEgPSAodGhpcy5fZGF0YSB8fCAnJykgKyBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGlmICghaXNPYmogfHwgdGhpcy5faXNIb3N0KGRhdGEpKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBkZWZhdWx0IHRvIGpzb25cbiAgaWYgKCF0eXBlKSB0aGlzLnR5cGUoJ2pzb24nKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNvcnQgYHF1ZXJ5c3RyaW5nYCBieSB0aGUgc29ydCBmdW5jdGlvblxuICpcbiAqXG4gKiBFeGFtcGxlczpcbiAqXG4gKiAgICAgICAvLyBkZWZhdWx0IG9yZGVyXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeSgpXG4gKiAgICAgICAgIC5lbmQoY2FsbGJhY2spXG4gKlxuICogICAgICAgLy8gY3VzdG9taXplZCBzb3J0IGZ1bmN0aW9uXG4gKiAgICAgICByZXF1ZXN0LmdldCgnL3VzZXInKVxuICogICAgICAgICAucXVlcnkoJ25hbWU9TmljaycpXG4gKiAgICAgICAgIC5xdWVyeSgnc2VhcmNoPU1hbm55JylcbiAqICAgICAgICAgLnNvcnRRdWVyeShmdW5jdGlvbihhLCBiKXtcbiAqICAgICAgICAgICByZXR1cm4gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAqICAgICAgICAgfSlcbiAqICAgICAgICAgLmVuZChjYWxsYmFjaylcbiAqXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gc29ydFxuICogQHJldHVybiB7UmVxdWVzdH0gZm9yIGNoYWluaW5nXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5zb3J0UXVlcnkgPSBmdW5jdGlvbihzb3J0KSB7XG4gIC8vIF9zb3J0IGRlZmF1bHQgdG8gdHJ1ZSBidXQgb3RoZXJ3aXNlIGNhbiBiZSBhIGZ1bmN0aW9uIG9yIGJvb2xlYW5cbiAgdGhpcy5fc29ydCA9IHR5cGVvZiBzb3J0ID09PSAndW5kZWZpbmVkJyA/IHRydWUgOiBzb3J0O1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ29tcG9zZSBxdWVyeXN0cmluZyB0byBhcHBlbmQgdG8gcmVxLnVybFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5SZXF1ZXN0QmFzZS5wcm90b3R5cGUuX2ZpbmFsaXplUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpe1xuICB2YXIgcXVlcnkgPSB0aGlzLl9xdWVyeS5qb2luKCcmJyk7XG4gIGlmIChxdWVyeSkge1xuICAgIHRoaXMudXJsICs9ICh0aGlzLnVybC5pbmRleE9mKCc/JykgPj0gMCA/ICcmJyA6ICc/JykgKyBxdWVyeTtcbiAgfVxuICB0aGlzLl9xdWVyeS5sZW5ndGggPSAwOyAvLyBNYWtlcyB0aGUgY2FsbCBpZGVtcG90ZW50XG5cbiAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnVybC5pbmRleE9mKCc/Jyk7XG4gICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgIHZhciBxdWVyeUFyciA9IHRoaXMudXJsLnN1YnN0cmluZyhpbmRleCArIDEpLnNwbGl0KCcmJyk7XG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHRoaXMuX3NvcnQpIHtcbiAgICAgICAgcXVlcnlBcnIuc29ydCh0aGlzLl9zb3J0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXJ5QXJyLnNvcnQoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMudXJsID0gdGhpcy51cmwuc3Vic3RyaW5nKDAsIGluZGV4KSArICc/JyArIHF1ZXJ5QXJyLmpvaW4oJyYnKTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIEZvciBiYWNrd2FyZHMgY29tcGF0IG9ubHlcblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fYXBwZW5kUXVlcnlTdHJpbmcgPSBmdW5jdGlvbigpIHtjb25zb2xlLnRyYWNlKFwiVW5zdXBwb3J0ZWRcIik7fVxuXG4vKipcbiAqIEludm9rZSBjYWxsYmFjayB3aXRoIHRpbWVvdXQgZXJyb3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuUmVxdWVzdEJhc2UucHJvdG90eXBlLl90aW1lb3V0RXJyb3IgPSBmdW5jdGlvbihyZWFzb24sIHRpbWVvdXQsIGVycm5vKXtcbiAgaWYgKHRoaXMuX2Fib3J0ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIGVyciA9IG5ldyBFcnJvcihyZWFzb24gKyB0aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyk7XG4gIGVyci50aW1lb3V0ID0gdGltZW91dDtcbiAgZXJyLmNvZGUgPSAnRUNPTk5BQk9SVEVEJztcbiAgZXJyLmVycm5vID0gZXJybm87XG4gIHRoaXMudGltZWRvdXQgPSB0cnVlO1xuICB0aGlzLmFib3J0KCk7XG4gIHRoaXMuY2FsbGJhY2soZXJyKTtcbn07XG5cblJlcXVlc3RCYXNlLnByb3RvdHlwZS5fc2V0VGltZW91dHMgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gIC8vIGRlYWRsaW5lXG4gIGlmICh0aGlzLl90aW1lb3V0ICYmICF0aGlzLl90aW1lcikge1xuICAgIHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgc2VsZi5fdGltZW91dEVycm9yKCdUaW1lb3V0IG9mICcsIHNlbGYuX3RpbWVvdXQsICdFVElNRScpO1xuICAgIH0sIHRoaXMuX3RpbWVvdXQpO1xuICB9XG4gIC8vIHJlc3BvbnNlIHRpbWVvdXRcbiAgaWYgKHRoaXMuX3Jlc3BvbnNlVGltZW91dCAmJiAhdGhpcy5fcmVzcG9uc2VUaW1lb3V0VGltZXIpIHtcbiAgICB0aGlzLl9yZXNwb25zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHNlbGYuX3RpbWVvdXRFcnJvcignUmVzcG9uc2UgdGltZW91dCBvZiAnLCBzZWxmLl9yZXNwb25zZVRpbWVvdXQsICdFVElNRURPVVQnKTtcbiAgICB9LCB0aGlzLl9yZXNwb25zZVRpbWVvdXQpO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xuXG4vKipcbiAqIEV4cG9zZSBgUmVzcG9uc2VCYXNlYC5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlc3BvbnNlQmFzZTtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSZXNwb25zZUJhc2VgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gUmVzcG9uc2VCYXNlKG9iaikge1xuICBpZiAob2JqKSByZXR1cm4gbWl4aW4ob2JqKTtcbn1cblxuLyoqXG4gKiBNaXhpbiB0aGUgcHJvdG90eXBlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9ialxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbWl4aW4ob2JqKSB7XG4gIGZvciAodmFyIGtleSBpbiBSZXNwb25zZUJhc2UucHJvdG90eXBlKSB7XG4gICAgb2JqW2tleV0gPSBSZXNwb25zZUJhc2UucHJvdG90eXBlW2tleV07XG4gIH1cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBHZXQgY2FzZS1pbnNlbnNpdGl2ZSBgZmllbGRgIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBmaWVsZFxuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiB0aGlzLmhlYWRlcltmaWVsZC50b0xvd2VyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogU2V0IGhlYWRlciByZWxhdGVkIHByb3BlcnRpZXM6XG4gKlxuICogICAtIGAudHlwZWAgdGhlIGNvbnRlbnQgdHlwZSB3aXRob3V0IHBhcmFtc1xuICpcbiAqIEEgcmVzcG9uc2Ugb2YgXCJDb250ZW50LVR5cGU6IHRleHQvcGxhaW47IGNoYXJzZXQ9dXRmLThcIlxuICogd2lsbCBwcm92aWRlIHlvdSB3aXRoIGEgYC50eXBlYCBvZiBcInRleHQvcGxhaW5cIi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaGVhZGVyXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRIZWFkZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24oaGVhZGVyKXtcbiAgICAvLyBUT0RPOiBtb2FyIVxuICAgIC8vIFRPRE86IG1ha2UgdGhpcyBhIHV0aWxcblxuICAgIC8vIGNvbnRlbnQtdHlwZVxuICAgIHZhciBjdCA9IGhlYWRlclsnY29udGVudC10eXBlJ10gfHwgJyc7XG4gICAgdGhpcy50eXBlID0gdXRpbHMudHlwZShjdCk7XG5cbiAgICAvLyBwYXJhbXNcbiAgICB2YXIgcGFyYW1zID0gdXRpbHMucGFyYW1zKGN0KTtcbiAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKSB0aGlzW2tleV0gPSBwYXJhbXNba2V5XTtcblxuICAgIHRoaXMubGlua3MgPSB7fTtcblxuICAgIC8vIGxpbmtzXG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGhlYWRlci5saW5rKSB7XG4gICAgICAgICAgICB0aGlzLmxpbmtzID0gdXRpbHMucGFyc2VMaW5rcyhoZWFkZXIubGluayk7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy8gaWdub3JlXG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXQgZmxhZ3Mgc3VjaCBhcyBgLm9rYCBiYXNlZCBvbiBgc3RhdHVzYC5cbiAqXG4gKiBGb3IgZXhhbXBsZSBhIDJ4eCByZXNwb25zZSB3aWxsIGdpdmUgeW91IGEgYC5va2Agb2YgX190cnVlX19cbiAqIHdoZXJlYXMgNXh4IHdpbGwgYmUgX19mYWxzZV9fIGFuZCBgLmVycm9yYCB3aWxsIGJlIF9fdHJ1ZV9fLiBUaGVcbiAqIGAuY2xpZW50RXJyb3JgIGFuZCBgLnNlcnZlckVycm9yYCBhcmUgYWxzbyBhdmFpbGFibGUgdG8gYmUgbW9yZVxuICogc3BlY2lmaWMsIGFuZCBgLnN0YXR1c1R5cGVgIGlzIHRoZSBjbGFzcyBvZiBlcnJvciByYW5naW5nIGZyb20gMS4uNVxuICogc29tZXRpbWVzIHVzZWZ1bCBmb3IgbWFwcGluZyByZXNwb25kIGNvbG9ycyBldGMuXG4gKlxuICogXCJzdWdhclwiIHByb3BlcnRpZXMgYXJlIGFsc28gZGVmaW5lZCBmb3IgY29tbW9uIGNhc2VzLiBDdXJyZW50bHkgcHJvdmlkaW5nOlxuICpcbiAqICAgLSAubm9Db250ZW50XG4gKiAgIC0gLmJhZFJlcXVlc3RcbiAqICAgLSAudW5hdXRob3JpemVkXG4gKiAgIC0gLm5vdEFjY2VwdGFibGVcbiAqICAgLSAubm90Rm91bmRcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3RhdHVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5SZXNwb25zZUJhc2UucHJvdG90eXBlLl9zZXRTdGF0dXNQcm9wZXJ0aWVzID0gZnVuY3Rpb24oc3RhdHVzKXtcbiAgICB2YXIgdHlwZSA9IHN0YXR1cyAvIDEwMCB8IDA7XG5cbiAgICAvLyBzdGF0dXMgLyBjbGFzc1xuICAgIHRoaXMuc3RhdHVzID0gdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzO1xuICAgIHRoaXMuc3RhdHVzVHlwZSA9IHR5cGU7XG5cbiAgICAvLyBiYXNpY3NcbiAgICB0aGlzLmluZm8gPSAxID09IHR5cGU7XG4gICAgdGhpcy5vayA9IDIgPT0gdHlwZTtcbiAgICB0aGlzLnJlZGlyZWN0ID0gMyA9PSB0eXBlO1xuICAgIHRoaXMuY2xpZW50RXJyb3IgPSA0ID09IHR5cGU7XG4gICAgdGhpcy5zZXJ2ZXJFcnJvciA9IDUgPT0gdHlwZTtcbiAgICB0aGlzLmVycm9yID0gKDQgPT0gdHlwZSB8fCA1ID09IHR5cGUpXG4gICAgICAgID8gdGhpcy50b0Vycm9yKClcbiAgICAgICAgOiBmYWxzZTtcblxuICAgIC8vIHN1Z2FyXG4gICAgdGhpcy5jcmVhdGVkID0gMjAxID09IHN0YXR1cztcbiAgICB0aGlzLmFjY2VwdGVkID0gMjAyID09IHN0YXR1cztcbiAgICB0aGlzLm5vQ29udGVudCA9IDIwNCA9PSBzdGF0dXM7XG4gICAgdGhpcy5iYWRSZXF1ZXN0ID0gNDAwID09IHN0YXR1cztcbiAgICB0aGlzLnVuYXV0aG9yaXplZCA9IDQwMSA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub3RBY2NlcHRhYmxlID0gNDA2ID09IHN0YXR1cztcbiAgICB0aGlzLmZvcmJpZGRlbiA9IDQwMyA9PSBzdGF0dXM7XG4gICAgdGhpcy5ub3RGb3VuZCA9IDQwNCA9PSBzdGF0dXM7XG4gICAgdGhpcy51bnByb2Nlc3NhYmxlRW50aXR5ID0gNDIyID09IHN0YXR1cztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBtaW1lIHR5cGUgZm9yIHRoZSBnaXZlbiBgc3RyYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnR5cGUgPSBmdW5jdGlvbihzdHIpe1xuICByZXR1cm4gc3RyLnNwbGl0KC8gKjsgKi8pLnNoaWZ0KCk7XG59O1xuXG4vKipcbiAqIFJldHVybiBoZWFkZXIgZmllbGQgcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5leHBvcnRzLnBhcmFtcyA9IGZ1bmN0aW9uKHN0cil7XG4gIHJldHVybiBzdHIuc3BsaXQoLyAqOyAqLykucmVkdWNlKGZ1bmN0aW9uKG9iaiwgc3RyKXtcbiAgICB2YXIgcGFydHMgPSBzdHIuc3BsaXQoLyAqPSAqLyk7XG4gICAgdmFyIGtleSA9IHBhcnRzLnNoaWZ0KCk7XG4gICAgdmFyIHZhbCA9IHBhcnRzLnNoaWZ0KCk7XG5cbiAgICBpZiAoa2V5ICYmIHZhbCkgb2JqW2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBQYXJzZSBMaW5rIGhlYWRlciBmaWVsZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZXhwb3J0cy5wYXJzZUxpbmtzID0gZnVuY3Rpb24oc3RyKXtcbiAgcmV0dXJuIHN0ci5zcGxpdCgvICosICovKS5yZWR1Y2UoZnVuY3Rpb24ob2JqLCBzdHIpe1xuICAgIHZhciBwYXJ0cyA9IHN0ci5zcGxpdCgvICo7ICovKTtcbiAgICB2YXIgdXJsID0gcGFydHNbMF0uc2xpY2UoMSwgLTEpO1xuICAgIHZhciByZWwgPSBwYXJ0c1sxXS5zcGxpdCgvICo9ICovKVsxXS5zbGljZSgxLCAtMSk7XG4gICAgb2JqW3JlbF0gPSB1cmw7XG4gICAgcmV0dXJuIG9iajtcbiAgfSwge30pO1xufTtcblxuLyoqXG4gKiBTdHJpcCBjb250ZW50IHJlbGF0ZWQgZmllbGRzIGZyb20gYGhlYWRlcmAuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBoZWFkZXJcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmV4cG9ydHMuY2xlYW5IZWFkZXIgPSBmdW5jdGlvbihoZWFkZXIsIGNoYW5nZXNPcmlnaW4pe1xuICBkZWxldGUgaGVhZGVyWydjb250ZW50LXR5cGUnXTtcbiAgZGVsZXRlIGhlYWRlclsnY29udGVudC1sZW5ndGgnXTtcbiAgZGVsZXRlIGhlYWRlclsndHJhbnNmZXItZW5jb2RpbmcnXTtcbiAgZGVsZXRlIGhlYWRlclsnaG9zdCddO1xuICAvLyBzZWN1aXJ0eVxuICBpZiAoY2hhbmdlc09yaWdpbikge1xuICAgIGRlbGV0ZSBoZWFkZXJbJ2F1dGhvcml6YXRpb24nXTtcbiAgICBkZWxldGUgaGVhZGVyWydjb29raWUnXTtcbiAgfVxuICByZXR1cm4gaGVhZGVyO1xufTtcbiIsInZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcbiIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmICghbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRtb2R1bGUud2VicGFja1BvbHlmaWxsID0gMTtcblx0fVxuXHRyZXR1cm4gbW9kdWxlO1xufTtcbiIsImZ1bmN0aW9uIERPTVBhcnNlcihvcHRpb25zKXtcclxuXHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8e2xvY2F0b3I6e319O1xyXG5cdFxyXG59XHJcbkRPTVBhcnNlci5wcm90b3R5cGUucGFyc2VGcm9tU3RyaW5nID0gZnVuY3Rpb24oc291cmNlLG1pbWVUeXBlKXtcclxuXHR2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHR2YXIgc2F4ID0gIG5ldyBYTUxSZWFkZXIoKTtcclxuXHR2YXIgZG9tQnVpbGRlciA9IG9wdGlvbnMuZG9tQnVpbGRlciB8fCBuZXcgRE9NSGFuZGxlcigpOy8vY29udGVudEhhbmRsZXIgYW5kIExleGljYWxIYW5kbGVyXHJcblx0dmFyIGVycm9ySGFuZGxlciA9IG9wdGlvbnMuZXJyb3JIYW5kbGVyO1xyXG5cdHZhciBsb2NhdG9yID0gb3B0aW9ucy5sb2NhdG9yO1xyXG5cdHZhciBkZWZhdWx0TlNNYXAgPSBvcHRpb25zLnhtbG5zfHx7fTtcclxuXHR2YXIgZW50aXR5TWFwID0geydsdCc6JzwnLCdndCc6Jz4nLCdhbXAnOicmJywncXVvdCc6J1wiJywnYXBvcyc6XCInXCJ9XHJcblx0aWYobG9jYXRvcil7XHJcblx0XHRkb21CdWlsZGVyLnNldERvY3VtZW50TG9jYXRvcihsb2NhdG9yKVxyXG5cdH1cclxuXHRcclxuXHRzYXguZXJyb3JIYW5kbGVyID0gYnVpbGRFcnJvckhhbmRsZXIoZXJyb3JIYW5kbGVyLGRvbUJ1aWxkZXIsbG9jYXRvcik7XHJcblx0c2F4LmRvbUJ1aWxkZXIgPSBvcHRpb25zLmRvbUJ1aWxkZXIgfHwgZG9tQnVpbGRlcjtcclxuXHRpZigvXFwveD9odG1sPyQvLnRlc3QobWltZVR5cGUpKXtcclxuXHRcdGVudGl0eU1hcC5uYnNwID0gJ1xceGEwJztcclxuXHRcdGVudGl0eU1hcC5jb3B5ID0gJ1xceGE5JztcclxuXHRcdGRlZmF1bHROU01hcFsnJ109ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcclxuXHR9XHJcblx0ZGVmYXVsdE5TTWFwLnhtbCA9IGRlZmF1bHROU01hcC54bWwgfHwgJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSc7XHJcblx0aWYoc291cmNlKXtcclxuXHRcdHNheC5wYXJzZShzb3VyY2UsZGVmYXVsdE5TTWFwLGVudGl0eU1hcCk7XHJcblx0fWVsc2V7XHJcblx0XHRzYXguZXJyb3JIYW5kbGVyLmVycm9yKFwiaW52YWxpZCBkb2Mgc291cmNlXCIpO1xyXG5cdH1cclxuXHRyZXR1cm4gZG9tQnVpbGRlci5kb2M7XHJcbn1cclxuZnVuY3Rpb24gYnVpbGRFcnJvckhhbmRsZXIoZXJyb3JJbXBsLGRvbUJ1aWxkZXIsbG9jYXRvcil7XHJcblx0aWYoIWVycm9ySW1wbCl7XHJcblx0XHRpZihkb21CdWlsZGVyIGluc3RhbmNlb2YgRE9NSGFuZGxlcil7XHJcblx0XHRcdHJldHVybiBkb21CdWlsZGVyO1xyXG5cdFx0fVxyXG5cdFx0ZXJyb3JJbXBsID0gZG9tQnVpbGRlciA7XHJcblx0fVxyXG5cdHZhciBlcnJvckhhbmRsZXIgPSB7fVxyXG5cdHZhciBpc0NhbGxiYWNrID0gZXJyb3JJbXBsIGluc3RhbmNlb2YgRnVuY3Rpb247XHJcblx0bG9jYXRvciA9IGxvY2F0b3J8fHt9XHJcblx0ZnVuY3Rpb24gYnVpbGQoa2V5KXtcclxuXHRcdHZhciBmbiA9IGVycm9ySW1wbFtrZXldO1xyXG5cdFx0aWYoIWZuICYmIGlzQ2FsbGJhY2spe1xyXG5cdFx0XHRmbiA9IGVycm9ySW1wbC5sZW5ndGggPT0gMj9mdW5jdGlvbihtc2cpe2Vycm9ySW1wbChrZXksbXNnKX06ZXJyb3JJbXBsO1xyXG5cdFx0fVxyXG5cdFx0ZXJyb3JIYW5kbGVyW2tleV0gPSBmbiAmJiBmdW5jdGlvbihtc2cpe1xyXG5cdFx0XHRmbignW3htbGRvbSAnK2tleSsnXVxcdCcrbXNnK19sb2NhdG9yKGxvY2F0b3IpKTtcclxuXHRcdH18fGZ1bmN0aW9uKCl7fTtcclxuXHR9XHJcblx0YnVpbGQoJ3dhcm5pbmcnKTtcclxuXHRidWlsZCgnZXJyb3InKTtcclxuXHRidWlsZCgnZmF0YWxFcnJvcicpO1xyXG5cdHJldHVybiBlcnJvckhhbmRsZXI7XHJcbn1cclxuXHJcbi8vY29uc29sZS5sb2coJyNcXG5cXG5cXG5cXG5cXG5cXG5cXG4jIyMjJylcclxuLyoqXHJcbiAqICtDb250ZW50SGFuZGxlcitFcnJvckhhbmRsZXJcclxuICogK0xleGljYWxIYW5kbGVyK0VudGl0eVJlc29sdmVyMlxyXG4gKiAtRGVjbEhhbmRsZXItRFRESGFuZGxlciBcclxuICogXHJcbiAqIERlZmF1bHRIYW5kbGVyOkVudGl0eVJlc29sdmVyLCBEVERIYW5kbGVyLCBDb250ZW50SGFuZGxlciwgRXJyb3JIYW5kbGVyXHJcbiAqIERlZmF1bHRIYW5kbGVyMjpEZWZhdWx0SGFuZGxlcixMZXhpY2FsSGFuZGxlciwgRGVjbEhhbmRsZXIsIEVudGl0eVJlc29sdmVyMlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9oZWxwZXJzL0RlZmF1bHRIYW5kbGVyLmh0bWxcclxuICovXHJcbmZ1bmN0aW9uIERPTUhhbmRsZXIoKSB7XHJcbiAgICB0aGlzLmNkYXRhID0gZmFsc2U7XHJcbn1cclxuZnVuY3Rpb24gcG9zaXRpb24obG9jYXRvcixub2RlKXtcclxuXHRub2RlLmxpbmVOdW1iZXIgPSBsb2NhdG9yLmxpbmVOdW1iZXI7XHJcblx0bm9kZS5jb2x1bW5OdW1iZXIgPSBsb2NhdG9yLmNvbHVtbk51bWJlcjtcclxufVxyXG4vKipcclxuICogQHNlZSBvcmcueG1sLnNheC5Db250ZW50SGFuZGxlciNzdGFydERvY3VtZW50XHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L0NvbnRlbnRIYW5kbGVyLmh0bWxcclxuICovIFxyXG5ET01IYW5kbGVyLnByb3RvdHlwZSA9IHtcclxuXHRzdGFydERvY3VtZW50IDogZnVuY3Rpb24oKSB7XHJcbiAgICBcdHRoaXMuZG9jID0gbmV3IERPTUltcGxlbWVudGF0aW9uKCkuY3JlYXRlRG9jdW1lbnQobnVsbCwgbnVsbCwgbnVsbCk7XHJcbiAgICBcdGlmICh0aGlzLmxvY2F0b3IpIHtcclxuICAgICAgICBcdHRoaXMuZG9jLmRvY3VtZW50VVJJID0gdGhpcy5sb2NhdG9yLnN5c3RlbUlkO1xyXG4gICAgXHR9XHJcblx0fSxcclxuXHRzdGFydEVsZW1lbnQ6ZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUsIHFOYW1lLCBhdHRycykge1xyXG5cdFx0dmFyIGRvYyA9IHRoaXMuZG9jO1xyXG5cdCAgICB2YXIgZWwgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSwgcU5hbWV8fGxvY2FsTmFtZSk7XHJcblx0ICAgIHZhciBsZW4gPSBhdHRycy5sZW5ndGg7XHJcblx0ICAgIGFwcGVuZEVsZW1lbnQodGhpcywgZWwpO1xyXG5cdCAgICB0aGlzLmN1cnJlbnRFbGVtZW50ID0gZWw7XHJcblx0ICAgIFxyXG5cdFx0dGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixlbClcclxuXHQgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbGVuOyBpKyspIHtcclxuXHQgICAgICAgIHZhciBuYW1lc3BhY2VVUkkgPSBhdHRycy5nZXRVUkkoaSk7XHJcblx0ICAgICAgICB2YXIgdmFsdWUgPSBhdHRycy5nZXRWYWx1ZShpKTtcclxuXHQgICAgICAgIHZhciBxTmFtZSA9IGF0dHJzLmdldFFOYW1lKGkpO1xyXG5cdFx0XHR2YXIgYXR0ciA9IGRvYy5jcmVhdGVBdHRyaWJ1dGVOUyhuYW1lc3BhY2VVUkksIHFOYW1lKTtcclxuXHRcdFx0dGhpcy5sb2NhdG9yICYmcG9zaXRpb24oYXR0cnMuZ2V0TG9jYXRvcihpKSxhdHRyKTtcclxuXHRcdFx0YXR0ci52YWx1ZSA9IGF0dHIubm9kZVZhbHVlID0gdmFsdWU7XHJcblx0XHRcdGVsLnNldEF0dHJpYnV0ZU5vZGUoYXR0cilcclxuXHQgICAgfVxyXG5cdH0sXHJcblx0ZW5kRWxlbWVudDpmdW5jdGlvbihuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSwgcU5hbWUpIHtcclxuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50RWxlbWVudFxyXG5cdFx0dmFyIHRhZ05hbWUgPSBjdXJyZW50LnRhZ05hbWU7XHJcblx0XHR0aGlzLmN1cnJlbnRFbGVtZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xyXG5cdH0sXHJcblx0c3RhcnRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKHByZWZpeCwgdXJpKSB7XHJcblx0fSxcclxuXHRlbmRQcmVmaXhNYXBwaW5nOmZ1bmN0aW9uKHByZWZpeCkge1xyXG5cdH0sXHJcblx0cHJvY2Vzc2luZ0luc3RydWN0aW9uOmZ1bmN0aW9uKHRhcmdldCwgZGF0YSkge1xyXG5cdCAgICB2YXIgaW5zID0gdGhpcy5kb2MuY3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uKHRhcmdldCwgZGF0YSk7XHJcblx0ICAgIHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsaW5zKVxyXG5cdCAgICBhcHBlbmRFbGVtZW50KHRoaXMsIGlucyk7XHJcblx0fSxcclxuXHRpZ25vcmFibGVXaGl0ZXNwYWNlOmZ1bmN0aW9uKGNoLCBzdGFydCwgbGVuZ3RoKSB7XHJcblx0fSxcclxuXHRjaGFyYWN0ZXJzOmZ1bmN0aW9uKGNoYXJzLCBzdGFydCwgbGVuZ3RoKSB7XHJcblx0XHRjaGFycyA9IF90b1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cylcclxuXHRcdC8vY29uc29sZS5sb2coY2hhcnMpXHJcblx0XHRpZihjaGFycyl7XHJcblx0XHRcdGlmICh0aGlzLmNkYXRhKSB7XHJcblx0XHRcdFx0dmFyIGNoYXJOb2RlID0gdGhpcy5kb2MuY3JlYXRlQ0RBVEFTZWN0aW9uKGNoYXJzKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR2YXIgY2hhck5vZGUgPSB0aGlzLmRvYy5jcmVhdGVUZXh0Tm9kZShjaGFycyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYodGhpcy5jdXJyZW50RWxlbWVudCl7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChjaGFyTm9kZSk7XHJcblx0XHRcdH1lbHNlIGlmKC9eXFxzKiQvLnRlc3QoY2hhcnMpKXtcclxuXHRcdFx0XHR0aGlzLmRvYy5hcHBlbmRDaGlsZChjaGFyTm9kZSk7XHJcblx0XHRcdFx0Ly9wcm9jZXNzIHhtbFxyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMubG9jYXRvciAmJiBwb3NpdGlvbih0aGlzLmxvY2F0b3IsY2hhck5vZGUpXHJcblx0XHR9XHJcblx0fSxcclxuXHRza2lwcGVkRW50aXR5OmZ1bmN0aW9uKG5hbWUpIHtcclxuXHR9LFxyXG5cdGVuZERvY3VtZW50OmZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5kb2Mubm9ybWFsaXplKCk7XHJcblx0fSxcclxuXHRzZXREb2N1bWVudExvY2F0b3I6ZnVuY3Rpb24gKGxvY2F0b3IpIHtcclxuXHQgICAgaWYodGhpcy5sb2NhdG9yID0gbG9jYXRvcil7Ly8gJiYgISgnbGluZU51bWJlcicgaW4gbG9jYXRvcikpe1xyXG5cdCAgICBcdGxvY2F0b3IubGluZU51bWJlciA9IDA7XHJcblx0ICAgIH1cclxuXHR9LFxyXG5cdC8vTGV4aWNhbEhhbmRsZXJcclxuXHRjb21tZW50OmZ1bmN0aW9uKGNoYXJzLCBzdGFydCwgbGVuZ3RoKSB7XHJcblx0XHRjaGFycyA9IF90b1N0cmluZy5hcHBseSh0aGlzLGFyZ3VtZW50cylcclxuXHQgICAgdmFyIGNvbW0gPSB0aGlzLmRvYy5jcmVhdGVDb21tZW50KGNoYXJzKTtcclxuXHQgICAgdGhpcy5sb2NhdG9yICYmIHBvc2l0aW9uKHRoaXMubG9jYXRvcixjb21tKVxyXG5cdCAgICBhcHBlbmRFbGVtZW50KHRoaXMsIGNvbW0pO1xyXG5cdH0sXHJcblx0XHJcblx0c3RhcnRDREFUQTpmdW5jdGlvbigpIHtcclxuXHQgICAgLy91c2VkIGluIGNoYXJhY3RlcnMoKSBtZXRob2RzXHJcblx0ICAgIHRoaXMuY2RhdGEgPSB0cnVlO1xyXG5cdH0sXHJcblx0ZW5kQ0RBVEE6ZnVuY3Rpb24oKSB7XHJcblx0ICAgIHRoaXMuY2RhdGEgPSBmYWxzZTtcclxuXHR9LFxyXG5cdFxyXG5cdHN0YXJ0RFREOmZ1bmN0aW9uKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge1xyXG5cdFx0dmFyIGltcGwgPSB0aGlzLmRvYy5pbXBsZW1lbnRhdGlvbjtcclxuXHQgICAgaWYgKGltcGwgJiYgaW1wbC5jcmVhdGVEb2N1bWVudFR5cGUpIHtcclxuXHQgICAgICAgIHZhciBkdCA9IGltcGwuY3JlYXRlRG9jdW1lbnRUeXBlKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCk7XHJcblx0ICAgICAgICB0aGlzLmxvY2F0b3IgJiYgcG9zaXRpb24odGhpcy5sb2NhdG9yLGR0KVxyXG5cdCAgICAgICAgYXBwZW5kRWxlbWVudCh0aGlzLCBkdCk7XHJcblx0ICAgIH1cclxuXHR9LFxyXG5cdC8qKlxyXG5cdCAqIEBzZWUgb3JnLnhtbC5zYXguRXJyb3JIYW5kbGVyXHJcblx0ICogQGxpbmsgaHR0cDovL3d3dy5zYXhwcm9qZWN0Lm9yZy9hcGlkb2Mvb3JnL3htbC9zYXgvRXJyb3JIYW5kbGVyLmh0bWxcclxuXHQgKi9cclxuXHR3YXJuaW5nOmZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRjb25zb2xlLndhcm4oJ1t4bWxkb20gd2FybmluZ11cXHQnK2Vycm9yLF9sb2NhdG9yKHRoaXMubG9jYXRvcikpO1xyXG5cdH0sXHJcblx0ZXJyb3I6ZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoJ1t4bWxkb20gZXJyb3JdXFx0JytlcnJvcixfbG9jYXRvcih0aGlzLmxvY2F0b3IpKTtcclxuXHR9LFxyXG5cdGZhdGFsRXJyb3I6ZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdGNvbnNvbGUuZXJyb3IoJ1t4bWxkb20gZmF0YWxFcnJvcl1cXHQnK2Vycm9yLF9sb2NhdG9yKHRoaXMubG9jYXRvcikpO1xyXG5cdCAgICB0aHJvdyBlcnJvcjtcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gX2xvY2F0b3IobCl7XHJcblx0aWYobCl7XHJcblx0XHRyZXR1cm4gJ1xcbkAnKyhsLnN5c3RlbUlkIHx8JycpKycjW2xpbmU6JytsLmxpbmVOdW1iZXIrJyxjb2w6JytsLmNvbHVtbk51bWJlcisnXSdcclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gX3RvU3RyaW5nKGNoYXJzLHN0YXJ0LGxlbmd0aCl7XHJcblx0aWYodHlwZW9mIGNoYXJzID09ICdzdHJpbmcnKXtcclxuXHRcdHJldHVybiBjaGFycy5zdWJzdHIoc3RhcnQsbGVuZ3RoKVxyXG5cdH1lbHNley8vamF2YSBzYXggY29ubmVjdCB3aWR0aCB4bWxkb20gb24gcmhpbm8od2hhdCBhYm91dDogXCI/ICYmICEoY2hhcnMgaW5zdGFuY2VvZiBTdHJpbmcpXCIpXHJcblx0XHRpZihjaGFycy5sZW5ndGggPj0gc3RhcnQrbGVuZ3RoIHx8IHN0YXJ0KXtcclxuXHRcdFx0cmV0dXJuIG5ldyBqYXZhLmxhbmcuU3RyaW5nKGNoYXJzLHN0YXJ0LGxlbmd0aCkrJyc7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY2hhcnM7XHJcblx0fVxyXG59XHJcblxyXG4vKlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9leHQvTGV4aWNhbEhhbmRsZXIuaHRtbFxyXG4gKiB1c2VkIG1ldGhvZCBvZiBvcmcueG1sLnNheC5leHQuTGV4aWNhbEhhbmRsZXI6XHJcbiAqICAjY29tbWVudChjaGFycywgc3RhcnQsIGxlbmd0aClcclxuICogICNzdGFydENEQVRBKClcclxuICogICNlbmRDREFUQSgpXHJcbiAqICAjc3RhcnREVEQobmFtZSwgcHVibGljSWQsIHN5c3RlbUlkKVxyXG4gKlxyXG4gKlxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5leHQuTGV4aWNhbEhhbmRsZXI6XHJcbiAqICAjZW5kRFREKClcclxuICogICNzdGFydEVudGl0eShuYW1lKVxyXG4gKiAgI2VuZEVudGl0eShuYW1lKVxyXG4gKlxyXG4gKlxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9leHQvRGVjbEhhbmRsZXIuaHRtbFxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5leHQuRGVjbEhhbmRsZXJcclxuICogXHQjYXR0cmlidXRlRGVjbChlTmFtZSwgYU5hbWUsIHR5cGUsIG1vZGUsIHZhbHVlKVxyXG4gKiAgI2VsZW1lbnREZWNsKG5hbWUsIG1vZGVsKVxyXG4gKiAgI2V4dGVybmFsRW50aXR5RGVjbChuYW1lLCBwdWJsaWNJZCwgc3lzdGVtSWQpXHJcbiAqICAjaW50ZXJuYWxFbnRpdHlEZWNsKG5hbWUsIHZhbHVlKVxyXG4gKiBAbGluayBodHRwOi8vd3d3LnNheHByb2plY3Qub3JnL2FwaWRvYy9vcmcveG1sL3NheC9leHQvRW50aXR5UmVzb2x2ZXIyLmh0bWxcclxuICogSUdOT1JFRCBtZXRob2Qgb2Ygb3JnLnhtbC5zYXguRW50aXR5UmVzb2x2ZXIyXHJcbiAqICAjcmVzb2x2ZUVudGl0eShTdHJpbmcgbmFtZSxTdHJpbmcgcHVibGljSWQsU3RyaW5nIGJhc2VVUkksU3RyaW5nIHN5c3RlbUlkKVxyXG4gKiAgI3Jlc29sdmVFbnRpdHkocHVibGljSWQsIHN5c3RlbUlkKVxyXG4gKiAgI2dldEV4dGVybmFsU3Vic2V0KG5hbWUsIGJhc2VVUkkpXHJcbiAqIEBsaW5rIGh0dHA6Ly93d3cuc2F4cHJvamVjdC5vcmcvYXBpZG9jL29yZy94bWwvc2F4L0RUREhhbmRsZXIuaHRtbFxyXG4gKiBJR05PUkVEIG1ldGhvZCBvZiBvcmcueG1sLnNheC5EVERIYW5kbGVyXHJcbiAqICAjbm90YXRpb25EZWNsKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCkge307XHJcbiAqICAjdW5wYXJzZWRFbnRpdHlEZWNsKG5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCwgbm90YXRpb25OYW1lKSB7fTtcclxuICovXHJcblwiZW5kRFRELHN0YXJ0RW50aXR5LGVuZEVudGl0eSxhdHRyaWJ1dGVEZWNsLGVsZW1lbnREZWNsLGV4dGVybmFsRW50aXR5RGVjbCxpbnRlcm5hbEVudGl0eURlY2wscmVzb2x2ZUVudGl0eSxnZXRFeHRlcm5hbFN1YnNldCxub3RhdGlvbkRlY2wsdW5wYXJzZWRFbnRpdHlEZWNsXCIucmVwbGFjZSgvXFx3Ky9nLGZ1bmN0aW9uKGtleSl7XHJcblx0RE9NSGFuZGxlci5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uKCl7cmV0dXJuIG51bGx9XHJcbn0pXHJcblxyXG4vKiBQcml2YXRlIHN0YXRpYyBoZWxwZXJzIHRyZWF0ZWQgYmVsb3cgYXMgcHJpdmF0ZSBpbnN0YW5jZSBtZXRob2RzLCBzbyBkb24ndCBuZWVkIHRvIGFkZCB0aGVzZSB0byB0aGUgcHVibGljIEFQSTsgd2UgbWlnaHQgdXNlIGEgUmVsYXRvciB0byBhbHNvIGdldCByaWQgb2Ygbm9uLXN0YW5kYXJkIHB1YmxpYyBwcm9wZXJ0aWVzICovXHJcbmZ1bmN0aW9uIGFwcGVuZEVsZW1lbnQgKGhhbmRlcixub2RlKSB7XHJcbiAgICBpZiAoIWhhbmRlci5jdXJyZW50RWxlbWVudCkge1xyXG4gICAgICAgIGhhbmRlci5kb2MuYXBwZW5kQ2hpbGQobm9kZSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGhhbmRlci5jdXJyZW50RWxlbWVudC5hcHBlbmRDaGlsZChub2RlKTtcclxuICAgIH1cclxufS8vYXBwZW5kQ2hpbGQgYW5kIHNldEF0dHJpYnV0ZU5TIGFyZSBwcmVmb3JtYW5jZSBrZXlcclxuXHJcbi8vaWYodHlwZW9mIHJlcXVpcmUgPT0gJ2Z1bmN0aW9uJyl7XHJcblx0dmFyIFhNTFJlYWRlciA9IHJlcXVpcmUoJy4vc2F4JykuWE1MUmVhZGVyO1xyXG5cdHZhciBET01JbXBsZW1lbnRhdGlvbiA9IGV4cG9ydHMuRE9NSW1wbGVtZW50YXRpb24gPSByZXF1aXJlKCcuL2RvbScpLkRPTUltcGxlbWVudGF0aW9uO1xyXG5cdGV4cG9ydHMuWE1MU2VyaWFsaXplciA9IHJlcXVpcmUoJy4vZG9tJykuWE1MU2VyaWFsaXplciA7XHJcblx0ZXhwb3J0cy5ET01QYXJzZXIgPSBET01QYXJzZXI7XHJcbi8vfVxyXG4iLCIvKlxuICogRE9NIExldmVsIDJcbiAqIE9iamVjdCBET01FeGNlcHRpb25cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLURPTS1MZXZlbC0xL2VjbWEtc2NyaXB0LWxhbmd1YWdlLWJpbmRpbmcuaHRtbFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDAwL1JFQy1ET00tTGV2ZWwtMi1Db3JlLTIwMDAxMTEzL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGNvcHkoc3JjLGRlc3Qpe1xuXHRmb3IodmFyIHAgaW4gc3JjKXtcblx0XHRkZXN0W3BdID0gc3JjW3BdO1xuXHR9XG59XG4vKipcbl5cXHcrXFwucHJvdG90eXBlXFwuKFtfXFx3XSspXFxzKj1cXHMqKCg/Oi4qXFx7XFxzKj9bXFxyXFxuXVtcXHNcXFNdKj9efSl8XFxTLio/KD89WztcXHJcXG5dKSk7P1xuXlxcdytcXC5wcm90b3R5cGVcXC4oW19cXHddKylcXHMqPVxccyooXFxTLio/KD89WztcXHJcXG5dKSk7P1xuICovXG5mdW5jdGlvbiBfZXh0ZW5kcyhDbGFzcyxTdXBlcil7XG5cdHZhciBwdCA9IENsYXNzLnByb3RvdHlwZTtcblx0aWYoT2JqZWN0LmNyZWF0ZSl7XG5cdFx0dmFyIHBwdCA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKVxuXHRcdHB0Ll9fcHJvdG9fXyA9IHBwdDtcblx0fVxuXHRpZighKHB0IGluc3RhbmNlb2YgU3VwZXIpKXtcblx0XHRmdW5jdGlvbiB0KCl7fTtcblx0XHR0LnByb3RvdHlwZSA9IFN1cGVyLnByb3RvdHlwZTtcblx0XHR0ID0gbmV3IHQoKTtcblx0XHRjb3B5KHB0LHQpO1xuXHRcdENsYXNzLnByb3RvdHlwZSA9IHB0ID0gdDtcblx0fVxuXHRpZihwdC5jb25zdHJ1Y3RvciAhPSBDbGFzcyl7XG5cdFx0aWYodHlwZW9mIENsYXNzICE9ICdmdW5jdGlvbicpe1xuXHRcdFx0Y29uc29sZS5lcnJvcihcInVua25vdyBDbGFzczpcIitDbGFzcylcblx0XHR9XG5cdFx0cHQuY29uc3RydWN0b3IgPSBDbGFzc1xuXHR9XG59XG52YXIgaHRtbG5zID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnIDtcbi8vIE5vZGUgVHlwZXNcbnZhciBOb2RlVHlwZSA9IHt9XG52YXIgRUxFTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gTm9kZVR5cGUuRUxFTUVOVF9OT0RFICAgICAgICAgICAgICAgID0gMTtcbnZhciBBVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSBOb2RlVHlwZS5BVFRSSUJVVEVfTk9ERSAgICAgICAgICAgICAgPSAyO1xudmFyIFRFWFRfTk9ERSAgICAgICAgICAgICAgICAgICA9IE5vZGVUeXBlLlRFWFRfTk9ERSAgICAgICAgICAgICAgICAgICA9IDM7XG52YXIgQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gTm9kZVR5cGUuQ0RBVEFfU0VDVElPTl9OT0RFICAgICAgICAgID0gNDtcbnZhciBFTlRJVFlfUkVGRVJFTkNFX05PREUgICAgICAgPSBOb2RlVHlwZS5FTlRJVFlfUkVGRVJFTkNFX05PREUgICAgICAgPSA1O1xudmFyIEVOVElUWV9OT0RFICAgICAgICAgICAgICAgICA9IE5vZGVUeXBlLkVOVElUWV9OT0RFICAgICAgICAgICAgICAgICA9IDY7XG52YXIgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gTm9kZVR5cGUuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gNztcbnZhciBDT01NRU5UX05PREUgICAgICAgICAgICAgICAgPSBOb2RlVHlwZS5DT01NRU5UX05PREUgICAgICAgICAgICAgICAgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IE5vZGVUeXBlLkRPQ1VNRU5UX05PREUgICAgICAgICAgICAgICA9IDk7XG52YXIgRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gTm9kZVR5cGUuRE9DVU1FTlRfVFlQRV9OT0RFICAgICAgICAgID0gMTA7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAgICAgID0gTm9kZVR5cGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAgICAgID0gMTE7XG52YXIgTk9UQVRJT05fTk9ERSAgICAgICAgICAgICAgID0gTm9kZVR5cGUuTk9UQVRJT05fTk9ERSAgICAgICAgICAgICAgID0gMTI7XG5cbi8vIEV4Y2VwdGlvbkNvZGVcbnZhciBFeGNlcHRpb25Db2RlID0ge31cbnZhciBFeGNlcHRpb25NZXNzYWdlID0ge307XG52YXIgSU5ERVhfU0laRV9FUlIgICAgICAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5JTkRFWF9TSVpFX0VSUiAgICAgICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMV09XCJJbmRleCBzaXplIGVycm9yXCIpLDEpO1xudmFyIERPTVNUUklOR19TSVpFX0VSUiAgICAgICAgICA9IEV4Y2VwdGlvbkNvZGUuRE9NU1RSSU5HX1NJWkVfRVJSICAgICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzJdPVwiRE9NU3RyaW5nIHNpemUgZXJyb3JcIiksMik7XG52YXIgSElFUkFSQ0hZX1JFUVVFU1RfRVJSICAgICAgID0gRXhjZXB0aW9uQ29kZS5ISUVSQVJDSFlfUkVRVUVTVF9FUlIgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbM109XCJIaWVyYXJjaHkgcmVxdWVzdCBlcnJvclwiKSwzKTtcbnZhciBXUk9OR19ET0NVTUVOVF9FUlIgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLldST05HX0RPQ1VNRU5UX0VSUiAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs0XT1cIldyb25nIGRvY3VtZW50XCIpLDQpO1xudmFyIElOVkFMSURfQ0hBUkFDVEVSX0VSUiAgICAgICA9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9DSEFSQUNURVJfRVJSICAgICAgID0gKChFeGNlcHRpb25NZXNzYWdlWzVdPVwiSW52YWxpZCBjaGFyYWN0ZXJcIiksNSk7XG52YXIgTk9fREFUQV9BTExPV0VEX0VSUiAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5OT19EQVRBX0FMTE9XRURfRVJSICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbNl09XCJObyBkYXRhIGFsbG93ZWRcIiksNik7XG52YXIgTk9fTU9ESUZJQ0FUSU9OX0FMTE9XRURfRVJSID0gRXhjZXB0aW9uQ29kZS5OT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlIgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbN109XCJObyBtb2RpZmljYXRpb24gYWxsb3dlZFwiKSw3KTtcbnZhciBOT1RfRk9VTkRfRVJSICAgICAgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLk5PVF9GT1VORF9FUlIgICAgICAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs4XT1cIk5vdCBmb3VuZFwiKSw4KTtcbnZhciBOT1RfU1VQUE9SVEVEX0VSUiAgICAgICAgICAgPSBFeGNlcHRpb25Db2RlLk5PVF9TVVBQT1JURURfRVJSICAgICAgICAgICA9ICgoRXhjZXB0aW9uTWVzc2FnZVs5XT1cIk5vdCBzdXBwb3J0ZWRcIiksOSk7XG52YXIgSU5VU0VfQVRUUklCVVRFX0VSUiAgICAgICAgID0gRXhjZXB0aW9uQ29kZS5JTlVTRV9BVFRSSUJVVEVfRVJSICAgICAgICAgPSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTBdPVwiQXR0cmlidXRlIGluIHVzZVwiKSwxMCk7XG4vL2xldmVsMlxudmFyIElOVkFMSURfU1RBVEVfRVJSICAgICAgICBcdD0gRXhjZXB0aW9uQ29kZS5JTlZBTElEX1NUQVRFX0VSUiAgICAgICAgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxMV09XCJJbnZhbGlkIHN0YXRlXCIpLDExKTtcbnZhciBTWU5UQVhfRVJSICAgICAgICAgICAgICAgXHQ9IEV4Y2VwdGlvbkNvZGUuU1lOVEFYX0VSUiAgICAgICAgICAgICAgIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTJdPVwiU3ludGF4IGVycm9yXCIpLDEyKTtcbnZhciBJTlZBTElEX01PRElGSUNBVElPTl9FUlIgXHQ9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9NT0RJRklDQVRJT05fRVJSIFx0PSAoKEV4Y2VwdGlvbk1lc3NhZ2VbMTNdPVwiSW52YWxpZCBtb2RpZmljYXRpb25cIiksMTMpO1xudmFyIE5BTUVTUEFDRV9FUlIgICAgICAgICAgICBcdD0gRXhjZXB0aW9uQ29kZS5OQU1FU1BBQ0VfRVJSICAgICAgICAgICBcdD0gKChFeGNlcHRpb25NZXNzYWdlWzE0XT1cIkludmFsaWQgbmFtZXNwYWNlXCIpLDE0KTtcbnZhciBJTlZBTElEX0FDQ0VTU19FUlIgICAgICAgXHQ9IEV4Y2VwdGlvbkNvZGUuSU5WQUxJRF9BQ0NFU1NfRVJSICAgICAgXHQ9ICgoRXhjZXB0aW9uTWVzc2FnZVsxNV09XCJJbnZhbGlkIGFjY2Vzc1wiKSwxNSk7XG5cblxuZnVuY3Rpb24gRE9NRXhjZXB0aW9uKGNvZGUsIG1lc3NhZ2UpIHtcblx0aWYobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKXtcblx0XHR2YXIgZXJyb3IgPSBtZXNzYWdlO1xuXHR9ZWxzZXtcblx0XHRlcnJvciA9IHRoaXM7XG5cdFx0RXJyb3IuY2FsbCh0aGlzLCBFeGNlcHRpb25NZXNzYWdlW2NvZGVdKTtcblx0XHR0aGlzLm1lc3NhZ2UgPSBFeGNlcHRpb25NZXNzYWdlW2NvZGVdO1xuXHRcdGlmKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBET01FeGNlcHRpb24pO1xuXHR9XG5cdGVycm9yLmNvZGUgPSBjb2RlO1xuXHRpZihtZXNzYWdlKSB0aGlzLm1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2UgKyBcIjogXCIgKyBtZXNzYWdlO1xuXHRyZXR1cm4gZXJyb3I7XG59O1xuRE9NRXhjZXB0aW9uLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcbmNvcHkoRXhjZXB0aW9uQ29kZSxET01FeGNlcHRpb24pXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItQ29yZS0yMDAwMTExMy9jb3JlLmh0bWwjSUQtNTM2Mjk3MTc3XG4gKiBUaGUgTm9kZUxpc3QgaW50ZXJmYWNlIHByb3ZpZGVzIHRoZSBhYnN0cmFjdGlvbiBvZiBhbiBvcmRlcmVkIGNvbGxlY3Rpb24gb2Ygbm9kZXMsIHdpdGhvdXQgZGVmaW5pbmcgb3IgY29uc3RyYWluaW5nIGhvdyB0aGlzIGNvbGxlY3Rpb24gaXMgaW1wbGVtZW50ZWQuIE5vZGVMaXN0IG9iamVjdHMgaW4gdGhlIERPTSBhcmUgbGl2ZS5cbiAqIFRoZSBpdGVtcyBpbiB0aGUgTm9kZUxpc3QgYXJlIGFjY2Vzc2libGUgdmlhIGFuIGludGVncmFsIGluZGV4LCBzdGFydGluZyBmcm9tIDAuXG4gKi9cbmZ1bmN0aW9uIE5vZGVMaXN0KCkge1xufTtcbk5vZGVMaXN0LnByb3RvdHlwZSA9IHtcblx0LyoqXG5cdCAqIFRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGxpc3QuIFRoZSByYW5nZSBvZiB2YWxpZCBjaGlsZCBub2RlIGluZGljZXMgaXMgMCB0byBsZW5ndGgtMSBpbmNsdXNpdmUuXG5cdCAqIEBzdGFuZGFyZCBsZXZlbDFcblx0ICovXG5cdGxlbmd0aDowLCBcblx0LyoqXG5cdCAqIFJldHVybnMgdGhlIGluZGV4dGggaXRlbSBpbiB0aGUgY29sbGVjdGlvbi4gSWYgaW5kZXggaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSBudW1iZXIgb2Ygbm9kZXMgaW4gdGhlIGxpc3QsIHRoaXMgcmV0dXJucyBudWxsLlxuXHQgKiBAc3RhbmRhcmQgbGV2ZWwxXG5cdCAqIEBwYXJhbSBpbmRleCAgdW5zaWduZWQgbG9uZyBcblx0ICogICBJbmRleCBpbnRvIHRoZSBjb2xsZWN0aW9uLlxuXHQgKiBAcmV0dXJuIE5vZGVcblx0ICogXHRUaGUgbm9kZSBhdCB0aGUgaW5kZXh0aCBwb3NpdGlvbiBpbiB0aGUgTm9kZUxpc3QsIG9yIG51bGwgaWYgdGhhdCBpcyBub3QgYSB2YWxpZCBpbmRleC4gXG5cdCAqL1xuXHRpdGVtOiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzW2luZGV4XSB8fCBudWxsO1xuXHR9LFxuXHR0b1N0cmluZzpmdW5jdGlvbihpc0hUTUwsbm9kZUZpbHRlcil7XG5cdFx0Zm9yKHZhciBidWYgPSBbXSwgaSA9IDA7aTx0aGlzLmxlbmd0aDtpKyspe1xuXHRcdFx0c2VyaWFsaXplVG9TdHJpbmcodGhpc1tpXSxidWYsaXNIVE1MLG5vZGVGaWx0ZXIpO1xuXHRcdH1cblx0XHRyZXR1cm4gYnVmLmpvaW4oJycpO1xuXHR9XG59O1xuZnVuY3Rpb24gTGl2ZU5vZGVMaXN0KG5vZGUscmVmcmVzaCl7XG5cdHRoaXMuX25vZGUgPSBub2RlO1xuXHR0aGlzLl9yZWZyZXNoID0gcmVmcmVzaFxuXHRfdXBkYXRlTGl2ZUxpc3QodGhpcyk7XG59XG5mdW5jdGlvbiBfdXBkYXRlTGl2ZUxpc3QobGlzdCl7XG5cdHZhciBpbmMgPSBsaXN0Ll9ub2RlLl9pbmMgfHwgbGlzdC5fbm9kZS5vd25lckRvY3VtZW50Ll9pbmM7XG5cdGlmKGxpc3QuX2luYyAhPSBpbmMpe1xuXHRcdHZhciBscyA9IGxpc3QuX3JlZnJlc2gobGlzdC5fbm9kZSk7XG5cdFx0Ly9jb25zb2xlLmxvZyhscy5sZW5ndGgpXG5cdFx0X19zZXRfXyhsaXN0LCdsZW5ndGgnLGxzLmxlbmd0aCk7XG5cdFx0Y29weShscyxsaXN0KTtcblx0XHRsaXN0Ll9pbmMgPSBpbmM7XG5cdH1cbn1cbkxpdmVOb2RlTGlzdC5wcm90b3R5cGUuaXRlbSA9IGZ1bmN0aW9uKGkpe1xuXHRfdXBkYXRlTGl2ZUxpc3QodGhpcyk7XG5cdHJldHVybiB0aGlzW2ldO1xufVxuXG5fZXh0ZW5kcyhMaXZlTm9kZUxpc3QsTm9kZUxpc3QpO1xuLyoqXG4gKiBcbiAqIE9iamVjdHMgaW1wbGVtZW50aW5nIHRoZSBOYW1lZE5vZGVNYXAgaW50ZXJmYWNlIGFyZSB1c2VkIHRvIHJlcHJlc2VudCBjb2xsZWN0aW9ucyBvZiBub2RlcyB0aGF0IGNhbiBiZSBhY2Nlc3NlZCBieSBuYW1lLiBOb3RlIHRoYXQgTmFtZWROb2RlTWFwIGRvZXMgbm90IGluaGVyaXQgZnJvbSBOb2RlTGlzdDsgTmFtZWROb2RlTWFwcyBhcmUgbm90IG1haW50YWluZWQgaW4gYW55IHBhcnRpY3VsYXIgb3JkZXIuIE9iamVjdHMgY29udGFpbmVkIGluIGFuIG9iamVjdCBpbXBsZW1lbnRpbmcgTmFtZWROb2RlTWFwIG1heSBhbHNvIGJlIGFjY2Vzc2VkIGJ5IGFuIG9yZGluYWwgaW5kZXgsIGJ1dCB0aGlzIGlzIHNpbXBseSB0byBhbGxvdyBjb252ZW5pZW50IGVudW1lcmF0aW9uIG9mIHRoZSBjb250ZW50cyBvZiBhIE5hbWVkTm9kZU1hcCwgYW5kIGRvZXMgbm90IGltcGx5IHRoYXQgdGhlIERPTSBzcGVjaWZpZXMgYW4gb3JkZXIgdG8gdGhlc2UgTm9kZXMuXG4gKiBOYW1lZE5vZGVNYXAgb2JqZWN0cyBpbiB0aGUgRE9NIGFyZSBsaXZlLlxuICogdXNlZCBmb3IgYXR0cmlidXRlcyBvciBEb2N1bWVudFR5cGUgZW50aXRpZXMgXG4gKi9cbmZ1bmN0aW9uIE5hbWVkTm9kZU1hcCgpIHtcbn07XG5cbmZ1bmN0aW9uIF9maW5kTm9kZUluZGV4KGxpc3Qsbm9kZSl7XG5cdHZhciBpID0gbGlzdC5sZW5ndGg7XG5cdHdoaWxlKGktLSl7XG5cdFx0aWYobGlzdFtpXSA9PT0gbm9kZSl7cmV0dXJuIGl9XG5cdH1cbn1cblxuZnVuY3Rpb24gX2FkZE5hbWVkTm9kZShlbCxsaXN0LG5ld0F0dHIsb2xkQXR0cil7XG5cdGlmKG9sZEF0dHIpe1xuXHRcdGxpc3RbX2ZpbmROb2RlSW5kZXgobGlzdCxvbGRBdHRyKV0gPSBuZXdBdHRyO1xuXHR9ZWxzZXtcblx0XHRsaXN0W2xpc3QubGVuZ3RoKytdID0gbmV3QXR0cjtcblx0fVxuXHRpZihlbCl7XG5cdFx0bmV3QXR0ci5vd25lckVsZW1lbnQgPSBlbDtcblx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcblx0XHRpZihkb2Mpe1xuXHRcdFx0b2xkQXR0ciAmJiBfb25SZW1vdmVBdHRyaWJ1dGUoZG9jLGVsLG9sZEF0dHIpO1xuXHRcdFx0X29uQWRkQXR0cmlidXRlKGRvYyxlbCxuZXdBdHRyKTtcblx0XHR9XG5cdH1cbn1cbmZ1bmN0aW9uIF9yZW1vdmVOYW1lZE5vZGUoZWwsbGlzdCxhdHRyKXtcblx0Ly9jb25zb2xlLmxvZygncmVtb3ZlIGF0dHI6JythdHRyKVxuXHR2YXIgaSA9IF9maW5kTm9kZUluZGV4KGxpc3QsYXR0cik7XG5cdGlmKGk+PTApe1xuXHRcdHZhciBsYXN0SW5kZXggPSBsaXN0Lmxlbmd0aC0xXG5cdFx0d2hpbGUoaTxsYXN0SW5kZXgpe1xuXHRcdFx0bGlzdFtpXSA9IGxpc3RbKytpXVxuXHRcdH1cblx0XHRsaXN0Lmxlbmd0aCA9IGxhc3RJbmRleDtcblx0XHRpZihlbCl7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudDtcblx0XHRcdGlmKGRvYyl7XG5cdFx0XHRcdF9vblJlbW92ZUF0dHJpYnV0ZShkb2MsZWwsYXR0cik7XG5cdFx0XHRcdGF0dHIub3duZXJFbGVtZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdH1lbHNle1xuXHRcdHRocm93IERPTUV4Y2VwdGlvbihOT1RfRk9VTkRfRVJSLG5ldyBFcnJvcihlbC50YWdOYW1lKydAJythdHRyKSlcblx0fVxufVxuTmFtZWROb2RlTWFwLnByb3RvdHlwZSA9IHtcblx0bGVuZ3RoOjAsXG5cdGl0ZW06Tm9kZUxpc3QucHJvdG90eXBlLml0ZW0sXG5cdGdldE5hbWVkSXRlbTogZnVuY3Rpb24oa2V5KSB7XG4vL1x0XHRpZihrZXkuaW5kZXhPZignOicpPjAgfHwga2V5ID09ICd4bWxucycpe1xuLy9cdFx0XHRyZXR1cm4gbnVsbDtcbi8vXHRcdH1cblx0XHQvL2NvbnNvbGUubG9nKClcblx0XHR2YXIgaSA9IHRoaXMubGVuZ3RoO1xuXHRcdHdoaWxlKGktLSl7XG5cdFx0XHR2YXIgYXR0ciA9IHRoaXNbaV07XG5cdFx0XHQvL2NvbnNvbGUubG9nKGF0dHIubm9kZU5hbWUsa2V5KVxuXHRcdFx0aWYoYXR0ci5ub2RlTmFtZSA9PSBrZXkpe1xuXHRcdFx0XHRyZXR1cm4gYXR0cjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cdHNldE5hbWVkSXRlbTogZnVuY3Rpb24oYXR0cikge1xuXHRcdHZhciBlbCA9IGF0dHIub3duZXJFbGVtZW50O1xuXHRcdGlmKGVsICYmIGVsIT10aGlzLl9vd25lckVsZW1lbnQpe1xuXHRcdFx0dGhyb3cgbmV3IERPTUV4Y2VwdGlvbihJTlVTRV9BVFRSSUJVVEVfRVJSKTtcblx0XHR9XG5cdFx0dmFyIG9sZEF0dHIgPSB0aGlzLmdldE5hbWVkSXRlbShhdHRyLm5vZGVOYW1lKTtcblx0XHRfYWRkTmFtZWROb2RlKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGF0dHIsb2xkQXR0cik7XG5cdFx0cmV0dXJuIG9sZEF0dHI7XG5cdH0sXG5cdC8qIHJldHVybnMgTm9kZSAqL1xuXHRzZXROYW1lZEl0ZW1OUzogZnVuY3Rpb24oYXR0cikgey8vIHJhaXNlczogV1JPTkdfRE9DVU1FTlRfRVJSLE5PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUixJTlVTRV9BVFRSSUJVVEVfRVJSXG5cdFx0dmFyIGVsID0gYXR0ci5vd25lckVsZW1lbnQsIG9sZEF0dHI7XG5cdFx0aWYoZWwgJiYgZWwhPXRoaXMuX293bmVyRWxlbWVudCl7XG5cdFx0XHR0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKElOVVNFX0FUVFJJQlVURV9FUlIpO1xuXHRcdH1cblx0XHRvbGRBdHRyID0gdGhpcy5nZXROYW1lZEl0ZW1OUyhhdHRyLm5hbWVzcGFjZVVSSSxhdHRyLmxvY2FsTmFtZSk7XG5cdFx0X2FkZE5hbWVkTm9kZSh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxhdHRyLG9sZEF0dHIpO1xuXHRcdHJldHVybiBvbGRBdHRyO1xuXHR9LFxuXG5cdC8qIHJldHVybnMgTm9kZSAqL1xuXHRyZW1vdmVOYW1lZEl0ZW06IGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXROYW1lZEl0ZW0oa2V5KTtcblx0XHRfcmVtb3ZlTmFtZWROb2RlKHRoaXMuX293bmVyRWxlbWVudCx0aGlzLGF0dHIpO1xuXHRcdHJldHVybiBhdHRyO1xuXHRcdFxuXHRcdFxuXHR9LC8vIHJhaXNlczogTk9UX0ZPVU5EX0VSUixOT19NT0RJRklDQVRJT05fQUxMT1dFRF9FUlJcblx0XG5cdC8vZm9yIGxldmVsMlxuXHRyZW1vdmVOYW1lZEl0ZW1OUzpmdW5jdGlvbihuYW1lc3BhY2VVUkksbG9jYWxOYW1lKXtcblx0XHR2YXIgYXR0ciA9IHRoaXMuZ2V0TmFtZWRJdGVtTlMobmFtZXNwYWNlVVJJLGxvY2FsTmFtZSk7XG5cdFx0X3JlbW92ZU5hbWVkTm9kZSh0aGlzLl9vd25lckVsZW1lbnQsdGhpcyxhdHRyKTtcblx0XHRyZXR1cm4gYXR0cjtcblx0fSxcblx0Z2V0TmFtZWRJdGVtTlM6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKSB7XG5cdFx0dmFyIGkgPSB0aGlzLmxlbmd0aDtcblx0XHR3aGlsZShpLS0pe1xuXHRcdFx0dmFyIG5vZGUgPSB0aGlzW2ldO1xuXHRcdFx0aWYobm9kZS5sb2NhbE5hbWUgPT0gbG9jYWxOYW1lICYmIG5vZGUubmFtZXNwYWNlVVJJID09IG5hbWVzcGFjZVVSSSl7XG5cdFx0XHRcdHJldHVybiBub2RlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fVxufTtcbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9SRUMtRE9NLUxldmVsLTEvbGV2ZWwtb25lLWNvcmUuaHRtbCNJRC0xMDIxNjE0OTBcbiAqL1xuZnVuY3Rpb24gRE9NSW1wbGVtZW50YXRpb24oLyogT2JqZWN0ICovIGZlYXR1cmVzKSB7XG5cdHRoaXMuX2ZlYXR1cmVzID0ge307XG5cdGlmIChmZWF0dXJlcykge1xuXHRcdGZvciAodmFyIGZlYXR1cmUgaW4gZmVhdHVyZXMpIHtcblx0XHRcdCB0aGlzLl9mZWF0dXJlcyA9IGZlYXR1cmVzW2ZlYXR1cmVdO1xuXHRcdH1cblx0fVxufTtcblxuRE9NSW1wbGVtZW50YXRpb24ucHJvdG90eXBlID0ge1xuXHRoYXNGZWF0dXJlOiBmdW5jdGlvbigvKiBzdHJpbmcgKi8gZmVhdHVyZSwgLyogc3RyaW5nICovIHZlcnNpb24pIHtcblx0XHR2YXIgdmVyc2lvbnMgPSB0aGlzLl9mZWF0dXJlc1tmZWF0dXJlLnRvTG93ZXJDYXNlKCldO1xuXHRcdGlmICh2ZXJzaW9ucyAmJiAoIXZlcnNpb24gfHwgdmVyc2lvbiBpbiB2ZXJzaW9ucykpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRjcmVhdGVEb2N1bWVudDpmdW5jdGlvbihuYW1lc3BhY2VVUkksICBxdWFsaWZpZWROYW1lLCBkb2N0eXBlKXsvLyByYWlzZXM6SU5WQUxJRF9DSEFSQUNURVJfRVJSLE5BTUVTUEFDRV9FUlIsV1JPTkdfRE9DVU1FTlRfRVJSXG5cdFx0dmFyIGRvYyA9IG5ldyBEb2N1bWVudCgpO1xuXHRcdGRvYy5pbXBsZW1lbnRhdGlvbiA9IHRoaXM7XG5cdFx0ZG9jLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0XHRkb2MuZG9jdHlwZSA9IGRvY3R5cGU7XG5cdFx0aWYoZG9jdHlwZSl7XG5cdFx0XHRkb2MuYXBwZW5kQ2hpbGQoZG9jdHlwZSk7XG5cdFx0fVxuXHRcdGlmKHF1YWxpZmllZE5hbWUpe1xuXHRcdFx0dmFyIHJvb3QgPSBkb2MuY3JlYXRlRWxlbWVudE5TKG5hbWVzcGFjZVVSSSxxdWFsaWZpZWROYW1lKTtcblx0XHRcdGRvYy5hcHBlbmRDaGlsZChyb290KTtcblx0XHR9XG5cdFx0cmV0dXJuIGRvYztcblx0fSxcblx0Ly8gSW50cm9kdWNlZCBpbiBET00gTGV2ZWwgMjpcblx0Y3JlYXRlRG9jdW1lbnRUeXBlOmZ1bmN0aW9uKHF1YWxpZmllZE5hbWUsIHB1YmxpY0lkLCBzeXN0ZW1JZCl7Ly8gcmFpc2VzOklOVkFMSURfQ0hBUkFDVEVSX0VSUixOQU1FU1BBQ0VfRVJSXG5cdFx0dmFyIG5vZGUgPSBuZXcgRG9jdW1lbnRUeXBlKCk7XG5cdFx0bm9kZS5uYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5vZGVOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLnB1YmxpY0lkID0gcHVibGljSWQ7XG5cdFx0bm9kZS5zeXN0ZW1JZCA9IHN5c3RlbUlkO1xuXHRcdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdFx0Ly9yZWFkb25seSBhdHRyaWJ1dGUgRE9NU3RyaW5nICAgICAgICBpbnRlcm5hbFN1YnNldDtcblx0XHRcblx0XHQvL1RPRE86Li5cblx0XHQvLyAgcmVhZG9ubHkgYXR0cmlidXRlIE5hbWVkTm9kZU1hcCAgICAgZW50aXRpZXM7XG5cdFx0Ly8gIHJlYWRvbmx5IGF0dHJpYnV0ZSBOYW1lZE5vZGVNYXAgICAgIG5vdGF0aW9ucztcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxufTtcblxuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMC9SRUMtRE9NLUxldmVsLTItQ29yZS0yMDAwMTExMy9jb3JlLmh0bWwjSUQtMTk1MDY0MTI0N1xuICovXG5cbmZ1bmN0aW9uIE5vZGUoKSB7XG59O1xuXG5Ob2RlLnByb3RvdHlwZSA9IHtcblx0Zmlyc3RDaGlsZCA6IG51bGwsXG5cdGxhc3RDaGlsZCA6IG51bGwsXG5cdHByZXZpb3VzU2libGluZyA6IG51bGwsXG5cdG5leHRTaWJsaW5nIDogbnVsbCxcblx0YXR0cmlidXRlcyA6IG51bGwsXG5cdHBhcmVudE5vZGUgOiBudWxsLFxuXHRjaGlsZE5vZGVzIDogbnVsbCxcblx0b3duZXJEb2N1bWVudCA6IG51bGwsXG5cdG5vZGVWYWx1ZSA6IG51bGwsXG5cdG5hbWVzcGFjZVVSSSA6IG51bGwsXG5cdHByZWZpeCA6IG51bGwsXG5cdGxvY2FsTmFtZSA6IG51bGwsXG5cdC8vIE1vZGlmaWVkIGluIERPTSBMZXZlbCAyOlxuXHRpbnNlcnRCZWZvcmU6ZnVuY3Rpb24obmV3Q2hpbGQsIHJlZkNoaWxkKXsvL3JhaXNlcyBcblx0XHRyZXR1cm4gX2luc2VydEJlZm9yZSh0aGlzLG5ld0NoaWxkLHJlZkNoaWxkKTtcblx0fSxcblx0cmVwbGFjZUNoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkLCBvbGRDaGlsZCl7Ly9yYWlzZXMgXG5cdFx0dGhpcy5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsb2xkQ2hpbGQpO1xuXHRcdGlmKG9sZENoaWxkKXtcblx0XHRcdHRoaXMucmVtb3ZlQ2hpbGQob2xkQ2hpbGQpO1xuXHRcdH1cblx0fSxcblx0cmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24ob2xkQ2hpbGQpe1xuXHRcdHJldHVybiBfcmVtb3ZlQ2hpbGQodGhpcyxvbGRDaGlsZCk7XG5cdH0sXG5cdGFwcGVuZENoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkKXtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsbnVsbCk7XG5cdH0sXG5cdGhhc0NoaWxkTm9kZXM6ZnVuY3Rpb24oKXtcblx0XHRyZXR1cm4gdGhpcy5maXJzdENoaWxkICE9IG51bGw7XG5cdH0sXG5cdGNsb25lTm9kZTpmdW5jdGlvbihkZWVwKXtcblx0XHRyZXR1cm4gY2xvbmVOb2RlKHRoaXMub3duZXJEb2N1bWVudHx8dGhpcyx0aGlzLGRlZXApO1xuXHR9LFxuXHQvLyBNb2RpZmllZCBpbiBET00gTGV2ZWwgMjpcblx0bm9ybWFsaXplOmZ1bmN0aW9uKCl7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5maXJzdENoaWxkO1xuXHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRpZihuZXh0ICYmIG5leHQubm9kZVR5cGUgPT0gVEVYVF9OT0RFICYmIGNoaWxkLm5vZGVUeXBlID09IFRFWFRfTk9ERSl7XG5cdFx0XHRcdHRoaXMucmVtb3ZlQ2hpbGQobmV4dCk7XG5cdFx0XHRcdGNoaWxkLmFwcGVuZERhdGEobmV4dC5kYXRhKTtcblx0XHRcdH1lbHNle1xuXHRcdFx0XHRjaGlsZC5ub3JtYWxpemUoKTtcblx0XHRcdFx0Y2hpbGQgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcbiAgXHQvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuXHRpc1N1cHBvcnRlZDpmdW5jdGlvbihmZWF0dXJlLCB2ZXJzaW9uKXtcblx0XHRyZXR1cm4gdGhpcy5vd25lckRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoZmVhdHVyZSx2ZXJzaW9uKTtcblx0fSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAyOlxuICAgIGhhc0F0dHJpYnV0ZXM6ZnVuY3Rpb24oKXtcbiAgICBcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMubGVuZ3RoPjA7XG4gICAgfSxcbiAgICBsb29rdXBQcmVmaXg6ZnVuY3Rpb24obmFtZXNwYWNlVVJJKXtcbiAgICBcdHZhciBlbCA9IHRoaXM7XG4gICAgXHR3aGlsZShlbCl7XG4gICAgXHRcdHZhciBtYXAgPSBlbC5fbnNNYXA7XG4gICAgXHRcdC8vY29uc29sZS5kaXIobWFwKVxuICAgIFx0XHRpZihtYXApe1xuICAgIFx0XHRcdGZvcih2YXIgbiBpbiBtYXApe1xuICAgIFx0XHRcdFx0aWYobWFwW25dID09IG5hbWVzcGFjZVVSSSl7XG4gICAgXHRcdFx0XHRcdHJldHVybiBuO1xuICAgIFx0XHRcdFx0fVxuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHRlbCA9IGVsLm5vZGVUeXBlID09IEFUVFJJQlVURV9OT0RFP2VsLm93bmVyRG9jdW1lbnQgOiBlbC5wYXJlbnROb2RlO1xuICAgIFx0fVxuICAgIFx0cmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAzOlxuICAgIGxvb2t1cE5hbWVzcGFjZVVSSTpmdW5jdGlvbihwcmVmaXgpe1xuICAgIFx0dmFyIGVsID0gdGhpcztcbiAgICBcdHdoaWxlKGVsKXtcbiAgICBcdFx0dmFyIG1hcCA9IGVsLl9uc01hcDtcbiAgICBcdFx0Ly9jb25zb2xlLmRpcihtYXApXG4gICAgXHRcdGlmKG1hcCl7XG4gICAgXHRcdFx0aWYocHJlZml4IGluIG1hcCl7XG4gICAgXHRcdFx0XHRyZXR1cm4gbWFwW3ByZWZpeF0gO1xuICAgIFx0XHRcdH1cbiAgICBcdFx0fVxuICAgIFx0XHRlbCA9IGVsLm5vZGVUeXBlID09IEFUVFJJQlVURV9OT0RFP2VsLm93bmVyRG9jdW1lbnQgOiBlbC5wYXJlbnROb2RlO1xuICAgIFx0fVxuICAgIFx0cmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICAvLyBJbnRyb2R1Y2VkIGluIERPTSBMZXZlbCAzOlxuICAgIGlzRGVmYXVsdE5hbWVzcGFjZTpmdW5jdGlvbihuYW1lc3BhY2VVUkkpe1xuICAgIFx0dmFyIHByZWZpeCA9IHRoaXMubG9va3VwUHJlZml4KG5hbWVzcGFjZVVSSSk7XG4gICAgXHRyZXR1cm4gcHJlZml4ID09IG51bGw7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBfeG1sRW5jb2RlcihjKXtcblx0cmV0dXJuIGMgPT0gJzwnICYmICcmbHQ7JyB8fFxuICAgICAgICAgYyA9PSAnPicgJiYgJyZndDsnIHx8XG4gICAgICAgICBjID09ICcmJyAmJiAnJmFtcDsnIHx8XG4gICAgICAgICBjID09ICdcIicgJiYgJyZxdW90OycgfHxcbiAgICAgICAgICcmIycrYy5jaGFyQ29kZUF0KCkrJzsnXG59XG5cblxuY29weShOb2RlVHlwZSxOb2RlKTtcbmNvcHkoTm9kZVR5cGUsTm9kZS5wcm90b3R5cGUpO1xuXG4vKipcbiAqIEBwYXJhbSBjYWxsYmFjayByZXR1cm4gdHJ1ZSBmb3IgY29udGludWUsZmFsc2UgZm9yIGJyZWFrXG4gKiBAcmV0dXJuIGJvb2xlYW4gdHJ1ZTogYnJlYWsgdmlzaXQ7XG4gKi9cbmZ1bmN0aW9uIF92aXNpdE5vZGUobm9kZSxjYWxsYmFjayl7XG5cdGlmKGNhbGxiYWNrKG5vZGUpKXtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXHRpZihub2RlID0gbm9kZS5maXJzdENoaWxkKXtcblx0XHRkb3tcblx0XHRcdGlmKF92aXNpdE5vZGUobm9kZSxjYWxsYmFjaykpe3JldHVybiB0cnVlfVxuICAgICAgICB9d2hpbGUobm9kZT1ub2RlLm5leHRTaWJsaW5nKVxuICAgIH1cbn1cblxuXG5cbmZ1bmN0aW9uIERvY3VtZW50KCl7XG59XG5mdW5jdGlvbiBfb25BZGRBdHRyaWJ1dGUoZG9jLGVsLG5ld0F0dHIpe1xuXHRkb2MgJiYgZG9jLl9pbmMrKztcblx0dmFyIG5zID0gbmV3QXR0ci5uYW1lc3BhY2VVUkkgO1xuXHRpZihucyA9PSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucy8nKXtcblx0XHQvL3VwZGF0ZSBuYW1lc3BhY2Vcblx0XHRlbC5fbnNNYXBbbmV3QXR0ci5wcmVmaXg/bmV3QXR0ci5sb2NhbE5hbWU6JyddID0gbmV3QXR0ci52YWx1ZVxuXHR9XG59XG5mdW5jdGlvbiBfb25SZW1vdmVBdHRyaWJ1dGUoZG9jLGVsLG5ld0F0dHIscmVtb3ZlKXtcblx0ZG9jICYmIGRvYy5faW5jKys7XG5cdHZhciBucyA9IG5ld0F0dHIubmFtZXNwYWNlVVJJIDtcblx0aWYobnMgPT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyl7XG5cdFx0Ly91cGRhdGUgbmFtZXNwYWNlXG5cdFx0ZGVsZXRlIGVsLl9uc01hcFtuZXdBdHRyLnByZWZpeD9uZXdBdHRyLmxvY2FsTmFtZTonJ11cblx0fVxufVxuZnVuY3Rpb24gX29uVXBkYXRlQ2hpbGQoZG9jLGVsLG5ld0NoaWxkKXtcblx0aWYoZG9jICYmIGRvYy5faW5jKXtcblx0XHRkb2MuX2luYysrO1xuXHRcdC8vdXBkYXRlIGNoaWxkTm9kZXNcblx0XHR2YXIgY3MgPSBlbC5jaGlsZE5vZGVzO1xuXHRcdGlmKG5ld0NoaWxkKXtcblx0XHRcdGNzW2NzLmxlbmd0aCsrXSA9IG5ld0NoaWxkO1xuXHRcdH1lbHNle1xuXHRcdFx0Ly9jb25zb2xlLmxvZygxKVxuXHRcdFx0dmFyIGNoaWxkID0gZWwuZmlyc3RDaGlsZDtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdFx0Y3NbaSsrXSA9IGNoaWxkO1xuXHRcdFx0XHRjaGlsZCA9Y2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHR9XG5cdFx0XHRjcy5sZW5ndGggPSBpO1xuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIGF0dHJpYnV0ZXM7XG4gKiBjaGlsZHJlbjtcbiAqIFxuICogd3JpdGVhYmxlIHByb3BlcnRpZXM6XG4gKiBub2RlVmFsdWUsQXR0cjp2YWx1ZSxDaGFyYWN0ZXJEYXRhOmRhdGFcbiAqIHByZWZpeFxuICovXG5mdW5jdGlvbiBfcmVtb3ZlQ2hpbGQocGFyZW50Tm9kZSxjaGlsZCl7XG5cdHZhciBwcmV2aW91cyA9IGNoaWxkLnByZXZpb3VzU2libGluZztcblx0dmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcblx0aWYocHJldmlvdXMpe1xuXHRcdHByZXZpb3VzLm5leHRTaWJsaW5nID0gbmV4dDtcblx0fWVsc2V7XG5cdFx0cGFyZW50Tm9kZS5maXJzdENoaWxkID0gbmV4dFxuXHR9XG5cdGlmKG5leHQpe1xuXHRcdG5leHQucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXM7XG5cdH1lbHNle1xuXHRcdHBhcmVudE5vZGUubGFzdENoaWxkID0gcHJldmlvdXM7XG5cdH1cblx0X29uVXBkYXRlQ2hpbGQocGFyZW50Tm9kZS5vd25lckRvY3VtZW50LHBhcmVudE5vZGUpO1xuXHRyZXR1cm4gY2hpbGQ7XG59XG4vKipcbiAqIHByZWZvcm1hbmNlIGtleShyZWZDaGlsZCA9PSBudWxsKVxuICovXG5mdW5jdGlvbiBfaW5zZXJ0QmVmb3JlKHBhcmVudE5vZGUsbmV3Q2hpbGQsbmV4dENoaWxkKXtcblx0dmFyIGNwID0gbmV3Q2hpbGQucGFyZW50Tm9kZTtcblx0aWYoY3Ape1xuXHRcdGNwLnJlbW92ZUNoaWxkKG5ld0NoaWxkKTsvL3JlbW92ZSBhbmQgdXBkYXRlXG5cdH1cblx0aWYobmV3Q2hpbGQubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe1xuXHRcdHZhciBuZXdGaXJzdCA9IG5ld0NoaWxkLmZpcnN0Q2hpbGQ7XG5cdFx0aWYgKG5ld0ZpcnN0ID09IG51bGwpIHtcblx0XHRcdHJldHVybiBuZXdDaGlsZDtcblx0XHR9XG5cdFx0dmFyIG5ld0xhc3QgPSBuZXdDaGlsZC5sYXN0Q2hpbGQ7XG5cdH1lbHNle1xuXHRcdG5ld0ZpcnN0ID0gbmV3TGFzdCA9IG5ld0NoaWxkO1xuXHR9XG5cdHZhciBwcmUgPSBuZXh0Q2hpbGQgPyBuZXh0Q2hpbGQucHJldmlvdXNTaWJsaW5nIDogcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG5cblx0bmV3Rmlyc3QucHJldmlvdXNTaWJsaW5nID0gcHJlO1xuXHRuZXdMYXN0Lm5leHRTaWJsaW5nID0gbmV4dENoaWxkO1xuXHRcblx0XG5cdGlmKHByZSl7XG5cdFx0cHJlLm5leHRTaWJsaW5nID0gbmV3Rmlyc3Q7XG5cdH1lbHNle1xuXHRcdHBhcmVudE5vZGUuZmlyc3RDaGlsZCA9IG5ld0ZpcnN0O1xuXHR9XG5cdGlmKG5leHRDaGlsZCA9PSBudWxsKXtcblx0XHRwYXJlbnROb2RlLmxhc3RDaGlsZCA9IG5ld0xhc3Q7XG5cdH1lbHNle1xuXHRcdG5leHRDaGlsZC5wcmV2aW91c1NpYmxpbmcgPSBuZXdMYXN0O1xuXHR9XG5cdGRve1xuXHRcdG5ld0ZpcnN0LnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXHR9d2hpbGUobmV3Rmlyc3QgIT09IG5ld0xhc3QgJiYgKG5ld0ZpcnN0PSBuZXdGaXJzdC5uZXh0U2libGluZykpXG5cdF9vblVwZGF0ZUNoaWxkKHBhcmVudE5vZGUub3duZXJEb2N1bWVudHx8cGFyZW50Tm9kZSxwYXJlbnROb2RlKTtcblx0Ly9jb25zb2xlLmxvZyhwYXJlbnROb2RlLmxhc3RDaGlsZC5uZXh0U2libGluZyA9PSBudWxsKVxuXHRpZiAobmV3Q2hpbGQubm9kZVR5cGUgPT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuXHRcdG5ld0NoaWxkLmZpcnN0Q2hpbGQgPSBuZXdDaGlsZC5sYXN0Q2hpbGQgPSBudWxsO1xuXHR9XG5cdHJldHVybiBuZXdDaGlsZDtcbn1cbmZ1bmN0aW9uIF9hcHBlbmRTaW5nbGVDaGlsZChwYXJlbnROb2RlLG5ld0NoaWxkKXtcblx0dmFyIGNwID0gbmV3Q2hpbGQucGFyZW50Tm9kZTtcblx0aWYoY3Ape1xuXHRcdHZhciBwcmUgPSBwYXJlbnROb2RlLmxhc3RDaGlsZDtcblx0XHRjcC5yZW1vdmVDaGlsZChuZXdDaGlsZCk7Ly9yZW1vdmUgYW5kIHVwZGF0ZVxuXHRcdHZhciBwcmUgPSBwYXJlbnROb2RlLmxhc3RDaGlsZDtcblx0fVxuXHR2YXIgcHJlID0gcGFyZW50Tm9kZS5sYXN0Q2hpbGQ7XG5cdG5ld0NoaWxkLnBhcmVudE5vZGUgPSBwYXJlbnROb2RlO1xuXHRuZXdDaGlsZC5wcmV2aW91c1NpYmxpbmcgPSBwcmU7XG5cdG5ld0NoaWxkLm5leHRTaWJsaW5nID0gbnVsbDtcblx0aWYocHJlKXtcblx0XHRwcmUubmV4dFNpYmxpbmcgPSBuZXdDaGlsZDtcblx0fWVsc2V7XG5cdFx0cGFyZW50Tm9kZS5maXJzdENoaWxkID0gbmV3Q2hpbGQ7XG5cdH1cblx0cGFyZW50Tm9kZS5sYXN0Q2hpbGQgPSBuZXdDaGlsZDtcblx0X29uVXBkYXRlQ2hpbGQocGFyZW50Tm9kZS5vd25lckRvY3VtZW50LHBhcmVudE5vZGUsbmV3Q2hpbGQpO1xuXHRyZXR1cm4gbmV3Q2hpbGQ7XG5cdC8vY29uc29sZS5sb2coXCJfX2FhXCIscGFyZW50Tm9kZS5sYXN0Q2hpbGQubmV4dFNpYmxpbmcgPT0gbnVsbClcbn1cbkRvY3VtZW50LnByb3RvdHlwZSA9IHtcblx0Ly9pbXBsZW1lbnRhdGlvbiA6IG51bGwsXG5cdG5vZGVOYW1lIDogICcjZG9jdW1lbnQnLFxuXHRub2RlVHlwZSA6ICBET0NVTUVOVF9OT0RFLFxuXHRkb2N0eXBlIDogIG51bGwsXG5cdGRvY3VtZW50RWxlbWVudCA6ICBudWxsLFxuXHRfaW5jIDogMSxcblx0XG5cdGluc2VydEJlZm9yZSA6ICBmdW5jdGlvbihuZXdDaGlsZCwgcmVmQ2hpbGQpey8vcmFpc2VzIFxuXHRcdGlmKG5ld0NoaWxkLm5vZGVUeXBlID09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUpe1xuXHRcdFx0dmFyIGNoaWxkID0gbmV3Q2hpbGQuZmlyc3RDaGlsZDtcblx0XHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdFx0dmFyIG5leHQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdFx0dGhpcy5pbnNlcnRCZWZvcmUoY2hpbGQscmVmQ2hpbGQpO1xuXHRcdFx0XHRjaGlsZCA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3Q2hpbGQ7XG5cdFx0fVxuXHRcdGlmKHRoaXMuZG9jdW1lbnRFbGVtZW50ID09IG51bGwgJiYgbmV3Q2hpbGQubm9kZVR5cGUgPT0gRUxFTUVOVF9OT0RFKXtcblx0XHRcdHRoaXMuZG9jdW1lbnRFbGVtZW50ID0gbmV3Q2hpbGQ7XG5cdFx0fVxuXHRcdFxuXHRcdHJldHVybiBfaW5zZXJ0QmVmb3JlKHRoaXMsbmV3Q2hpbGQscmVmQ2hpbGQpLChuZXdDaGlsZC5vd25lckRvY3VtZW50ID0gdGhpcyksbmV3Q2hpbGQ7XG5cdH0sXG5cdHJlbW92ZUNoaWxkIDogIGZ1bmN0aW9uKG9sZENoaWxkKXtcblx0XHRpZih0aGlzLmRvY3VtZW50RWxlbWVudCA9PSBvbGRDaGlsZCl7XG5cdFx0XHR0aGlzLmRvY3VtZW50RWxlbWVudCA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBfcmVtb3ZlQ2hpbGQodGhpcyxvbGRDaGlsZCk7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGltcG9ydE5vZGUgOiBmdW5jdGlvbihpbXBvcnRlZE5vZGUsZGVlcCl7XG5cdFx0cmV0dXJuIGltcG9ydE5vZGUodGhpcyxpbXBvcnRlZE5vZGUsZGVlcCk7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGdldEVsZW1lbnRCeUlkIDpcdGZ1bmN0aW9uKGlkKXtcblx0XHR2YXIgcnR2ID0gbnVsbDtcblx0XHRfdmlzaXROb2RlKHRoaXMuZG9jdW1lbnRFbGVtZW50LGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0aWYobm9kZS5ub2RlVHlwZSA9PSBFTEVNRU5UX05PREUpe1xuXHRcdFx0XHRpZihub2RlLmdldEF0dHJpYnV0ZSgnaWQnKSA9PSBpZCl7XG5cdFx0XHRcdFx0cnR2ID0gbm9kZTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cdFx0cmV0dXJuIHJ0djtcblx0fSxcblx0XG5cdC8vZG9jdW1lbnQgZmFjdG9yeSBtZXRob2Q6XG5cdGNyZWF0ZUVsZW1lbnQgOlx0ZnVuY3Rpb24odGFnTmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRWxlbWVudCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHRhZ05hbWU7XG5cdFx0bm9kZS50YWdOYW1lID0gdGFnTmFtZTtcblx0XHRub2RlLmNoaWxkTm9kZXMgPSBuZXcgTm9kZUxpc3QoKTtcblx0XHR2YXIgYXR0cnNcdD0gbm9kZS5hdHRyaWJ1dGVzID0gbmV3IE5hbWVkTm9kZU1hcCgpO1xuXHRcdGF0dHJzLl9vd25lckVsZW1lbnQgPSBub2RlO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVEb2N1bWVudEZyYWdtZW50IDpcdGZ1bmN0aW9uKCl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRG9jdW1lbnRGcmFnbWVudCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZVRleHROb2RlIDpcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBub2RlID0gbmV3IFRleHQoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUuYXBwZW5kRGF0YShkYXRhKVxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVDb21tZW50IDpcdGZ1bmN0aW9uKGRhdGEpe1xuXHRcdHZhciBub2RlID0gbmV3IENvbW1lbnQoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUuYXBwZW5kRGF0YShkYXRhKVxuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVDREFUQVNlY3Rpb24gOlx0ZnVuY3Rpb24oZGF0YSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgQ0RBVEFTZWN0aW9uKCk7XG5cdFx0bm9kZS5vd25lckRvY3VtZW50ID0gdGhpcztcblx0XHRub2RlLmFwcGVuZERhdGEoZGF0YSlcblx0XHRyZXR1cm4gbm9kZTtcblx0fSxcblx0Y3JlYXRlUHJvY2Vzc2luZ0luc3RydWN0aW9uIDpcdGZ1bmN0aW9uKHRhcmdldCxkYXRhKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24oKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnQgPSB0aGlzO1xuXHRcdG5vZGUudGFnTmFtZSA9IG5vZGUudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdG5vZGUubm9kZVZhbHVlPSBub2RlLmRhdGEgPSBkYXRhO1xuXHRcdHJldHVybiBub2RlO1xuXHR9LFxuXHRjcmVhdGVBdHRyaWJ1dGUgOlx0ZnVuY3Rpb24obmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgQXR0cigpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudFx0PSB0aGlzO1xuXHRcdG5vZGUubmFtZSA9IG5hbWU7XG5cdFx0bm9kZS5ub2RlTmFtZVx0PSBuYW1lO1xuXHRcdG5vZGUubG9jYWxOYW1lID0gbmFtZTtcblx0XHRub2RlLnNwZWNpZmllZCA9IHRydWU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdGNyZWF0ZUVudGl0eVJlZmVyZW5jZSA6XHRmdW5jdGlvbihuYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBFbnRpdHlSZWZlcmVuY2UoKTtcblx0XHRub2RlLm93bmVyRG9jdW1lbnRcdD0gdGhpcztcblx0XHRub2RlLm5vZGVOYW1lXHQ9IG5hbWU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGNyZWF0ZUVsZW1lbnROUyA6XHRmdW5jdGlvbihuYW1lc3BhY2VVUkkscXVhbGlmaWVkTmFtZSl7XG5cdFx0dmFyIG5vZGUgPSBuZXcgRWxlbWVudCgpO1xuXHRcdHZhciBwbCA9IHF1YWxpZmllZE5hbWUuc3BsaXQoJzonKTtcblx0XHR2YXIgYXR0cnNcdD0gbm9kZS5hdHRyaWJ1dGVzID0gbmV3IE5hbWVkTm9kZU1hcCgpO1xuXHRcdG5vZGUuY2hpbGROb2RlcyA9IG5ldyBOb2RlTGlzdCgpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS50YWdOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblx0XHRpZihwbC5sZW5ndGggPT0gMil7XG5cdFx0XHRub2RlLnByZWZpeCA9IHBsWzBdO1xuXHRcdFx0bm9kZS5sb2NhbE5hbWUgPSBwbFsxXTtcblx0XHR9ZWxzZXtcblx0XHRcdC8vZWwucHJlZml4ID0gbnVsbDtcblx0XHRcdG5vZGUubG9jYWxOYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHR9XG5cdFx0YXR0cnMuX293bmVyRWxlbWVudCA9IG5vZGU7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH0sXG5cdC8vIEludHJvZHVjZWQgaW4gRE9NIExldmVsIDI6XG5cdGNyZWF0ZUF0dHJpYnV0ZU5TIDpcdGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSxxdWFsaWZpZWROYW1lKXtcblx0XHR2YXIgbm9kZSA9IG5ldyBBdHRyKCk7XG5cdFx0dmFyIHBsID0gcXVhbGlmaWVkTmFtZS5zcGxpdCgnOicpO1xuXHRcdG5vZGUub3duZXJEb2N1bWVudCA9IHRoaXM7XG5cdFx0bm9kZS5ub2RlTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0bm9kZS5uYW1lID0gcXVhbGlmaWVkTmFtZTtcblx0XHRub2RlLm5hbWVzcGFjZVVSSSA9IG5hbWVzcGFjZVVSSTtcblx0XHRub2RlLnNwZWNpZmllZCA9IHRydWU7XG5cdFx0aWYocGwubGVuZ3RoID09IDIpe1xuXHRcdFx0bm9kZS5wcmVmaXggPSBwbFswXTtcblx0XHRcdG5vZGUubG9jYWxOYW1lID0gcGxbMV07XG5cdFx0fWVsc2V7XG5cdFx0XHQvL2VsLnByZWZpeCA9IG51bGw7XG5cdFx0XHRub2RlLmxvY2FsTmFtZSA9IHF1YWxpZmllZE5hbWU7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG59O1xuX2V4dGVuZHMoRG9jdW1lbnQsTm9kZSk7XG5cblxuZnVuY3Rpb24gRWxlbWVudCgpIHtcblx0dGhpcy5fbnNNYXAgPSB7fTtcbn07XG5FbGVtZW50LnByb3RvdHlwZSA9IHtcblx0bm9kZVR5cGUgOiBFTEVNRU5UX05PREUsXG5cdGhhc0F0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5vZGUobmFtZSkhPW51bGw7XG5cdH0sXG5cdGdldEF0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpO1xuXHRcdHJldHVybiBhdHRyICYmIGF0dHIudmFsdWUgfHwgJyc7XG5cdH0sXG5cdGdldEF0dHJpYnV0ZU5vZGUgOiBmdW5jdGlvbihuYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbShuYW1lKTtcblx0fSxcblx0c2V0QXR0cmlidXRlIDogZnVuY3Rpb24obmFtZSwgdmFsdWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZUF0dHJpYnV0ZShuYW1lKTtcblx0XHRhdHRyLnZhbHVlID0gYXR0ci5ub2RlVmFsdWUgPSBcIlwiICsgdmFsdWU7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIpXG5cdH0sXG5cdHJlbW92ZUF0dHJpYnV0ZSA6IGZ1bmN0aW9uKG5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpXG5cdFx0YXR0ciAmJiB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUoYXR0cik7XG5cdH0sXG5cdFxuXHQvL2ZvdXIgcmVhbCBvcGVhcnRpb24gbWV0aG9kXG5cdGFwcGVuZENoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkKXtcblx0XHRpZihuZXdDaGlsZC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSl7XG5cdFx0XHRyZXR1cm4gdGhpcy5pbnNlcnRCZWZvcmUobmV3Q2hpbGQsbnVsbCk7XG5cdFx0fWVsc2V7XG5cdFx0XHRyZXR1cm4gX2FwcGVuZFNpbmdsZUNoaWxkKHRoaXMsbmV3Q2hpbGQpO1xuXHRcdH1cblx0fSxcblx0c2V0QXR0cmlidXRlTm9kZSA6IGZ1bmN0aW9uKG5ld0F0dHIpe1xuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMuc2V0TmFtZWRJdGVtKG5ld0F0dHIpO1xuXHR9LFxuXHRzZXRBdHRyaWJ1dGVOb2RlTlMgOiBmdW5jdGlvbihuZXdBdHRyKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLnNldE5hbWVkSXRlbU5TKG5ld0F0dHIpO1xuXHR9LFxuXHRyZW1vdmVBdHRyaWJ1dGVOb2RlIDogZnVuY3Rpb24ob2xkQXR0cil7XG5cdFx0Ly9jb25zb2xlLmxvZyh0aGlzID09IG9sZEF0dHIub3duZXJFbGVtZW50KVxuXHRcdHJldHVybiB0aGlzLmF0dHJpYnV0ZXMucmVtb3ZlTmFtZWRJdGVtKG9sZEF0dHIubm9kZU5hbWUpO1xuXHR9LFxuXHQvL2dldCByZWFsIGF0dHJpYnV0ZSBuYW1lLGFuZCByZW1vdmUgaXQgYnkgcmVtb3ZlQXR0cmlidXRlTm9kZVxuXHRyZW1vdmVBdHRyaWJ1dGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHR2YXIgb2xkID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMobmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpO1xuXHRcdG9sZCAmJiB0aGlzLnJlbW92ZUF0dHJpYnV0ZU5vZGUob2xkKTtcblx0fSxcblx0XG5cdGhhc0F0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZU5vZGVOUyhuYW1lc3BhY2VVUkksIGxvY2FsTmFtZSkhPW51bGw7XG5cdH0sXG5cdGdldEF0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpe1xuXHRcdHZhciBhdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGVOb2RlTlMobmFtZXNwYWNlVVJJLCBsb2NhbE5hbWUpO1xuXHRcdHJldHVybiBhdHRyICYmIGF0dHIudmFsdWUgfHwgJyc7XG5cdH0sXG5cdHNldEF0dHJpYnV0ZU5TIDogZnVuY3Rpb24obmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lLCB2YWx1ZSl7XG5cdFx0dmFyIGF0dHIgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlQXR0cmlidXRlTlMobmFtZXNwYWNlVVJJLCBxdWFsaWZpZWROYW1lKTtcblx0XHRhdHRyLnZhbHVlID0gYXR0ci5ub2RlVmFsdWUgPSBcIlwiICsgdmFsdWU7XG5cdFx0dGhpcy5zZXRBdHRyaWJ1dGVOb2RlKGF0dHIpXG5cdH0sXG5cdGdldEF0dHJpYnV0ZU5vZGVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHRyZXR1cm4gdGhpcy5hdHRyaWJ1dGVzLmdldE5hbWVkSXRlbU5TKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKTtcblx0fSxcblx0XG5cdGdldEVsZW1lbnRzQnlUYWdOYW1lIDogZnVuY3Rpb24odGFnTmFtZSl7XG5cdFx0cmV0dXJuIG5ldyBMaXZlTm9kZUxpc3QodGhpcyxmdW5jdGlvbihiYXNlKXtcblx0XHRcdHZhciBscyA9IFtdO1xuXHRcdFx0X3Zpc2l0Tm9kZShiYXNlLGZ1bmN0aW9uKG5vZGUpe1xuXHRcdFx0XHRpZihub2RlICE9PSBiYXNlICYmIG5vZGUubm9kZVR5cGUgPT0gRUxFTUVOVF9OT0RFICYmICh0YWdOYW1lID09PSAnKicgfHwgbm9kZS50YWdOYW1lID09IHRhZ05hbWUpKXtcblx0XHRcdFx0XHRscy5wdXNoKG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBscztcblx0XHR9KTtcblx0fSxcblx0Z2V0RWxlbWVudHNCeVRhZ05hbWVOUyA6IGZ1bmN0aW9uKG5hbWVzcGFjZVVSSSwgbG9jYWxOYW1lKXtcblx0XHRyZXR1cm4gbmV3IExpdmVOb2RlTGlzdCh0aGlzLGZ1bmN0aW9uKGJhc2Upe1xuXHRcdFx0dmFyIGxzID0gW107XG5cdFx0XHRfdmlzaXROb2RlKGJhc2UsZnVuY3Rpb24obm9kZSl7XG5cdFx0XHRcdGlmKG5vZGUgIT09IGJhc2UgJiYgbm9kZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIChuYW1lc3BhY2VVUkkgPT09ICcqJyB8fCBub2RlLm5hbWVzcGFjZVVSSSA9PT0gbmFtZXNwYWNlVVJJKSAmJiAobG9jYWxOYW1lID09PSAnKicgfHwgbm9kZS5sb2NhbE5hbWUgPT0gbG9jYWxOYW1lKSl7XG5cdFx0XHRcdFx0bHMucHVzaChub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gbHM7XG5cdFx0XHRcblx0XHR9KTtcblx0fVxufTtcbkRvY3VtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IEVsZW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lO1xuRG9jdW1lbnQucHJvdG90eXBlLmdldEVsZW1lbnRzQnlUYWdOYW1lTlMgPSBFbGVtZW50LnByb3RvdHlwZS5nZXRFbGVtZW50c0J5VGFnTmFtZU5TO1xuXG5cbl9leHRlbmRzKEVsZW1lbnQsTm9kZSk7XG5mdW5jdGlvbiBBdHRyKCkge1xufTtcbkF0dHIucHJvdG90eXBlLm5vZGVUeXBlID0gQVRUUklCVVRFX05PREU7XG5fZXh0ZW5kcyhBdHRyLE5vZGUpO1xuXG5cbmZ1bmN0aW9uIENoYXJhY3RlckRhdGEoKSB7XG59O1xuQ2hhcmFjdGVyRGF0YS5wcm90b3R5cGUgPSB7XG5cdGRhdGEgOiAnJyxcblx0c3Vic3RyaW5nRGF0YSA6IGZ1bmN0aW9uKG9mZnNldCwgY291bnQpIHtcblx0XHRyZXR1cm4gdGhpcy5kYXRhLnN1YnN0cmluZyhvZmZzZXQsIG9mZnNldCtjb3VudCk7XG5cdH0sXG5cdGFwcGVuZERhdGE6IGZ1bmN0aW9uKHRleHQpIHtcblx0XHR0ZXh0ID0gdGhpcy5kYXRhK3RleHQ7XG5cdFx0dGhpcy5ub2RlVmFsdWUgPSB0aGlzLmRhdGEgPSB0ZXh0O1xuXHRcdHRoaXMubGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cdH0sXG5cdGluc2VydERhdGE6IGZ1bmN0aW9uKG9mZnNldCx0ZXh0KSB7XG5cdFx0dGhpcy5yZXBsYWNlRGF0YShvZmZzZXQsMCx0ZXh0KTtcblx0XG5cdH0sXG5cdGFwcGVuZENoaWxkOmZ1bmN0aW9uKG5ld0NoaWxkKXtcblx0XHR0aHJvdyBuZXcgRXJyb3IoRXhjZXB0aW9uTWVzc2FnZVtISUVSQVJDSFlfUkVRVUVTVF9FUlJdKVxuXHR9LFxuXHRkZWxldGVEYXRhOiBmdW5jdGlvbihvZmZzZXQsIGNvdW50KSB7XG5cdFx0dGhpcy5yZXBsYWNlRGF0YShvZmZzZXQsY291bnQsXCJcIik7XG5cdH0sXG5cdHJlcGxhY2VEYXRhOiBmdW5jdGlvbihvZmZzZXQsIGNvdW50LCB0ZXh0KSB7XG5cdFx0dmFyIHN0YXJ0ID0gdGhpcy5kYXRhLnN1YnN0cmluZygwLG9mZnNldCk7XG5cdFx0dmFyIGVuZCA9IHRoaXMuZGF0YS5zdWJzdHJpbmcob2Zmc2V0K2NvdW50KTtcblx0XHR0ZXh0ID0gc3RhcnQgKyB0ZXh0ICsgZW5kO1xuXHRcdHRoaXMubm9kZVZhbHVlID0gdGhpcy5kYXRhID0gdGV4dDtcblx0XHR0aGlzLmxlbmd0aCA9IHRleHQubGVuZ3RoO1xuXHR9XG59XG5fZXh0ZW5kcyhDaGFyYWN0ZXJEYXRhLE5vZGUpO1xuZnVuY3Rpb24gVGV4dCgpIHtcbn07XG5UZXh0LnByb3RvdHlwZSA9IHtcblx0bm9kZU5hbWUgOiBcIiN0ZXh0XCIsXG5cdG5vZGVUeXBlIDogVEVYVF9OT0RFLFxuXHRzcGxpdFRleHQgOiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR2YXIgdGV4dCA9IHRoaXMuZGF0YTtcblx0XHR2YXIgbmV3VGV4dCA9IHRleHQuc3Vic3RyaW5nKG9mZnNldCk7XG5cdFx0dGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIG9mZnNldCk7XG5cdFx0dGhpcy5kYXRhID0gdGhpcy5ub2RlVmFsdWUgPSB0ZXh0O1xuXHRcdHRoaXMubGVuZ3RoID0gdGV4dC5sZW5ndGg7XG5cdFx0dmFyIG5ld05vZGUgPSB0aGlzLm93bmVyRG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUobmV3VGV4dCk7XG5cdFx0aWYodGhpcy5wYXJlbnROb2RlKXtcblx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobmV3Tm9kZSwgdGhpcy5uZXh0U2libGluZyk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXdOb2RlO1xuXHR9XG59XG5fZXh0ZW5kcyhUZXh0LENoYXJhY3RlckRhdGEpO1xuZnVuY3Rpb24gQ29tbWVudCgpIHtcbn07XG5Db21tZW50LnByb3RvdHlwZSA9IHtcblx0bm9kZU5hbWUgOiBcIiNjb21tZW50XCIsXG5cdG5vZGVUeXBlIDogQ09NTUVOVF9OT0RFXG59XG5fZXh0ZW5kcyhDb21tZW50LENoYXJhY3RlckRhdGEpO1xuXG5mdW5jdGlvbiBDREFUQVNlY3Rpb24oKSB7XG59O1xuQ0RBVEFTZWN0aW9uLnByb3RvdHlwZSA9IHtcblx0bm9kZU5hbWUgOiBcIiNjZGF0YS1zZWN0aW9uXCIsXG5cdG5vZGVUeXBlIDogQ0RBVEFfU0VDVElPTl9OT0RFXG59XG5fZXh0ZW5kcyhDREFUQVNlY3Rpb24sQ2hhcmFjdGVyRGF0YSk7XG5cblxuZnVuY3Rpb24gRG9jdW1lbnRUeXBlKCkge1xufTtcbkRvY3VtZW50VHlwZS5wcm90b3R5cGUubm9kZVR5cGUgPSBET0NVTUVOVF9UWVBFX05PREU7XG5fZXh0ZW5kcyhEb2N1bWVudFR5cGUsTm9kZSk7XG5cbmZ1bmN0aW9uIE5vdGF0aW9uKCkge1xufTtcbk5vdGF0aW9uLnByb3RvdHlwZS5ub2RlVHlwZSA9IE5PVEFUSU9OX05PREU7XG5fZXh0ZW5kcyhOb3RhdGlvbixOb2RlKTtcblxuZnVuY3Rpb24gRW50aXR5KCkge1xufTtcbkVudGl0eS5wcm90b3R5cGUubm9kZVR5cGUgPSBFTlRJVFlfTk9ERTtcbl9leHRlbmRzKEVudGl0eSxOb2RlKTtcblxuZnVuY3Rpb24gRW50aXR5UmVmZXJlbmNlKCkge1xufTtcbkVudGl0eVJlZmVyZW5jZS5wcm90b3R5cGUubm9kZVR5cGUgPSBFTlRJVFlfUkVGRVJFTkNFX05PREU7XG5fZXh0ZW5kcyhFbnRpdHlSZWZlcmVuY2UsTm9kZSk7XG5cbmZ1bmN0aW9uIERvY3VtZW50RnJhZ21lbnQoKSB7XG59O1xuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUubm9kZU5hbWUgPVx0XCIjZG9jdW1lbnQtZnJhZ21lbnRcIjtcbkRvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLm5vZGVUeXBlID1cdERPQ1VNRU5UX0ZSQUdNRU5UX05PREU7XG5fZXh0ZW5kcyhEb2N1bWVudEZyYWdtZW50LE5vZGUpO1xuXG5cbmZ1bmN0aW9uIFByb2Nlc3NpbmdJbnN0cnVjdGlvbigpIHtcbn1cblByb2Nlc3NpbmdJbnN0cnVjdGlvbi5wcm90b3R5cGUubm9kZVR5cGUgPSBQUk9DRVNTSU5HX0lOU1RSVUNUSU9OX05PREU7XG5fZXh0ZW5kcyhQcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sTm9kZSk7XG5mdW5jdGlvbiBYTUxTZXJpYWxpemVyKCl7fVxuWE1MU2VyaWFsaXplci5wcm90b3R5cGUuc2VyaWFsaXplVG9TdHJpbmcgPSBmdW5jdGlvbihub2RlLGlzSHRtbCxub2RlRmlsdGVyKXtcblx0cmV0dXJuIG5vZGVTZXJpYWxpemVUb1N0cmluZy5jYWxsKG5vZGUsaXNIdG1sLG5vZGVGaWx0ZXIpO1xufVxuTm9kZS5wcm90b3R5cGUudG9TdHJpbmcgPSBub2RlU2VyaWFsaXplVG9TdHJpbmc7XG5mdW5jdGlvbiBub2RlU2VyaWFsaXplVG9TdHJpbmcoaXNIdG1sLG5vZGVGaWx0ZXIpe1xuXHR2YXIgYnVmID0gW107XG5cdHZhciByZWZOb2RlID0gdGhpcy5ub2RlVHlwZSA9PSA5P3RoaXMuZG9jdW1lbnRFbGVtZW50OnRoaXM7XG5cdHZhciBwcmVmaXggPSByZWZOb2RlLnByZWZpeDtcblx0dmFyIHVyaSA9IHJlZk5vZGUubmFtZXNwYWNlVVJJO1xuXHRcblx0aWYodXJpICYmIHByZWZpeCA9PSBudWxsKXtcblx0XHQvL2NvbnNvbGUubG9nKHByZWZpeClcblx0XHR2YXIgcHJlZml4ID0gcmVmTm9kZS5sb29rdXBQcmVmaXgodXJpKTtcblx0XHRpZihwcmVmaXggPT0gbnVsbCl7XG5cdFx0XHQvL2lzSFRNTCA9IHRydWU7XG5cdFx0XHR2YXIgdmlzaWJsZU5hbWVzcGFjZXM9W1xuXHRcdFx0e25hbWVzcGFjZTp1cmkscHJlZml4Om51bGx9XG5cdFx0XHQvL3tuYW1lc3BhY2U6dXJpLHByZWZpeDonJ31cblx0XHRcdF1cblx0XHR9XG5cdH1cblx0c2VyaWFsaXplVG9TdHJpbmcodGhpcyxidWYsaXNIdG1sLG5vZGVGaWx0ZXIsdmlzaWJsZU5hbWVzcGFjZXMpO1xuXHQvL2NvbnNvbGUubG9nKCcjIyMnLHRoaXMubm9kZVR5cGUsdXJpLHByZWZpeCxidWYuam9pbignJykpXG5cdHJldHVybiBidWYuam9pbignJyk7XG59XG5mdW5jdGlvbiBuZWVkTmFtZXNwYWNlRGVmaW5lKG5vZGUsaXNIVE1MLCB2aXNpYmxlTmFtZXNwYWNlcykge1xuXHR2YXIgcHJlZml4ID0gbm9kZS5wcmVmaXh8fCcnO1xuXHR2YXIgdXJpID0gbm9kZS5uYW1lc3BhY2VVUkk7XG5cdGlmICghcHJlZml4ICYmICF1cmkpe1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXHRpZiAocHJlZml4ID09PSBcInhtbFwiICYmIHVyaSA9PT0gXCJodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2VcIiBcblx0XHR8fCB1cmkgPT0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJyl7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cdFxuXHR2YXIgaSA9IHZpc2libGVOYW1lc3BhY2VzLmxlbmd0aCBcblx0Ly9jb25zb2xlLmxvZygnQEBAQCcsbm9kZS50YWdOYW1lLHByZWZpeCx1cmksdmlzaWJsZU5hbWVzcGFjZXMpXG5cdHdoaWxlIChpLS0pIHtcblx0XHR2YXIgbnMgPSB2aXNpYmxlTmFtZXNwYWNlc1tpXTtcblx0XHQvLyBnZXQgbmFtZXNwYWNlIHByZWZpeFxuXHRcdC8vY29uc29sZS5sb2cobm9kZS5ub2RlVHlwZSxub2RlLnRhZ05hbWUsbnMucHJlZml4LHByZWZpeClcblx0XHRpZiAobnMucHJlZml4ID09IHByZWZpeCl7XG5cdFx0XHRyZXR1cm4gbnMubmFtZXNwYWNlICE9IHVyaTtcblx0XHR9XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhpc0hUTUwsdXJpLHByZWZpeD09JycpXG5cdC8vaWYoaXNIVE1MICYmIHByZWZpeCA9PW51bGwgJiYgdXJpID09ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJyl7XG5cdC8vXHRyZXR1cm4gZmFsc2U7XG5cdC8vfVxuXHQvL25vZGUuZmxhZyA9ICcxMTExMSdcblx0Ly9jb25zb2xlLmVycm9yKDMsdHJ1ZSxub2RlLmZsYWcsbm9kZS5wcmVmaXgsbm9kZS5uYW1lc3BhY2VVUkkpXG5cdHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplVG9TdHJpbmcobm9kZSxidWYsaXNIVE1MLG5vZGVGaWx0ZXIsdmlzaWJsZU5hbWVzcGFjZXMpe1xuXHRpZihub2RlRmlsdGVyKXtcblx0XHRub2RlID0gbm9kZUZpbHRlcihub2RlKTtcblx0XHRpZihub2RlKXtcblx0XHRcdGlmKHR5cGVvZiBub2RlID09ICdzdHJpbmcnKXtcblx0XHRcdFx0YnVmLnB1c2gobm9kZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9ZWxzZXtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Ly9idWYuc29ydC5hcHBseShhdHRycywgYXR0cmlidXRlU29ydGVyKTtcblx0fVxuXHRzd2l0Y2gobm9kZS5ub2RlVHlwZSl7XG5cdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdGlmICghdmlzaWJsZU5hbWVzcGFjZXMpIHZpc2libGVOYW1lc3BhY2VzID0gW107XG5cdFx0dmFyIHN0YXJ0VmlzaWJsZU5hbWVzcGFjZXMgPSB2aXNpYmxlTmFtZXNwYWNlcy5sZW5ndGg7XG5cdFx0dmFyIGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBsZW4gPSBhdHRycy5sZW5ndGg7XG5cdFx0dmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdHZhciBub2RlTmFtZSA9IG5vZGUudGFnTmFtZTtcblx0XHRcblx0XHRpc0hUTUwgPSAgKGh0bWxucyA9PT0gbm9kZS5uYW1lc3BhY2VVUkkpIHx8aXNIVE1MIFxuXHRcdGJ1Zi5wdXNoKCc8Jyxub2RlTmFtZSk7XG5cdFx0XG5cdFx0XG5cdFx0XG5cdFx0Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtcblx0XHRcdC8vIGFkZCBuYW1lc3BhY2VzIGZvciBhdHRyaWJ1dGVzXG5cdFx0XHR2YXIgYXR0ciA9IGF0dHJzLml0ZW0oaSk7XG5cdFx0XHRpZiAoYXR0ci5wcmVmaXggPT0gJ3htbG5zJykge1xuXHRcdFx0XHR2aXNpYmxlTmFtZXNwYWNlcy5wdXNoKHsgcHJlZml4OiBhdHRyLmxvY2FsTmFtZSwgbmFtZXNwYWNlOiBhdHRyLnZhbHVlIH0pO1xuXHRcdFx0fWVsc2UgaWYoYXR0ci5ub2RlTmFtZSA9PSAneG1sbnMnKXtcblx0XHRcdFx0dmlzaWJsZU5hbWVzcGFjZXMucHVzaCh7IHByZWZpeDogJycsIG5hbWVzcGFjZTogYXR0ci52YWx1ZSB9KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Zm9yKHZhciBpPTA7aTxsZW47aSsrKXtcblx0XHRcdHZhciBhdHRyID0gYXR0cnMuaXRlbShpKTtcblx0XHRcdGlmIChuZWVkTmFtZXNwYWNlRGVmaW5lKGF0dHIsaXNIVE1MLCB2aXNpYmxlTmFtZXNwYWNlcykpIHtcblx0XHRcdFx0dmFyIHByZWZpeCA9IGF0dHIucHJlZml4fHwnJztcblx0XHRcdFx0dmFyIHVyaSA9IGF0dHIubmFtZXNwYWNlVVJJO1xuXHRcdFx0XHR2YXIgbnMgPSBwcmVmaXggPyAnIHhtbG5zOicgKyBwcmVmaXggOiBcIiB4bWxuc1wiO1xuXHRcdFx0XHRidWYucHVzaChucywgJz1cIicgLCB1cmkgLCAnXCInKTtcblx0XHRcdFx0dmlzaWJsZU5hbWVzcGFjZXMucHVzaCh7IHByZWZpeDogcHJlZml4LCBuYW1lc3BhY2U6dXJpIH0pO1xuXHRcdFx0fVxuXHRcdFx0c2VyaWFsaXplVG9TdHJpbmcoYXR0cixidWYsaXNIVE1MLG5vZGVGaWx0ZXIsdmlzaWJsZU5hbWVzcGFjZXMpO1xuXHRcdH1cblx0XHQvLyBhZGQgbmFtZXNwYWNlIGZvciBjdXJyZW50IG5vZGVcdFx0XG5cdFx0aWYgKG5lZWROYW1lc3BhY2VEZWZpbmUobm9kZSxpc0hUTUwsIHZpc2libGVOYW1lc3BhY2VzKSkge1xuXHRcdFx0dmFyIHByZWZpeCA9IG5vZGUucHJlZml4fHwnJztcblx0XHRcdHZhciB1cmkgPSBub2RlLm5hbWVzcGFjZVVSSTtcblx0XHRcdHZhciBucyA9IHByZWZpeCA/ICcgeG1sbnM6JyArIHByZWZpeCA6IFwiIHhtbG5zXCI7XG5cdFx0XHRidWYucHVzaChucywgJz1cIicgLCB1cmkgLCAnXCInKTtcblx0XHRcdHZpc2libGVOYW1lc3BhY2VzLnB1c2goeyBwcmVmaXg6IHByZWZpeCwgbmFtZXNwYWNlOnVyaSB9KTtcblx0XHR9XG5cdFx0XG5cdFx0aWYoY2hpbGQgfHwgaXNIVE1MICYmICEvXig/Om1ldGF8bGlua3xpbWd8YnJ8aHJ8aW5wdXQpJC9pLnRlc3Qobm9kZU5hbWUpKXtcblx0XHRcdGJ1Zi5wdXNoKCc+Jyk7XG5cdFx0XHQvL2lmIGlzIGNkYXRhIGNoaWxkIG5vZGVcblx0XHRcdGlmKGlzSFRNTCAmJiAvXnNjcmlwdCQvaS50ZXN0KG5vZGVOYW1lKSl7XG5cdFx0XHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdFx0XHRpZihjaGlsZC5kYXRhKXtcblx0XHRcdFx0XHRcdGJ1Zi5wdXNoKGNoaWxkLmRhdGEpO1xuXHRcdFx0XHRcdH1lbHNle1xuXHRcdFx0XHRcdFx0c2VyaWFsaXplVG9TdHJpbmcoY2hpbGQsYnVmLGlzSFRNTCxub2RlRmlsdGVyLHZpc2libGVOYW1lc3BhY2VzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdFx0fVxuXHRcdFx0fWVsc2Vcblx0XHRcdHtcblx0XHRcdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0XHRcdHNlcmlhbGl6ZVRvU3RyaW5nKGNoaWxkLGJ1Zixpc0hUTUwsbm9kZUZpbHRlcix2aXNpYmxlTmFtZXNwYWNlcyk7XG5cdFx0XHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0YnVmLnB1c2goJzwvJyxub2RlTmFtZSwnPicpO1xuXHRcdH1lbHNle1xuXHRcdFx0YnVmLnB1c2goJy8+Jyk7XG5cdFx0fVxuXHRcdC8vIHJlbW92ZSBhZGRlZCB2aXNpYmxlIG5hbWVzcGFjZXNcblx0XHQvL3Zpc2libGVOYW1lc3BhY2VzLmxlbmd0aCA9IHN0YXJ0VmlzaWJsZU5hbWVzcGFjZXM7XG5cdFx0cmV0dXJuO1xuXHRjYXNlIERPQ1VNRU5UX05PREU6XG5cdGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcblx0XHR2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0c2VyaWFsaXplVG9TdHJpbmcoY2hpbGQsYnVmLGlzSFRNTCxub2RlRmlsdGVyLHZpc2libGVOYW1lc3BhY2VzKTtcblx0XHRcdGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0fVxuXHRcdHJldHVybjtcblx0Y2FzZSBBVFRSSUJVVEVfTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goJyAnLG5vZGUubmFtZSwnPVwiJyxub2RlLnZhbHVlLnJlcGxhY2UoL1s8JlwiXS9nLF94bWxFbmNvZGVyKSwnXCInKTtcblx0Y2FzZSBURVhUX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKG5vZGUuZGF0YS5yZXBsYWNlKC9bPCZdL2csX3htbEVuY29kZXIpKTtcblx0Y2FzZSBDREFUQV9TRUNUSU9OX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCAnPCFbQ0RBVEFbJyxub2RlLmRhdGEsJ11dPicpO1xuXHRjYXNlIENPTU1FTlRfTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goIFwiPCEtLVwiLG5vZGUuZGF0YSxcIi0tPlwiKTtcblx0Y2FzZSBET0NVTUVOVF9UWVBFX05PREU6XG5cdFx0dmFyIHB1YmlkID0gbm9kZS5wdWJsaWNJZDtcblx0XHR2YXIgc3lzaWQgPSBub2RlLnN5c3RlbUlkO1xuXHRcdGJ1Zi5wdXNoKCc8IURPQ1RZUEUgJyxub2RlLm5hbWUpO1xuXHRcdGlmKHB1YmlkKXtcblx0XHRcdGJ1Zi5wdXNoKCcgUFVCTElDIFwiJyxwdWJpZCk7XG5cdFx0XHRpZiAoc3lzaWQgJiYgc3lzaWQhPScuJykge1xuXHRcdFx0XHRidWYucHVzaCggJ1wiIFwiJyxzeXNpZCk7XG5cdFx0XHR9XG5cdFx0XHRidWYucHVzaCgnXCI+Jyk7XG5cdFx0fWVsc2UgaWYoc3lzaWQgJiYgc3lzaWQhPScuJyl7XG5cdFx0XHRidWYucHVzaCgnIFNZU1RFTSBcIicsc3lzaWQsJ1wiPicpO1xuXHRcdH1lbHNle1xuXHRcdFx0dmFyIHN1YiA9IG5vZGUuaW50ZXJuYWxTdWJzZXQ7XG5cdFx0XHRpZihzdWIpe1xuXHRcdFx0XHRidWYucHVzaChcIiBbXCIsc3ViLFwiXVwiKTtcblx0XHRcdH1cblx0XHRcdGJ1Zi5wdXNoKFwiPlwiKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHRjYXNlIFBST0NFU1NJTkdfSU5TVFJVQ1RJT05fTk9ERTpcblx0XHRyZXR1cm4gYnVmLnB1c2goIFwiPD9cIixub2RlLnRhcmdldCxcIiBcIixub2RlLmRhdGEsXCI/PlwiKTtcblx0Y2FzZSBFTlRJVFlfUkVGRVJFTkNFX05PREU6XG5cdFx0cmV0dXJuIGJ1Zi5wdXNoKCAnJicsbm9kZS5ub2RlTmFtZSwnOycpO1xuXHQvL2Nhc2UgRU5USVRZX05PREU6XG5cdC8vY2FzZSBOT1RBVElPTl9OT0RFOlxuXHRkZWZhdWx0OlxuXHRcdGJ1Zi5wdXNoKCc/Pycsbm9kZS5ub2RlTmFtZSk7XG5cdH1cbn1cbmZ1bmN0aW9uIGltcG9ydE5vZGUoZG9jLG5vZGUsZGVlcCl7XG5cdHZhciBub2RlMjtcblx0c3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG5cdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdG5vZGUyID0gbm9kZS5jbG9uZU5vZGUoZmFsc2UpO1xuXHRcdG5vZGUyLm93bmVyRG9jdW1lbnQgPSBkb2M7XG5cdFx0Ly92YXIgYXR0cnMgPSBub2RlMi5hdHRyaWJ1dGVzO1xuXHRcdC8vdmFyIGxlbiA9IGF0dHJzLmxlbmd0aDtcblx0XHQvL2Zvcih2YXIgaT0wO2k8bGVuO2krKyl7XG5cdFx0XHQvL25vZGUyLnNldEF0dHJpYnV0ZU5vZGVOUyhpbXBvcnROb2RlKGRvYyxhdHRycy5pdGVtKGkpLGRlZXApKTtcblx0XHQvL31cblx0Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuXHRcdGJyZWFrO1xuXHRjYXNlIEFUVFJJQlVURV9OT0RFOlxuXHRcdGRlZXAgPSB0cnVlO1xuXHRcdGJyZWFrO1xuXHQvL2Nhc2UgRU5USVRZX1JFRkVSRU5DRV9OT0RFOlxuXHQvL2Nhc2UgUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFOlxuXHQvLy8vY2FzZSBURVhUX05PREU6XG5cdC8vY2FzZSBDREFUQV9TRUNUSU9OX05PREU6XG5cdC8vY2FzZSBDT01NRU5UX05PREU6XG5cdC8vXHRkZWVwID0gZmFsc2U7XG5cdC8vXHRicmVhaztcblx0Ly9jYXNlIERPQ1VNRU5UX05PREU6XG5cdC8vY2FzZSBET0NVTUVOVF9UWVBFX05PREU6XG5cdC8vY2Fubm90IGJlIGltcG9ydGVkLlxuXHQvL2Nhc2UgRU5USVRZX05PREU6XG5cdC8vY2FzZSBOT1RBVElPTl9OT0RF77yaXG5cdC8vY2FuIG5vdCBoaXQgaW4gbGV2ZWwzXG5cdC8vZGVmYXVsdDp0aHJvdyBlO1xuXHR9XG5cdGlmKCFub2RlMil7XG5cdFx0bm9kZTIgPSBub2RlLmNsb25lTm9kZShmYWxzZSk7Ly9mYWxzZVxuXHR9XG5cdG5vZGUyLm93bmVyRG9jdW1lbnQgPSBkb2M7XG5cdG5vZGUyLnBhcmVudE5vZGUgPSBudWxsO1xuXHRpZihkZWVwKXtcblx0XHR2YXIgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0d2hpbGUoY2hpbGQpe1xuXHRcdFx0bm9kZTIuYXBwZW5kQ2hpbGQoaW1wb3J0Tm9kZShkb2MsY2hpbGQsZGVlcCkpO1xuXHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblx0cmV0dXJuIG5vZGUyO1xufVxuLy9cbi8vdmFyIF9yZWxhdGlvbk1hcCA9IHtmaXJzdENoaWxkOjEsbGFzdENoaWxkOjEscHJldmlvdXNTaWJsaW5nOjEsbmV4dFNpYmxpbmc6MSxcbi8vXHRcdFx0XHRcdGF0dHJpYnV0ZXM6MSxjaGlsZE5vZGVzOjEscGFyZW50Tm9kZToxLGRvY3VtZW50RWxlbWVudDoxLGRvY3R5cGUsfTtcbmZ1bmN0aW9uIGNsb25lTm9kZShkb2Msbm9kZSxkZWVwKXtcblx0dmFyIG5vZGUyID0gbmV3IG5vZGUuY29uc3RydWN0b3IoKTtcblx0Zm9yKHZhciBuIGluIG5vZGUpe1xuXHRcdHZhciB2ID0gbm9kZVtuXTtcblx0XHRpZih0eXBlb2YgdiAhPSAnb2JqZWN0JyApe1xuXHRcdFx0aWYodiAhPSBub2RlMltuXSl7XG5cdFx0XHRcdG5vZGUyW25dID0gdjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblx0aWYobm9kZS5jaGlsZE5vZGVzKXtcblx0XHRub2RlMi5jaGlsZE5vZGVzID0gbmV3IE5vZGVMaXN0KCk7XG5cdH1cblx0bm9kZTIub3duZXJEb2N1bWVudCA9IGRvYztcblx0c3dpdGNoIChub2RlMi5ub2RlVHlwZSkge1xuXHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHR2YXIgYXR0cnNcdD0gbm9kZS5hdHRyaWJ1dGVzO1xuXHRcdHZhciBhdHRyczJcdD0gbm9kZTIuYXR0cmlidXRlcyA9IG5ldyBOYW1lZE5vZGVNYXAoKTtcblx0XHR2YXIgbGVuID0gYXR0cnMubGVuZ3RoXG5cdFx0YXR0cnMyLl9vd25lckVsZW1lbnQgPSBub2RlMjtcblx0XHRmb3IodmFyIGk9MDtpPGxlbjtpKyspe1xuXHRcdFx0bm9kZTIuc2V0QXR0cmlidXRlTm9kZShjbG9uZU5vZGUoZG9jLGF0dHJzLml0ZW0oaSksdHJ1ZSkpO1xuXHRcdH1cblx0XHRicmVhazs7XG5cdGNhc2UgQVRUUklCVVRFX05PREU6XG5cdFx0ZGVlcCA9IHRydWU7XG5cdH1cblx0aWYoZGVlcCl7XG5cdFx0dmFyIGNoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXHRcdHdoaWxlKGNoaWxkKXtcblx0XHRcdG5vZGUyLmFwcGVuZENoaWxkKGNsb25lTm9kZShkb2MsY2hpbGQsZGVlcCkpO1xuXHRcdFx0Y2hpbGQgPSBjaGlsZC5uZXh0U2libGluZztcblx0XHR9XG5cdH1cblx0cmV0dXJuIG5vZGUyO1xufVxuXG5mdW5jdGlvbiBfX3NldF9fKG9iamVjdCxrZXksdmFsdWUpe1xuXHRvYmplY3Rba2V5XSA9IHZhbHVlXG59XG4vL2RvIGR5bmFtaWNcbnRyeXtcblx0aWYoT2JqZWN0LmRlZmluZVByb3BlcnR5KXtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTGl2ZU5vZGVMaXN0LnByb3RvdHlwZSwnbGVuZ3RoJyx7XG5cdFx0XHRnZXQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0X3VwZGF0ZUxpdmVMaXN0KHRoaXMpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy4kJGxlbmd0aDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoTm9kZS5wcm90b3R5cGUsJ3RleHRDb250ZW50Jyx7XG5cdFx0XHRnZXQ6ZnVuY3Rpb24oKXtcblx0XHRcdFx0cmV0dXJuIGdldFRleHRDb250ZW50KHRoaXMpO1xuXHRcdFx0fSxcblx0XHRcdHNldDpmdW5jdGlvbihkYXRhKXtcblx0XHRcdFx0c3dpdGNoKHRoaXMubm9kZVR5cGUpe1xuXHRcdFx0XHRjYXNlIEVMRU1FTlRfTk9ERTpcblx0XHRcdFx0Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuXHRcdFx0XHRcdHdoaWxlKHRoaXMuZmlyc3RDaGlsZCl7XG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUNoaWxkKHRoaXMuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGRhdGEgfHwgU3RyaW5nKGRhdGEpKXtcblx0XHRcdFx0XHRcdHRoaXMuYXBwZW5kQ2hpbGQodGhpcy5vd25lckRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly9UT0RPOlxuXHRcdFx0XHRcdHRoaXMuZGF0YSA9IGRhdGE7XG5cdFx0XHRcdFx0dGhpcy52YWx1ZSA9IGRhdGE7XG5cdFx0XHRcdFx0dGhpcy5ub2RlVmFsdWUgPSBkYXRhO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0XHRcblx0XHRmdW5jdGlvbiBnZXRUZXh0Q29udGVudChub2RlKXtcblx0XHRcdHN3aXRjaChub2RlLm5vZGVUeXBlKXtcblx0XHRcdGNhc2UgRUxFTUVOVF9OT0RFOlxuXHRcdFx0Y2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuXHRcdFx0XHR2YXIgYnVmID0gW107XG5cdFx0XHRcdG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cdFx0XHRcdHdoaWxlKG5vZGUpe1xuXHRcdFx0XHRcdGlmKG5vZGUubm9kZVR5cGUhPT03ICYmIG5vZGUubm9kZVR5cGUgIT09OCl7XG5cdFx0XHRcdFx0XHRidWYucHVzaChnZXRUZXh0Q29udGVudChub2RlKSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBidWYuam9pbignJyk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRyZXR1cm4gbm9kZS5ub2RlVmFsdWU7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdF9fc2V0X18gPSBmdW5jdGlvbihvYmplY3Qsa2V5LHZhbHVlKXtcblx0XHRcdC8vY29uc29sZS5sb2codmFsdWUpXG5cdFx0XHRvYmplY3RbJyQkJytrZXldID0gdmFsdWVcblx0XHR9XG5cdH1cbn1jYXRjaChlKXsvL2llOFxufVxuXG4vL2lmKHR5cGVvZiByZXF1aXJlID09ICdmdW5jdGlvbicpe1xuXHRleHBvcnRzLkRPTUltcGxlbWVudGF0aW9uID0gRE9NSW1wbGVtZW50YXRpb247XG5cdGV4cG9ydHMuWE1MU2VyaWFsaXplciA9IFhNTFNlcmlhbGl6ZXI7XG4vL31cbiIsIi8vWzRdICAgXHROYW1lU3RhcnRDaGFyXHQgICA6Oj0gICBcdFwiOlwiIHwgW0EtWl0gfCBcIl9cIiB8IFthLXpdIHwgWyN4QzAtI3hENl0gfCBbI3hEOC0jeEY2XSB8IFsjeEY4LSN4MkZGXSB8IFsjeDM3MC0jeDM3RF0gfCBbI3gzN0YtI3gxRkZGXSB8IFsjeDIwMEMtI3gyMDBEXSB8IFsjeDIwNzAtI3gyMThGXSB8IFsjeDJDMDAtI3gyRkVGXSB8IFsjeDMwMDEtI3hEN0ZGXSB8IFsjeEY5MDAtI3hGRENGXSB8IFsjeEZERjAtI3hGRkZEXSB8IFsjeDEwMDAwLSN4RUZGRkZdXHJcbi8vWzRhXSAgIFx0TmFtZUNoYXJcdCAgIDo6PSAgIFx0TmFtZVN0YXJ0Q2hhciB8IFwiLVwiIHwgXCIuXCIgfCBbMC05XSB8ICN4QjcgfCBbI3gwMzAwLSN4MDM2Rl0gfCBbI3gyMDNGLSN4MjA0MF1cclxuLy9bNV0gICBcdE5hbWVcdCAgIDo6PSAgIFx0TmFtZVN0YXJ0Q2hhciAoTmFtZUNoYXIpKlxyXG52YXIgbmFtZVN0YXJ0Q2hhciA9IC9bQS1aX2EtelxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLy8vXFx1MTAwMDAtXFx1RUZGRkZcclxudmFyIG5hbWVDaGFyID0gbmV3IFJlZ0V4cChcIltcXFxcLVxcXFwuMC05XCIrbmFtZVN0YXJ0Q2hhci5zb3VyY2Uuc2xpY2UoMSwtMSkrXCJcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MF1cIik7XHJcbnZhciB0YWdOYW1lUGF0dGVybiA9IG5ldyBSZWdFeHAoJ14nK25hbWVTdGFydENoYXIuc291cmNlK25hbWVDaGFyLnNvdXJjZSsnKig/OlxcOicrbmFtZVN0YXJ0Q2hhci5zb3VyY2UrbmFtZUNoYXIuc291cmNlKycqKT8kJyk7XHJcbi8vdmFyIHRhZ05hbWVQYXR0ZXJuID0gL15bYS16QS1aX11bXFx3XFwtXFwuXSooPzpcXDpbYS16QS1aX11bXFx3XFwtXFwuXSopPyQvXHJcbi8vdmFyIGhhbmRsZXJzID0gJ3Jlc29sdmVFbnRpdHksZ2V0RXh0ZXJuYWxTdWJzZXQsY2hhcmFjdGVycyxlbmREb2N1bWVudCxlbmRFbGVtZW50LGVuZFByZWZpeE1hcHBpbmcsaWdub3JhYmxlV2hpdGVzcGFjZSxwcm9jZXNzaW5nSW5zdHJ1Y3Rpb24sc2V0RG9jdW1lbnRMb2NhdG9yLHNraXBwZWRFbnRpdHksc3RhcnREb2N1bWVudCxzdGFydEVsZW1lbnQsc3RhcnRQcmVmaXhNYXBwaW5nLG5vdGF0aW9uRGVjbCx1bnBhcnNlZEVudGl0eURlY2wsZXJyb3IsZmF0YWxFcnJvcix3YXJuaW5nLGF0dHJpYnV0ZURlY2wsZWxlbWVudERlY2wsZXh0ZXJuYWxFbnRpdHlEZWNsLGludGVybmFsRW50aXR5RGVjbCxjb21tZW50LGVuZENEQVRBLGVuZERURCxlbmRFbnRpdHksc3RhcnRDREFUQSxzdGFydERURCxzdGFydEVudGl0eScuc3BsaXQoJywnKVxyXG5cclxuLy9TX1RBRyxcdFNfQVRUUixcdFNfRVEsXHRTX0FUVFJfTk9RVU9UX1ZBTFVFXHJcbi8vU19BVFRSX1NQQUNFLFx0U19BVFRSX0VORCxcdFNfVEFHX1NQQUNFLCBTX1RBR19DTE9TRVxyXG52YXIgU19UQUcgPSAwOy8vdGFnIG5hbWUgb2ZmZXJyaW5nXHJcbnZhciBTX0FUVFIgPSAxOy8vYXR0ciBuYW1lIG9mZmVycmluZyBcclxudmFyIFNfQVRUUl9TUEFDRT0yOy8vYXR0ciBuYW1lIGVuZCBhbmQgc3BhY2Ugb2ZmZXJcclxudmFyIFNfRVEgPSAzOy8vPXNwYWNlP1xyXG52YXIgU19BVFRSX05PUVVPVF9WQUxVRSA9IDQ7Ly9hdHRyIHZhbHVlKG5vIHF1b3QgdmFsdWUgb25seSlcclxudmFyIFNfQVRUUl9FTkQgPSA1Oy8vYXR0ciB2YWx1ZSBlbmQgYW5kIG5vIHNwYWNlKHF1b3QgZW5kKVxyXG52YXIgU19UQUdfU1BBQ0UgPSA2Oy8vKGF0dHIgdmFsdWUgZW5kIHx8IHRhZyBlbmQgKSAmJiAoc3BhY2Ugb2ZmZXIpXHJcbnZhciBTX1RBR19DTE9TRSA9IDc7Ly9jbG9zZWQgZWw8ZWwgLz5cclxuXHJcbmZ1bmN0aW9uIFhNTFJlYWRlcigpe1xyXG5cdFxyXG59XHJcblxyXG5YTUxSZWFkZXIucHJvdG90eXBlID0ge1xyXG5cdHBhcnNlOmZ1bmN0aW9uKHNvdXJjZSxkZWZhdWx0TlNNYXAsZW50aXR5TWFwKXtcclxuXHRcdHZhciBkb21CdWlsZGVyID0gdGhpcy5kb21CdWlsZGVyO1xyXG5cdFx0ZG9tQnVpbGRlci5zdGFydERvY3VtZW50KCk7XHJcblx0XHRfY29weShkZWZhdWx0TlNNYXAgLGRlZmF1bHROU01hcCA9IHt9KVxyXG5cdFx0cGFyc2Uoc291cmNlLGRlZmF1bHROU01hcCxlbnRpdHlNYXAsXHJcblx0XHRcdFx0ZG9tQnVpbGRlcix0aGlzLmVycm9ySGFuZGxlcik7XHJcblx0XHRkb21CdWlsZGVyLmVuZERvY3VtZW50KCk7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlKHNvdXJjZSxkZWZhdWx0TlNNYXBDb3B5LGVudGl0eU1hcCxkb21CdWlsZGVyLGVycm9ySGFuZGxlcil7XHJcblx0ZnVuY3Rpb24gZml4ZWRGcm9tQ2hhckNvZGUoY29kZSkge1xyXG5cdFx0Ly8gU3RyaW5nLnByb3RvdHlwZS5mcm9tQ2hhckNvZGUgZG9lcyBub3Qgc3VwcG9ydHNcclxuXHRcdC8vID4gMiBieXRlcyB1bmljb2RlIGNoYXJzIGRpcmVjdGx5XHJcblx0XHRpZiAoY29kZSA+IDB4ZmZmZikge1xyXG5cdFx0XHRjb2RlIC09IDB4MTAwMDA7XHJcblx0XHRcdHZhciBzdXJyb2dhdGUxID0gMHhkODAwICsgKGNvZGUgPj4gMTApXHJcblx0XHRcdFx0LCBzdXJyb2dhdGUyID0gMHhkYzAwICsgKGNvZGUgJiAweDNmZik7XHJcblxyXG5cdFx0XHRyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShzdXJyb2dhdGUxLCBzdXJyb2dhdGUyKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRmdW5jdGlvbiBlbnRpdHlSZXBsYWNlcihhKXtcclxuXHRcdHZhciBrID0gYS5zbGljZSgxLC0xKTtcclxuXHRcdGlmKGsgaW4gZW50aXR5TWFwKXtcclxuXHRcdFx0cmV0dXJuIGVudGl0eU1hcFtrXTsgXHJcblx0XHR9ZWxzZSBpZihrLmNoYXJBdCgwKSA9PT0gJyMnKXtcclxuXHRcdFx0cmV0dXJuIGZpeGVkRnJvbUNoYXJDb2RlKHBhcnNlSW50KGsuc3Vic3RyKDEpLnJlcGxhY2UoJ3gnLCcweCcpKSlcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoJ2VudGl0eSBub3QgZm91bmQ6JythKTtcclxuXHRcdFx0cmV0dXJuIGE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGZ1bmN0aW9uIGFwcGVuZFRleHQoZW5kKXsvL2hhcyBzb21lIGJ1Z3NcclxuXHRcdGlmKGVuZD5zdGFydCl7XHJcblx0XHRcdHZhciB4dCA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsZW5kKS5yZXBsYWNlKC8mIz9cXHcrOy9nLGVudGl0eVJlcGxhY2VyKTtcclxuXHRcdFx0bG9jYXRvciYmcG9zaXRpb24oc3RhcnQpO1xyXG5cdFx0XHRkb21CdWlsZGVyLmNoYXJhY3RlcnMoeHQsMCxlbmQtc3RhcnQpO1xyXG5cdFx0XHRzdGFydCA9IGVuZFxyXG5cdFx0fVxyXG5cdH1cclxuXHRmdW5jdGlvbiBwb3NpdGlvbihwLG0pe1xyXG5cdFx0d2hpbGUocD49bGluZUVuZCAmJiAobSA9IGxpbmVQYXR0ZXJuLmV4ZWMoc291cmNlKSkpe1xyXG5cdFx0XHRsaW5lU3RhcnQgPSBtLmluZGV4O1xyXG5cdFx0XHRsaW5lRW5kID0gbGluZVN0YXJ0ICsgbVswXS5sZW5ndGg7XHJcblx0XHRcdGxvY2F0b3IubGluZU51bWJlcisrO1xyXG5cdFx0XHQvL2NvbnNvbGUubG9nKCdsaW5lKys6Jyxsb2NhdG9yLHN0YXJ0UG9zLGVuZFBvcylcclxuXHRcdH1cclxuXHRcdGxvY2F0b3IuY29sdW1uTnVtYmVyID0gcC1saW5lU3RhcnQrMTtcclxuXHR9XHJcblx0dmFyIGxpbmVTdGFydCA9IDA7XHJcblx0dmFyIGxpbmVFbmQgPSAwO1xyXG5cdHZhciBsaW5lUGF0dGVybiA9IC8uKig/Olxcclxcbj98XFxuKXwuKiQvZ1xyXG5cdHZhciBsb2NhdG9yID0gZG9tQnVpbGRlci5sb2NhdG9yO1xyXG5cdFxyXG5cdHZhciBwYXJzZVN0YWNrID0gW3tjdXJyZW50TlNNYXA6ZGVmYXVsdE5TTWFwQ29weX1dXHJcblx0dmFyIGNsb3NlTWFwID0ge307XHJcblx0dmFyIHN0YXJ0ID0gMDtcclxuXHR3aGlsZSh0cnVlKXtcclxuXHRcdHRyeXtcclxuXHRcdFx0dmFyIHRhZ1N0YXJ0ID0gc291cmNlLmluZGV4T2YoJzwnLHN0YXJ0KTtcclxuXHRcdFx0aWYodGFnU3RhcnQ8MCl7XHJcblx0XHRcdFx0aWYoIXNvdXJjZS5zdWJzdHIoc3RhcnQpLm1hdGNoKC9eXFxzKiQvKSl7XHJcblx0XHRcdFx0XHR2YXIgZG9jID0gZG9tQnVpbGRlci5kb2M7XHJcblx0ICAgIFx0XHRcdHZhciB0ZXh0ID0gZG9jLmNyZWF0ZVRleHROb2RlKHNvdXJjZS5zdWJzdHIoc3RhcnQpKTtcclxuXHQgICAgXHRcdFx0ZG9jLmFwcGVuZENoaWxkKHRleHQpO1xyXG5cdCAgICBcdFx0XHRkb21CdWlsZGVyLmN1cnJlbnRFbGVtZW50ID0gdGV4dDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKHRhZ1N0YXJ0PnN0YXJ0KXtcclxuXHRcdFx0XHRhcHBlbmRUZXh0KHRhZ1N0YXJ0KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRzd2l0Y2goc291cmNlLmNoYXJBdCh0YWdTdGFydCsxKSl7XHJcblx0XHRcdGNhc2UgJy8nOlxyXG5cdFx0XHRcdHZhciBlbmQgPSBzb3VyY2UuaW5kZXhPZignPicsdGFnU3RhcnQrMyk7XHJcblx0XHRcdFx0dmFyIHRhZ05hbWUgPSBzb3VyY2Uuc3Vic3RyaW5nKHRhZ1N0YXJ0KzIsZW5kKTtcclxuXHRcdFx0XHR2YXIgY29uZmlnID0gcGFyc2VTdGFjay5wb3AoKTtcclxuXHRcdFx0XHRpZihlbmQ8MCl7XHJcblx0XHRcdFx0XHRcclxuXHQgICAgICAgIFx0XHR0YWdOYW1lID0gc291cmNlLnN1YnN0cmluZyh0YWdTdGFydCsyKS5yZXBsYWNlKC9bXFxzPF0uKi8sJycpO1xyXG5cdCAgICAgICAgXHRcdC8vY29uc29sZS5lcnJvcignI0BAQEBAQCcrdGFnTmFtZSlcclxuXHQgICAgICAgIFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoXCJlbmQgdGFnIG5hbWU6IFwiK3RhZ05hbWUrJyBpcyBub3QgY29tcGxldGU6Jytjb25maWcudGFnTmFtZSk7XHJcblx0ICAgICAgICBcdFx0ZW5kID0gdGFnU3RhcnQrMSt0YWdOYW1lLmxlbmd0aDtcclxuXHQgICAgICAgIFx0fWVsc2UgaWYodGFnTmFtZS5tYXRjaCgvXFxzPC8pKXtcclxuXHQgICAgICAgIFx0XHR0YWdOYW1lID0gdGFnTmFtZS5yZXBsYWNlKC9bXFxzPF0uKi8sJycpO1xyXG5cdCAgICAgICAgXHRcdGVycm9ySGFuZGxlci5lcnJvcihcImVuZCB0YWcgbmFtZTogXCIrdGFnTmFtZSsnIG1heWJlIG5vdCBjb21wbGV0ZScpO1xyXG5cdCAgICAgICAgXHRcdGVuZCA9IHRhZ1N0YXJ0KzErdGFnTmFtZS5sZW5ndGg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vY29uc29sZS5lcnJvcihwYXJzZVN0YWNrLmxlbmd0aCxwYXJzZVN0YWNrKVxyXG5cdFx0XHRcdC8vY29uc29sZS5lcnJvcihjb25maWcpO1xyXG5cdFx0XHRcdHZhciBsb2NhbE5TTWFwID0gY29uZmlnLmxvY2FsTlNNYXA7XHJcblx0XHRcdFx0dmFyIGVuZE1hdGNoID0gY29uZmlnLnRhZ05hbWUgPT0gdGFnTmFtZTtcclxuXHRcdFx0XHR2YXIgZW5kSWdub3JlQ2FzZU1hY2ggPSBlbmRNYXRjaCB8fCBjb25maWcudGFnTmFtZSYmY29uZmlnLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PSB0YWdOYW1lLnRvTG93ZXJDYXNlKClcclxuXHRcdCAgICAgICAgaWYoZW5kSWdub3JlQ2FzZU1hY2gpe1xyXG5cdFx0ICAgICAgICBcdGRvbUJ1aWxkZXIuZW5kRWxlbWVudChjb25maWcudXJpLGNvbmZpZy5sb2NhbE5hbWUsdGFnTmFtZSk7XHJcblx0XHRcdFx0XHRpZihsb2NhbE5TTWFwKXtcclxuXHRcdFx0XHRcdFx0Zm9yKHZhciBwcmVmaXggaW4gbG9jYWxOU01hcCl7XHJcblx0XHRcdFx0XHRcdFx0ZG9tQnVpbGRlci5lbmRQcmVmaXhNYXBwaW5nKHByZWZpeCkgO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZighZW5kTWF0Y2gpe1xyXG5cdFx0ICAgICAgICAgICAgXHRlcnJvckhhbmRsZXIuZmF0YWxFcnJvcihcImVuZCB0YWcgbmFtZTogXCIrdGFnTmFtZSsnIGlzIG5vdCBtYXRjaCB0aGUgY3VycmVudCBzdGFydCB0YWdOYW1lOicrY29uZmlnLnRhZ05hbWUgKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdCAgICAgICAgfWVsc2V7XHJcblx0XHQgICAgICAgIFx0cGFyc2VTdGFjay5wdXNoKGNvbmZpZylcclxuXHRcdCAgICAgICAgfVxyXG5cdFx0XHRcdFxyXG5cdFx0XHRcdGVuZCsrO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdC8vIGVuZCBlbG1lbnRcclxuXHRcdFx0Y2FzZSAnPyc6Ly8gPD8uLi4/PlxyXG5cdFx0XHRcdGxvY2F0b3ImJnBvc2l0aW9uKHRhZ1N0YXJ0KTtcclxuXHRcdFx0XHRlbmQgPSBwYXJzZUluc3RydWN0aW9uKHNvdXJjZSx0YWdTdGFydCxkb21CdWlsZGVyKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0Y2FzZSAnISc6Ly8gPCFkb2N0eXBlLDwhW0NEQVRBLDwhLS1cclxuXHRcdFx0XHRsb2NhdG9yJiZwb3NpdGlvbih0YWdTdGFydCk7XHJcblx0XHRcdFx0ZW5kID0gcGFyc2VEQ0Moc291cmNlLHRhZ1N0YXJ0LGRvbUJ1aWxkZXIsZXJyb3JIYW5kbGVyKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRsb2NhdG9yJiZwb3NpdGlvbih0YWdTdGFydCk7XHJcblx0XHRcdFx0dmFyIGVsID0gbmV3IEVsZW1lbnRBdHRyaWJ1dGVzKCk7XHJcblx0XHRcdFx0dmFyIGN1cnJlbnROU01hcCA9IHBhcnNlU3RhY2tbcGFyc2VTdGFjay5sZW5ndGgtMV0uY3VycmVudE5TTWFwO1xyXG5cdFx0XHRcdC8vZWxTdGFydEVuZFxyXG5cdFx0XHRcdHZhciBlbmQgPSBwYXJzZUVsZW1lbnRTdGFydFBhcnQoc291cmNlLHRhZ1N0YXJ0LGVsLGN1cnJlbnROU01hcCxlbnRpdHlSZXBsYWNlcixlcnJvckhhbmRsZXIpO1xyXG5cdFx0XHRcdHZhciBsZW4gPSBlbC5sZW5ndGg7XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYoIWVsLmNsb3NlZCAmJiBmaXhTZWxmQ2xvc2VkKHNvdXJjZSxlbmQsZWwudGFnTmFtZSxjbG9zZU1hcCkpe1xyXG5cdFx0XHRcdFx0ZWwuY2xvc2VkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGlmKCFlbnRpdHlNYXAubmJzcCl7XHJcblx0XHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCd1bmNsb3NlZCB4bWwgYXR0cmlidXRlJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKGxvY2F0b3IgJiYgbGVuKXtcclxuXHRcdFx0XHRcdHZhciBsb2NhdG9yMiA9IGNvcHlMb2NhdG9yKGxvY2F0b3Ise30pO1xyXG5cdFx0XHRcdFx0Ly90cnl7Ly9hdHRyaWJ1dGUgcG9zaXRpb24gZml4ZWRcclxuXHRcdFx0XHRcdGZvcih2YXIgaSA9IDA7aTxsZW47aSsrKXtcclxuXHRcdFx0XHRcdFx0dmFyIGEgPSBlbFtpXTtcclxuXHRcdFx0XHRcdFx0cG9zaXRpb24oYS5vZmZzZXQpO1xyXG5cdFx0XHRcdFx0XHRhLmxvY2F0b3IgPSBjb3B5TG9jYXRvcihsb2NhdG9yLHt9KTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdC8vfWNhdGNoKGUpe2NvbnNvbGUuZXJyb3IoJ0BAQEBAJytlKX1cclxuXHRcdFx0XHRcdGRvbUJ1aWxkZXIubG9jYXRvciA9IGxvY2F0b3IyXHJcblx0XHRcdFx0XHRpZihhcHBlbmRFbGVtZW50KGVsLGRvbUJ1aWxkZXIsY3VycmVudE5TTWFwKSl7XHJcblx0XHRcdFx0XHRcdHBhcnNlU3RhY2sucHVzaChlbClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGRvbUJ1aWxkZXIubG9jYXRvciA9IGxvY2F0b3I7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRpZihhcHBlbmRFbGVtZW50KGVsLGRvbUJ1aWxkZXIsY3VycmVudE5TTWFwKSl7XHJcblx0XHRcdFx0XHRcdHBhcnNlU3RhY2sucHVzaChlbClcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0XHJcblx0XHRcdFx0aWYoZWwudXJpID09PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcgJiYgIWVsLmNsb3NlZCl7XHJcblx0XHRcdFx0XHRlbmQgPSBwYXJzZUh0bWxTcGVjaWFsQ29udGVudChzb3VyY2UsZW5kLGVsLnRhZ05hbWUsZW50aXR5UmVwbGFjZXIsZG9tQnVpbGRlcilcclxuXHRcdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHRcdGVuZCsrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fWNhdGNoKGUpe1xyXG5cdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoJ2VsZW1lbnQgcGFyc2UgZXJyb3I6ICcrZSlcclxuXHRcdFx0Ly9lcnJvckhhbmRsZXIuZXJyb3IoJ2VsZW1lbnQgcGFyc2UgZXJyb3I6ICcrZSk7XHJcblx0XHRcdGVuZCA9IC0xO1xyXG5cdFx0XHQvL3Rocm93IGU7XHJcblx0XHR9XHJcblx0XHRpZihlbmQ+c3RhcnQpe1xyXG5cdFx0XHRzdGFydCA9IGVuZDtcclxuXHRcdH1lbHNle1xyXG5cdFx0XHQvL1RPRE86IOi/memHjOacieWPr+iDvXNheOWbnumAgO+8jOacieS9jee9rumUmeivr+mjjumZqVxyXG5cdFx0XHRhcHBlbmRUZXh0KE1hdGgubWF4KHRhZ1N0YXJ0LHN0YXJ0KSsxKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuZnVuY3Rpb24gY29weUxvY2F0b3IoZix0KXtcclxuXHR0LmxpbmVOdW1iZXIgPSBmLmxpbmVOdW1iZXI7XHJcblx0dC5jb2x1bW5OdW1iZXIgPSBmLmNvbHVtbk51bWJlcjtcclxuXHRyZXR1cm4gdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIEBzZWUgI2FwcGVuZEVsZW1lbnQoc291cmNlLGVsU3RhcnRFbmQsZWwsc2VsZkNsb3NlZCxlbnRpdHlSZXBsYWNlcixkb21CdWlsZGVyLHBhcnNlU3RhY2spO1xyXG4gKiBAcmV0dXJuIGVuZCBvZiB0aGUgZWxlbWVudFN0YXJ0UGFydChlbmQgb2YgZWxlbWVudEVuZFBhcnQgZm9yIHNlbGZDbG9zZWQgZWwpXHJcbiAqL1xyXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnRTdGFydFBhcnQoc291cmNlLHN0YXJ0LGVsLGN1cnJlbnROU01hcCxlbnRpdHlSZXBsYWNlcixlcnJvckhhbmRsZXIpe1xyXG5cdHZhciBhdHRyTmFtZTtcclxuXHR2YXIgdmFsdWU7XHJcblx0dmFyIHAgPSArK3N0YXJ0O1xyXG5cdHZhciBzID0gU19UQUc7Ly9zdGF0dXNcclxuXHR3aGlsZSh0cnVlKXtcclxuXHRcdHZhciBjID0gc291cmNlLmNoYXJBdChwKTtcclxuXHRcdHN3aXRjaChjKXtcclxuXHRcdGNhc2UgJz0nOlxyXG5cdFx0XHRpZihzID09PSBTX0FUVFIpey8vYXR0ck5hbWVcclxuXHRcdFx0XHRhdHRyTmFtZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKTtcclxuXHRcdFx0XHRzID0gU19FUTtcclxuXHRcdFx0fWVsc2UgaWYocyA9PT0gU19BVFRSX1NQQUNFKXtcclxuXHRcdFx0XHRzID0gU19FUTtcclxuXHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0Ly9mYXRhbEVycm9yOiBlcXVhbCBtdXN0IGFmdGVyIGF0dHJOYW1lIG9yIHNwYWNlIGFmdGVyIGF0dHJOYW1lXHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdhdHRyaWJ1dGUgZXF1YWwgbXVzdCBhZnRlciBhdHRyTmFtZScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnXFwnJzpcclxuXHRcdGNhc2UgJ1wiJzpcclxuXHRcdFx0aWYocyA9PT0gU19FUSB8fCBzID09PSBTX0FUVFIgLy98fCBzID09IFNfQVRUUl9TUEFDRVxyXG5cdFx0XHRcdCl7Ly9lcXVhbFxyXG5cdFx0XHRcdGlmKHMgPT09IFNfQVRUUil7XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKVxyXG5cdFx0XHRcdFx0YXR0ck5hbWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscClcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c3RhcnQgPSBwKzE7XHJcblx0XHRcdFx0cCA9IHNvdXJjZS5pbmRleE9mKGMsc3RhcnQpXHJcblx0XHRcdFx0aWYocD4wKXtcclxuXHRcdFx0XHRcdHZhbHVlID0gc291cmNlLnNsaWNlKHN0YXJ0LHApLnJlcGxhY2UoLyYjP1xcdys7L2csZW50aXR5UmVwbGFjZXIpO1xyXG5cdFx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLHZhbHVlLHN0YXJ0LTEpO1xyXG5cdFx0XHRcdFx0cyA9IFNfQVRUUl9FTkQ7XHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHQvL2ZhdGFsRXJyb3I6IG5vIGVuZCBxdW90IG1hdGNoXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBubyBlbmQgXFwnJytjKydcXCcgbWF0Y2gnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNlIGlmKHMgPT0gU19BVFRSX05PUVVPVF9WQUxVRSl7XHJcblx0XHRcdFx0dmFsdWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCkucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhhdHRyTmFtZSx2YWx1ZSxzdGFydCxwKVxyXG5cdFx0XHRcdGVsLmFkZChhdHRyTmFtZSx2YWx1ZSxzdGFydCk7XHJcblx0XHRcdFx0Ly9jb25zb2xlLmRpcihlbClcclxuXHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJythdHRyTmFtZSsnXCIgbWlzc2VkIHN0YXJ0IHF1b3QoJytjKycpISEnKTtcclxuXHRcdFx0XHRzdGFydCA9IHArMTtcclxuXHRcdFx0XHRzID0gU19BVFRSX0VORFxyXG5cdFx0XHR9ZWxzZXtcclxuXHRcdFx0XHQvL2ZhdGFsRXJyb3I6IG5vIGVxdWFsIGJlZm9yZVxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcignYXR0cmlidXRlIHZhbHVlIG11c3QgYWZ0ZXIgXCI9XCInKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJy8nOlxyXG5cdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdGNhc2UgU19UQUc6XHJcblx0XHRcdFx0ZWwuc2V0VGFnTmFtZShzb3VyY2Uuc2xpY2Uoc3RhcnQscCkpO1xyXG5cdFx0XHRjYXNlIFNfQVRUUl9FTkQ6XHJcblx0XHRcdGNhc2UgU19UQUdfU1BBQ0U6XHJcblx0XHRcdGNhc2UgU19UQUdfQ0xPU0U6XHJcblx0XHRcdFx0cyA9U19UQUdfQ0xPU0U7XHJcblx0XHRcdFx0ZWwuY2xvc2VkID0gdHJ1ZTtcclxuXHRcdFx0Y2FzZSBTX0FUVFJfTk9RVU9UX1ZBTFVFOlxyXG5cdFx0XHRjYXNlIFNfQVRUUjpcclxuXHRcdFx0Y2FzZSBTX0FUVFJfU1BBQ0U6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdC8vY2FzZSBTX0VROlxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImF0dHJpYnV0ZSBpbnZhbGlkIGNsb3NlIGNoYXIoJy8nKVwiKVxyXG5cdFx0XHR9XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSAnJzovL2VuZCBkb2N1bWVudFxyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcigndW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKVxyXG5cdFx0XHRlcnJvckhhbmRsZXIuZXJyb3IoJ3VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XHJcblx0XHRcdGlmKHMgPT0gU19UQUcpe1xyXG5cdFx0XHRcdGVsLnNldFRhZ05hbWUoc291cmNlLnNsaWNlKHN0YXJ0LHApKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcDtcclxuXHRcdGNhc2UgJz4nOlxyXG5cdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdGNhc2UgU19UQUc6XHJcblx0XHRcdFx0ZWwuc2V0VGFnTmFtZShzb3VyY2Uuc2xpY2Uoc3RhcnQscCkpO1xyXG5cdFx0XHRjYXNlIFNfQVRUUl9FTkQ6XHJcblx0XHRcdGNhc2UgU19UQUdfU1BBQ0U6XHJcblx0XHRcdGNhc2UgU19UQUdfQ0xPU0U6XHJcblx0XHRcdFx0YnJlYWs7Ly9ub3JtYWxcclxuXHRcdFx0Y2FzZSBTX0FUVFJfTk9RVU9UX1ZBTFVFOi8vQ29tcGF0aWJsZSBzdGF0ZVxyXG5cdFx0XHRjYXNlIFNfQVRUUjpcclxuXHRcdFx0XHR2YWx1ZSA9IHNvdXJjZS5zbGljZShzdGFydCxwKTtcclxuXHRcdFx0XHRpZih2YWx1ZS5zbGljZSgtMSkgPT09ICcvJyl7XHJcblx0XHRcdFx0XHRlbC5jbG9zZWQgID0gdHJ1ZTtcclxuXHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuc2xpY2UoMCwtMSlcclxuXHRcdFx0XHR9XHJcblx0XHRcdGNhc2UgU19BVFRSX1NQQUNFOlxyXG5cdFx0XHRcdGlmKHMgPT09IFNfQVRUUl9TUEFDRSl7XHJcblx0XHRcdFx0XHR2YWx1ZSA9IGF0dHJOYW1lO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZihzID09IFNfQVRUUl9OT1FVT1RfVkFMVUUpe1xyXG5cdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrdmFsdWUrJ1wiIG1pc3NlZCBxdW90KFwiKSEhJyk7XHJcblx0XHRcdFx0XHRlbC5hZGQoYXR0ck5hbWUsdmFsdWUucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlciksc3RhcnQpXHJcblx0XHRcdFx0fWVsc2V7XHJcblx0XHRcdFx0XHRpZihjdXJyZW50TlNNYXBbJyddICE9PSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcgfHwgIXZhbHVlLm1hdGNoKC9eKD86ZGlzYWJsZWR8Y2hlY2tlZHxzZWxlY3RlZCkkL2kpKXtcclxuXHRcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyLndhcm5pbmcoJ2F0dHJpYnV0ZSBcIicrdmFsdWUrJ1wiIG1pc3NlZCB2YWx1ZSEhIFwiJyt2YWx1ZSsnXCIgaW5zdGVhZCEhJylcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGVsLmFkZCh2YWx1ZSx2YWx1ZSxzdGFydClcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgU19FUTpcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2F0dHJpYnV0ZSB2YWx1ZSBtaXNzZWQhIScpO1xyXG5cdFx0XHR9XHJcbi8vXHRcdFx0Y29uc29sZS5sb2codGFnTmFtZSx0YWdOYW1lUGF0dGVybix0YWdOYW1lUGF0dGVybi50ZXN0KHRhZ05hbWUpKVxyXG5cdFx0XHRyZXR1cm4gcDtcclxuXHRcdC8qeG1sIHNwYWNlICdcXHgyMCcgfCAjeDkgfCAjeEQgfCAjeEE7ICovXHJcblx0XHRjYXNlICdcXHUwMDgwJzpcclxuXHRcdFx0YyA9ICcgJztcclxuXHRcdGRlZmF1bHQ6XHJcblx0XHRcdGlmKGM8PSAnICcpey8vc3BhY2VcclxuXHRcdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdFx0Y2FzZSBTX1RBRzpcclxuXHRcdFx0XHRcdGVsLnNldFRhZ05hbWUoc291cmNlLnNsaWNlKHN0YXJ0LHApKTsvL3RhZ05hbWVcclxuXHRcdFx0XHRcdHMgPSBTX1RBR19TUEFDRTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19BVFRSOlxyXG5cdFx0XHRcdFx0YXR0ck5hbWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscClcclxuXHRcdFx0XHRcdHMgPSBTX0FUVFJfU1BBQ0U7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfQVRUUl9OT1FVT1RfVkFMVUU6XHJcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBzb3VyY2Uuc2xpY2Uoc3RhcnQscCkucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIFwiJyt2YWx1ZSsnXCIgbWlzc2VkIHF1b3QoXCIpISEnKTtcclxuXHRcdFx0XHRcdGVsLmFkZChhdHRyTmFtZSx2YWx1ZSxzdGFydClcclxuXHRcdFx0XHRjYXNlIFNfQVRUUl9FTkQ6XHJcblx0XHRcdFx0XHRzID0gU19UQUdfU1BBQ0U7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19UQUdfU1BBQ0U6XHJcblx0XHRcdFx0Ly9jYXNlIFNfRVE6XHJcblx0XHRcdFx0Ly9jYXNlIFNfQVRUUl9TUEFDRTpcclxuXHRcdFx0XHQvL1x0dm9pZCgpO2JyZWFrO1xyXG5cdFx0XHRcdC8vY2FzZSBTX1RBR19DTE9TRTpcclxuXHRcdFx0XHRcdC8vaWdub3JlIHdhcm5pbmdcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1lbHNley8vbm90IHNwYWNlXHJcbi8vU19UQUcsXHRTX0FUVFIsXHRTX0VRLFx0U19BVFRSX05PUVVPVF9WQUxVRVxyXG4vL1NfQVRUUl9TUEFDRSxcdFNfQVRUUl9FTkQsXHRTX1RBR19TUEFDRSwgU19UQUdfQ0xPU0VcclxuXHRcdFx0XHRzd2l0Y2gocyl7XHJcblx0XHRcdFx0Ly9jYXNlIFNfVEFHOnZvaWQoKTticmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19BVFRSOnZvaWQoKTticmVhaztcclxuXHRcdFx0XHQvL2Nhc2UgU19BVFRSX05PUVVPVF9WQUxVRTp2b2lkKCk7YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX0FUVFJfU1BBQ0U6XHJcblx0XHRcdFx0XHR2YXIgdGFnTmFtZSA9ICBlbC50YWdOYW1lO1xyXG5cdFx0XHRcdFx0aWYoY3VycmVudE5TTWFwWycnXSAhPT0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnIHx8ICFhdHRyTmFtZS5tYXRjaCgvXig/OmRpc2FibGVkfGNoZWNrZWR8c2VsZWN0ZWQpJC9pKSl7XHJcblx0XHRcdFx0XHRcdGVycm9ySGFuZGxlci53YXJuaW5nKCdhdHRyaWJ1dGUgXCInK2F0dHJOYW1lKydcIiBtaXNzZWQgdmFsdWUhISBcIicrYXR0ck5hbWUrJ1wiIGluc3RlYWQyISEnKVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0ZWwuYWRkKGF0dHJOYW1lLGF0dHJOYW1lLHN0YXJ0KTtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gcDtcclxuXHRcdFx0XHRcdHMgPSBTX0FUVFI7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlIFNfQVRUUl9FTkQ6XHJcblx0XHRcdFx0XHRlcnJvckhhbmRsZXIud2FybmluZygnYXR0cmlidXRlIHNwYWNlIGlzIHJlcXVpcmVkXCInK2F0dHJOYW1lKydcIiEhJylcclxuXHRcdFx0XHRjYXNlIFNfVEFHX1NQQUNFOlxyXG5cdFx0XHRcdFx0cyA9IFNfQVRUUjtcclxuXHRcdFx0XHRcdHN0YXJ0ID0gcDtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgU19FUTpcclxuXHRcdFx0XHRcdHMgPSBTX0FUVFJfTk9RVU9UX1ZBTFVFO1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBwO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSBTX1RBR19DTE9TRTpcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcImVsZW1lbnRzIGNsb3NlZCBjaGFyYWN0ZXIgJy8nIGFuZCAnPicgbXVzdCBiZSBjb25uZWN0ZWQgdG9cIik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9Ly9lbmQgb3V0ZXIgc3dpdGNoXHJcblx0XHQvL2NvbnNvbGUubG9nKCdwKysnLHApXHJcblx0XHRwKys7XHJcblx0fVxyXG59XHJcbi8qKlxyXG4gKiBAcmV0dXJuIHRydWUgaWYgaGFzIG5ldyBuYW1lc3BhY2UgZGVmaW5lXHJcbiAqL1xyXG5mdW5jdGlvbiBhcHBlbmRFbGVtZW50KGVsLGRvbUJ1aWxkZXIsY3VycmVudE5TTWFwKXtcclxuXHR2YXIgdGFnTmFtZSA9IGVsLnRhZ05hbWU7XHJcblx0dmFyIGxvY2FsTlNNYXAgPSBudWxsO1xyXG5cdC8vdmFyIGN1cnJlbnROU01hcCA9IHBhcnNlU3RhY2tbcGFyc2VTdGFjay5sZW5ndGgtMV0uY3VycmVudE5TTWFwO1xyXG5cdHZhciBpID0gZWwubGVuZ3RoO1xyXG5cdHdoaWxlKGktLSl7XHJcblx0XHR2YXIgYSA9IGVsW2ldO1xyXG5cdFx0dmFyIHFOYW1lID0gYS5xTmFtZTtcclxuXHRcdHZhciB2YWx1ZSA9IGEudmFsdWU7XHJcblx0XHR2YXIgbnNwID0gcU5hbWUuaW5kZXhPZignOicpO1xyXG5cdFx0aWYobnNwPjApe1xyXG5cdFx0XHR2YXIgcHJlZml4ID0gYS5wcmVmaXggPSBxTmFtZS5zbGljZSgwLG5zcCk7XHJcblx0XHRcdHZhciBsb2NhbE5hbWUgPSBxTmFtZS5zbGljZShuc3ArMSk7XHJcblx0XHRcdHZhciBuc1ByZWZpeCA9IHByZWZpeCA9PT0gJ3htbG5zJyAmJiBsb2NhbE5hbWVcclxuXHRcdH1lbHNle1xyXG5cdFx0XHRsb2NhbE5hbWUgPSBxTmFtZTtcclxuXHRcdFx0cHJlZml4ID0gbnVsbFxyXG5cdFx0XHRuc1ByZWZpeCA9IHFOYW1lID09PSAneG1sbnMnICYmICcnXHJcblx0XHR9XHJcblx0XHQvL2NhbiBub3Qgc2V0IHByZWZpeCxiZWNhdXNlIHByZWZpeCAhPT0gJydcclxuXHRcdGEubG9jYWxOYW1lID0gbG9jYWxOYW1lIDtcclxuXHRcdC8vcHJlZml4ID09IG51bGwgZm9yIG5vIG5zIHByZWZpeCBhdHRyaWJ1dGUgXHJcblx0XHRpZihuc1ByZWZpeCAhPT0gZmFsc2Upey8vaGFjayEhXHJcblx0XHRcdGlmKGxvY2FsTlNNYXAgPT0gbnVsbCl7XHJcblx0XHRcdFx0bG9jYWxOU01hcCA9IHt9XHJcblx0XHRcdFx0Ly9jb25zb2xlLmxvZyhjdXJyZW50TlNNYXAsMClcclxuXHRcdFx0XHRfY29weShjdXJyZW50TlNNYXAsY3VycmVudE5TTWFwPXt9KVxyXG5cdFx0XHRcdC8vY29uc29sZS5sb2coY3VycmVudE5TTWFwLDEpXHJcblx0XHRcdH1cclxuXHRcdFx0Y3VycmVudE5TTWFwW25zUHJlZml4XSA9IGxvY2FsTlNNYXBbbnNQcmVmaXhdID0gdmFsdWU7XHJcblx0XHRcdGEudXJpID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAveG1sbnMvJ1xyXG5cdFx0XHRkb21CdWlsZGVyLnN0YXJ0UHJlZml4TWFwcGluZyhuc1ByZWZpeCwgdmFsdWUpIFxyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgaSA9IGVsLmxlbmd0aDtcclxuXHR3aGlsZShpLS0pe1xyXG5cdFx0YSA9IGVsW2ldO1xyXG5cdFx0dmFyIHByZWZpeCA9IGEucHJlZml4O1xyXG5cdFx0aWYocHJlZml4KXsvL25vIHByZWZpeCBhdHRyaWJ1dGUgaGFzIG5vIG5hbWVzcGFjZVxyXG5cdFx0XHRpZihwcmVmaXggPT09ICd4bWwnKXtcclxuXHRcdFx0XHRhLnVyaSA9ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnO1xyXG5cdFx0XHR9aWYocHJlZml4ICE9PSAneG1sbnMnKXtcclxuXHRcdFx0XHRhLnVyaSA9IGN1cnJlbnROU01hcFtwcmVmaXggfHwgJyddXHJcblx0XHRcdFx0XHJcblx0XHRcdFx0Ly97Y29uc29sZS5sb2coJyMjIycrYS5xTmFtZSxkb21CdWlsZGVyLmxvY2F0b3Iuc3lzdGVtSWQrJycsY3VycmVudE5TTWFwLGEudXJpKX1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHR2YXIgbnNwID0gdGFnTmFtZS5pbmRleE9mKCc6Jyk7XHJcblx0aWYobnNwPjApe1xyXG5cdFx0cHJlZml4ID0gZWwucHJlZml4ID0gdGFnTmFtZS5zbGljZSgwLG5zcCk7XHJcblx0XHRsb2NhbE5hbWUgPSBlbC5sb2NhbE5hbWUgPSB0YWdOYW1lLnNsaWNlKG5zcCsxKTtcclxuXHR9ZWxzZXtcclxuXHRcdHByZWZpeCA9IG51bGw7Ly9pbXBvcnRhbnQhIVxyXG5cdFx0bG9jYWxOYW1lID0gZWwubG9jYWxOYW1lID0gdGFnTmFtZTtcclxuXHR9XHJcblx0Ly9ubyBwcmVmaXggZWxlbWVudCBoYXMgZGVmYXVsdCBuYW1lc3BhY2VcclxuXHR2YXIgbnMgPSBlbC51cmkgPSBjdXJyZW50TlNNYXBbcHJlZml4IHx8ICcnXTtcclxuXHRkb21CdWlsZGVyLnN0YXJ0RWxlbWVudChucyxsb2NhbE5hbWUsdGFnTmFtZSxlbCk7XHJcblx0Ly9lbmRQcmVmaXhNYXBwaW5nIGFuZCBzdGFydFByZWZpeE1hcHBpbmcgaGF2ZSBub3QgYW55IGhlbHAgZm9yIGRvbSBidWlsZGVyXHJcblx0Ly9sb2NhbE5TTWFwID0gbnVsbFxyXG5cdGlmKGVsLmNsb3NlZCl7XHJcblx0XHRkb21CdWlsZGVyLmVuZEVsZW1lbnQobnMsbG9jYWxOYW1lLHRhZ05hbWUpO1xyXG5cdFx0aWYobG9jYWxOU01hcCl7XHJcblx0XHRcdGZvcihwcmVmaXggaW4gbG9jYWxOU01hcCl7XHJcblx0XHRcdFx0ZG9tQnVpbGRlci5lbmRQcmVmaXhNYXBwaW5nKHByZWZpeCkgXHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9ZWxzZXtcclxuXHRcdGVsLmN1cnJlbnROU01hcCA9IGN1cnJlbnROU01hcDtcclxuXHRcdGVsLmxvY2FsTlNNYXAgPSBsb2NhbE5TTWFwO1xyXG5cdFx0Ly9wYXJzZVN0YWNrLnB1c2goZWwpO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG59XHJcbmZ1bmN0aW9uIHBhcnNlSHRtbFNwZWNpYWxDb250ZW50KHNvdXJjZSxlbFN0YXJ0RW5kLHRhZ05hbWUsZW50aXR5UmVwbGFjZXIsZG9tQnVpbGRlcil7XHJcblx0aWYoL14oPzpzY3JpcHR8dGV4dGFyZWEpJC9pLnRlc3QodGFnTmFtZSkpe1xyXG5cdFx0dmFyIGVsRW5kU3RhcnQgPSAgc291cmNlLmluZGV4T2YoJzwvJyt0YWdOYW1lKyc+JyxlbFN0YXJ0RW5kKTtcclxuXHRcdHZhciB0ZXh0ID0gc291cmNlLnN1YnN0cmluZyhlbFN0YXJ0RW5kKzEsZWxFbmRTdGFydCk7XHJcblx0XHRpZigvWyY8XS8udGVzdCh0ZXh0KSl7XHJcblx0XHRcdGlmKC9ec2NyaXB0JC9pLnRlc3QodGFnTmFtZSkpe1xyXG5cdFx0XHRcdC8vaWYoIS9cXF1cXF0+Ly50ZXN0KHRleHQpKXtcclxuXHRcdFx0XHRcdC8vbGV4SGFuZGxlci5zdGFydENEQVRBKCk7XHJcblx0XHRcdFx0XHRkb21CdWlsZGVyLmNoYXJhY3RlcnModGV4dCwwLHRleHQubGVuZ3RoKTtcclxuXHRcdFx0XHRcdC8vbGV4SGFuZGxlci5lbmRDREFUQSgpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIGVsRW5kU3RhcnQ7XHJcblx0XHRcdFx0Ly99XHJcblx0XHRcdH0vL31lbHNley8vdGV4dCBhcmVhXHJcblx0XHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSgvJiM/XFx3KzsvZyxlbnRpdHlSZXBsYWNlcik7XHJcblx0XHRcdFx0ZG9tQnVpbGRlci5jaGFyYWN0ZXJzKHRleHQsMCx0ZXh0Lmxlbmd0aCk7XHJcblx0XHRcdFx0cmV0dXJuIGVsRW5kU3RhcnQ7XHJcblx0XHRcdC8vfVxyXG5cdFx0XHRcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIGVsU3RhcnRFbmQrMTtcclxufVxyXG5mdW5jdGlvbiBmaXhTZWxmQ2xvc2VkKHNvdXJjZSxlbFN0YXJ0RW5kLHRhZ05hbWUsY2xvc2VNYXApe1xyXG5cdC8vaWYodGFnTmFtZSBpbiBjbG9zZU1hcCl7XHJcblx0dmFyIHBvcyA9IGNsb3NlTWFwW3RhZ05hbWVdO1xyXG5cdGlmKHBvcyA9PSBudWxsKXtcclxuXHRcdC8vY29uc29sZS5sb2codGFnTmFtZSlcclxuXHRcdHBvcyA9ICBzb3VyY2UubGFzdEluZGV4T2YoJzwvJyt0YWdOYW1lKyc+JylcclxuXHRcdGlmKHBvczxlbFN0YXJ0RW5kKXsvL+W/mOiusOmXreWQiFxyXG5cdFx0XHRwb3MgPSBzb3VyY2UubGFzdEluZGV4T2YoJzwvJyt0YWdOYW1lKVxyXG5cdFx0fVxyXG5cdFx0Y2xvc2VNYXBbdGFnTmFtZV0gPXBvc1xyXG5cdH1cclxuXHRyZXR1cm4gcG9zPGVsU3RhcnRFbmQ7XHJcblx0Ly99IFxyXG59XHJcbmZ1bmN0aW9uIF9jb3B5KHNvdXJjZSx0YXJnZXQpe1xyXG5cdGZvcih2YXIgbiBpbiBzb3VyY2Upe3RhcmdldFtuXSA9IHNvdXJjZVtuXX1cclxufVxyXG5mdW5jdGlvbiBwYXJzZURDQyhzb3VyY2Usc3RhcnQsZG9tQnVpbGRlcixlcnJvckhhbmRsZXIpey8vc3VyZSBzdGFydCB3aXRoICc8ISdcclxuXHR2YXIgbmV4dD0gc291cmNlLmNoYXJBdChzdGFydCsyKVxyXG5cdHN3aXRjaChuZXh0KXtcclxuXHRjYXNlICctJzpcclxuXHRcdGlmKHNvdXJjZS5jaGFyQXQoc3RhcnQgKyAzKSA9PT0gJy0nKXtcclxuXHRcdFx0dmFyIGVuZCA9IHNvdXJjZS5pbmRleE9mKCctLT4nLHN0YXJ0KzQpO1xyXG5cdFx0XHQvL2FwcGVuZCBjb21tZW50IHNvdXJjZS5zdWJzdHJpbmcoNCxlbmQpLy88IS0tXHJcblx0XHRcdGlmKGVuZD5zdGFydCl7XHJcblx0XHRcdFx0ZG9tQnVpbGRlci5jb21tZW50KHNvdXJjZSxzdGFydCs0LGVuZC1zdGFydC00KTtcclxuXHRcdFx0XHRyZXR1cm4gZW5kKzM7XHJcblx0XHRcdH1lbHNle1xyXG5cdFx0XHRcdGVycm9ySGFuZGxlci5lcnJvcihcIlVuY2xvc2VkIGNvbW1lbnRcIik7XHJcblx0XHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0XHR9XHJcblx0XHR9ZWxzZXtcclxuXHRcdFx0Ly9lcnJvclxyXG5cdFx0XHRyZXR1cm4gLTE7XHJcblx0XHR9XHJcblx0ZGVmYXVsdDpcclxuXHRcdGlmKHNvdXJjZS5zdWJzdHIoc3RhcnQrMyw2KSA9PSAnQ0RBVEFbJyl7XHJcblx0XHRcdHZhciBlbmQgPSBzb3VyY2UuaW5kZXhPZignXV0+JyxzdGFydCs5KTtcclxuXHRcdFx0ZG9tQnVpbGRlci5zdGFydENEQVRBKCk7XHJcblx0XHRcdGRvbUJ1aWxkZXIuY2hhcmFjdGVycyhzb3VyY2Usc3RhcnQrOSxlbmQtc3RhcnQtOSk7XHJcblx0XHRcdGRvbUJ1aWxkZXIuZW5kQ0RBVEEoKSBcclxuXHRcdFx0cmV0dXJuIGVuZCszO1xyXG5cdFx0fVxyXG5cdFx0Ly88IURPQ1RZUEVcclxuXHRcdC8vc3RhcnREVEQoamF2YS5sYW5nLlN0cmluZyBuYW1lLCBqYXZhLmxhbmcuU3RyaW5nIHB1YmxpY0lkLCBqYXZhLmxhbmcuU3RyaW5nIHN5c3RlbUlkKSBcclxuXHRcdHZhciBtYXRjaHMgPSBzcGxpdChzb3VyY2Usc3RhcnQpO1xyXG5cdFx0dmFyIGxlbiA9IG1hdGNocy5sZW5ndGg7XHJcblx0XHRpZihsZW4+MSAmJiAvIWRvY3R5cGUvaS50ZXN0KG1hdGNoc1swXVswXSkpe1xyXG5cdFx0XHR2YXIgbmFtZSA9IG1hdGNoc1sxXVswXTtcclxuXHRcdFx0dmFyIHB1YmlkID0gbGVuPjMgJiYgL15wdWJsaWMkL2kudGVzdChtYXRjaHNbMl1bMF0pICYmIG1hdGNoc1szXVswXVxyXG5cdFx0XHR2YXIgc3lzaWQgPSBsZW4+NCAmJiBtYXRjaHNbNF1bMF07XHJcblx0XHRcdHZhciBsYXN0TWF0Y2ggPSBtYXRjaHNbbGVuLTFdXHJcblx0XHRcdGRvbUJ1aWxkZXIuc3RhcnREVEQobmFtZSxwdWJpZCAmJiBwdWJpZC5yZXBsYWNlKC9eKFsnXCJdKSguKj8pXFwxJC8sJyQyJyksXHJcblx0XHRcdFx0XHRzeXNpZCAmJiBzeXNpZC5yZXBsYWNlKC9eKFsnXCJdKSguKj8pXFwxJC8sJyQyJykpO1xyXG5cdFx0XHRkb21CdWlsZGVyLmVuZERURCgpO1xyXG5cdFx0XHRcclxuXHRcdFx0cmV0dXJuIGxhc3RNYXRjaC5pbmRleCtsYXN0TWF0Y2hbMF0ubGVuZ3RoXHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiAtMTtcclxufVxyXG5cclxuXHJcblxyXG5mdW5jdGlvbiBwYXJzZUluc3RydWN0aW9uKHNvdXJjZSxzdGFydCxkb21CdWlsZGVyKXtcclxuXHR2YXIgZW5kID0gc291cmNlLmluZGV4T2YoJz8+JyxzdGFydCk7XHJcblx0aWYoZW5kKXtcclxuXHRcdHZhciBtYXRjaCA9IHNvdXJjZS5zdWJzdHJpbmcoc3RhcnQsZW5kKS5tYXRjaCgvXjxcXD8oXFxTKilcXHMqKFtcXHNcXFNdKj8pXFxzKiQvKTtcclxuXHRcdGlmKG1hdGNoKXtcclxuXHRcdFx0dmFyIGxlbiA9IG1hdGNoWzBdLmxlbmd0aDtcclxuXHRcdFx0ZG9tQnVpbGRlci5wcm9jZXNzaW5nSW5zdHJ1Y3Rpb24obWF0Y2hbMV0sIG1hdGNoWzJdKSA7XHJcblx0XHRcdHJldHVybiBlbmQrMjtcclxuXHRcdH1lbHNley8vZXJyb3JcclxuXHRcdFx0cmV0dXJuIC0xO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gLTE7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBAcGFyYW0gc291cmNlXHJcbiAqL1xyXG5mdW5jdGlvbiBFbGVtZW50QXR0cmlidXRlcyhzb3VyY2Upe1xyXG5cdFxyXG59XHJcbkVsZW1lbnRBdHRyaWJ1dGVzLnByb3RvdHlwZSA9IHtcclxuXHRzZXRUYWdOYW1lOmZ1bmN0aW9uKHRhZ05hbWUpe1xyXG5cdFx0aWYoIXRhZ05hbWVQYXR0ZXJuLnRlc3QodGFnTmFtZSkpe1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgdGFnTmFtZTonK3RhZ05hbWUpXHJcblx0XHR9XHJcblx0XHR0aGlzLnRhZ05hbWUgPSB0YWdOYW1lXHJcblx0fSxcclxuXHRhZGQ6ZnVuY3Rpb24ocU5hbWUsdmFsdWUsb2Zmc2V0KXtcclxuXHRcdGlmKCF0YWdOYW1lUGF0dGVybi50ZXN0KHFOYW1lKSl7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhdHRyaWJ1dGU6JytxTmFtZSlcclxuXHRcdH1cclxuXHRcdHRoaXNbdGhpcy5sZW5ndGgrK10gPSB7cU5hbWU6cU5hbWUsdmFsdWU6dmFsdWUsb2Zmc2V0Om9mZnNldH1cclxuXHR9LFxyXG5cdGxlbmd0aDowLFxyXG5cdGdldExvY2FsTmFtZTpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS5sb2NhbE5hbWV9LFxyXG5cdGdldExvY2F0b3I6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0ubG9jYXRvcn0sXHJcblx0Z2V0UU5hbWU6ZnVuY3Rpb24oaSl7cmV0dXJuIHRoaXNbaV0ucU5hbWV9LFxyXG5cdGdldFVSSTpmdW5jdGlvbihpKXtyZXR1cm4gdGhpc1tpXS51cml9LFxyXG5cdGdldFZhbHVlOmZ1bmN0aW9uKGkpe3JldHVybiB0aGlzW2ldLnZhbHVlfVxyXG4vL1x0LGdldEluZGV4OmZ1bmN0aW9uKHVyaSwgbG9jYWxOYW1lKSl7XHJcbi8vXHRcdGlmKGxvY2FsTmFtZSl7XHJcbi8vXHRcdFx0XHJcbi8vXHRcdH1lbHNle1xyXG4vL1x0XHRcdHZhciBxTmFtZSA9IHVyaVxyXG4vL1x0XHR9XHJcbi8vXHR9LFxyXG4vL1x0Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRWYWx1ZSh0aGlzLmdldEluZGV4LmFwcGx5KHRoaXMsYXJndW1lbnRzKSl9LFxyXG4vL1x0Z2V0VHlwZTpmdW5jdGlvbih1cmksbG9jYWxOYW1lKXt9XHJcbi8vXHRnZXRUeXBlOmZ1bmN0aW9uKGkpe30sXHJcbn1cclxuXHJcblxyXG5cclxuXHJcbmZ1bmN0aW9uIF9zZXRfcHJvdG9fKHRoaXoscGFyZW50KXtcclxuXHR0aGl6Ll9fcHJvdG9fXyA9IHBhcmVudDtcclxuXHRyZXR1cm4gdGhpejtcclxufVxyXG5pZighKF9zZXRfcHJvdG9fKHt9LF9zZXRfcHJvdG9fLnByb3RvdHlwZSkgaW5zdGFuY2VvZiBfc2V0X3Byb3RvXykpe1xyXG5cdF9zZXRfcHJvdG9fID0gZnVuY3Rpb24odGhpeixwYXJlbnQpe1xyXG5cdFx0ZnVuY3Rpb24gcCgpe307XHJcblx0XHRwLnByb3RvdHlwZSA9IHBhcmVudDtcclxuXHRcdHAgPSBuZXcgcCgpO1xyXG5cdFx0Zm9yKHBhcmVudCBpbiB0aGl6KXtcclxuXHRcdFx0cFtwYXJlbnRdID0gdGhpeltwYXJlbnRdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHA7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBzcGxpdChzb3VyY2Usc3RhcnQpe1xyXG5cdHZhciBtYXRjaDtcclxuXHR2YXIgYnVmID0gW107XHJcblx0dmFyIHJlZyA9IC8nW14nXSsnfFwiW15cIl0rXCJ8W15cXHM8PlxcLz1dKz0/fChcXC8/XFxzKj58PCkvZztcclxuXHRyZWcubGFzdEluZGV4ID0gc3RhcnQ7XHJcblx0cmVnLmV4ZWMoc291cmNlKTsvL3NraXAgPFxyXG5cdHdoaWxlKG1hdGNoID0gcmVnLmV4ZWMoc291cmNlKSl7XHJcblx0XHRidWYucHVzaChtYXRjaCk7XHJcblx0XHRpZihtYXRjaFsxXSlyZXR1cm4gYnVmO1xyXG5cdH1cclxufVxyXG5cclxuZXhwb3J0cy5YTUxSZWFkZXIgPSBYTUxSZWFkZXI7XHJcblxyXG4iLCIvKipcbiAqIEVudHJ5U3RvcmUgaXMgdGhlIG1haW4gY2xhc3MgdGhhdCBpcyB1c2VkIHRvIGNvbm5lY3QgdG8gYSBydW5uaW5nIHNlcnZlci1zaWRlXG4gKiBFbnRyeVN0b3JlIHJlcG9zaXRvcnkuXG4gKiBAZXhwb3J0cyBzdG9yZS9BdXRoXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RvcmUvRW50cnlTdG9yZX0gZW50cnlzdG9yZSAtIGEgcmVwb3NpdG9yeSBpbnN0YW5jZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudHJ5c3RvcmUpIHtcbiAgICB0aGlzLmVudHJ5c3RvcmUgPSBlbnRyeXN0b3JlO1xuICAgIHRoaXMuX2xpc3RlbmVyQ291bnRlciA9IDA7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgRnVuY3Rpb24+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fbGlzdGVuZXJzSWR4ID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgbWVzc2FnZUxpc3RlbmVycyh0b3BpYywgb2JqKSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzSWR4LmZvckVhY2goKGZ1bmMpID0+IHtcbiAgICAgIGZ1bmModG9waWMsIG9iaik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhbiBhdXRoZW50aWZpY2F0aW9uIGxpc3RlbmVyLCBpdCB3aWxsIGJlIG5vdGlmaWVkIG9mIGxvZ2luIGFuZCBsb2dvdXQgZXZlbnRzLlxuICAgKiBAcGFyYW0ge2F1dGhMaXN0ZW5lcn0gbGlzdGVuZXJcbiAgICovXG4gIGFkZEF1dGhMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5fX2FsaWQgPT0gbnVsbCkge1xuICAgICAgbGlzdGVuZXIuX19hbGlkID0gYGlkeF8ke3RoaXMuX2xpc3RlbmVyQ291bnRlcn1gO1xuICAgICAgdGhpcy5fbGlzdGVuZXJDb3VudGVyICs9IDE7XG4gICAgfVxuICAgIHRoaXMuX2xpc3RlbmVyc0lkeC5zZXQobGlzdGVuZXIuX19hbGlkLCBsaXN0ZW5lcik7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBhdXRoZW50aWZpY2F0aW9uIGxpc3RlbmVyLlxuICAgKiBAcGFyYW0ge2F1dGhMaXN0ZW5lcn0gbGlzdGVuZXJcbiAgICovXG4gIHJlbW92ZUF1dGhMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lci5fX2FsaWQgIT0gbnVsbCkge1xuICAgICAgdGhpcy5fbGlzdGVuZXJzSWR4LmRlbGV0ZShsaXN0ZW5lci5fX2FsaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBZaWVsZHMgaW5mb3JtYXRpb24gYWJvdXQgd2hvIGN1cnJlbnRseSBpcyBhdXRoZW50aWNhdGVkIGFnYWluc3QgdGhlIEVudHJ5U3RvcmUgcmVwb3NpdG9yeS5cbiAgICogQHJldHVybnMge1Byb21pc2UuPHN0b3JlL0VudHJ5SW5mbz59IC0gdXBvbiBzdWNjZXNzIGFuIG9iamVjdCBjb250YWluaW5nIGF0dHJpYnV0ZXMgXCJ1c2VyXCIgYmVpbmdcbiAgICogdGhlIHVzZXJuYW1lLCBcImlkXCIgb2YgdGhlIHVzZXIgZW50cnksXG4gICAqIGFuZCBcImhvbWVjb250ZXh0XCIgYmVpbmcgdGhlIGVudHJ5LWlkIG9mIHRoZSBob21lIGNvbnRleHQgaXMgcHJvdmlkZWQuXG4gICAqIEBzZWUge0BsaW5rIHN0b3JlL0VudHJ5U3RvcmUjYXV0aCBhdXRofVxuICAgKiBAc2VlIHtAbGluayBzdG9yZS9FbnRyeVN0b3JlI2xvZ291dCBsb2dvdXR9XG4gICAqL1xuICBhc3luYyBnZXRVc2VySW5mbyhmb3JjZUxvb2t1cCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMudXNlckluZm8gJiYgIWZvcmNlTG9va3VwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudXNlckluZm8pO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3VpRGVmKSB7XG4gICAgICB0aGlzLl91aURlZiA9IHRoaXMuZW50cnlzdG9yZS5nZXRSRVNUKCkuZ2V0KGAke3RoaXMuZW50cnlzdG9yZS5fYmFzZVVSSX1hdXRoL3VzZXJgLCBudWxsLCB0cnVlKTtcbiAgICAgIHRoaXMuZW50cnlzdG9yZS5oYW5kbGVBc3luYyh0aGlzLl91aURlZiwgJ2dldFVzZXJJbmZvJyk7XG4gICAgICB0aGlzLnVzZXJJbmZvID0gYXdhaXQgdGhpcy5fdWlEZWY7XG4gICAgICBkZWxldGUgdGhpcy5fdWlEZWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3VpRGVmO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxzdG9yZS9FbnRyeT59IG9uIHN1Y2Nlc3MgdGhlIGVudHJ5IGZvciB0aGUgY3VycmVudGx5IHNpZ25lZCBpbiB1c2VyIGlzIHByb3ZpZGVkLlxuICAgKi9cbiAgYXN5bmMgZ2V0VXNlckVudHJ5KGZvcmNlTG9va3VwID0gZmFsc2UpIHtcbiAgICBpZiAodGhpcy51c2VyRW50cnkgJiYgIWZvcmNlTG9va3VwKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMudXNlckVudHJ5KTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX3VlRGVmKSB7XG4gICAgICB0aGlzLl91ZURlZiA9IHRoaXMuZ2V0VXNlckluZm8oZm9yY2VMb29rdXApO1xuICAgICAgY29uc3QgdXNlckluZm8gPSBhd2FpdCB0aGlzLl91ZURlZjtcbiAgICAgIHRoaXMudXNlckVudHJ5ID0gYXdhaXQgdGhpcy5lbnRyeXN0b3JlLmdldEVudHJ5KHRoaXMuZW50cnlzdG9yZS5nZXRFbnRyeVVSSSgnX3ByaW5jaXBhbHMnLCB1c2VySW5mby5pZCksIHtcbiAgICAgICAgYXN5bmNDb250ZXh0OiAnZ2V0VXNlckVudHJ5JyxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy51c2VyRW50cnk7XG4gIH1cblxuICAvKipcbiAgICogQXV0aGVudGljYXRlIHVzaW5nIGNyZWRlbnRpYWxzIGNvbnRhaW5pbmcgYSB1c2VyLCBhIHBhc3N3b3JkIGFuZCBhbiBvcHRpb25hbCBtYXhBZ2VcbiAgICogZ2l2ZW4gaW4gc2Vjb25kcy5cbiAgICpcbiAgICogQHBhcmFtIHVzZXJcbiAgICogQHBhcmFtIHBhc3N3b3JkXG4gICAqIEBwYXJhbSBtYXhBZ2VcbiAgICogQHJldHVybnMge3hoclByb21pc2V9XG4gICAqL1xuICBhc3luYyBsb2dpbih1c2VyLCBwYXNzd29yZCwgbWF4QWdlKSB7XG4gICAgaWYgKHRoaXMudXNlckluZm8gJiYgdGhpcy51c2VySW5mby51c2VyID09PSB1c2VyKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVc2VySW5mbygpO1xuICAgIH1cblxuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0ge1xuICAgICAgYmFzZTogdGhpcy5lbnRyeXN0b3JlLmdldEJhc2VVUkkoKSxcbiAgICAgIHVzZXIsXG4gICAgICBwYXNzd29yZCxcbiAgICAgIG1heEFnZSxcbiAgICB9O1xuXG4gICAgY29uc3QgYXV0aFByb21pc2UgPSB0aGlzLmVudHJ5c3RvcmUuZ2V0UkVTVCgpLmF1dGgoY3JlZGVudGlhbHMpO1xuICAgIHRoaXMuZW50cnlzdG9yZS5oYW5kbGVBc3luYyhhdXRoUHJvbWlzZSwgJ2xvZ2luJyk7XG4gICAgY29uc3QgYXV0aCA9IGF3YWl0IGF1dGhQcm9taXNlO1xuICAgIGlmICh0eXBlb2YgYXV0aCA9PT0gJ29iamVjdCcgJiYgYXV0aC51c2VyKSB7XG4gICAgICByZXR1cm4gYXV0aDtcbiAgICB9XG4gICAgY29uc3QgdXNlckluZm8gPSBhd2FpdCB0aGlzLmVudHJ5c3RvcmUuZ2V0UkVTVCgpLmdldChgJHt0aGlzLmVudHJ5c3RvcmUuX2Jhc2VVUkl9YXV0aC91c2VyYCwgbnVsbCwgdHJ1ZSk7XG5cbiAgICBpZiAodGhpcy5fdWlEZWYpIHtcbiAgICAgIHRoaXMuX3VpRGVmLmNhbmNlbCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdWVEZWYpIHtcbiAgICAgIHRoaXMuX3VlRGVmLmNhbmNlbCgpO1xuICAgIH1cblxuICAgIHRoaXMudXNlckluZm8gPSB1c2VySW5mbztcbiAgICBkZWxldGUgdGhpcy51c2VyRW50cnk7XG4gICAgdGhpcy5lbnRyeXN0b3JlLmdldENhY2hlKCkuYWxsTmVlZFJlZnJlc2goKTtcbiAgICB0aGlzLm1lc3NhZ2VMaXN0ZW5lcnMoJ2xvZ2luJywgdXNlckluZm8pO1xuXG4gICAgcmV0dXJuIHVzZXJJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIExvZ291dCB0aGUgY3VycmVudGx5IGF1dGhvcml6ZWQgdXNlci5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBsb2dvdXQoKSB7XG4gICAgaWYgKHRoaXMudXNlckluZm8gJiYgdGhpcy51c2VySW5mby51c2VyID09PSAnZ3Vlc3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRVc2VySW5mbygpO1xuICAgIH1cblxuICAgIGNvbnN0IGNyZWRlbnRpYWxzID0ge1xuICAgICAgYmFzZTogdGhpcy5lbnRyeXN0b3JlLmdldEJhc2VVUkkoKSxcbiAgICAgIGxvZ291dDogdHJ1ZSxcbiAgICB9O1xuXG4gICAgY29uc3QgbG9nb3V0UHJvbWlzZSA9IHRoaXMuZW50cnlzdG9yZS5nZXRSRVNUKCkuYXV0aChjcmVkZW50aWFscyk7XG4gICAgdGhpcy5lbnRyeXN0b3JlLmhhbmRsZUFzeW5jKGxvZ291dFByb21pc2UsICdsb2dvdXQnKTtcblxuICAgIHRoaXMudXNlckluZm8gPSB7IHVzZXI6ICdndWVzdCcsIGlkOiAnX2d1ZXN0JyB9O1xuICAgIGRlbGV0ZSB0aGlzLnVzZXJFbnRyeTtcbiAgICB0aGlzLmVudHJ5c3RvcmUuZ2V0Q2FjaGUoKS5hbGxOZWVkUmVmcmVzaCgpO1xuICAgIHRoaXMubWVzc2FnZUxpc3RlbmVycygnbG9nb3V0JywgdGhpcy51c2VySW5mbyk7XG5cbiAgICByZXR1cm4gdGhpcy51c2VySW5mbztcbiAgfVxufVxuXG4vKipcbiAqIEBuYW1lIHVzZXJJbmZvUHJvbWlzZVxuICogQGV4dGVuZHMgeGhyUHJvbWlzZVxuICogQGNsYXNzXG4gKi9cbi8qKlxuICogQG5hbWUgdXNlckluZm9Qcm9taXNlI3RoZW5cbiAqIEBwYXJhbSB7dXNlckluZm9DYWxsYmFja30gb25TdWNjZXNzXG4gKiBAcGFyYW0ge3hockZhaWx1cmVDYWxsYmFja30gb25FcnJvclxuICovXG4vKipcbiAqIEBjYWxsYmFjayB1c2VySW5mb0NhbGxiYWNrXG4gKiBAcGFyYW0ge3VzZXJJbmZvfSByZXNvdXJjZVxuICovXG4vKipcbiAqIEBuYW1lIHVzZXJJbmZvXG4gKiBAbmFtZXNwYWNlXG4gKiBAcHJvcGVydHkge3N0cmluZ30gIHVzZXIgICAgICAgICAgICAgICAgICAgLSB0aGUgdXNlcm5hbWVcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgaWQgICAgICAgICAgICAgICAgICAgICAtIHRoZSBlbnRyeSBpZCBvZiB0aGUgdXNlcnMgZW50cnlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSAgaG9tZWNvbnRleHQgICAgICAgICAgICAtIHRoZSBlbnRyeSBpZCBvZiB0aGUgdXNlcnMgaG9tZSBjb250ZXh0LlxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIGF1dGhMaXN0ZW5lclxuICogQHBhcmFtIHtzdHJpbmd9IHRvcGljIC0gZWl0aGVyIGxvZ2luIG9yIGxvZ291dC5cbiAqIEBwYXJhbSB7dXNlckluZm99IHVzZXJJbmZvIC0gYW4gb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgdXNlciBpbmZvcm1hdGlvblxuICovXG4iLCIvKipcbiAqIENhY2hlcyBsb2FkZWQgZW50cmllcyBhbmQga2VlcHMgdHJhY2sgb2Ygd2hpY2ggZW50cmllcyB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZCAocmVmcmVzaGVkKS5cbiAqIFRoZSBjYWNoZSBhbHNvIHByb3ZpZGVzIGEgbGlzdGVuZXIgZnVuY3Rpb25hbGl0eSB0aGF0IGFsbG93cyB5b3UgdG8gYmUgbm90aWZpZWQgb2ZcbiAqIHdoZW4gZW50cmllcyBhcmUgdXBkYXRlZC5cbiAqXG4gKiBAZXhwb3J0cyBzdG9yZS9DYWNoZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtNYXA8c3RyaW5nLCBGdW5jdGlvbj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9saXN0ZW5lcnNJZHggPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgc3RvcmUvRW50cnk+fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fY2FjaGVJZHggPSBuZXcgTWFwKCk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgU2V0PHN0b3JlL0VudHJ5Pj59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jYWNoZUlkeFJlc291cmNlID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUge01hcDxzdHJpbmcsIG9iamVjdD59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9jYWNoZUN0cmwgPSBuZXcgTWFwKCk7XG5cbiAgICB0aGlzLl9saXN0ZW5lckNvdW50ZXIgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBvciB1cGRhdGUgdGhlIGVudHJ5IHRvIHRoZSBjYWNoZS5cbiAgICogQWxsIGxpc3RlbmVycyB3aWxsIGJlIG5vdGlmaWVkIHVubGVzcyBzaWxlbnRseSBpcyBzcGVjaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RvcmUvRW50cnl9IGVudHJ5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IHNpbGVudGx5IC0gbGlzdGVuZXJzIHdpbGwgYmUgbm90aWZpZWQgdW5sZXNzIHRydWUgaXMgc3BlY2lmaWVkLlxuICAgKi9cbiAgY2FjaGUoZW50cnksIHNpbGVudGx5KSB7XG4gICAgY29uc3QgZW50cnlVUkkgPSBlbnRyeS5nZXRVUkkoKTtcbiAgICBjb25zdCBwcmV2aW91c2x5Q2FjaGVkID0gdGhpcy5fY2FjaGVJZHguaGFzKGVudHJ5VVJJKTtcblxuICAgIHRoaXMuX2NhY2hlSWR4LnNldChlbnRyeVVSSSwgZW50cnkpO1xuXG4gICAgY29uc3QgZW50cnlSVVJJID0gZW50cnkuZ2V0UmVzb3VyY2VVUkkoKTtcbiAgICBjb25zdCBlbnRyaWVzU2V0ID0gdGhpcy5fY2FjaGVJZHhSZXNvdXJjZS5oYXMoZW50cnlSVVJJKSA/IHRoaXMuX2NhY2hlSWR4UmVzb3VyY2UuZ2V0KGVudHJ5UlVSSSkgOiBuZXcgU2V0KCk7XG5cbiAgICBpZiAoIWVudHJpZXNTZXQuaGFzKGVudHJ5KSkge1xuICAgICAgZW50cmllc1NldC5hZGQoZW50cnkpO1xuICAgIH1cblxuICAgIHRoaXMuX2NhY2hlSWR4UmVzb3VyY2Uuc2V0KGVudHJ5UlVSSSwgZW50cmllc1NldCk7XG5cbiAgICB0aGlzLl9jYWNoZUN0cmwuc2V0KGVudHJ5VVJJLCB7XG4gICAgICBkYXRlOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICB9KTtcblxuICAgIGlmIChwcmV2aW91c2x5Q2FjaGVkICYmIHNpbGVudGx5ICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VMaXN0ZW5lcnMoJ3JlZnJlc2hlZCcsIGVudHJ5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIHNpbmdsZSBlbnRyeSBmcm9tIHRoZSBjYWNoZS5cbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeX0gZW50cnkgdGhlIGVudHJ5IHRvIHJlbW92ZS5cbiAgICovXG4gIHVuQ2FjaGUoZW50cnkpIHtcbiAgICBjb25zdCBlbnRyeVVSSSA9IGVudHJ5LmdldFVSSSgpO1xuICAgIGNvbnN0IGVudHJ5UlVSSSA9IGVudHJ5LmdldFJlc291cmNlVVJJKCk7XG5cbiAgICB0aGlzLl9jYWNoZUlkeC5kZWxldGUoZW50cnlVUkkpO1xuICAgIGNvbnN0IGVudHJpZXNTZXQgPSB0aGlzLl9jYWNoZUlkeFJlc291cmNlLmdldChlbnRyeVJVUkkpO1xuXG4gICAgaWYgKGVudHJpZXNTZXQuc2l6ZSA+IDApIHtcbiAgICAgIGVudHJpZXNTZXQuZGVsZXRlKGVudHJ5KTtcbiAgICAgIGlmIChlbnRyaWVzU2V0LnNpemUgPT09IDApIHtcbiAgICAgICAgdGhpcy5fY2FjaGVJZHhSZXNvdXJjZS5kZWxldGUoZW50cnlSVVJJKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTWFya3MgYW4gZW50cnkgYXMgaW4gbmVlZCBvZiByZWZyZXNoIGZyb20gdGhlIHN0b3JlLlxuICAgKiBBbGwgbGlzdGVuZXJzIGFyZSBub3RpZmllZCBvZiB0aGUgZW50cnkgbm93IGJlaW5nIGluIG5lZWQgb2YgcmVmcmVzaGluZyB1bmxlc3NcbiAgICogc2lsZW50bHkgaXMgc2V0IHRvIHRydWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RvcmUvRW50cnl9IGVudHJ5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IHNpbGVudGx5XG4gICAqL1xuICBzZXRSZWZyZXNoTmVlZGVkKGVudHJ5LCBzaWxlbnRseSkge1xuICAgIGNvbnN0IGVudHJ5VVJJID0gZW50cnkuZ2V0VVJJKCk7XG4gICAgY29uc3QgY3RybCA9IHRoaXMuX2NhY2hlQ3RybC5nZXQoZW50cnlVUkkpO1xuICAgIGlmIChjdHJsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gY2FjaGUgY29udHJvbCBvZiBleGlzdGluZyBlbnRyeTogJHtlbnRyeVVSSX1gKTtcbiAgICB9XG4gICAgY3RybC5zdGFsZSA9IHRydWU7XG4gICAgaWYgKHNpbGVudGx5ICE9PSB0cnVlKSB7XG4gICAgICB0aGlzLm1lc3NhZ2VMaXN0ZW5lcnMoJ25lZWRSZWZyZXNoJywgZW50cnkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBIGNvbnZlbmllbmNlIG1ldGhvZCBmb3IgY2FjaGluZyBtdWx0aXBsZSBlbnRyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5W119IGVudHJ5QXJyXG4gICAqIEBwYXJhbSB7Qm9vbGVhbj19IHNpbGVudGx5XG4gICAqIEBzZWUgc3RvcmUvQ2FjaGUjY2FjaGVcbiAgICovXG4gIGNhY2hlQWxsKGVudHJ5QXJyLCBzaWxlbnRseSkge1xuICAgIGVudHJ5QXJyLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICB0aGlzLmNhY2hlKGVudHJ5LCBzaWxlbnRseSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIGVudHJ5IGZyb20gaXQncyBVUkkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbnRyeVVSSVxuICAgKiBAcmV0dXJucyB7c3RvcmUvRW50cnl8dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0KGVudHJ5VVJJKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlSWR4LmdldChlbnRyeVVSSSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgYWxsIGVudHJpZXMgdGhhdCBoYXZlIHRoZSBzcGVjaWZpZWQgdXJpIGFzIHJlc291cmNlLlxuICAgKiBOb3RlIHRoYXQgc2luY2Ugc2V2ZXJhbCBlbnRyaWVzIChlLmcuIGxpbmtzKSBtYXkgaGF2ZSB0aGUgc2FtZSB1cmlcbiAgICogYXMgcmVzb3VyY2UgdGhpcyBtZXRob2QgcmV0dXJucyBhbiBhcnJheS4gSG93ZXZlciwgaW4gbWFueSBzaXR1YXRpb25zXG4gICAqIHRoZXJlIHdpbGwgYmUgemVybyBvciBvbmUgZW50cnkgcGVyIHVyaS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICAgKiBAcmV0dXJucyB7U2V0PHN0b3JlL0VudHJ5Pn0gYWx3YXlzIHJldHVybnMgYSBzZXQsIG1heSBiZSBlbXB0eSB0aG91Z2guXG4gICAqL1xuICBnZXRCeVJlc291cmNlVVJJKHVyaSkge1xuICAgIHJldHVybiBuZXcgU2V0KHRoaXMuX2NhY2hlSWR4UmVzb3VyY2UuZ2V0KHVyaSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlbGxzIHdoZXRoZXIgdGhlIGVudHJ5IGlzIGluIG5lZWQgb2YgYSByZWZyZXNoIGZyb20gdGhlIHJlcG9zaXRvcnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RvcmUvRW50cnl9IGVudHJ5XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgbmVlZFJlZnJlc2goZW50cnkpIHtcbiAgICBjb25zdCBlbnRyeVVSSSA9IGVudHJ5LmdldFVSSSgpO1xuICAgIGNvbnN0IGN0cmwgPSB0aGlzLl9jYWNoZUN0cmwuZ2V0KGVudHJ5VVJJKTtcbiAgICBpZiAoY3RybCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBFcnJvcihgTm8gY2FjaGUgY29udHJvbCBvZiBleGlzdGluZyBlbnRyeTogJHtlbnRyeVVSSX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGN0cmwuc3RhbGUgPT09IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXJcbiAgICovXG4gIGFkZENhY2hlVXBkYXRlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBpZiAobGlzdGVuZXIuX19jbGlkICE9IG51bGwpIHtcbiAgICAgIGxpc3RlbmVyLl9fY2xpZCA9IGBpZHhfJHt0aGlzLl9saXN0ZW5lckNvdW50ZXJ9YDtcbiAgICAgIHRoaXMuX2xpc3RlbmVyQ291bnRlciArPSAxO1xuICAgIH1cbiAgICB0aGlzLl9saXN0ZW5lcnNJZHguc2V0KGxpc3RlbmVyLl9fY2xpZCwgbGlzdGVuZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyXG4gICAqL1xuICByZW1vdmVDYWNoZVVwZGF0ZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyLl9fY2xpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9saXN0ZW5lcnNJZHguZGVsZXRlKGxpc3RlbmVyLl9fY2xpZCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFncmVlZCB0b3BpY3MgYXJlOlxuICAgKiBhbGxFbnRyaWVzTmVlZFJlZnJlc2ggLSBhbGwgZW50cmllcyBhcmUgbm93IGluIG5lZWQgb2YgcmVmcmVzaCxcbiAgICogdHlwaWNhbGx5IGhhcHBlbnMgYWZ0ZXIgYSBjaGFuZ2Ugb2YgdXNlcihzaWduIGluKVxuICAgKiBuZWVkUmVmcmVzaCAtIHRoZSBzcGVjaWZpZWQgZW50cnkgbmVlZCB0byBiZSByZWZyZXNoZWQuXG4gICAqIHJlZnJlc2hlZCAtIHRoZSBzcGVjaWZpZWQgZW50cnkgaGF2ZSBiZWVuIHJlZnJlc2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRvcGljXG4gICAqIEBwYXJhbSB7c3RvcmUvRW50cnk9fSBhZmZlY3RlZEVudHJ5XG4gICAqL1xuICBtZXNzYWdlTGlzdGVuZXJzKHRvcGljLCBhZmZlY3RlZEVudHJ5KSB7XG4gICAgdGhpcy5fbGlzdGVuZXJzSWR4LmZvckVhY2goKGZ1bmMpID0+IHtcbiAgICAgIGZ1bmModG9waWMsIGFmZmVjdGVkRW50cnkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hcmtzIGFsbCBlbnRyaWVzIGFzIGluIG5lZWQgb2YgcmVmcmVzaCBhbmQgY29uc2VxdWVudGx5IG1lc3NhZ2VzIGFsbCBsaXN0ZW5lcnNcbiAgICogd2l0aCB0aGUgYWxsRW50cmllc05lZWRSZWZyZXNoIHRvcGljLlxuICAgKi9cbiAgYWxsTmVlZFJlZnJlc2goKSB7XG4gICAgdGhpcy5fY2FjaGVJZHguZm9yRWFjaCgoZW50cnksIHVyaSkgPT4ge1xuICAgICAgLy8gRG8gbm90IG1lc3NhZ2VMaXN0ZW5lcnMgZm9yIGV2ZXJ5IGVudHJ5LlxuICAgICAgdGhpcy5zZXRSZWZyZXNoTmVlZGVkKHRoaXMuX2NhY2hlSWR4W3VyaV0sIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMubWVzc2FnZUxpc3RlbmVycygnYWxsRW50cmllc05lZWRSZWZyZXNoJyk7XG4gIH1cblxuICAvKipcbiAgICogQ2xlYXJzIHRoZSBjYWNoZSBmcm9tIGFsbCBjYWNoZWQgZW50cmllcy5cbiAgICogV2FybmluZzogYWxsIHJlZmVyZW5jZXMgdG8gZW50cmllcyBuZWVkcyB0byBiZSBkaXNjYXJkZWQgYXMgdGhleSB3aWxsIG5vdCBiZVxuICAgKiBrZXB0IGluIHN5bmMgd2l0aCBjaGFuZ2VzLlxuICAgKi9cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy5fY2FjaGVJZHggPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5fY2FjaGVJZHhSZXNvdXJjZSA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLl9jYWNoZUN0cmwgPSBuZXcgTWFwKCk7XG4gIH1cbn1cbiIsImltcG9ydCBHcmFwaFJlc291cmNlIGZyb20gJy4vR3JhcGgnO1xuaW1wb3J0IFBpcGVsaW5lIGZyb20gJy4vUGlwZWxpbmUnO1xuaW1wb3J0IFByb3RvdHlwZUVudHJ5IGZyb20gJy4vUHJvdG90eXBlRW50cnknO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vUmVzb3VyY2UnO1xuaW1wb3J0IFN0cmluZ1Jlc291cmNlIGZyb20gJy4vU3RyaW5nJztcbmltcG9ydCB0eXBlcyBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBNZXRob2RzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBFbnRyeVN0b3JlIHJlcG9zaXRvcnkgc2NvcGVkIHRvIGEgc3BlY2lmaWMgY29udGV4dC5cbiAqXG4gKiBAZXhwb3J0cyBzdG9yZS9Db250ZXh0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvbnRleHQgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBsaXN0IG9mIGVudHJpZXMgaW4gdGhlIGNvbnRleHQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzb3J0IC0gc2FtZSBzb3J0IG9iamVjdCBhcyBwcm92aWRlZCBpbiB0aGUgb3B0aW9uYWxMb2FkUGFyYW1zIHRvXG4gICAqIHtAc2VlIHN0b3JlL0VudHJ5U3RvcmUjZ2V0RW50cnkgZ2V0RW50cnl9IG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGxpbWl0IC0gc2FtZSBsaW1pdCBhcyBwcm92aWRlZCBpbiB0aGUgb3B0aW9uYWxMb2FkUGFyYW1zIHRvXG4gICAqIHtAc2VlIHN0b3JlL0VudHJ5U3RvcmUjZ2V0RW50cnkgZ2V0RW50cnl9IG1ldGhvZC5cbiAgICogQHBhcmFtIHtpbnRlZ2VyfSBwYWdlIC0gdW5sZXNzIGxpbWl0IGlzIHNldCB0byAtMSAobm8gcGFnaW5hdGlvbikgd2UgbmVlZCB0byBzcGVjaWZ5XG4gICAqIHdoaWNoIHBhZ2UgdG8gbG9hZCwgZmlyc3QgcGFnZSBpcyAwLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnlbXT59IHVwb24gc3VjY2VzcyB0aGUgcHJvbWlzZSByZXR1cm5zIGFuIGFycmF5IG9mIGVudHJpZXMuXG4gICAqIEBzZWUgc3RvcmUvRW50cnlTdG9yZSNnZXRMaXN0RW50cmllc1xuICAgKi9cbiAgbGlzdEVudHJpZXMoc29ydCwgbGltaXQsIHBhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbnRyeVN0b3JlKCkuZ2V0TGlzdEVudHJpZXMoYCR7dGhpcy5fcmVzb3VyY2VVUkl9L2VudHJ5L19hbGxgLCBzb3J0LCBsaW1pdCwgcGFnZSk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVuaWVuY2UgbWV0aG9kLCB0byByZXRyaWV2ZSBhbiBlbnRyeSBmcm9tIHRoaXMgY29udGV4dC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5SWRcbiAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbmFsTG9hZFBhcmFtcyBzYW1lIHBhcmFtZXRlciBhcyBpbiB7QHNlZSBzdG9yZS9FbnRyeVN0b3JlI2dldEVudHJ5fVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnk+fVxuICAgKiBAc2VlIHN0b3JlL0VudHJ5U3RvcmUjZ2V0RW50cnlcbiAgICovXG4gIGdldEVudHJ5QnlJZChlbnRyeUlkLCBvcHRpb25hbExvYWRQYXJhbXMgPSB7fSkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5U3RvcmUoKS5nZXRFbnRyeSh0aGlzLmdldEVudHJ5VVJJYnlJZChlbnRyeUlkKSwgb3B0aW9uYWxMb2FkUGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBhbmRzIHRoZSBnaXZlbiBlbnRyeSBpZCBpbnRvIGEgZnVsbCBVUkkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeUlkXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBVUkkgZm9yIGFuIGVudHJ5IGluIHRoaXMgY29udGV4dCB3aXRoIHRoZSBnaXZlbiBpZC5cbiAgICovXG4gIGdldEVudHJ5VVJJYnlJZChlbnRyeUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlTdG9yZSgpLmdldEVudHJ5VVJJKHRoaXMuZ2V0SWQoKSwgZW50cnlJZCk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgUHJvdG90eXBlRW50cnkgdGhhdCBoYXMgdGhlIGN1cnJlbnQgY29udGV4dCBhcyBjb250YWluZXIuXG4gICAqIENhbGwge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5I2NvbW1pdCBjb21taXR9IG9uIHRoZSBQcm90b3R5cGVFbnRyeSB0byBhY3R1YWxseSBjcmVhdGUgaXRcbiAgICogKHJldHVybnMgYSBwcm9taXNlKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCAtIGlkIGZvciB0aGUgZW50cnksIGZhaWxzIGFmdGVyIGNvbW1pdCBpZiBhbiBlbnRyeSBleGlzdHMgYWxyZWFkeSB3aXRoXG4gICAqIHRoaXMgaWQuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX1cbiAgICovXG4gIG5ld0VudHJ5KGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm90b3R5cGVFbnRyeSh0aGlzLCBpZCk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgUHJvdG90eXBlRW50cnkgdGhhdCBjb3JyZXNwb25kcyB0byBhIGxvY2FsIG5hbWVkIHJlc291cmNlIHRoYXRcbiAgICogaGFzIHRoZSBjdXJyZW50IGNvbnRleHQgYXMgY29udGFpbmVyLlxuICAgKiBDYWxsIHtAbGluayBzdG9yZS9Qcm90b3R5cGVFbnRyeSNjb21taXQgY29tbWl0fSBvbiB0aGUgUHJvdG90eXBlRW50cnkgdG8gYWN0dWFsbHkgY3JlYXRlIGl0XG4gICAqIChyZXR1cm5zIGEgcHJvbWlzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgLSBpZCBmb3IgdGhlIGVudHJ5LCBmYWlscyBhZnRlciBjb21taXQgaWYgYW4gZW50cnkgZXhpc3RzIGFscmVhZHlcbiAgICogd2l0aCB0aGlzIGlkLlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9XG4gICAqL1xuICBuZXdOYW1lZEVudHJ5KGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm90b3R5cGVFbnRyeSh0aGlzLCBpZCkuc2V0UmVzb3VyY2VUeXBlKHR5cGVzLlJUX05BTUVEUkVTT1VSQ0UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIFByb3RvdHlwZUVudHJ5IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBsaW5rIHRoYXQgaGFzIHRoZVxuICAgKiBjdXJyZW50IGNvbnRleHQgYXMgY29udGFpbmVyLlxuICAgKiBDYWxsIHtAbGluayBzdG9yZS9Qcm90b3R5cGVFbnRyeSNjb21taXQgY29tbWl0fSBvbiB0aGUgUHJvdG90eXBlRW50cnkgdG8gYWN0dWFsbHkgY3JlYXRlXG4gICAqIGl0IChyZXR1cm5zIGEgcHJvbWlzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIC0gdGhlIFVSSSBmb3IgdGhlIHJlc291cmNlIHdlIGFyZSBtYWtpbmcgYSBsaW5rIHRvLCBtYW5kYXRvcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgLSBpZCBmb3IgdGhlIGVudHJ5LCBmYWlscyBhZnRlciBjb21taXQgaWYgYW4gZW50cnkgZXhpc3RzIGFscmVhZHlcbiAgICogd2l0aCB0aGlzIGlkLlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9XG4gICAqL1xuICBuZXdMaW5rKGxpbmssIGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm90b3R5cGVFbnRyeSh0aGlzLCBpZCkuc2V0UmVzb3VyY2VVUkkobGluaykuc2V0RW50cnlUeXBlKHR5cGVzLkVUX0xJTkspO1xuICB9XG5cbiAgLyoqXG4gICAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIFByb3RvdHlwZUVudHJ5IHRoYXQgaXMgYSBsaW5rcmVmIHRoYXQgaGFzIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICogYXMgY29udGFpbmVyLiBDYWxsIHtAbGluayBzdG9yZS9Qcm90b3R5cGVFbnRyeSNjb21taXQgY29tbWl0fSBvbiB0aGUgUHJvdG90eXBlRW50cnkgdG9cbiAgICogYWN0dWFsbHkgY3JlYXRlIGl0IChyZXR1cm5zIGEgcHJvbWlzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaW5rIC0gaXMgdGhlIFVSSSBmb3IgdGhlIHJlc291cmNlIHdlIGFyZSBtYWtpbmcgYSBsaW5rIHRvLCBtYW5kYXRvcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXRhZGF0YUxpbmsgLSBpcyB0aGUgVVJJIGZvciB0aGUgbWV0YWRhdGEgYXJlIHJlZmVycmluZyB0bywgbWFuZGF0b3J5LlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGlkIC0gaWQgZm9yIHRoZSBlbnRyeSwgZmFpbHMgYWZ0ZXIgY29tbWl0IGlmIGFuIGVudHJ5IGV4aXN0cyBhbHJlYWR5XG4gICAqIHdpdGggdGhpcyBpZC5cbiAgICogQHJldHVybnMge3N0b3JlL1Byb3RvdHlwZUVudHJ5fVxuICAgKi9cbiAgbmV3TGlua1JlZihsaW5rLCBtZXRhZGF0YUxpbmssIGlkKSB7XG4gICAgcmV0dXJuIG5ldyBQcm90b3R5cGVFbnRyeSh0aGlzLCBpZClcbiAgICAgIC5zZXRSZXNvdXJjZVVSSShsaW5rKVxuICAgICAgLnNldEV4dGVybmFsTWV0YWRhdGFVUkkobWV0YWRhdGFMaW5rKVxuICAgICAgLnNldEVudHJ5VHlwZSh0eXBlcy5FVF9MSU5LUkVGKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBQcm90b3R5cGVFbnRyeSB0aGF0IGlzIGEgcmVmZXJlbmNlIGFuZCBoYXMgdGhlIGN1cnJlbnRcbiAgICogY29udGV4dCBhcyBjb250YWluZXIuIENhbGwge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5I2NvbW1pdCBjb21taXR9IG9uIHRoZVxuICAgKiBQcm90b3R5cGVFbnRyeSB0byBhY3R1YWxseSBjcmVhdGUgaXQgKHJldHVybnMgYSBwcm9taXNlKS5cbiAgICogVGhlIG9ubHkgZGlmZmVyZW5jZSB0byB0aGUgbmV3TGlua1JlZiBtZXRob2QgaXMgdGhhdCB0aGUgRW50cnlUeXBlIGlzIFJlZmVyZW5jZSBpbnN0ZWFkXG4gICAqIG9mIExpbmtSZWZlcmVuY2Ugd2hpY2ggaW1wbGllcyB0aGF0IHRoZXJlIGlzIG5vIGxvY2FsIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGluayAtIHRoZSBVUkkgZm9yIHRoZSByZXNvdXJjZSB3ZSBhcmUgbWFraW5nIGEgbGluayB0bywgbWFuZGF0b3J5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0YWRhdGFMaW5rIC0gdGhlIFVSSSBmb3IgdGhlIG1ldGFkYXRhIGFyZSByZWZlcnJpbmcgdG8sIG1hbmRhdG9yeS5cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCBmb3IgdGhlIGVudHJ5LCBmYWlscyBhZnRlciBjb21taXQgaWYgYW4gZW50cnkgZXhpc3RzIGFscmVhZHkgd2l0aFxuICAgKiB0aGlzIGlkLlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9XG4gICAqL1xuICBuZXdSZWYobGluaywgbWV0YWRhdGFMaW5rLCBpZCkge1xuICAgIHJldHVybiBuZXcgUHJvdG90eXBlRW50cnkodGhpcywgaWQpXG4gICAgICAuc2V0UmVzb3VyY2VVUkkobGluaylcbiAgICAgIC5zZXRFeHRlcm5hbE1ldGFkYXRhVVJJKG1ldGFkYXRhTGluaylcbiAgICAgIC5zZXRFbnRyeVR5cGUodHlwZXMuRVRfUkVGKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBQcm90b3R5cGVFbnRyeSB3aG9zZSByZXNvdXJjZSBpcyBhIHtAbGluayBzdG9yZS9MaXN0IExpc3QpXG4gICAqIGFuZCBoYXMgdGhlIGN1cnJlbnQgY29udGV4dCBhcyBjb250YWluZXIuXG4gICAqIENhbGwge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5I2NvbW1pdCBjb21taXR9IG9uIHRoZSBQcm90b3R5cGVFbnRyeSB0byBhY3R1YWxseSBjcmVhdGVcbiAgICogaXQgKHJldHVybnMgYSBwcm9taXNlKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIGFuIG9wdGlvbmFsIGlkIGZvciB0aGUgZW50cnksIGZhaWxzIG9uIGNvbW1pdCBpZiBhbiBlbnRyeSBleGlzdHMgYWxyZWFkeVxuICAgKiB3aXRoIHRoaXMgaWQuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX1cbiAgICovXG4gIG5ld0xpc3QoaWQpIHtcbiAgICByZXR1cm4gbmV3IFByb3RvdHlwZUVudHJ5KHRoaXMsIGlkKS5zZXRHcmFwaFR5cGUodHlwZXMuR1RfTElTVCk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgUHJvdG90eXBlRW50cnkgd2hvc2UgcmVzb3VyY2UgaXMgYSB7QGxpbmsgc3RvcmUvR3JhcGggR3JhcGh9XG4gICAqIGFuZCBoYXMgdGhlIGN1cnJlbnQgY29udGV4dCBhcyBjb250YWluZXIuXG4gICAqIENhbGwge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5I2NvbW1pdCBjb21taXR9IG9uIHRoZSBQcm90b3R5cGVFbnRyeSB0byBhY3R1YWxseSBjcmVhdGUgaXRcbiAgICogKHJldHVybnMgYSBwcm9taXNlKS5cbiAgICpcbiAgICogQHBhcmFtIHtyZGZqc29uL0dyYXBofSBncmFwaCAtIGdyYXBoIHRvIHN0b3JlIGFzIGEgcmVzb3VyY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgLSBpZCBmb3IgdGhlIGVudHJ5LCBmYWlscyB1cG9uIGNvbW1pdCBpZiBhbiBlbnRyeSBleGlzdHMgYWxyZWFkeVxuICAgKiB3aXRoIHRoaXMgaWQuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX1cbiAgICovXG4gIG5ld0dyYXBoKGdyYXBoLCBpZCkge1xuICAgIGNvbnN0IHByb3RvdHlwZUVudHJ5ID0gbmV3IFByb3RvdHlwZUVudHJ5KHRoaXMsIGlkKS5zZXRHcmFwaFR5cGUodHlwZXMuR1RfR1JBUEgpO1xuICAgIGNvbnN0IGVudHJ5SW5mbyA9IHByb3RvdHlwZUVudHJ5LmdldEVudHJ5SW5mbygpO1xuICAgIHByb3RvdHlwZUVudHJ5Ll9yZXNvdXJjZSA9IG5ldyBHcmFwaFJlc291cmNlKGVudHJ5SW5mby5nZXRFbnRyeVVSSSgpLCBlbnRyeUluZm8uZ2V0UmVzb3VyY2VVUkkoKSxcbiAgICAgIHRoaXMuZ2V0RW50cnlTdG9yZSgpLCBncmFwaCB8fCB7fSk7XG5cbiAgICByZXR1cm4gcHJvdG90eXBlRW50cnk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgUHJvdG90eXBlRW50cnkgd2hvc2UgcmVzb3VyY2UgaXMgYSB7QGxpbmsgc3RvcmUvU3RyaW5nIFN0cmluZ31cbiAgICogdGhhdCBoYXMgdGhlIGN1cnJlbnQgY29udGV4dCBhcyBjb250YWluZXIuXG4gICAqIENhbGwge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5I2NvbW1pdCBjb21taXR9IG9uIHRoZSBQcm90b3R5cGVFbnRyeSB0byBhY3R1YWxseSBjcmVhdGVcbiAgICogaXQgKHJldHVybnMgYSBwcm9taXNlKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBzdHIgYW4gb3B0aW9uYWwgc3RyaW5nIGZvciB0aGUgU3RyaW5nIFJlc291cmNlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gaWQgYW4gb3B0aW9uYWwgaWQgZm9yIHRoZSBlbnRyeSwgZmFpbHMgdXBvbiBjb21taXQgaWYgYW4gZW50cnkgZXhpc3RzXG4gICAqIGFscmVhZHkgd2l0aCB0aGlzIGlkLlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9XG4gICAqL1xuICBuZXdTdHJpbmcoc3RyLCBpZCkge1xuICAgIGNvbnN0IHByb3RvdHlwZUVudHJ5ID0gbmV3IFByb3RvdHlwZUVudHJ5KHRoaXMsIGlkKS5zZXRHcmFwaFR5cGUodHlwZXMuR1RfU1RSSU5HKTtcbiAgICBjb25zdCBlbnRyeUluZm8gPSBwcm90b3R5cGVFbnRyeS5nZXRFbnRyeUluZm8oKTtcbiAgICBwcm90b3R5cGVFbnRyeS5fcmVzb3VyY2UgPSBuZXcgU3RyaW5nUmVzb3VyY2UoZW50cnlJbmZvLmdldEVudHJ5VVJJKCksXG4gICAgICBlbnRyeUluZm8uZ2V0UmVzb3VyY2VVUkkoKSwgdGhpcy5nZXRFbnRyeVN0b3JlKCksIHN0cik7XG5cbiAgICByZXR1cm4gcHJvdG90eXBlRW50cnk7XG4gIH1cblxuICAvKipcbiAgICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgUHJvdG90eXBlRW50cnkgd2hvc2UgcmVzb3VyY2UgaXMgYVxuICAgKiB7QGxpbmsgc3RvcmUvUGlwZWxpbmUgcGlwZWxpbmV9IHRoYXQgaGFzIHRoZSBjdXJyZW50IGNvbnRleHQgYXMgY29udGFpbmVyLlxuICAgKiBDYWxsIHtAbGluayBzdG9yZS9Qcm90b3R5cGVFbnRyeSNjb21taXQgY29tbWl0fSBvbiB0aGUgUHJvdG90eXBlRW50cnkgdG8gYWN0dWFsbHkgY3JlYXRlIGl0XG4gICAqIChyZXR1cm5zIGEgcHJvbWlzZSkuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBpZCBhbiBvcHRpb25hbCBpZCBmb3IgdGhlIGVudHJ5LCBmYWlscyB1cG9uIGNvbW1pdCBpZiBhbiBlbnRyeSBleGlzdHNcbiAgICogYWxyZWFkeSB3aXRoIHRoaXMgaWQuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX1cbiAgICovXG4gIG5ld1BpcGVsaW5lKGlkKSB7XG4gICAgY29uc3QgcHJvdG90eXBlRW50cnkgPSBuZXcgUHJvdG90eXBlRW50cnkodGhpcywgaWQpLnNldEdyYXBoVHlwZSh0eXBlcy5HVF9QSVBFTElORSk7XG4gICAgY29uc3QgZW50cnlJbmZvID0gcHJvdG90eXBlRW50cnkuZ2V0RW50cnlJbmZvKCk7XG4gICAgcHJvdG90eXBlRW50cnkuX3Jlc291cmNlID0gbmV3IFBpcGVsaW5lKGVudHJ5SW5mby5nZXRFbnRyeVVSSSgpLCBlbnRyeUluZm8uZ2V0UmVzb3VyY2VVUkkoKSwgdGhpcy5nZXRFbnRyeVN0b3JlKCksIHt9KTtcblxuICAgIHJldHVybiBwcm90b3R5cGVFbnRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBmb3IgdGhpcyBjb250ZXh0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0TmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fbmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGFuZ2Ugb2YgY29udGV4dCBuYW1lLCBzdWNjZWVkcyBpZiBuYW1lIGlzIG5vdCBpbiB1c2UgYWxyZWFkeSBieSBhbm90aGVyIGNvbnRleHQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc2V0TmFtZShuYW1lKSB7XG4gICAgY29uc3Qgb2xkTmFtZSA9IHRoaXMuX25hbWU7XG4gICAgdGhpcy5fbmFtZSA9IG5hbWU7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlTdG9yZSgpLmhhbmRsZUFzeW5jKHRoaXMuZ2V0RW50cnlTdG9yZSgpLmdldFJFU1QoKVxuICAgICAgLnB1dChgJHt0aGlzLmdldEVudHJ5VVJJKCl9L25hbWVgLCBKU09OLnN0cmluZ2lmeSh7IG5hbWUgfSkpLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgY29uc3QgZW50cnkgPSB0aGlzLmdldEVudHJ5KHRydWUpO1xuICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICBlbnRyeS5nZXRFbnRyeUluZm8oKS5fbmFtZSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9LCAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9uYW1lID0gb2xkTmFtZTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0pLCAnc2V0Q29udGV4dE5hbWUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyB0aGUgdXNlciBvciBncm91cCB0aGF0IGhhcyB0aGlzIGNvbnRleHQgYXMgaG9tZWNvbnRleHQgaWYgYW55LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnk+fSBpZiBzdWNjZWVkcyBpZiBjb250ZXh0IGEgaG9tZWNvbnRleHQgb2Ygc29tZSB1c2VyIG9yIGdyb3VwLlxuICAgKiBAYXN5bmNcbiAgICovXG4gIGFzeW5jIGdldEhvbWVDb250ZXh0T2YoKSB7XG4gICAgY29uc3QgY29udGV4dEVudHJ5ID0gYXdhaXQgdGhpcy5nZXRFbnRyeSgpO1xuICAgIGNvbnN0IGVzID0gY29udGV4dEVudHJ5LmdldEVudHJ5U3RvcmUoKTtcbiAgICBjb25zdCBncm91cFJlc291cmNlQXJyID0gY29udGV4dEVudHJ5LmdldFJlZmVycmVycygnc3RvcmU6aG9tZUNvbnRleHQnKTtcbiAgICBpZiAoZ3JvdXBSZXNvdXJjZUFyci5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm4gZXMuZ2V0RW50cnkoZXMuZ2V0RW50cnlVUklGcm9tVVJJKGdyb3VwUmVzb3VyY2VBcnJbMF0pKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyB1c2VyIG9yIGdyb3VwIHRoYXQgaGFzIHRoaXMgY29udGV4dCBhcyBob21lIGNvbnRleHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3VwZGF0ZShkYXRhKSB7XG4gICAgdGhpcy5fbmFtZSA9IGRhdGEuYWxpYXMgfHwgZGF0YS5uYW1lOyAvLyBUT0RPLCBjaGFuZ2UgdG8gb25seSBuYW1lIGFmdGVyIGNsZWFuLXVwXG4gIH1cbn07XG4iLCJpbXBvcnQgeyBHcmFwaCB9IGZyb20gJ3JkZmpzb24nO1xuaW1wb3J0IHR5cGVzIGZyb20gJy4vdHlwZXMnO1xuaW1wb3J0IEVudHJ5U3RvcmUgZnJvbSAnLi9FbnRyeVN0b3JlJztcbmltcG9ydCBmYWN0b3J5IGZyb20gJy4vZmFjdG9yeSc7XG5cbi8qKlxuICogRW50cmllcyBhcmUgYXQgdGhlIGNlbnRlciBvZiB0aGlzIEFQSS4gRW50cmllcyBob2xkcyB0b2dldGhlciBtZXRhZGF0YSwgZXh0ZXJuYWwgbWV0YWRhdGEsXG4gKiByZXNvdXJjZXMsIGFjY2VzcyBjb250cm9sLCBhbmQgcHJvdmVuYW5jZS4gSGVuY2UsIGVudHJpZXMgYXBwZWFyIGluIHRoZSBtYWpvcml0eSBvZiBtZXRob2RzLFxuICogZWl0aGVyIGRpcmVjdGx5IG9yIGluIGNhbGxiYWNrcyB2aWEgcHJvbWlzZXMuIEVhY2ggZW50cnkgaGFzIGEgc2ltcGxlIGlkZW50aWZpZXIgd2l0aGluIGFcbiAqIGNvbnRleHQgYW5kIGEgZ2xvYmFsbHkgdW5pcXVlIFVSSSB0aGF0IGNhbiBiZSB1c2VkIHRvIGxvYWQsIHN0b3JlIGFuZCBpbmRleCB0aGUgZW50cnkuXG4gKlxuICogTWFueSBvZiB0aGUgbWV0aG9kcyBpbiB0aGlzIGNsYXNzIGFyZSBjb252ZW5pZW5jZSBtZXRob2RzIHRoYXQgYWxsb3dzIHRoZSBkZXZlbG9wZXIgdG8gaW50ZXJhY3RcbiAqIHdpdGggdGhlIGluZm9ybWF0aW9uIHJldHJpZXZlZCBmcm9tIHRoZSByZXBvc2l0b3J5IHdpdGhvdXQgZGlnZ2luZyB0aHJvdWdoIHRoZSBSREYgZ3JhcGhzLlxuICogRm9yIGluc3RhbmNlLCBhbGwgbWV0aG9kcyBzdGFydGluZyB3aXRoIF9jYW5fIG9yIF9pc18gYXJlIGNvbnZlbmllbmNlIG1ldGhvZHMgZm9yIHdvcmtpbmdcbiAqIHdpdGggYWNjZXNzIGNvbnRyb2wgb3IgdGhlIHR5cGUgaW5mb3JtYXRpb24gYXZhaWxhYmxlIGluIHRoZSBhc3NvY2lhdGVkXG4gKiBUaGUgc2FtZSBpcyB0cnVlIGZvciB0aGUgbWFqb3JpdHkgb2YgdGhlIGdldCBtZXRob2RzLFxuICogb25seSB0aG9zZSB0aGF0IGhhdmUgY29ycmVzcG9uZGluZyBzZXQgbWV0aG9kcyBhcmUgcmVhbGx5IHVuaXF1ZSBmb3IgdGhpcyBjbGFzcy5cbiAqXG4gKiBAbGluayBzdG9yZS9FbnRyeUluZm9cbiAqIEBleHBvcnRzIHN0b3JlL0VudHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudHJ5IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RvcmUvQ29udGV4dH0gY29udGV4dCBjb250YWluZXIgZm9yIHRoaXMgZW50cnlcbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeUluZm99IGVudHJ5SW5mbyBkZWZpbmVzIHRoZSBiYXNpY3Mgb2YgdGhpcyBlbnRyeVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGV4dCwgZW50cnlJbmZvKSB7XG4gICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgdGhpcy5fZW50cnlJbmZvID0gZW50cnlJbmZvO1xuICAgIHRoaXMuX2VudHJ5SW5mby5fZW50cnkgPSB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeVN0b3JlfVxuICAgKi9cbiAgZ2V0RW50cnlTdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dC5nZXRFbnRyeVN0b3JlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0b3JlL0VudHJ5SW5mb31cbiAgICovXG4gIGdldEVudHJ5SW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlJbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlbmllbmNlIG1ldGhvZCwgc2FtZSBhcyBjYWxsaW5nIGVudHJ5LmdldEVudHJ5SW5mbygpLmdldEVudHJ5VVJJKClcbiAgICogQHJldHVybiB7c3RyaW5nfSB0aGUgZW50cnkgdXJpLlxuICAgKiBAc2VlIHN0b3JlL0VudHJ5SW5mbyNnZXRFbnRyeVVSSVxuICAgKi9cbiAgZ2V0VVJJKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyeUluZm8uZ2V0RW50cnlVUkkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QsIHNhbWUgYXMgY2FsbGluZyBlbnRyeS5nZXRFbnRyeUluZm8oKS5nZXRJZCgpXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBpZCBvZiB0aGUgZW50cnlcbiAgICogQHNlZSBzdG9yZS9FbnRyeUluZm8jZ2V0SWRcbiAgICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyeUluZm8uZ2V0SWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSBtZXRob2QsIHNhbWUgYXMgY2FsbGluZyBlbnRyeS5nZXRFbnRyeUluZm8oKS5nZXRSZXNvdXJjZVVSSSgpXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IGEgVVJJIHRvIHRoZSByZXNvdXJjZSBvZiB0aGlzIGVudHJ5LlxuICAgKi9cbiAgZ2V0UmVzb3VyY2VVUkkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5SW5mby5nZXRSZXNvdXJjZVVSSSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Db250ZXh0fVxuICAgKi9cbiAgZ2V0Q29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhbiBSREYgZ3JhcGggYXMgYW4ge0BsaW5rIHJkZmpzb24vR3JhcGh9IGluc3RhbmNlLlxuICAgKiBAcmV0dXJuIHtyZGZqc29uL0dyYXBofSBhIFJERiBncmFwaCB3aXRoIG1ldGFkYXRhLCB0eXBpY2FsbHkgY29udGFpbmluZyBzdGF0ZW1lbnRzIGFib3V0XG4gICAqIHRoZSByZXNvdXJjZVVSSS4gVGhlIHJldHVybmVkIGdyYXBoIG1heSBiZSBlbXB0eSBidXQgbmV2ZXIgbnVsbCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXRNZXRhZGF0YSgpIHtcbiAgICBpZiAodGhpcy5fbWV0YWRhdGEgPT0gbnVsbCkge1xuICAgICAgdGhpcy5fbWV0YWRhdGEgPSBuZXcgR3JhcGgoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgbWV0YWRhdGEgZ3JhcGggZm9yIHRoaXMgZW50cnkgd2l0aG91dCBwdXNoaW5nIGl0IHRvIHRoZSByZXBvc2l0b3J5LlxuICAgKiBJbiBtYW55IGNhc2VzIHRoaXMgbWV0aG9kIGlzIG5vdCBuZWVkZWQgc2luY2UgeW91IGNhbiBnZXQgdGhlIG1ldGFkYXRhIGdyYXBoLFxuICAgKiBtb2RpZnkgaXQgYW5kIHRoZW4gY29tbWl0IHRoZSBjaGFuZ2VzIGRpcmVjdGx5LlxuICAgKlxuICAgKiBIb3dldmVyLCBpbiBzb21lIGNhc2VzIHlvdSBuZWVkIHRvIHNldCBhIG5ldyBtZXRhZGF0YSBncmFwaCwgZS5nLlxuICAgKiB5b3Ugd2FudCB0byBvdmVyd3JpdGUgdGhlIG1ldGFkYXRhIHdpdGggYSBuZXcgZ3JhcGggcmV0cmlldmVkIGZyb20gYW5vdGhlciBzb3VyY2Ugb3IgdGhlXG4gICAqIGVudHJ5IGhhdmUgYmVlbiByZWZyZXNoZWQgd2l0aCBuZXcgaW5mb3JtYXRpb24gYW5kIHlvdSB3YW50IHRvIGNvbW1pdCB0aGUgbWVyZ2VkIHJlc3VsdHMuXG4gICAqIEluIHRoZXNlIGNhc2VzIHlvdSBuZWVkIHRvIGRpc2NhcmQgdGhlIGN1cnJlbnQgbWV0YWRhdGEgZ3JhcGggd2l0aCBoZWxwIG9mIHRoaXMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0ge3JkZmpzb24vR3JhcGh9IGdyYXBoIGlzIGFuIFJERiBncmFwaCB3aXRoIG1ldGFkYXRhLCBpZiBpdCBpcyBub3QgcHJvdmlkZWQgdGhlIGN1cnJlbnRcbiAgICogbWV0YWRhdGEgZ3JhcGggaXMgc2F2ZWQgKHRoZXJlIGlzIGN1cnJlbnRseSBubyBjaGVjayB3aGV0aGVyIGl0IGhhcyBiZWVuIG1vZGlmaWVkIG9yIG5vdCkuXG4gICAqIEByZXR1cm4gc3RvcmUvRW50cnkgLSB0byBhbGxvdyBjaGFpbmluZyB3aXRoIG90aGVyIG1ldGhvZHMsIGUuZy4gd2l0aCBjb21taXRNZXRhZGF0YS5cbiAgICovXG4gIHNldE1ldGFkYXRhKGdyYXBoKSB7XG4gICAgdGhpcy5fbWV0YWRhdGEgPSBncmFwaDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaWxsIHB1c2ggdGhlIG1ldGFkYXRhIGZvciB0aGlzIGVudHJ5IHRvIHRoZSByZXBvc2l0b3J5LlxuICAgKiBJZiBtZXRhZGF0YSBoYXMgYmVlbiBzZXQgZm9yIGFuIGVudHJ5IHdpdGggRW50cnlUeXBlICdyZWZlcmVuY2UnXG4gICAqIHRoZSBlbnRyeSB0eXBlIHdpbGwgY2hhbmdlIHRvICdsaW5rcmVmZXJlbmNlJyB1cG9uIGEgc3VjY2Vzc2Z1bCBjb21taXQuXG4gICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpZ25vcmVJZlVubW9kaWZpZWRTaW5jZUNoZWNrPWZhbHNlXSBpZiBleHBsaWNpdGx5IHNldCB0byB0cnVlIG5vIGNoZWNrIGlzIGRvbmVcbiAgICogaWYgaW5mb3JtYXRpb24gaXMgc3RhbGUsIGFsc28gaXQgd2lsbCBub3QgYXV0b21hdGljYWxseSByZWZyZXNoIHdpdGggdGhlIGxhdGVzdCBkYXRlXG4gICAqIEByZXR1cm4ge1Byb21pc2UuPHN0b3JlL0VudHJ5Pn0gYSBwcm9taXNlIHRoYXQgb24gc3VjY2VzcyB3aWxsIGNvbnRhaW4gdGhlIGN1cnJlbnQgdXBkYXRlZCBlbnRyeS5cbiAgICovXG4gIGNvbW1pdE1ldGFkYXRhKGlnbm9yZUlmVW5tb2RpZmllZFNpbmNlQ2hlY2sgPSBmYWxzZSkge1xuICAgIGxldCBwO1xuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG4gICAgaWYgKHRoaXMuaXNSZWZlcmVuY2UoKSkge1xuICAgICAgcCA9IFByb21pc2UucmVqZWN0KGBFbnRyeSBcIiR7dGhpcy5nZXRVUkkoKX1cIiBpcyBhIHJlZmVyZW5jZSBhbmQgaGF2ZSBubyBsb2NhbCBtZXRhZGF0YSB0aGF0IGNhbiBiZSBzYXZlZC5gKTtcbiAgICB9IGVsc2UgaWYgKCF0aGlzLmNhbldyaXRlTWV0YWRhdGEoKSkge1xuICAgICAgcCA9IFByb21pc2UucmVqZWN0KGBZb3UgZG8gbm90IGhhdmUgc3VmZmljaWVudCBhY2Nlc3MgcmlnaHRzIHRvIHNhdmUgbWV0YWRhdGEgb24gZW50cnkgXCIke3RoaXMuZ2V0VVJJKCl9XCIuYCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZWRSZWZyZXNoKCkpIHtcbiAgICAgIHAgPSBQcm9taXNlLnJlamVjdChgVGhlIGVudHJ5IFwiJHt0aGlzLmdldFVSSSgpfVwiIG5lZWQgdG8gYmUgcmVmcmVzaGVkIGJlZm9yZSBpdHMgbG9jYWwgbWV0YWRhdGEgY2FuIGJlIHNhdmVkLlxcbmAgK1xuICAgICAgICAnVGhpcyBtZXNzYWdlIGluZGljYXRlcyB0aGF0IHRoZSBjbGllbnQgaXMgd3JpdHRlbiBwb29ybHksIHRoaXMgY2FzZSBzaG91bGQgaGF2ZSBiZWVuIHRha2VuIGludG8gYWNjb3VudC4nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX21ldGFkYXRhID09IG51bGwpIHtcbiAgICAgIHAgPSBQcm9taXNlLnJlamVjdChgVGhlIGVudHJ5IFwiJHt0aGlzLmdldFVSSSgpfVwiIHNob3VsZCBhbGxvdyBsb2NhbCBtZXRhZGF0YSB0byBiZSBzYXZlZCwgYnV0IHRoZXJlIGlzIG5vIGxvY2FsIG1ldGFkYXRhLlxcblRoaXMgbWVzc2FnZSBpcyBhIGJ1ZyBpbiB0aGUgc3RvcmVqcyBBUEkuYCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpZ25vcmVJZlVubW9kaWZpZWRTaW5jZUNoZWNrKSB7XG4gICAgICAgIHAgPSBlcy5nZXRSRVNUKCkucHV0KHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0TWV0YWRhdGFVUkkoKSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLl9tZXRhZGF0YS5leHBvcnRSREZKU09OKCkpKS50aGVuKCgpID0+IHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbW9kID0gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRNb2RpZmljYXRpb25EYXRlKCk7XG4gICAgICAgIHAgPSBlcy5nZXRSRVNUKCkucHV0KHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0TWV0YWRhdGFVUkkoKSxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLl9tZXRhZGF0YS5leHBvcnRSREZKU09OKCkpLCBtb2QpXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRSZWZyZXNoTmVlZGVkKHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpLnRoZW4oKCkgPT4gdGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgICAvLyBGYWlsZWQgcmVmcmVzaGluZywgYnV0IHN1Y2NlZWRlZCBhdCBzYXZpbmcgbWV0YWRhdGEsXG4gICAgICAgICAgICAgIC8vIGF0IGxlYXN0IHNlbmQgb3V0IG1lc3NhZ2UgdGhhdCBpdCBuZWVkcyB0byBiZSByZWZyZXNoZWQuXG4gICAgICAgICAgICAgIHRoaXMuZ2V0RW50cnlTdG9yZSgpLmdldENhY2hlKCkubWVzc2FnZSgncmVmcmVzaGVkJywgdGhpcyk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhwLCAnY29tbWl0TWV0YWRhdGEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGVudHJ5LmdldE1ldGFkYXRhKCkuYWRkKGVudHJ5LmdldFJlc291cmNlVVJJKCksIHByZWRpY2F0ZSwgbylcbiAgICogYnV0IGluc3RlYWQgb2YgcmV0dXJuaW5nIHRoZSBjcmVhdGVkIHN0YXRlbWVudCBpdCByZXR1cm5zIHRoZSBlbnRyeSBpdHNlbGYsXG4gICAqIGFsbG93aW5nIGNoYWluZWQgbWV0aG9kIGNhbGxzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZGljYXRlIHRoZSBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9iamVjdCB0aGUgb2JqZWN0XG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeX1cbiAgICovXG4gIGFkZChwcmVkaWNhdGUsIG9iamVjdCkge1xuICAgIHRoaXMuZ2V0TWV0YWRhdGEoKS5hZGQodGhpcy5nZXRSZXNvdXJjZVVSSSgpLCBwcmVkaWNhdGUsIG9iamVjdCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2FtZSBhcyBlbnRyeS5nZXRNZXRhZGF0YSgpLmFkZEwoZW50cnkuZ2V0UmVzb3VyY2VVUkkoKSwgcHJlZGljYXRlLCBsaXRlcmFsLCBsYW5nKVxuICAgKiBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgdGhlIGNyZWF0ZWQgc3RhdGVtZW50IGl0IHJldHVybnMgdGhlIGVudHJ5IGl0c2VsZixcbiAgICogYWxsb3dpbmcgY2hhaW5lZCBtZXRob2QgY2FsbHMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVkaWNhdGUgdGhlIHByZWRpY2F0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGl0ZXJhbCB0aGUgbGl0ZXJhbCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2UgYW4gb3B0aW9uYWwgbGFuZ3VhZ2VcbiAgICogQHJldHVybnMge3N0b3JlL0VudHJ5fVxuICAgKi9cbiAgYWRkTChwcmVkaWNhdGUsIGxpdGVyYWwsIGxhbmd1YWdlKSB7XG4gICAgdGhpcy5nZXRNZXRhZGF0YSgpLmFkZEwodGhpcy5nZXRSZXNvdXJjZVVSSSgpLCBwcmVkaWNhdGUsIGxpdGVyYWwsIGxhbmd1YWdlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGVudHJ5LmdldE1ldGFkYXRhKCkuYWRkRChlbnRyeS5nZXRSZXNvdXJjZVVSSSgpLCBwcmVkaWNhdGUsIGxpdGVyYWwsIGxhbmcpXG4gICAqIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyB0aGUgY3JlYXRlZCBzdGF0ZW1lbnQgaXQgcmV0dXJucyB0aGUgZW50cnkgaXRzZWxmLFxuICAgKiBhbGxvd2luZyBjaGFpbmVkIG1ldGhvZCBjYWxscy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZWRpY2F0ZSB0aGUgcHJlZGljYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXRlcmFsIHRoZSBsaXRlcmFsIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhdHlwZSB0aGUgZGF0YXR5cGUgKHNob3VsZCBiZSBhIHN0cmluZylcbiAgICogQHJldHVybnMge3N0b3JlL0VudHJ5fVxuICAgKi9cbiAgYWRkRChwcmVkaWNhdGUsIGxpdGVyYWwsIGRhdGF0eXBlKSB7XG4gICAgdGhpcy5nZXRNZXRhZGF0YSgpLmFkZEQodGhpcy5nZXRSZXNvdXJjZVVSSSgpLCBwcmVkaWNhdGUsIGxpdGVyYWwsIGRhdGF0eXBlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDYWNoZWQgZXh0ZXJuYWwgbWV0YWRhdGEgY2FuIG9ubHkgYmUgcHJvdmlkZWQgZm9yIGVudHJpZXMgd2l0aCBlbnRyeSB0eXBlXG4gICAqIHJlZmVyZW5jZSBvciBsaW5rIHJlZmVyZW5jZS5cbiAgICpcbiAgICogQHJldHVybiB7cmRmanNvbi9HcmFwaH0gLSBhIFJERiBncmFwaCB3aXRoIGNhY2hlZCBleHRlcm5hbCBtZXRhZGF0YSwgdHlwaWNhbGx5IGNvbnRhaW5pbmdcbiAgICogc3RhdGVtZW50cyBhYm91dCB0aGUgcmVzb3VyY2VVUkkuIFRoZSByZXR1cm5lZCBncmFwaCBtYXkgYmUgZW1wdHkgYnV0IG5ldmVyIG51bGxcbiAgICogb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSgpIHtcbiAgICBpZiAodGhpcy5fY2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9jYWNoZWRFeHRlcm5hbE1ldGFkYXRhID0gbmV3IEdyYXBoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX2NhY2hlZEV4dGVybmFsTWV0YWRhdGE7XG4gIH1cblxuICBnZXRJbmZlcnJlZE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZlcnJlZE1ldGFkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBuZXcgY2FjaGVkIGV4dGVybmFsIG1ldGFkYXRhIGdyYXBoIGZvciB0aGlzIGVudHJ5IHdpdGhvdXQgcHVzaGluZ1xuICAgKiBpdCB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtyZGZqc29uL0dyYXBofSBncmFwaCBpcyBhbiBSREYgZ3JhcGggd2l0aCBtZXRhZGF0YS5cbiAgICogQHJldHVybiBzdG9yZS9FbnRyeSAtIHRvIGFsbG93IGNoYWluaW5nIHdpdGggb3RoZXIgbWV0aG9kcyxcbiAgICogZS5nLiB3aXRoIGNvbW1pdENhY2hlZEV4dGVybmFsTWV0YWRhdGEuXG4gICAqL1xuICBzZXRDYWNoZWRFeHRlcm5hbE1ldGFkYXRhKGdyYXBoKSB7XG4gICAgaWYgKGdyYXBoKSB7XG4gICAgICB0aGlzLl9jYWNoZWRFeHRlcm5hbE1ldGFkYXRhID0gZ3JhcGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIHRoZSBjdXJyZW50IGNhY2hlZCBleHRlcm5hbCBtZXRhZGF0YSBncmFwaCBmb3IgdGhpcyBlbnRyeSB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZS48c3RvcmUvRW50cnk+fSBhIHByb21pc2UgdGhhdCBvbiBzdWNjZXNzIHdpbGwgY29udGFpbiB0aGUgY3VycmVudCB1cGRhdGVkIGVudHJ5LlxuICAgKi9cbiAgY29tbWl0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSgpIHtcbiAgICBjb25zdCBlcyA9IHRoaXMuZ2V0RW50cnlTdG9yZSgpO1xuICAgIGNvbnN0IG1vZCA9IHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0TW9kaWZpY2F0aW9uRGF0ZSgpO1xuICAgIGNvbnN0IHByb21pc2UgPSBlcy5nZXRSRVNUKCkucHV0KHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YVVSSSgpLFxuICAgICAgSlNPTi5zdHJpbmdpZnkodGhpcy5fY2FjaGVkRXh0ZXJuYWxNZXRhZGF0YS5leHBvcnRSREZKU09OKCkpLCBtb2QpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UmVmcmVzaE5lZWRlZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaCgpLnRoZW4oKCkgPT4gdGhpcywgKCkgPT4ge1xuICAgICAgICAgIC8vIEZhaWxlZCByZWZyZXNoaW5nLCBidXQgc3VjY2VlZGVkIGF0IHNhdmluZyBtZXRhZGF0YSxcbiAgICAgICAgICAvLyBhdCBsZWFzdCBzZW5kIG91dCBtZXNzYWdlIHRoYXQgaXQgbmVlZHMgdG8gYmUgcmVmcmVzaGVkLlxuICAgICAgICAgIHRoaXMuZ2V0RW50cnlTdG9yZSgpLmdldENhY2hlKCkubWVzc2FnZSgncmVmcmVzaGVkJywgdGhpcyk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gZXMuaGFuZGxlQXN5bmMocHJvbWlzZSwgJ2NvbW1pdENhY2hlZEV4dGVybmFsTWV0YWRhdGEnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdG9kbyByZW1haW5zIHRvIGJlIHN1cHBvcnRlZCBpbiByZXBvc2l0b3J5XG4gICAqIEByZXR1cm5zIHtyZGZqc29uL0dyYXBofVxuICAgKi9cbiAgZ2V0RXh0cmFjdGVkTWV0YWRhdGEoKSB7XG4gICAgaWYgKHRoaXMuX2V4dHJhY3RlZE1ldGFkYXRhID09IG51bGwpIHtcbiAgICAgIHRoaXMuX2V4dHJhY3RlZE1ldGFkYXRhID0gbmV3IEdyYXBoKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9leHRyYWN0ZWRNZXRhZGF0YTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyB0aGUgcmVzb3VyY2UgZm9yIHRoaXMgZW50cnkgaWYgaXQgZXhpc3RzIGluIGEgcHJvbWlzZSxcbiAgICogZS5nLiBpZiB0aGUgZ3JhcGgtdHlwZSBpcyBub3Qgbm9uZS5cbiAgICogSXQgaXMgYWxzbyBwb3NzaWJsZSB0byByZXF1ZXN0IHRoZSByZXNvdXJjZSBkaXJlY3RseSwgaS5lLiBnZXQgdGhlIHJlc291cmNlIHJhdGhlclxuICAgKiB0aGFuIGEgcHJvbWlzZS4gVGhpcyBpcyBhY2hpZXZlZCBieSBzcGVjaWZ5aW5nIHRoZSBcImRpcmVjdFwiIHBhcmFtZXRlciBhcyB0cnVlLlxuICAgKiBUaGlzIGFsd2F5cyB3b3JrIGZvciBMaXN0cywgR3JvdXBzLCBhbmQgQ29udGV4dCByZXNvdXJjZXMuXG4gICAqIEZvciBhbGwgb3RoZXIgcmVzb3VyY2VzIGl0IHdpbGwgd29yayBpZiB0aGUgcmVzb3VyY2UsIGUuZy4gYSBHcmFwaCxcbiAgICogYSBTdHJpbmcgZXRjLiBpcyBhbHJlYWR5IGxvYWRlZC4gSWYgaXQgaXMgbm90IGxvYWRlZCBudWxsIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9SZXNvdXJjZSB8IFByb21pc2UuPHN0b3JlL1Jlc291cmNlPn1cbiAgICovXG4gIGdldFJlc291cmNlKGRpcmVjdCA9IGZhbHNlKSB7XG4gICAgaWYgKGRpcmVjdCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlO1xuICAgIH1cbiAgICBjb25zdCBlcyA9IHRoaXMuZ2V0RW50cnlTdG9yZSgpO1xuICAgIGxldCBwcm9taXNlO1xuICAgIGlmICh0aGlzLl9yZXNvdXJjZSkge1xuICAgICAgcHJvbWlzZSA9IFByb21pc2UucmVzb2x2ZSh0aGlzLl9yZXNvdXJjZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuaXNTdHJpbmcoKSA/ICd0ZXh0JyA6IG51bGw7XG4gICAgICBwcm9taXNlID0gZXMuZ2V0UkVTVCgpLmdldCh0aGlzLmdldFJlc291cmNlVVJJKCksIGZvcm1hdCkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBmYWN0b3J5LnVwZGF0ZU9yQ3JlYXRlUmVzb3VyY2UodGhpcywgeyByZXNvdXJjZTogZGF0YSB9LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Jlc291cmNlO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhwcm9taXNlLCAnZ2V0UmVzb3VyY2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7cmRmanNvbi9HcmFwaH1cbiAgICovXG4gIGdldFJlZmVycmVyc0dyYXBoKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWxhdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgVVJJcyB0aGF0IGhhcyByZWZlcnJlZCB0byB0aGlzIEVudHJ5IHVzaW5nIHZhcmlvdXMgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BcbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgZ2V0UmVmZXJyZXJzKHByb3ApIHtcbiAgICByZXR1cm4gdGhpcy5fcmVsYXRpb24uZmluZChudWxsLCBwcm9wLCBudWxsKS5tYXAoc3RtdCA9PiBzdG10LmdldFN1YmplY3QoKSk7XG4gIH1cblxuICAvKipcbiAgICogYSBsaXN0IG9mIGVudHJ5IFVSSXMgY29ycmVzcG9uZGluZyB0byBsaXN0IGVudHJpZXMgd2hlcmUgdGhpcyBlbnRyeSBpcyBjb250YWluZWQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIGdldFBhcmVudExpc3RzKCkge1xuICAgIGNvbnN0IGxpc3RSZXNvdXJjZVVSSUFyciA9IHRoaXMuZ2V0UmVmZXJyZXJzKCdodHRwOi8vZW50cnlzdG9yZS5vcmcvdGVybXMvaGFzTGlzdE1lbWJlcicpO1xuICAgIHJldHVybiBsaXN0UmVzb3VyY2VVUklBcnIubWFwKHJlc1VSSSA9PlxuICAgICAgZmFjdG9yeS5nZXRFbnRyeVVSSUZyb21VUkkodGhpcy5nZXRFbnRyeVN0b3JlKCksIHJlc1VSSSksIHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIGEgbGlzdCBvZiBlbnRyeSBVUklzIGNvcnJlc3BvbmRpbmcgdG8gZ3JvdXBzIHdoZXJlIHRoaXMgdXNlciBlbnRyeSBpcyBtZW1iZXIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICovXG4gIGdldFBhcmVudEdyb3VwcygpIHtcbiAgICBjb25zdCBncm91cFJlc291cmNlVVJJQXJyID0gdGhpcy5nZXRSZWZlcnJlcnMoJ2h0dHA6Ly9lbnRyeXN0b3JlLm9yZy90ZXJtcy9oYXNHcm91cE1lbWJlcicpO1xuICAgIHJldHVybiBncm91cFJlc291cmNlVVJJQXJyLm1hcChyZXNVUkkgPT5cbiAgICAgIGZhY3RvcnkuZ2V0RW50cnlVUklGcm9tVVJJKHRoaXMuZ2V0RW50cnlTdG9yZSgpLCByZXNVUkkpLCB0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBhIGxpc3Qgb2YgY29tbWVudHMgKGkuZS4gdGhlaXIgVVJJcykgb2YgdGhpcyBlbnRyeS5cbiAgICogQHJldHVybnMge3N0cmluZ1tdfVxuICAgKi9cbiAgZ2V0Q29tbWVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVmZXJyZXJzKCdodHRwOi8vb250b2xvZ2kuZXMvbGlrZSNyZWdhcmRpbmcnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgcmVzb3VyY2Ugb2YgdGhpcyBlbnRyeSBvZiB0aGUgR3JhcGhUeXBlIGxpc3Q/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNMaXN0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5SW5mbygpLmdldEdyYXBoVHlwZSgpID09PSB0eXBlcy5HVF9MSVNUO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSByZXNvdXJjZSBvZiB0aGlzIGVudHJ5IG9mIHRoZSBHcmFwaHR5cGUgcmVzdWx0bGlzdD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1Jlc3VsdExpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0R3JhcGhUeXBlKCkgPT09IHR5cGVzLkdUX1JFU1VMVExJU1Q7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIHJlc291cmNlIG9mIHRoaXMgZW50cnkgb2YgdGhlIEdyYXBoVHlwZSBjb250ZXh0P1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzQ29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRHcmFwaFR5cGUoKSA9PT0gdHlwZXMuR1RfQ09OVEVYVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgcmVzb3VyY2Ugb2YgdGhpcyBlbnRyeSBvZiB0aGUgR3JhcGhUeXBlIHN5c3RlbWNvbnRleHQ/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNTeXN0ZW1Db250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5SW5mbygpLmdldEdyYXBoVHlwZSgpID09PSB0eXBlcy5HVF9TWVNURU1DT05URVhUO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSByZXNvdXJjZSBvZiB0aGlzIGVudHJ5IG9mIHRoZSBHcmFwaFR5cGUgdXNlcj9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1VzZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0R3JhcGhUeXBlKCkgPT09IHR5cGVzLkdUX1VTRVI7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIHJlc291cmNlIG9mIHRoaXMgZW50cnkgb2YgdGhlIEdyYXBoVHlwZSBncm91cD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0dyb3VwKCkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5SW5mbygpLmdldEdyYXBoVHlwZSgpID09PSB0eXBlcy5HVF9HUk9VUDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgcmVzb3VyY2Ugb2YgdGhpcyBlbnRyeSBvZiB0aGUgR3JhcGhUeXBlIGdyYXBoP1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzR3JhcGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0R3JhcGhUeXBlKCkgPT09IHR5cGVzLkdUX0dSQVBIO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSByZXNvdXJjZSBvZiB0aGlzIGVudHJ5IG9mIHRoZSBHcmFwaFR5cGUgcGlwZWxpbmU/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNQaXBlbGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRHcmFwaFR5cGUoKSA9PT0gdHlwZXMuR1RfUElQRUxJTkU7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIHJlc291cmNlIG9mIHRoaXMgZW50cnkgb2YgdGhlIEdyYXBoVHlwZSBwaXBlbGluZXJlc3VsdD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1BpcGVsaW5lUmVzdWx0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5SW5mbygpLmdldEdyYXBoVHlwZSgpID09PSB0eXBlcy5HVF9QSVBFTElORVJFU1VMVDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgcmVzb3VyY2Ugb2YgdGhpcyBlbnRyeSBvZiB0aGUgR3JhcGhUeXBlIHN0cmluZz9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRHcmFwaFR5cGUoKSA9PT0gdHlwZXMuR1RfU1RSSU5HO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSByZXNvdXJjZSBvZiB0aGlzIGVudHJ5IG9mIHRoZSBHcmFwaFR5cGUgbm9uZT9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc05vbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0R3JhcGhUeXBlKCkgPT09IHR5cGVzLkdUX05PTkU7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhpcyBlbnRyeSBvZiB0aGUgRW50cnlUeXBlIGxpbms/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNMaW5rKCkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5SW5mbygpLmdldEVudHJ5VHlwZSgpID09PSB0eXBlcy5FVF9MSU5LO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoaXMgZW50cnkgb2YgdGhlIEVudHJ5VHlwZSByZWZlcmVuY2U/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaXNSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0RW50cnlUeXBlKCkgPT09IHR5cGVzLkVUX1JFRjtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGlzIGVudHJ5IG9mIHRoZSBFbnRyeVR5cGUgbGlua3JlZmVyZW5jZT9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0xpbmtSZWZlcmVuY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0RW50cnlUeXBlKCkgPT09IHR5cGVzLkVUX0xJTktSRUY7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGVudHJ5IG9mIHRoZSBFbnRyeVR5cGUgbGluaywgbGlua3JlZmVyZW5jZSBvciByZWZlcmVuY2U/XG4gICAqIFRoYXQgaXMsIHRoZSByZXNvdXJjZSBjYW4gYmUgY29udHJvbGxlZCB2aWEge0BsaW5rIHN0b3JlL0VudHJ5SW5mbyNzZXRSZXNvdXJjZVVSSX0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIGVudHJ5dHlwZSBpcyBOT1QgbG9jYWwuXG4gICAqL1xuICBpc0V4dGVybmFsKCkge1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5SW5mbygpLmdldEVudHJ5VHlwZSgpICE9PSB0eXBlcy5FVF9MT0NBTDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgRW50cnlUeXBlIGxvY2FsLCBpLmUuIHRoZSByZXNvdXJjZXMgVVJJIGlzIG1haW50YWluZWRcbiAgICogYXV0b21hdGljYWxseSBieSB0aGUgcmVwb3NpdG9yeSBmb3IgdGhpcyBlbnRyeS5cbiAgICogT3Bwb3NpdGUgdG8ge0BsaW5rIHN0b3JlL0VudHJ5I2lzTGlua0xpa2V9LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0RW50cnlUeXBlKCkgPT09IHR5cGVzLkVUX0xPQ0FMO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBlbnRyeSBhIGxvY2FsIGxpbmsvbGlua3JlZmVyZW5jZS9yZWZlcmVuY2UgdG8gYW5vdGhlciBlbnRyeSBpbiB0aGUgcmVwb3NpdG9yeS5cbiAgICogVGhhdCBpcywgdHJ1ZSBpZiB0aGUgZW50cnkgaXMgYSBsaW5rLCBsaW5rcmVmZXJlbmNlIG9yIHJlZmVyZW5jZSBBTkQgdGhlIHJlc291cmNlIFVSSVxuICAgKiBiZWxvbmdzIHRvIGFub3RoZXIgZW50cnkgaW4gdGhlIHNhbWUgcmVwb3NpdG9yeS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0xpbmtUb0VudHJ5KCkge1xuICAgIGNvbnN0IGJhc2UgPSB0aGlzLmdldEVudHJ5U3RvcmUoKS5nZXRCYXNlVVJJKCk7XG4gICAgcmV0dXJuIHRoaXMuaXNFeHRlcm5hbCgpICYmIHRoaXMuZ2V0UmVzb3VyY2VVUkkoKS5zdWJzdHIoMCwgYmFzZS5sZW5ndGgpID09PSBiYXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIElzIHRoZSBlbnRyeSBpcyBhIGxpbmsgdG8gYW5vdGhlciBlbnRyeSAoYXMgZWl0aGVyIGEgbGluaywgbGlua3JlZmVyZW5jZSBvciByZWZlcmVuY2UpIHRoZVxuICAgKiBsaW5rZWQgdG8gZW50cnkgaXMgcmV0dXJuZWQgaW4gYSBwcm9taXNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnk+fHVuZGVmaW5lZH0gdW5kZWZpbmVkIG9ubHkgaWYgdGhlIGVudHJ5IGRvZXMgbm90IGxpbmsgdG8gYW5vdGhlciBlbnRyeS5cbiAgICovXG4gIGdldExpbmtlZEVudHJ5KCkge1xuICAgIGlmICh0aGlzLmlzTGlua1RvRW50cnkoKSkge1xuICAgICAgLy8gSW4gY2FzZSB0aGUgbGluayBpcyB0byB0aGUgcmVzb3VyY2UgVVJJIHJhdGhlciB0aGFuIHRoZSBlbnRyeSBVUkksIHdlIGV4dHJhY3RcbiAgICAgIC8vIHRoZSBlbnRyeSBpZCBhbmQgY29udGV4dCBpZCBhbmQgcmVidWlsZCB0aGUgZW50cnkgVVJJLlxuICAgICAgY29uc3QgZXMgPSB0aGlzLmdldEVudHJ5U3RvcmUoKTtcbiAgICAgIGNvbnN0IHJlc291cmNlVVJJID0gdGhpcy5nZXRSZXNvdXJjZVVSSSgpO1xuICAgICAgY29uc3QgZW50cnlJZCA9IGVzLmdldEVudHJ5SWQocmVzb3VyY2VVUkkpO1xuICAgICAgY29uc3QgY29udGV4dElkID0gZXMuZ2V0Q29udGV4dElkKHJlc291cmNlVVJJKTtcbiAgICAgIGNvbnN0IGVudHJ5VVJJID0gZXMuZ2V0RW50cnlVUkkoY29udGV4dElkLCBlbnRyeUlkKTtcbiAgICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyh0aGlzLmdldEVudHJ5U3RvcmUoKS5nZXRFbnRyeShlbnRyeVVSSSksICdnZXRMaW5rZWRFbnRyeScpO1xuICAgIH1cblxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGVudHJ5IGFuIGluZm9ybWF0aW9uIHJlc291cmNlP1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGlzSW5mb3JtYXRpb25SZXNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRSZXNvdXJjZVR5cGUoKSA9PT0gdHlwZXMuUlRfSU5GT1JNQVRJT05SRVNPVVJDRTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgZW50cnkgYSBuYW1lZCByZXNvdXJjZT9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc05hbWVkUmVzb3VyY2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cnlJbmZvKCkuZ2V0UmVzb3VyY2VUeXBlKCkgPT09IHR5cGVzLlJUX05BTUVEUkVTT1VSQ0U7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGN1cnJlbnQgdXNlciBhbiBvd25lciBvZiB0aGlzIGVudHJ5P1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIGNhbkFkbWluaXN0ZXJFbnRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRzLmFkbWluaXN0ZXIgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGN1cnJlbnQgdXNlciBhdXRob3JpemVkIHRvIHJlYWQgdGhlIHJlc291cmNlIG9mIHRoaXMgZW50cnk/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuUmVhZFJlc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodHMuYWRtaW5pc3RlciB8fCB0aGlzLl9yaWdodHMucmVhZHJlc291cmNlXG4gICAgICB8fCB0aGlzLl9yaWdodHMud3JpdGVyZXNvdXJjZSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgY3VycmVudCB1c2VyIGF1dGhvcml6ZWQgdG8gd3JpdGUgdGhlIHJlc291cmNlIG9mIHRoaXMgZW50cnk/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuV3JpdGVSZXNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRzLmFkbWluaXN0ZXIgfHwgdGhpcy5fcmlnaHRzLndyaXRlcmVzb3VyY2UgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSXMgdGhlIGN1cnJlbnQgdXNlciBhdXRob3JpemVkIHRvIHJlYWQgdGhlIG1ldGFkYXRhIG9mIHRoaXMgZW50cnk/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuUmVhZE1ldGFkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9yaWdodHMuYWRtaW5pc3RlciB8fCB0aGlzLl9yaWdodHMucmVhZG1ldGFkYXRhXG4gICAgICB8fCB0aGlzLl9yaWdodHMud3JpdGVtZXRhZGF0YSB8fCBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJcyB0aGUgY3VycmVudCB1c2VyIGF1dGhvcml6ZWQgdG8gd3JpdGUgdGhlIG1ldGFkYXRhIG9mIHRoaXMgZW50cnk/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2FuV3JpdGVNZXRhZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmlnaHRzLmFkbWluaXN0ZXIgfHwgdGhpcy5fcmlnaHRzLndyaXRlbWV0YWRhdGEgfHwgZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGVudHJ5IGlzIGF2YWlsYWJsZSBwdWJsaWNhbGx5IG9yIG5vdC5cbiAgICogVG8gbWFrZSBzdXJlIHRoaXMgbWV0aG9kIHJldHVybnMgYSBib29sZWFuIG1ha2Ugc3VyZSB0aGUgY29udGV4dHMgZW50cnkgaXMgbG9hZGVkLCBlLmcuIHZpYTpcbiAgICogZW50cnkuZ2V0Q29udGV4dCgpLmdldEVudHJ5KCkudGhlbihmdW5jdGlvbigpIHtcbiAgICogICAgaWYgKGVudHJ5LmlzUHVibGljKCkpIHsuLi59IC8vT3Igd2hhdGV2ZXIgeW91IG5lZWQgdG8gZG8gd2l0aCB0aGUgaXNQdWJsaWMgbWV0aG9kLlxuICAgKiB9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gdW5kZWZpbmVkIG9ubHkgaWYgdGhlIGVudHJ5IGhhcyBubyBBQ0wgYW5kIHRoZSBjb250ZXh0cyBlbnRyeVxuICAgKiB3aGljaCBzcGVjaWZpZXMgdGhlIGRlZmF1bHQgYWNjZXNzIGlzIG5vdCBjYWNoZWQsIG90aGVyd2lzZSBhIGJvb2xlYW4gaXMgcmV0dXJuZWQuXG4gICAqL1xuICBpc1B1YmxpYygpIHtcbiAgICBjb25zdCBndWVzdFByaW5jaXBhbCA9IHRoaXMuZ2V0RW50cnlTdG9yZSgpLmdldFJlc291cmNlVVJJKCdfcHJpbmNpcGFscycsICdfZ3Vlc3QnKTtcbiAgICBsZXQgYWNsID0gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRBQ0woKTtcbiAgICBpZiAoYWNsLmNvbnRleHRPdmVycmlkZSkge1xuICAgICAgcmV0dXJuIFsncndyaXRlJywgJ3JyZWFkJywgJ213cml0ZScsICdtcmVhZCddLnNvbWUoa2V5ID0+IGFjbFtrZXldLmluZGV4T2YoZ3Vlc3RQcmluY2lwYWwpICE9PSAtMSk7XG4gICAgfVxuICAgIGNvbnN0IGNlID0gdGhpcy5nZXRDb250ZXh0KCkuZ2V0RW50cnkodHJ1ZSk7XG4gICAgaWYgKGNlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGFjbCA9IGNlLmdldEVudHJ5SW5mbygpLmdldEFDTCgpO1xuICAgIHJldHVybiBbJ3J3cml0ZScsICdycmVhZCddLnNvbWUoa2V5ID0+IGFjbFtrZXldLmluZGV4T2YoZ3Vlc3RQcmluY2lwYWwpICE9PSAtMSk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGlzIGVudHJ5IGlzIGF2YWlsYWJsZSB0byB0aGUgc3BlY2lmaWVkIHVzZXIuXG4gICAqIFRvIG1ha2Ugc3VyZSB0aGlzIG1ldGhvZCByZXR1cm5zIGEgYm9vbGVhbiBhbmQgbm90IHVuZGVmaW5lZCxcbiAgICogbWFrZSBzdXJlIHRoYXQgdGhlIGNvbnRleHRzIGVudHJ5IGlzIGxvYWRlZCwgZS5nLiB2aWE6XG4gICAqXG4gICAqIGVudHJ5LmdldENvbnRleHQoKS5nZXRFbnRyeSgpLnRoZW4oZnVuY3Rpb24oKSB7XG4gICAqICAgIC8vQW5kIHRoZW4gZG8geW91IGNoZWNrLCBlLmcuOlxuICAgKiAgICBlbnRyeS5nZXRFbnRyeVN0b3JlKCkuZ2V0VXNlckVudHJ5KCkudGhlbihmdW5jdGlvbihjdXJyZW50VXNlckVudHJ5KSB7XG4gICAqICAgICAgIGlmIChlbnRyeS5pc1ByaXZhdGVUbyhjdXJyZW50VXNlckVudHJ5KSB7Li4ufVxuICAgKiAgICB9KVxuICAgKiB9XG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufHVuZGVmaW5lZH0gdW5kZWZpbmVkIGlmIHRoZSBjb250ZXh0cyBlbnRyeSB3aGljaFxuICAgKiBzcGVjaWZpZXMgdGhlIGRlZmF1bHQgYWNjZXNzIGlzIG5vdCBjYWNoZWQsIG90aGVyd2lzZSBhIGJvb2xlYW4gaXMgcmV0dXJuZWQuXG4gICAqL1xuICBpc1ByaXZhdGVUbyh1c2VyRW50cnkpIHtcbiAgICBjb25zdCB1c2VyUHJpbmNpcGFsID0gdXNlckVudHJ5LmdldFJlc291cmNlVVJJKCk7XG4gICAgY29uc3QgYWNsID0gdGhpcy5nZXRFbnRyeUluZm8oKS5nZXRBQ0woKTtcbiAgICBjb25zdCBjZSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEVudHJ5KHRydWUpO1xuICAgIGlmIChjZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBjYWNsID0gY2UuZ2V0RW50cnlJbmZvKCkuZ2V0QUNMKCk7XG4gICAgaWYgKGNhY2wuYWRtaW4ubGVuZ3RoICE9PSAxIHx8IGFjbC5hZG1pblswXSAhPT0gdXNlclByaW5jaXBhbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWNsLmNvbnRleHRPdmVycmlkZSkge1xuICAgICAgcmV0dXJuIGFjbC5hZG1pbi5sZW5ndGggPT09IDEgJiYgYWNsLmFkbWluWzBdID09PSB1c2VyUHJpbmNpcGFsO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoaXMgZW50cnkgd2l0aG91dCBhbnkgb3B0aW9uIHRvIHJlY292ZXIgaXQuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcmVjdXJzaXZlIGlmIHRydWUgYW5kIHRoZSBlbnRyeSBpcyBhIGxpc3QgaXQgd2lsbCBkZWxldGUgdGhlIGVudGlyZSB0cmVlIG9mXG4gICAqIGxpc3RzIGFuZCBhbGwgZW50cmllcyB0aGF0IGlzIG9ubHkgY29udGFpbmVkIGluIHRoZSBjdXJyZW50IGxpc3Qgb3IgYW55IG9mIGl0cyBjaGlsZCBsaXN0cy5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gd2hpY2ggb24gc3VjY2VzcyBpbmRpY2F0ZXMgdGhhdCB0aGUgZGVsZXRpb24gaGFzIHN1Y2NlZWRlZC5cbiAgICovXG4gIGRlbChyZWN1cnNpdmUgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG4gICAgY29uc3QgdW5DYWNoZSA9ICgpID0+IGVzLmdldENhY2hlKCkudW5DYWNoZSh0aGlzKTtcblxuICAgIGlmIChyZWN1cnNpdmUgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhlcy5nZXRSRVNUKCkuZGVsKGAke3RoaXMuZ2V0VVJJKCl9P3JlY3Vyc2l2ZT10cnVlYClcbiAgICAgICAgLnRoZW4odW5DYWNoZSksICdkZWxFbnRyeScpO1xuICAgIH1cblxuICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhlcy5nZXRSRVNUKCkuZGVsKHRoaXMuZ2V0VVJJKCkpLnRoZW4odW5DYWNoZSksICdkZWxFbnRyeScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoYXQgYW4gZW50cnkgbmVlZHMgdG8gYmUgcmVmcmVzaGVkIHR5cGljYWxseSBtZWFucyB0aGF0IGl0IGNvbnRhaW5zIHN0YWxlIGRhdGFcbiAgICogKHdpdGggcmVzcGVjdCB0byB3aGF0IGlzIGF2YWlsYWJsZSBpbiB0aGUgc3RvcmUpLlxuICAgKiBUaGUgZW50cnkgc2hvdWxkIGJlIHJlZnJlc2ggYmVmb3JlIGl0IGlzIGZ1cnRoZXIgdXNlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2lsZW50bHkgdGhlIGNhY2hlIHdpbGwgc2VuZCBvdXQgYSBzdGFsZSBtZXNzYWdlICh0byBhbGwgcmVnaXN0ZXJlZFxuICAgKiBsaXN0ZW5lcnMgb2YgdGhlIGNhY2hlKSBmb3IgdGhpcyBlbnRyeSBpZiB0aGUgdmFsdWUgaXMgZmFsc2Ugb3IgdW5kZWZpbmVkLlxuICAgKiBAc2VlIHN0b3JlLkVudHJ5I3JlZnJlc2guXG4gICAqL1xuICBzZXRSZWZyZXNoTmVlZGVkKHNpbGVudGx5ID0gdHJ1ZSkge1xuICAgIHRoaXMuZ2V0RW50cnlTdG9yZSgpLmdldENhY2hlKCkuc2V0UmVmcmVzaE5lZWRlZCh0aGlzLCBzaWxlbnRseSk7XG4gIH1cblxuICAvKipcbiAgICogVGVsbHMgd2hldGhlciBhbiBlbnRyeSBuZWVkcyB0byBiZSByZWZyZXNoZWQuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIGVudHJ5IG5lZWQgdG8gYmUgcmVmcmVzaGVkIGJlZm9yZSB1c2VkLlxuICAgKiBAc2VlIHN0b3JlL0VudHJ5I3JlZnJlc2guXG4gICAqL1xuICBuZWVkUmVmcmVzaCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFbnRyeVN0b3JlKCkuZ2V0Q2FjaGUoKS5uZWVkUmVmcmVzaCh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWZyZXNoZXMgYW4gZW50cnkgaWYgbmVlZGVkLCB0aGF0IGlzLCBpZiBpdCBoYXMgYmVlbiBtYXJrZWQgYXMgaW52YWxpZC5cbiAgICogQHBhcmFtIHtib29sZWFuPX0gc2lsZW50bHkgdGhlIGNhY2hlIHdpbGwgc2VuZCBvdXQgYSByZWZyZXNoIG1lc3NhZ2UgZm9yIHRoaXMgZW50cnlcbiAgICogaWYgYSByZWZyZXNoIHdhcyBuZWVkZWQgQU5EIGlmIHRoZSB2YWx1ZSBvZiBzaWxlbnRseSBpcyBmYWxzZSBvciB1bmRlZmluZWQuIElmIGZvcmNlIGlzIHRydWVcbiAgICogaXQgd2lsbCBzZW5kIG91dCBhIHJlZnJlc2ggbWVzc2FnZSBhbnlob3cuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IFtmb3JjZT1mYWxzZV0gSWYgdHJ1ZSB0aGUgZW50cnkgd2lsbCBiZSByZWZyZXNoZWQgaW5kZXBlbmRlbnQgaWYgaXQgd2FzIG1hcmtlZCBpbiBuZWVkXG4gICAqIG9mIGEgcmVmcmVzaCBvciBub3QuXG4gICAqL1xuICByZWZyZXNoKHNpbGVudGx5ID0gdHJ1ZSwgZm9yY2UgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG4gICAgbGV0IHA7XG4gICAgaWYgKGZvcmNlID09PSB0cnVlIHx8IGVzLmdldENhY2hlKCkubmVlZFJlZnJlc2godGhpcykpIHtcbiAgICAgIGNvbnN0IGVudHJ5VVJJID0gdGhpcy5nZXRVUkkoKTtcbiAgICAgIHAgPSBlcy5nZXRSRVNUKCkuZ2V0KGZhY3RvcnkuZ2V0RW50cnlMb2FkVVJJKGVudHJ5VVJJKSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBmYWN0b3J5LnVwZGF0ZSh0aGlzLCBkYXRhKTtcbiAgICAgICAgZXMuZ2V0Q2FjaGUoKS5jYWNoZSh0aGlzLCBzaWxlbnRseSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHAgPSBQcm9taXNlLnJlc29sdmUodGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhwLCAncmVmcmVzaCcpO1xuICB9XG59O1xuIiwiaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgR3JhcGggfSBmcm9tICdyZGZqc29uJztcbmltcG9ydCBmYWN0b3J5IGZyb20gJy4vZmFjdG9yeSc7XG5pbXBvcnQgdGVybXMgZnJvbSAnLi90ZXJtcyc7XG5cbi8qKlxuICogRW50cnlJbmZvIGlzIGEgY2xhc3MgdGhhdCBjb250YWlucyBhbGwgdGhlIGFkbWluaXN0cmF0aXZlIGluZm9ybWF0aW9uIG9mIGFuIGVudHJ5LlxuICogQGV4cG9ydHMgc3RvcmUvRW50cnlJbmZvXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudHJ5SW5mbyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZW50cnlVUkkgbXVzdCBiZSBwcm92aWRlZCB1bmxlc3MgdGhlIGdyYXBoIGNvbnRhaW5zIGEgc3RhdGVtZW50IHdpdGhcbiAgICogdGhlIHN0b3JlOnJlc291cmNlIHByb3BlcnR5IHdoaWNoIGFsbG93cyB1cyB0byBpbmZlciB0aGUgZW50cnlVUkkuXG4gICAqIEBwYXJhbSB7cmRmanNvbi9HcmFwaH0gZ3JhcGggY29ycmVzcG9uZHMgdG8gYSByZGZqc29uLkdyYXBoIGNsYXNzIHdpdGggdGhlIGVudHJ5aW5mbyBhc1xuICAgKiBzdGF0ZW1lbnRzXG4gICAqIEBwYXJhbSB7c3RvcmUvRW50cnlTdG9yZX0gZW50cnlTdG9yZVxuICAgKi9cbiAgY29uc3RydWN0b3IoZW50cnlVUkksIGdyYXBoLCBlbnRyeVN0b3JlKSB7XG4gICAgdGhpcy5fZW50cnlVUkkgPSBlbnRyeVVSSSB8fCBncmFwaC5maW5kKG51bGwsIHRlcm1zLnJlc291cmNlKVswXS5nZXRTdWJqZWN0KCk7XG4gICAgdGhpcy5fZ3JhcGggPSBncmFwaCB8fCBuZXcgR3JhcGgoKTtcbiAgICB0aGlzLl9lbnRyeVN0b3JlID0gZW50cnlTdG9yZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvRW50cnl9XG4gICAqL1xuICBnZXRFbnRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtyZGZqc29uL0dyYXBofSBncmFwaFxuICAgKi9cbiAgc2V0R3JhcGgoZ3JhcGgpIHtcbiAgICB0aGlzLl9ncmFwaCA9IGdyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge3JkZmpzb24vR3JhcGh9XG4gICAqL1xuICBnZXRHcmFwaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGg7XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIHRoZSBlbnRyeSBpbmZvcm1hdGlvbiB0byB0aGUgcmVwb3NpdG9yeSwgZS5nLiBwb3N0cyB0b1xuICAgKiBiYXNlcGF0aC9zdG9yZS97Y29udGV4dElkfS9lbnRyeS97ZW50cnlJZH1cbiAgICogQHBhcmFtcyB7Ym9vbGVhbn0gaWdub3JlSWZVbm1vZGlmaWVkU2luY2VDaGVjayBpZiBleHBsaWNpdGx5IHNldCB0byB0cnVlIG5vIGNoZWNrIGlzIGRvbmVcbiAgICogaWYgaW5mb3JtYXRpb24gaXMgc3RhbGUsIGFsc28gaXQgd2lsbCBub3QgYXV0b21hdGljYWxseSByZWZyZXNoIHdpdGggdGhlIGxhdGVzdCBkYXRlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxzdG9yZS9FbnRyeUluZm8+fVxuICAgKi9cbiAgY29tbWl0KGlnbm9yZUlmVW5tb2RpZmllZFNpbmNlQ2hlY2sgPSBmYWxzZSkge1xuICAgIGNvbnN0IGVzID0gdGhpcy5fZW50cnkuZ2V0RW50cnlTdG9yZSgpO1xuICAgIGxldCBtb2Q7XG4gICAgaWYgKGlnbm9yZUlmVW5tb2RpZmllZFNpbmNlQ2hlY2sgPT09IHRydWUpIHtcbiAgICAgIG1vZCA9IHRoaXMuZ2V0TW9kaWZpY2F0aW9uRGF0ZSgpO1xuICAgIH1cbiAgICBjb25zdCBwID0gZXMuZ2V0UkVTVCgpLnB1dCh0aGlzLmdldEVudHJ5VVJJKCksXG4gICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLl9ncmFwaC5leHBvcnRSREZKU09OKCkpLCBtb2QpXG4gICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgIGlmIChpZ25vcmVJZlVubW9kaWZpZWRTaW5jZUNoZWNrICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5fZW50cnkuc2V0UmVmcmVzaE5lZWRlZCh0cnVlKTtcbiAgICAgICAgICByZXR1cm4gdGhpcy5fZW50cnkucmVmcmVzaCgpLnRoZW4oKCkgPT4gdGhpcywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gRmFpbGVkIHJlZnJlc2hpbmcsIGJ1dCBzdWNjZWVkZWQgYXQgc2F2aW5nIG1ldGFkYXRhLFxuICAgICAgICAgICAgLy8gYXQgbGVhc3Qgc2VuZCBvdXQgbWVzc2FnZSB0aGF0IGl0IG5lZWRzIHRvIGJlIHJlZnJlc2hlZC5cbiAgICAgICAgICAgIGVzLmdldENhY2hlKCkubWVzc2FnZSgncmVmcmVzaGVkJywgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0pO1xuXG4gICAgcmV0dXJuIGVzLmhhbmRsZUFzeW5jKHAsICdjb21taXRFbnRyeUluZm8nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0RW50cnlVUkkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5VVJJO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBpZCBvZiB0aGUgZW50cnlcbiAgICovXG4gIGdldElkKCkge1xuICAgIHJldHVybiBmYWN0b3J5LmdldEVudHJ5SWQodGhpcy5fZW50cnlVUkkpO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBlbnRyeSBpcyBhIHVzZXIsIGdyb3VwIG9yIGNvbnRleHQgdGhlcmUgY2FuIGJlIGEgbmFtZS5cbiAgICogSW4gZ2VuZXJhbCB0aGUgbmFtZSBpcyBhY2Nlc3NlZCBvbiB0aGUgcmVzb3VyY2UsIGJ1dCBpbiBjZXJ0YWluXG4gICAqIHNpdHVhdGlvbnMgd2UgZG8gbm90IGhhdmUgdGhlIHJlc291cmNlIHlldChub3QgbG9hZGVkKSBidXQgd2Ugc3RpbGxcbiAgICogaGF2ZSB0aGUgbmFtZSAoZnJvbSBhIHNlYXJjaCB3aGVyZSB0aGUgbmFtZSBpcyBwcm92aWRlZCBidXQgbm90IHRoZSByZXNvdXJjZSksXG4gICAqIGluIHRoaXMgY2FzZSB3ZSBjYW4gYWNjZXNzIHRoaXMgbmFtZSBoZXJlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBhIHVzZXJuYW1lLCBncm91cG5hbWUgb3IgY29udGV4dG5hbWUgb2YgdGhlIGVudHJ5XG4gICAqL1xuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIElmIHRoZSBlbnRyeSBpcyBhIHVzZXIgdGhlcmUgY2FuIGJlIGEgZGlzYWJsZWQgc3RhdGUuXG4gICAqIEluIGdlbmVyYWwgdGhlIGRpc2FibGVkIHN0YXRlIGlzIGFjY2Vzc2VkIG9uIHRoZSByZXNvdXJjZSwgYnV0IGluIGNlcnRhaW5cbiAgICogc2l0dWF0aW9ucyB3ZSBkbyBub3QgaGF2ZSB0aGUgcmVzb3VyY2UgeWV0KG5vdCBsb2FkZWQpIGJ1dCB3ZSBzdGlsbFxuICAgKiBoYXZlIHRoZSBkaXNhYmxlZCBzdGF0ZSAoZnJvbSBhIHNlYXJjaCB3aGVyZSB0aGUgZGlzYWJsZWQgc3RhdGUgaXMgcHJvdmlkZWRcbiAgICogYnV0IG5vdCB0aGUgcmVzb3VyY2UpLCBpbiB0aGlzIGNhc2Ugd2UgY2FuIGFjY2VzcyB0aGUgZGlzYWJsZWQgc3RhdGUgaGVyZS5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IGEgZGlzYWJsZWQgc3RhdGUgb2YgYSB1c2VyXG4gICAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kaXNhYmxlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0TWV0YWRhdGFVUkkoKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZ2V0TWV0YWRhdGFVUklGcm9tVVJJKHRoaXMuX2VudHJ5U3RvcmUsIHRoaXMuX2VudHJ5VVJJKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0RXh0ZXJuYWxNZXRhZGF0YVVSSSgpIHtcbiAgICAvLyBUT0RPIHdpbGwgb25seSBleGlzdCBmb3IgTGlua1JlZmVyZW5jZXMgYW5kIFJlZmVyZW5jZXMuXG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRoaXMuX2VudHJ5VVJJLCB0ZXJtcy5leHRlcm5hbE1ldGFkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdXJpXG4gICAqL1xuICBzZXRFeHRlcm5hbE1ldGFkYXRhVVJJKHVyaSkge1xuICAgIHRoaXMuX2dyYXBoLmZpbmRBbmRSZW1vdmUodGhpcy5fZW50cnlVUkksIHRlcm1zLmV4dGVybmFsTWV0YWRhdGEpO1xuICAgIHRoaXMuX2dyYXBoLmNyZWF0ZSh0aGlzLl9lbnRyeVVSSSwgdGVybXMuZXh0ZXJuYWxNZXRhZGF0YSwgeyB0eXBlOiAndXJpJywgdmFsdWU6IHVyaSB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YVVSSSgpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5nZXRDYWNoZWRFeHRlcm5hbE1ldGFkYXRhVVJJKHRoaXMuX2VudHJ5VVJJKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0UmVzb3VyY2VVUkkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRoaXMuX2VudHJ5VVJJLCB0ZXJtcy5yZXNvdXJjZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVyaVxuICAgKi9cbiAgc2V0UmVzb3VyY2VVUkkodXJpKSB7XG4gICAgY29uc3Qgb2xkUmVzb3VyY2VVUkkgPSB0aGlzLmdldFJlc291cmNlVVJJKCk7XG4gICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZSh0aGlzLl9lbnRyeVVSSSwgdGVybXMucmVzb3VyY2UpO1xuICAgIHRoaXMuX2dyYXBoLmNyZWF0ZSh0aGlzLl9lbnRyeVVSSSwgdGVybXMucmVzb3VyY2UsIHsgdHlwZTogJ3VyaScsIHZhbHVlOiB1cmkgfSk7XG4gICAgaWYgKG9sZFJlc291cmNlVVJJKSB7XG4gICAgICBjb25zdCBzdG10cyA9IHRoaXMuX2dyYXBoLmZpbmQob2xkUmVzb3VyY2VVUkkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdG10cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdG10c1tpXS5zZXRTdWJqZWN0KHVyaSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IG9uZSBvZiB0aGUgZW50cnlUeXBlc1xuICAgKiBAc2VlIHN0b3JlL3Rlcm1zI2VudHJ5VHlwZVxuICAgKi9cbiAgZ2V0RW50cnlUeXBlKCkge1xuICAgIGNvbnN0IGV0ID0gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUodGhpcy5fZW50cnlVUkksIHRlcm1zLnJkZi50eXBlKTtcbiAgICByZXR1cm4gdGVybXMuZW50cnlUeXBlW2V0IHx8ICdkZWZhdWx0J107XG4gIH1cblxuICBzdGF0aWMgZ2V0UmVzb3VyY2VUeXBlSGVscGVyKGVudHJ5LCB2b2NhYikge1xuICAgIGNvbnN0IHN0bXRzID0gZW50cnkuX2dyYXBoLmZpbmQoZW50cnkuZ2V0UmVzb3VyY2VVUkkoKSwgdGVybXMucmRmLnR5cGUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RtdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHQgPSB2b2NhYltzdG10c1tpXS5nZXRWYWx1ZSgpXTtcbiAgICAgIGlmICh0ICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZvY2FiLmRlZmF1bHQ7XG4gIH1cblxuICAvKipcbiAgICogdGhlIHJlc291cmNlIHR5cGUgb2YgdGhlIGVudHJ5LCBlLmcuIFwiSW5mb3JtYXRpb25cIiwgXCJSZXNvbHZhYmxlXCIgZXRjLlxuICAgKiBUaGUgYWxsb3dlZCB2YWx1ZXMgYXJlIGF2YWlsYWJsZSBpbiBzdG9yZS90eXBlcyBiZWdpbm5pbmcgd2l0aCAnUlRfJy5cbiAgICogRS5nLiB0byBjaGVjayBpZiB0aGUgZW50cnkgaXMgYW4gaW5mb3JtYXRpb24gcmVzb3VyY2U6XG4gICAqIGlmIChlaS5nZXRSZXNvdXJjZVR5cGUoKSA9PT0gdHlwZXMuUlRfSU5GT1JNQVRJT05SRVNPVVJDRSkgey4uLn1cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldFJlc291cmNlVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRSZXNvdXJjZVR5cGVIZWxwZXIodGhpcywgdGVybXMucmVzb3VyY2VUeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgZ3JhcGggdHlwZSBvZiB0aGUgZW50cnksIGUuZy4gXCJVc2VyXCIsIFwiTGlzdFwiLCBcIlN0cmluZ1wiLCBldGMuXG4gICAqIFRoZSBhbGxvd2VkIHZhbHVlcyBhcmUgYXZhaWxhYmxlIGluIHN0b3JlL3R5cGVzIGJlZ2lubmluZyB3aXRoICdHVF8nLlxuICAgKiBFLmcuIHRvIGNoZWNrIGlmIHRoZSBlbnRyeSBpcyBhIGxpc3Q6XG4gICAqIGlmIChlaS5nZXRHcmFwaFR5cGUoKSA9PT0gdHlwZXMuR1RfTElTVCkgey4uLn1cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIGdldEdyYXBoVHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5nZXRSZXNvdXJjZVR5cGVIZWxwZXIodGhpcywgdGVybXMuZ3JhcGhUeXBlKTtcbiAgfVxuXG4gIC8vIFRPRE86IGNoYW5nZSB0byBlbnRyeVVSSSBpbnN0ZWFkIG9mIHJlc291cmNlVVJJIGZvciBwcmluY2lwYWxVUklzLlxuICAvKipcbiAgICogVGhlIGFjbCBvYmplY3QgcmV0dXJuZWQgbG9va3MgbGlrZTpcbiAgICoge1xuICAgKiAgIGFkbWluOiAgW3ByaW5jaXBhbFVSSTEsIHByaW5jaXBhbFVSSTIsIC4uLl0sXG4gICAqICAgcnJlYWQ6ICBbcHJpbmNpcGFsVVJJMywgLi4uXSxcbiAgICogICByd3JpdGU6IFtwcmluY2lwYWxVUkk0LCAuLi5dLFxuICAgKiAgIG1yZWFkOiAgW3ByaW5jaXBhbFVSSTUsIC4uLl0sXG4gICAqICAgbXdyaXRlOiBbcHJpbmNpcGFsVVJJNiwgLi4uXVxuICAgKiB9XG4gICAqXG4gICAqIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGFuIGFycmF5IGZvciBlYWNoIGtleSwgaXQgbWlnaHQgYmUgZW1wdHkgdGhvdWdoLlxuICAgKiBUaGUgcHJpbmNpcGFsVVJJKiB3aWxsIGFsd2F5cyBiZSBhbiBVUkkgdG8gdGhlIHJlc291cmNlIG9mIGEgdXNlciBvciBncm91cCBlbnRyeS5cbiAgICpcbiAgICogUGxlYXNlIG5vdGUgdGhhdCBhIG5vbiBlbXB0eSBhY2wgb3ZlcnJpZGVzIGFueSBkZWZhdWx0cyBmcm9tIHRoZSBzdXJyb3VuZGluZyBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGFzSWRzIC0gaWYgdHJ1ZSB0aGUgcHJpbmNpcGFsVVJJcyBhcmUgc2hvcnRlbmVkIHRvIGVudHJ5IGlkZW50aWZpZXJzLlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IGFuIGFjbCBvYmplY3QuXG4gICAqL1xuICBnZXRBQ0woYXNJZHMgPSBmYWxzZSkge1xuICAgIGNvbnN0IGYgPSAoc3RtdCkgPT4ge1xuICAgICAgaWYgKGFzSWRzKSB7XG4gICAgICAgIHJldHVybiBmYWN0b3J5LmdldEVudHJ5SWQoc3RtdC5nZXRWYWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzdG10LmdldFZhbHVlKCk7XG4gICAgfTsgIC8vIFN0YXRlbWVudCA+IG9iamVjdCB2YWx1ZS5cbiAgICBjb25zdCBydSA9IHRoaXMuZ2V0UmVzb3VyY2VVUkkoKTtcbiAgICBjb25zdCBtdSA9IHRoaXMuZ2V0TWV0YWRhdGFVUkkoKTtcbiAgICBjb25zdCBhY2wgPSB7XG4gICAgICBhZG1pbjogdGhpcy5fZ3JhcGguZmluZCh0aGlzLl9lbnRyeVVSSSwgdGVybXMuYWNsLndyaXRlKS5tYXAoZiksXG4gICAgICBycmVhZDogdGhpcy5fZ3JhcGguZmluZChydSwgdGVybXMuYWNsLnJlYWQpLm1hcChmKSxcbiAgICAgIHJ3cml0ZTogdGhpcy5fZ3JhcGguZmluZChydSwgdGVybXMuYWNsLndyaXRlKS5tYXAoZiksXG4gICAgICBtcmVhZDogdGhpcy5fZ3JhcGguZmluZChtdSwgdGVybXMuYWNsLnJlYWQpLm1hcChmKSxcbiAgICAgIG13cml0ZTogdGhpcy5fZ3JhcGguZmluZChtdSwgdGVybXMuYWNsLndyaXRlKS5tYXAoZiksXG4gICAgfTtcbiAgICBhY2wuY29udGV4dE92ZXJyaWRlID0gYWNsLmFkbWluLmxlbmd0aCAhPT0gMCB8fCBhY2wucnJlYWQubGVuZ3RoICE9PSAwXG4gICAgICB8fCBhY2wucndyaXRlLmxlbmd0aCAhPT0gMCB8fCBhY2wubXJlYWQubGVuZ3RoICE9PSAwIHx8IGFjbC5td3JpdGUubGVuZ3RoICE9PSAwO1xuICAgIHJldHVybiBhY2w7XG4gIH1cblxuICAvKipcbiAgICogaWYgdGhlIGVudHJ5IGhhcyBhbiBleHBsaWNpdCBBQ0wgb3IgaWYgdGhlIGNvbnRhaW5pbmcgY29udGV4dHMgQUNMIGlzIHVzZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgaGFzQUNMKCkge1xuICAgIHJldHVybiB0aGlzLmdldEFDTCgpLmNvbnRleHRPdmVycmlkZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBhY2wgd2l0aCB0aGUgcHJvdmlkZWQgYWNsLlxuICAgKiBUaGUgYWNsIG9iamVjdCBpcyB0aGUgc2FtZSBhcyB5b3UgZ2V0IGZyb20gdGhlIGdldEFDTCBjYWxsLlxuICAgKiBUaGUgZmlyc3QgZGlmZmVyZW5jZSBpcyB0aGF0IHRoZSBhY2wgb2JqZWN0IGZyb20gdGhpcyBtZXRob2QgaXMgYWxsb3dlZCB0byBiZSBlbXB0eVxuICAgKiBvciBsZWF2ZSBvdXQgc29tZSBrZXlzIHRoYXQgYXJlIG5vdCB0byBiZSBzZXQuXG4gICAqIFRoZSBzZWNvbmQgZGlmZmVyZW5jZSBpcyB0aGF0IGl0IGFsbG93cyBlbnRyeUlkcyBhcyB2YWx1ZXMgaW4gdGhlIGFycmF5cyxcbiAgICogbm90IG9ubHkgZnVsbCByZXNvdXJjZSBVUklzLCBib3RoIGhhdmUgdG8gcmVmZXIgdG8gcHJpbmNpcGFscyB0aG91Z2guXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBhY2wgc2FtZSBraW5kIG9mIG9iamVjdCB5b3UgZ2V0IGZyb20gZ2V0QUNMLlxuICAgKi9cbiAgc2V0QUNMKGFjbCkge1xuICAgIGNvbnN0IGcgPSB0aGlzLl9ncmFwaDtcbiAgICBjb25zdCBmID0gKHN1YmosIHByZWQsIHByaW5jaXBhbHMsIGJhc2UpID0+IHtcbiAgICAgIGcuZmluZEFuZFJlbW92ZShzdWJqLCBwcmVkKTtcbiAgICAgIChwcmluY2lwYWxzIHx8IFtdKS5mb3JFYWNoKChwcmluY2lwYWwpID0+IHtcbiAgICAgICAgaWYgKHByaW5jaXBhbC5sZW5ndGggPCBiYXNlLmxlbmd0aCB8fCBwcmluY2lwYWwuaW5kZXhPZihiYXNlKSAhPT0gMCkge1xuICAgICAgICAgIC8vIHByaW5jaXBhbCBpcyBlbnRyeSBpZC5cbiAgICAgICAgICBnLmFkZChzdWJqLCBwcmVkLCB7IHR5cGU6ICd1cmknLCB2YWx1ZTogYmFzZSArIHByaW5jaXBhbCB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBwcmluY2lwYWwgaXMgYSBmdWxsIGVudHJ5IHJlc291cmNlIHVyaS5cbiAgICAgICAgICBnLmFkZChzdWJqLCBwcmVkLCB7IHR5cGU6ICd1cmknLCB2YWx1ZTogcHJpbmNpcGFsIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IF9hY2wgPSBhY2wgfHwge307XG4gICAgY29uc3QgcnUgPSB0aGlzLmdldFJlc291cmNlVVJJKCk7XG4gICAgY29uc3QgbXUgPSB0aGlzLmdldE1ldGFkYXRhVVJJKCk7XG4gICAgY29uc3QgYmFzZSA9IGZhY3RvcnkuZ2V0UmVzb3VyY2VCYXNlKHRoaXMuX2VudHJ5LmdldEVudHJ5U3RvcmUoKSwgJ19wcmluY2lwYWxzJyk7XG4gICAgZih0aGlzLl9lbnRyeVVSSSwgdGVybXMuYWNsLndyaXRlLCBfYWNsLmFkbWluLCBiYXNlKTtcbiAgICBmKHJ1LCB0ZXJtcy5hY2wucmVhZCwgX2FjbC5ycmVhZCwgYmFzZSk7XG4gICAgZihydSwgdGVybXMuYWNsLndyaXRlLCBfYWNsLnJ3cml0ZSwgYmFzZSk7XG4gICAgZihtdSwgdGVybXMuYWNsLnJlYWQsIF9hY2wubXJlYWQsIGJhc2UpO1xuICAgIGYobXUsIHRlcm1zLmFjbC53cml0ZSwgX2FjbC5td3JpdGUsIGJhc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGVyZSBhcmUgYW55IG1ldGFkYXRhIHJldmlzaW9ucyBmb3IgdGhpcyBlbnRyeSxcbiAgICogaW4gcHJhY3Rpc2UgdGhpcyBpcyBhbHdheXMgdHJ1ZSBpZiBwcm92ZW5hbmNlIGlzIGVuYWJsZWQgZm9yIHRoaXMgZW50cnkuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlcmUgaXMgYXQgbGVhc3Qgb25lIG1ldGFkYXRhIHJldmlzaW9uLlxuICAgKi9cbiAgaGFzTWV0YWRhdGFSZXZpc2lvbnMoKSB7XG4gICAgLy8gY29uc3QgbWRVUkkgPSB0aGlzLmdldE1ldGFkYXRhVVJJKCk7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKG51bGwsICdvd2w6c2FtZUFzJykgIT0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0cyBhbiBhcnJheSBvZiBtZXRhZGF0YSByZXZpc2lvbnMgZnJvbSB0aGUgZ3JhcGguXG4gICAqIEVhY2ggcmV2aXNpb24gaXMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnM6XG4gICAqICAgKiB0aW1lIC0gd2hlbiB0aGUgY2hhbmdlIHdhcyBtYWRlIChEYXRlKVxuICAgKiAgICogYnkgICAtIHRoZSB1c2VyIHdobyBwZXJmb3JtZWQgdGhlIGNoYW5nZSAoZW50cnlVUkkpXG4gICAqICAgKiByZXYgIC0gdGhlIHJldmlzaW9uIG51bWJlciAoc3RyaW5nKVxuICAgKiAgICogdXJpICAtIGFuIFVSSSB0byB0aGlzIHJldmlzaW9uIChzdHJpbmcpXG4gICAqXG4gICAqIFRoZSB1cmkgb2YgdGhlIHJldmlzaW9uIGNhbiBiZSB1c2VkIGJ5IHRoZSBtZXRob2QgZ2V0TWV0YWRhdGFSZXZpc2lvbkdyYXBoXG4gICAqIHRvIGdldCBhIGhvbGQgb2YgdGhlIGFjdHVhbCBuZXcgZ3JhcGggdGhhdCBjYXVzZWQgdGhlIHJldmlzaW9uLlxuICAgKlxuICAgKiBAcmV0dXJuIHt7dGltZTogRGF0ZSwgYnk6IHN0cmluZywgcmV2OiBzdHJpbmcsIHVyaTogc3RyaW5nfVtdfSBhIHNvcnRlZCBhcnJheSBvZiByZXZpc2lvbnMsIGxhdGVzdCByZXZpc2lvbiBmaXJzdC5cbiAgICovXG4gIGdldE1ldGFkYXRhUmV2aXNpb25zKCkge1xuICAgIGNvbnN0IHJldnMgPSBbXTtcbiAgICBjb25zdCBtZFVSSSA9IHRoaXMuZ2V0TWV0YWRhdGFVUkkoKTtcbiAgICBjb25zdCBzdG10cyA9IHRoaXMuX2dyYXBoLmZpbmQobnVsbCwgJ293bDpzYW1lQXMnLCBtZFVSSSk7XG5cbiAgICBpZiAoc3RtdHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICByZXR1cm4gcmV2cztcbiAgICB9XG4gICAgbGV0IHVyaSA9IHN0bXRzWzBdLmdldFN1YmplY3QoKTtcbiAgICBjb25zdCBlcyA9IHRoaXMuX2VudHJ5U3RvcmU7XG4gICAgd2hpbGUgKHVyaSkge1xuICAgICAgcmV2cy5wdXNoKHtcbiAgICAgICAgdXJpLFxuICAgICAgICByZXY6IHVyaS5zdWJzdHIobWRVUkkubGVuZ3RoICsgNSksXG4gICAgICAgIHRpbWU6IG1vbWVudCh0aGlzLl9ncmFwaC5maW5kRmlyc3RWYWx1ZSh1cmksICdwcm92OmdlbmVyYXRlZEF0VGltZScpKS50b0RhdGUoKSxcbiAgICAgICAgYnk6IGVzLmdldEVudHJ5VVJJRnJvbVVSSSh0aGlzLl9ncmFwaC5maW5kRmlyc3RWYWx1ZSh1cmksICdwcm92Ondhc0F0dHJpYnV0ZWRUbycpKSxcbiAgICAgIH0pO1xuICAgICAgdXJpID0gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUodXJpLCAncHJvdjp3YXNSZXZpc2lvbk9mJyk7XG4gICAgfVxuICAgIHJldnMuc29ydCgocjEsIHIyKSA9PiB7XG4gICAgICBpZiAocjEudGltZSA+IHIyLnRpbWUpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfSBlbHNlIGlmIChyMS50aW1lIDwgcjIudGltZSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuICAgIHJldHVybiByZXZzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbWV0YWRhdGEgZ3JhcGggb2YgYSBjZXJ0YWluIHJldmlzaW9uIGZyb20gaXRzIGdyYXBoLlxuICAgKiBAcGFyYW0gcmV2aXNpb25VUklcbiAgICogQHJldHVybiB7UHJvbWlzZS48cmRmanNvbi9HcmFwaD59XG4gICAqL1xuICBhc3luYyBnZXRNZXRhZGF0YVJldmlzaW9uR3JhcGgocmV2aXNpb25VUkkpIHtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5fZW50cnlTdG9yZS5nZXRSRVNUKCkuZ2V0KHJldmlzaW9uVVJJKTtcbiAgICByZXR1cm4gbmV3IEdyYXBoKGRhdGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBsYWJlbCBvZiB0aGUgcmVzb3VyY2Ugb2YgdGhpcyBlbnRyeSxcbiAgICogdHlwaWNhbGx5IHNldCB3aGVuIHVwbG9hZGluZyBhIGZpbGUuXG4gICAqL1xuICBnZXRMYWJlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUodGhpcy5nZXRSZXNvdXJjZVVSSSgpLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC8wMS9yZGYtc2NoZW1hI2xhYmVsJyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyBhIG5ldyBsYWJlbCBvZiB0aGUgcmVzb3VyY2UgaW4gdGhlIGdyYXBoLCBjYWxsXG4gICAqIHtAbGluayBzdG9yZS9FbnRyeUluZm8jY29tbWl0IGNvbW1pdH0gdG8gcHVzaFxuICAgKiB0aGUgdXBkYXRlZCBncmFwaCB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxhYmVsIC0gYSBuZXcgbGFiZWwgZm9yIHRoZSByZXNvdXJjZS5cbiAgICovXG4gIHNldExhYmVsKGxhYmVsKSB7XG4gICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZSh0aGlzLmdldFJlc291cmNlVVJJKCksICdodHRwOi8vd3d3LnczLm9yZy8yMDAwLzAxL3JkZi1zY2hlbWEjbGFiZWwnKTtcbiAgICBpZiAobGFiZWwgIT0gbnVsbCAmJiBsYWJlbCAhPT0gJycpIHtcbiAgICAgIHRoaXMuX2dyYXBoLmFkZCh0aGlzLmdldFJlc291cmNlVVJJKCksICdodHRwOi8vd3d3LnczLm9yZy8yMDAwLzAxL3JkZi1zY2hlbWEjbGFiZWwnLCB7XG4gICAgICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICAgICAgdmFsdWU6IGxhYmVsLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IHRoZSBmb3JtYXQgb2YgdGhlIHJlc291cmNlIG9mIHRoaXMgZW50cnkuXG4gICAqL1xuICBnZXRGb3JtYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRoaXMuZ2V0UmVzb3VyY2VVUkkoKSwgJ2h0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9mb3JtYXQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IGZvcm1hdCBvZiB0aGUgcmVzb3VyY2UgaW4gdGhlIGdyYXBoLCBjYWxsIHtAbGluayBzdG9yZS9FbnRyeUluZm8jY29tbWl0IGNvbW1pdH1cbiAgICogdG8gcHVzaCB0aGUgdXBkYXRlZCBncmFwaCB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIGEgZm9ybWF0IGluIHRoZSBmb3JtIGFwcGxpY2F0aW9uL2pzb24gb3IgdGV4dC9wbGFpbi5cbiAgICovXG4gIHNldEZvcm1hdChmb3JtYXQpIHtcbiAgICB0aGlzLl9ncmFwaC5maW5kQW5kUmVtb3ZlKHRoaXMuZ2V0UmVzb3VyY2VVUkkoKSwgJ2h0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9mb3JtYXQnKTtcbiAgICBpZiAoZm9ybWF0ICE9IG51bGwgJiYgZm9ybWF0ICE9PSAnJykge1xuICAgICAgdGhpcy5fZ3JhcGguYWRkTCh0aGlzLmdldFJlc291cmNlVVJJKCksICdodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvZm9ybWF0JywgZm9ybWF0KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ30gdGhlIHN0YXR1cyBvZiB0aGlzIGVudHJ5LCBhbHdheXMgYSBVUkkuXG4gICAqL1xuICBnZXRTdGF0dXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRoaXMuZ2V0RW50cnlVUkkoKSwgdGVybXMuc3RhdHVzLnByb3BlcnR5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIGEgbmV3IHN0YXR1cyBmb3IgdGhpcyBlbnRyeVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RhdHVzXG4gICAqL1xuICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZSh0aGlzLmdldEVudHJ5VVJJKCksIHRlcm1zLnN0YXR1cy5wcm9wZXJ0eSk7XG4gICAgaWYgKHN0YXR1cyAhPSBudWxsICYmIHN0YXR1cyAhPT0gJycgJiYgc3RhdHVzLmluZGV4T2YoJ2h0dHAnKSA9PT0gMCkge1xuICAgICAgdGhpcy5fZ3JhcGguYWRkKHRoaXMuZ2V0RW50cnlVUkkoKSwgdGVybXMuc3RhdHVzLnByb3BlcnR5LCBzdGF0dXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7RGF0ZX0gdGhlIGRhdGUgd2hlbiB0aGUgZW50cnkgd2FzIGNyZWF0ZWQuXG4gICAqL1xuICBnZXRDcmVhdGlvbkRhdGUoKSB7XG4gICAgY29uc3QgZCA9IHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRoaXMuZ2V0RW50cnlVUkkoKSwgJ2h0dHA6Ly9wdXJsLm9yZy9kYy90ZXJtcy9jcmVhdGVkJyk7XG4gICAgcmV0dXJuIG1vbWVudChkKS50b0RhdGUoKTsgLy8gTXVzdCBhbHdheXMgZXhpc3QuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge0RhdGV9IHRoZSBkYXRlIG9mIGxhc3QgbW9kaWZpY2F0aW9uIChhY2NvcmRpbmcgdG8gdGhlIHJlcG9zaXRvcnksXG4gICAqIGxvY2FsIGNoYW5nZXMgYXJlIG5vdCByZWZsZWN0ZWQpLlxuICAgKi9cbiAgZ2V0TW9kaWZpY2F0aW9uRGF0ZSgpIHtcbiAgICBjb25zdCBkID0gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUodGhpcy5nZXRFbnRyeVVSSSgpLCAnaHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zL21vZGlmaWVkJyk7XG4gICAgaWYgKGQgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG1vbWVudChkKS50b0RhdGUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q3JlYXRpb25EYXRlKCk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1N0cmluZ30gYSBVUkkgdG8gY3JlYXRvciwgdGhlIHVzZXIgRW50cnkgcmVzb3VyY2UgVVJJIGlzIHVzZWQsIGUuZy4gXCJodHRwOi8vc29tZXJlcG8vc3RvcmUvX3ByaW5jaXBhbHMvcmVzb3VyY2UvNFwiLCBuZXZlciBudWxsLlxuICAgKi9cbiAgZ2V0Q3JlYXRvcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUodGhpcy5nZXRFbnRyeVVSSSgpLCAnaHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zL2NyZWF0b3InKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldFNpemUoKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUodGhpcy5nZXRSZXNvdXJjZVVSSSgpLCAnaHR0cDovL3B1cmwub3JnL2RjL3Rlcm1zL2V4dGVudCcpO1xuICAgIGlmIChwYXJzZUludChleHRlbnQsIDEwKSA9PT0gcGFyc2VJbnQoZXh0ZW50LCAxMCkpIHtcbiAgICAgIHJldHVybiBwYXJzZUludChleHRlbnQsIDEwKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IGFuIGFycmF5IG9mIFVSSXMgdG8gdGhlIGNvbnRyaWJ1dG9ycyB1c2luZyB0aGVpciBFbnRyeSByZXNvdXJjZSBVUklzLFxuICAgKiBlLmcuIFtcImh0dHA6Ly9zb21lcmVwby9zdG9yZS9fcHJpbmNpcGFscy9yZXNvdXJjZS80XCJdLCBuZXZlciBudWxsIGFsdGhvdWdoIHRoZSBhcnJheSBtaWdodCBiZSBlbXB0eS5cbiAgICovXG4gIGdldENvbnRyaWJ1dG9ycygpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGguZmluZCh0aGlzLmdldEVudHJ5VVJJKCksICdodHRwOi8vcHVybC5vcmcvZGMvdGVybXMvY29udHJpYnV0b3InKS5tYXAoc3RtdCA9PiBzdG10LmdldFZhbHVlKCkpO1xuICB9XG59O1xuIiwiaW1wb3J0IEF1dGggZnJvbSAnLi9BdXRoJztcbmltcG9ydCBDYWNoZSBmcm9tICcuL0NhY2hlJztcbmltcG9ydCBmYWN0b3J5IGZyb20gJy4vZmFjdG9yeSc7XG5pbXBvcnQgUHJvdG90eXBlRW50cnkgZnJvbSAnLi9Qcm90b3R5cGVFbnRyeSc7XG5pbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi9SZXNvdXJjZSc7XG5pbXBvcnQgUmVzdCBmcm9tICcuL1Jlc3QnO1xuaW1wb3J0IFNvbHJRdWVyeSBmcm9tICcuL1NvbHJRdWVyeSc7XG5pbXBvcnQgdHlwZXMgZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgVXNlciBmcm9tICcuL1VzZXInO1xuaW1wb3J0IHsgaXNCcm93c2VyIH0gZnJvbSAnLi91dGlscyc7XG5cbmNvbnN0IGhlID0gcmVxdWlyZSgnaGUnKTsgLy8gVE9ETyBAc2NhemFuOiBSZW1vdmUgd2hlbiBlY2hvRmlsZSBpcyBjaGFuZ2VkIGJ5IEBIYW5uZXNcblxuLyoqXG4gKiBFbnRyeVN0b3JlIGlzIHRoZSBtYWluIGNsYXNzIHRoYXQgaXMgdXNlZCB0byBjb25uZWN0IHRvIGEgcnVubmluZyBzZXJ2ZXItc2lkZSBFbnRyeVN0b3JlXG4gKiByZXBvc2l0b3J5LlxuICogQGV4cG9ydHMgc3RvcmUvRW50cnlTdG9yZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRyeVN0b3JlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyaW5nPX0gYmFzZVVSSSAtIFVSTCB0byB0aGUgRW50cnlTdG9yZSByZXBvc2l0b3J5IHdlIHNob3VsZCBjb21tdW5pY2F0ZSB3aXRoLFxuICAgKiBtYXkgYmUgbGVmdCBvdXQgYW5kXG4gICAqIGd1ZXNzZWQgaWYgcnVuIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudCAoYXBwZW5kcyBcIi9zdG9yZS9cIiB0byB0aGUgd2luZG93LmxvY2F0aW9uLm9yaWdpbilcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBjcmVkZW50aWFscyAtIHNhbWUgYXMgcHJvdmlkZWQgaW4gdGhlIHtAbGluayBzdG9yZS9FbnRyeVN0b3JlI2F1dGggYXV0aH1cbiAgICogbWV0aG9kLlxuICAgKi9cbiAgY29uc3RydWN0b3IoYmFzZVVSSSwgY3JlZGVudGlhbHMpIHtcbiAgICBpZiAoaXNCcm93c2VyKCkgJiYgYmFzZVVSSSA9PSBudWxsKSB7XG4gICAgICB0aGlzLl9iYXNlVVJJID0gYCR7d2luZG93LmxvY2F0aW9uLm9yaWdpbn0vc3RvcmUvYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fYmFzZVVSSSA9IGJhc2VVUkk7XG4gICAgICBpZiAodGhpcy5fYmFzZVVSSVt0aGlzLl9iYXNlVVJJLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgdGhpcy5fYmFzZVVSSSA9IGAke3RoaXMuX2Jhc2VVUkl9L2A7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAgICB0aGlzLl9hdXRoID0gbmV3IEF1dGgodGhpcyk7XG4gICAgaWYgKGNyZWRlbnRpYWxzKSB7XG4gICAgICB0aGlzLmF1dGgoY3JlZGVudGlhbHMpO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZXh0cyA9IHt9O1xuICAgIHRoaXMuX3Jlc3QgPSBuZXcgUmVzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGNhbGxlZCBmb3IgZXZlcnkgYXN5bmNocm9ub3VzIGNhbGwgYmVpbmcgbWFkZS5cbiAgICogVGhlIGhhbmRsZXIgaXMgaW52b2tlZCB3aXRoIHRoZSBwcm9taXNlIGZyb20gdGhlIGFzeW5jaHJvbm91cyBjYWxsXG4gICAqIGFuZCBhIGNhbGxUeXBlIHBhcmFtZXRlciBpbmRpY2F0aW5nIHdoaWNoIGFzeW5jaHJvbm91cyBjYWxsIHRoYXQgaGFzIGJlZW4gbWFkZS5cbiAgICpcbiAgICogVGhlIGNhbGxUeXBlIHBhcmFtZXRlciBjYW4gdGFrZSB0aGUgZm9sbG93aW5nIHZhbHVlczpcbiAgICogLSBnZXRFbnRyeSAgICAgICAgLSBhbiBlbnRyeSBpcyByZXRyaWV2ZWQgKEVudHJ5U3RvcmUuZ2V0RW50cnkpXG4gICAqIC0gY3JlYXRlRW50cnkgICAgIC0gYW4gZW50cnkgaXMgY3JlYXRlZCAgIChFbnRyeVN0b3JlLmNyZWF0ZUVudHJ5KVxuICAgKiAtIGNyZWF0ZUdyb3VwQW5kQ29udGV4dCAtIGEgZ3JvdXAgYW5kIGNvbnRleHQgcGFpciBpcyBjcmVhdGVkXG4gICAqIChFbnRyeVN0b3JlLmNyZWF0ZUdyb3VwQW5kQ29udGV4dClcbiAgICogLSBsb2FkVmlhUHJveHkgICAgLSBkYXRhIGlzIHJlcXVlc3RlZCB2aWEgcmVwb3NpdG9yeSBwcm94eSAoRW50cnlTdG9yZS5sb2FkVmlhUHJveHkpXG4gICAqIC0gY29tbWl0TWV0YWRhdGEgIC0gY2hhbmdlcyB0byBtZXRhZGF0YSBpcyBwdXNoZWQgKEVudHJ5LmNvbW1pdE1ldGFkYXRhKVxuICAgKiAtIGNvbW1pdENhY2hlZEV4dGVybmFsTWV0YWRhdGEgLSBjaGFuZ2VzIHRvIGNhY2hlZCBleHRlcm5hbCBtZXRhZGF0YSBpcyBwdXNoZWRcbiAgICogKEVudHJ5LmNvbW1pdENhY2hlZEV4dGVybmFsTWV0YWRhdGEpXG4gICAqIC0gZ2V0UmVzb3VyY2UgICAgIC0gdGhlIGVudHJ5J3MgcmVzb3VyY2UgaGFzIGJlZW4gcmVxdWVzdGVkIChFbnRyeS5nZXRSZXNvdXJjZSlcbiAgICogLSBnZXRMaW5rZWRFbnRyeSAgLSBhIGxpbmtlZCBlbnRyeSBpcyByZXF1ZXN0ZWQgKEVudHJ5LmdldExpbmtlZEVudHJ5KVxuICAgKiAtIGRlbEVudHJ5ICAgICAgICAtIGFuIGVudHJ5IGlzIGRlbGV0ZWQgKEVudHJ5LmRlbClcbiAgICogLSByZWZyZXNoICAgICAgICAgLSBhbiBlbnRyeSBpcyByZWZyZXNoZWQgKEVudHJ5LnJlZnJlc2gpXG4gICAqIC0gc2V0Q29udGV4dE5hbWUgIC0gdGhlIG5hbWUgb2YgYSBjb250ZXh0IGlzIGNoYW5nZWQgKENvbnRleHQuc2V0TmFtZSlcbiAgICogLSBnZXRVc2VySW5mbyAgICAgLSB0aGUgdXNlciBpbmZvcm1hdGlvbiBpcyByZXF1ZXN0ZWQgKGF1dGguZ2V0VXNlckluZm8pXG4gICAqIC0gZ2V0VXNlckVudHJ5ICAgIC0gdGhlIHVzZXIgZW50cnkgaXMgcmVxdWVzdGVkIChhdXRoLmdldFVzZXJFbnRyeSlcbiAgICogLSBsb2dpbiAgICAgICAgICAgLSBsb2dnaW5nIGluIChhdXRoLmxvZ2luKVxuICAgKiAtIGxvZ291dCAgICAgICAgICAtIGxvZ2dpbmcgb3V0IChhdXRoLmxvZ291dClcbiAgICogLSBjb21taXRFbnRyeUluZm8gLSBwdXNoaW5nIGNoYW5nZXMgaW4gZW50cnkgaW5mb3JtYXRpb24gKEVudHJ5SW5mby5jb21taXQpXG4gICAqIC0gZ2V0RmlsZSAgICAgICAgIC0gdGhlIGNvbnRlbnRzIG9mIGEgZmlsZSByZXNvdXJjZSBpcyByZXF1ZXN0ZWQgKEZpbGUuZ2V0KilcbiAgICogLSBwdXRGaWxlICAgICAgICAgLSB0aGUgY29udGVudHMgb2YgYSBmaWxlIGlzIHB1c2hlZCAoRmlsZS5wdXQqKVxuICAgKiAtIGNvbW1pdEdyYXBoICAgICAtIGEgZ3JhcGggcmVzb3VyY2UgaXMgcHVzaGVkIChHcmFwaC5jb21taXQpXG4gICAqIC0gY29tbWl0U3RyaW5nICAgIC0gYSBzdHJpbmcgcmVzb3VyY2UgaXMgcHVzaGVkIChTdHJpbmcuY29tbWl0KVxuICAgKiAtIHNldEdyb3VwTmFtZSAgICAtIGEgbmV3IG5hbWUgb2YgYSBncm91cCBpcyBwdXNoZWQgKEdyb3VwLnNldE5hbWUpXG4gICAqIC0gc2V0VXNlck5hbWUgICAgIC0gYSBuZXcgbmFtZSBvZiBhIHVzZXIgaXMgcHVzaGVkIChVc2VyLnNldE5hbWUpXG4gICAqIC0gc2V0VXNlckRpc2FibGVkIC0gYSBuZXcgZGlzYWJsZWQgc3RhdGUgb2YgYSB1c2VyIGlzIHB1c2hlZCAoVXNlci5zZXREaXNhYmxlZClcbiAgICogLSBzZXRVc2VyTGFuZ3VhZ2UgLSBhIG5ldyBwcmVmZXJyZWQgbGFuZ3VhZ2Ugb2YgdGhlIHVzZXIgaXMgcHVzaGVkIChVc2VyLnNldExhbmd1YWdlKVxuICAgKiAtIHNldFVzZXJQYXNzd29yZCAtIGEgbmV3IHBhc3N3b3JkIGZvciB0aGUgdXNlciBpcyBwdXNoZWQgKFVzZXIuc2V0UGFzc3dvcmQpXG4gICAqIC0gc2V0VXNlckhvbWVDb250ZXh0IC0gYSBuZXcgaG9tZSBjb250ZXh0IGZvciB0aGUgdXNlciBpcyBwdXNoZWQgKFVzZXIuc2V0SG9tZUNvbnRleHQpXG4gICAqIC0gc2V0VXNlckN1c3RvbVByb3BlcnRpZXMgLSBuZXcgY3VzdG9tIHByb3BlcnRpZXMgZm9yIHRoZSB1c2VyIChVc2VyLnNldEN1c3RvbVByb3BlcnRpZXMpXG4gICAqIC0gbG9hZExpc3RFbnRyaWVzIC0gbWVtYmVycyBvZiBhIGxpc3QgYXJlIHJlcXVlc3RlZCAoTGlzdC5nZXRFbnRyaWVzKVxuICAgKiAtIHNldExpc3QgICAgICAgICAtIHRoZSBsaXN0IG1lbWJlcnMgYXJlIGNoYW5nZWQgdmlhIGEgbGlzdFxuICAgKiAtIGFkZFRvTGlzdCAgICAgICAtIFNlZSBMaXN0LmFkZEVudHJ5XG4gICAqIC0gcmVtb3ZlRnJvbUxpc3QgIC0gU2VlIExpc3QucmVtb3ZlRW50cnlcbiAgICogLnJlbW92ZUVudHJ5KVxuICAgKiAtIHNlYXJjaCAgICAgICAgICAtIGEgc2VhcmNoIGlzIGJlaW5nIHBlcmZvcm1lZCAoU2VhcmNoTGlzdC5nZXRFbnRyaWVzKVxuICAgKiAtIGV4ZWN1dGUgICAgICAgICAtIGEgcGlwZWxpbmUgaXMgZXhlY3V0ZWQgKFBpcGVsaW5lLmV4ZWN1dGUpXG4gICAqXG4gICAqIEBwYXJhbSB7UHJvbWlzZS48c3RyaW5nPn0gbGlzdGVuZXJcbiAgICovXG4gIGFkZEFzeW5jTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBpZiAodGhpcy5hc3luY0xpc3RlbmVycykge1xuICAgICAgdGhpcy5hc3luY0xpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hc3luY0xpc3RlbmVycyA9IFtsaXN0ZW5lcl07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IGFkZGVkIGxpc3RlbmVyIGZvciBhc3luY2hyb25vdXMgY2FsbHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsaXN0ZW5lclxuICAgKi9cbiAgcmVtb3ZlQXN5bmNMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIGlmICh0aGlzLmFzeW5jTGlzdGVuZXJzKSB7XG4gICAgICB0aGlzLmFzeW5jTGlzdGVuZXJzLnNwbGljZSh0aGlzLmFzeW5jTGlzdGVuZXJzLmluZGV4T2YobGlzdGVuZXIpLCAxKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtQcm9taXNlfSBwcm9taXNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0XG4gICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAqL1xuICBoYW5kbGVBc3luYyhwcm9taXNlLCBjb250ZXh0KSB7XG4gICAgaWYgKHRoaXMuYXN5bmNMaXN0ZW5lcnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hc3luY0xpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmFzeW5jTGlzdGVuZXJzW2ldKHByb21pc2UsIGNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9BdXRofSB3aGVyZSBmdW5jdGlvbmFsaXR5IHJlbGF0ZWQgdG8gYXV0aG9yaXphdGlvbiBhcmUgbG9jYXRlZCxcbiAgICogaW5jbHVkaW5nIGEgbGlzdGVuZXIgaW5mcmFzdHJ1Y3R1cmUuXG4gICAqL1xuICBnZXRBdXRoKCkge1xuICAgIHJldHVybiB0aGlzLl9hdXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIFlpZWxkcyBpbmZvcm1hdGlvbiBhYm91dCB3aG8gY3VycmVudGx5IGlzIGF1dGhlbnRpY2F0ZWQgYWdhaW5zdCB0aGUgRW50cnlTdG9yZSByZXBvc2l0b3J5LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnlJbmZvPn0gLSB1cG9uIHN1Y2Nlc3MgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYXR0cmlidXRlcyBcInVzZXJcIiBiZWluZ1xuICAgKiB0aGUgdXNlcm5hbWUsIFwiaWRcIiBvZiB0aGUgdXNlciBlbnRyeSwgYW5kIFwiaG9tZWNvbnRleHRcIiBiZWluZyB0aGUgZW50cnktaWQgb2YgdGhlXG4gICAqIGhvbWUgY29udGV4dCBpcyBwcm92aWRlZC5cbiAgICogQHNlZSB7QGxpbmsgc3RvcmUvRW50cnlTdG9yZSNhdXRoIGF1dGh9XG4gICAqIEBzZWUge0BsaW5rIHN0b3JlL0VudHJ5U3RvcmUjbG9nb3V0IGxvZ291dH1cbiAgICogQGRlcHJlY2F0ZWQgdXNlIGNvcnJlc3BvbmRpbmcgbWV0aG9kIG9uIGF1dGggb2JqZWN0IGluc3RlYWQuXG4gICAqL1xuICBnZXRVc2VySW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aC5nZXRVc2VySW5mbygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxzdG9yZS9FbnRyeT59IG9uIHN1Y2Nlc3MgdGhlIGVudHJ5IGZvciB0aGUgY3VycmVudGx5IHNpZ25lZCBpbiB1c2VyIGlzIHByb3ZpZGVkLlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgY29ycmVzcG9uZGluZyBtZXRob2Qgb24gYXV0aCBvYmplY3QgaW5zdGVhZC5cbiAgICovXG4gIGdldFVzZXJFbnRyeSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYXV0aC5nZXRVc2VyRW50cnkoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBdXRoZW50aWNhdGUgdXNpbmcgY3JlZGVudGlhbHMgY29udGFpbmluZyBhIHVzZXIsIGEgcGFzc3dvcmQgYW5kIGFuIG9wdGlvbmFsIG1heEFnZSBnaXZlblxuICAgKiBpbiBzZWNvbmRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3t1c2VyLCBwYXNzd29yZCwgbWF4QWdlfX0gY3JlZGVudGlhbHMgYXMgYSBwYXJhbWV0ZXIgb2JqZWN0XG4gICAqIEBkZXByZWNhdGVkIHVzZSBjb3JyZXNwb25kaW5nIG1ldGhvZCBvbiBhdXRoIG9iamVjdCBpbnN0ZWFkLlxuICAgKi9cbiAgYXV0aChjcmVkZW50aWFscykge1xuICAgIGlmIChjcmVkZW50aWFscyA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5fYXV0aC5sb2dvdXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2F1dGgubG9naW4oY3JlZGVudGlhbHMudXNlciwgY3JlZGVudGlhbHMucGFzc3dvcmQsIGNyZWRlbnRpYWxzLm1heEFnZSk7XG4gIH1cblxuICAvKipcbiAgICogTG9nb3V0IHRoZSBjdXJyZW50bHkgYXV0aG9yaXplZCB1c2VyLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQGRlcHJlY2F0ZWQgdXNlIGNvcnJlc3BvbmRpbmcgbWV0aG9kIG9uIGF1dGggb2JqZWN0IGluc3RlYWQuXG4gICAqL1xuICBsb2dvdXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2F1dGgubG9nb3V0KCk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2hlcyBhbiBlbnRyeSBnaXZlbiBhbiBlbnRyeVVSSS4gSWYgdGhlIGVudHJ5IGlzIGFscmVhZHkgbG9hZGVkIGFuZCBhdmFpbGFibGUgaW4gdGhlXG4gICAqIGNhY2hlIGl0IHdpbGwgYmUgcmV0dXJuZWQgZGlyZWN0bHksIG90aGVyd2lzZSBpdCB3aWxsIGJlIGxvYWRlZCBmcm9tIHRoZSByZXBvc2l0b3J5LlxuICAgKiBJZiB0aGUgZW50cnkgaXMgYWxyZWFkeSBsb2FkZWQgYnV0IG1hcmtlZCBhcyBpbiBuZWVkIG9mIGEgcmVmcmVzaCBpdCB3aWxsIGJlIHJlZnJlc2hlZFxuICAgKiBmaXJzdC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGxvYWQgcGFyYW1ldGVycyBhcmUgcHJvdmlkZWQgaW4gYSBzaW5nbGUgcGFyYW1ldGVyIG9iamVjdCB3aXRoIHNpeCBwb3NzaWJsZVxuICAgKiBhdHRyaWJ1dGVzLiBCZWxvdyB3ZSBvdXRsaW5lIHRoZXNlIGF0dHJpYnV0ZXMsIHRoZSBmaXJzdCB0d28gKGZvcmNlTG9hZCBhbmQgZGlyZWN0KSBhcHBsaWVzXG4gICAqIHRvIGFsbCBraW5kIG9mIGVudHJpZXMgd2hpbGUgdGhlIGZvbGxvd2luZyB0aHJlZSAobGltaXQsIG9mZnNldCBhbmQgc29ydCkgb25seSBhcHBsaWVzIGlmXG4gICAqIHRoZSBlbnRyeSBpcyBhIGxpc3Q6XG4gICAqXG4gICAqIGZvcmNlTG9hZCAtIGlnbm9yZXMgaWYgdGhlIGVudHJ5IGlzIGFscmVhZHkgaW4gY2FjaGUgYW5kIGZldGNoZXMgZnJvbSB0aGUgcmVwb3NpdG9yeVxuICAgKiBsb2FkUmVzb3VyY2UgLSBtYWtlcyBzdXJlIHRoYXQgZW50cnkuZ2V0UmVzb3VyY2UodHJ1ZSkgd2lsbCBub3QgcmV0dXJuIG51bGxcbiAgICogICAgIChkb2VzIG5vdCB3b3JrIGluIGNvbWJpbmF0aW9uIHdpdGggZGlyZWN0KS5cbiAgICogZGlyZWN0IC0gcmV0dXJucyB0aGUgZW50cnkgZnJvbSB0aGUgY2FjaGUgZGlyZWN0bHkgcmF0aGVyIHRoYW4gcmV0dXJuaW5nIGEgcHJvbWlzZSxcbiAgICogICAgaWYgdGhlIGVudHJ5IGlzIG5vdCBpbiB0aGUgY2FjaGUgYW4gdW5kZWZpbmVkIHZhbHVlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAqIGxpbWl0IC0gb25seSBhIGxpbWl0ZWQgbnVtYmVyIG9mIGNoaWxkcmVuIGFyZSBsb2FkZWQsIC0xIG1lYW5zIG5vIGxpbWl0LCAwLCB1bmRlZmluZWRcbiAgICogICAgb3IgaWYgdGhlIGF0dHJpYnV0ZSBpcyBub3QgcHJvdmlkZWQgbWVhbnMgdGhhdCB0aGUgZGVmYXVsdCBsaW1pdCBvZiAyMCBpcyB1c2VkLlxuICAgKiBvZmZzZXQgLSBvbmx5IGNoaWxkcmVuIGZyb20gb2ZmZXN0IGFuZCBmb3J3YXJkIGlzIHJldHVybmVkLCBtdXN0IGJlIHBvc2l0aXZlLlxuICAgKiBzb3J0IC0gaW5mb3JtYXRpb24gb24gaG93IHRvIHNvcnQgdGhlIGNoaWxkcmVuOlxuICAgKiAgICAgKiBpZiBzb3J0IGlzIG5vdCBwcm92aWRlZCBhdCBhbGwgb3IgYW4gZW1wdHkgb2JqZWN0IGlzIHByb3ZpZGVkIHRoZSBtZW1iZXJzIG9mIHRoZVxuICAgKiAgICAgICBsaXN0IHdpbGwgbm90IGJlIHNvcnRlZCwgaW5zdGVhZCB0aGUgbGlzdCdzIG5hdHVyYWwgb3JkZXIgd2lsbCBiZSB1c2VkXG4gICAqICAgICAqIGlmIHNvcnQgaXMgZ2l2ZW4gYXMgbnVsbCB0aGUgZGVmYXVsdHMgd2lsbCBiZSB1c2VkICh7c29ydEJ5OiBcInRpdGxlXCIsIHByaW86IFwiTGlzdFwifSkuXG4gICAqICAgICAqIGlmIHNvcnQgaXMgZ2l2ZW4gYXMgYSBub24gZW10cHkgb2JqZWN0IHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyBhcmUgY29uc2lkZXJlZDpcbiAgICogICAgICAgKiogc29ydEJ5IC0gdGhlIGF0dHJpYnV0ZSBpbnN0cnVjdHMgd2hpY2ggbWV0YWRhdGEgZmllbGQgdG8gc29ydCB0aGUgY2hpbGRyZW4gYnksXG4gICAqICAgICAgICAgIGkuZS4sIHRpdGxlLCBjcmVhdGVkLCBtb2RpZmllZCwgb3Igc2l6ZS5cbiAgICogICAgICAgKiogbGFuZyAtIGlmIHNvcnQgaXMgdGl0bGUgYW5kIHRoZSB0aXRsZSBpcyBwcm92aWRlZCBpbiBzZXZlcmFsIGxhbmd1YWdlcyBhXG4gICAqICAgICAgICAgIHByaW9yaXRpemVkIGxhbmd1YWdlIGNhbiBiZSBnaXZlbi5cbiAgICogICAgICAgKiogcHJpbyAtIGFsbG93cyBzcGVjaWZpYyBncmFwaHR5cGVzIHRvIGJlIHByaW9yaXRpemVkXG4gICAqICAgICAgICAgIChlLmcuIHNob3cgdXAgaW4gdGhlIHRvcCBvZiB0aGUgbGlzdCkuXG4gICAqICAgICAgICoqIGRlc2NlbmRpbmcgLSBpZiB0cnVlIHRoZSBjaGlsZHJlbiBhcmUgc2hvd24gaW4gZGVzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICpcbiAgICogKipOb3RlKiogLSBpbiB0aGUgY2FzZSB3aGVyZSB0aGUgZW50cnkgaXMgYSBsaXN0IGl0IGlzIHBvc3NpYmxlIHRvIGNoYW5nZSB0aGUgbGltaXQsXG4gICAqIG9mZnNldCBhbmQgc29ydCBsYXRlciBieSBjYWxsaW5nIHRoZSBjb3JyZXNwb25kaW5nIG1ldGhvZHMgb24gdGhlIHtAbGluayBzdG9yZS9MaXN0fVxuICAgKiByZXNvdXJjZSwgZS5nLiB7QGxpbmsgc3RvcmUvTGlzdCNzZXRTb3J0fS4gSG93ZXZlciwgc2V0dGluZyB0aGUgdmFsdWVzIGFscmVhZHkgaW4gdGhpc1xuICAgKiBtZXRob2QgY2FsbCBoYXMgYXMgYSBjb25zZXF1ZW5jZSB0aGF0IG9uZSBsZXNzIHJlcXVlc3QgdG8gdGhlIHJlcG9zaXRvcnkgaXMgbWFkZSBhcyB5b3VcbiAgICogd2lsbCBnZXQgbWVtYmVycyAoaW4gdGhlIHJpZ2h0IGFtb3VudCBhbmQgb3JkZXIpIGluIHRoZSBzYW1lIHJlcXVlc3QgYXMgeW91IGdldCBtZXRhZGF0YVxuICAgKiBhbmQgb3RoZXIgaW5mb3JtYXRpb24uXG4gICAqXG4gICAqIEEgcmVxdWVzdCBvZiBhIGxpc3QgZW50cnkgY2FuIGxvb2sgbGlrZTpcbiAgICpcbiAgICogICAgIHZhciBldXJpID0gZW50cnlzdG9yZS5nZXRFbnRyeVVSSShcIjFcIiwgXCIxXCIpO1xuICAgKiAgICAgZW50cnlzdG9yZS5nZXRFbnRyeShldXJpLCB7XG4gICAqICAgICAgICAgIGZvcmNlTG9hZDogdHJ1ZSxcbiAgICogICAgICAgICAgbGltaXQ6IDEwLFxuICAgKiAgICAgICAgICBvZmZzZXQ6IDIwLFxuICAgKiAgICAgICAgICBzb3J0OiB7XG4gICAqICAgICAgICAgICAgIHNvcnRCeTogXCJtb2RpZmllZFwiLFxuICAgKiAgICAgICAgICAgICBwcmlvOiB0eXBlcy5HVF9MSVNUXG4gICAqICAgICAgICAgIH1cbiAgICogICAgICB9KTtcbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIHBhcmFtcyBoZXJlIHNheXMgdGhhdCB3ZSBmb3JjZSBhIGxvYWQgZnJvbSB0aGUgcmVwb3NpdG9yeSwgdGhhdCB3ZSB3YW50IHRoZVxuICAgKiByZXN1bHRzIHRvIGJlIHBhZ2luYXRlZCB3aXRoIGEgbGltaXQgb2YgMTAgZW50cmllcyBwZXIgcGFnZSBhbmQgdGhhdCB3ZSB3YW50IHBhZ2UgMy5cbiAgICogV2UgYWxzbyBpbmRpY2F0ZSB0aGF0IHdlIHdhbnQgdGhlIGxpc3QgdG8gYmUgc29ydGVkIGJ5IGxhdGVzdCBtb2RpZmljYXRpb24gZGF0ZSBhbmQgdGhhdFxuICAgKiBpZiB0aGVyZSBhcmUgbWVtYmVyIGVudHJpZXMgdGhhdCBhcmUgbGlzdHMgdGhleSBzaG91bGQgYmUgc29ydGVkIHRvIHRoZSB0b3AuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeVVSSSAtIHRoZSBlbnRyeVVSSSBmb3IgdGhlIGVudHJ5IHRvIHJldHJpZXZlLlxuICAgKiBAcGFyYW0ge3tmb3JjZUxvYWQsIGRpcmVjdCwgbG9hZFJlc291cmNlLCBsaW1pdCwgb2Zmc2V0LCBzb3J0LCBhc3luY0NvbnRleHR9fSBvcHRpb25hbExvYWRQYXJhbXMgLSBwYXJhbWV0ZXJzIGZvciBob3cgdG8gbG9hZCBhbiBlbnRyeS5cbiAgICogQHJldHVybiB7UHJvbWlzZS48c3RvcmUvRW50cnk+IHwgc3RvcmUvRW50cnkgfCB1bmRlZmluZWR9IC0gYnkgZGVmYXVsdCBhIHByb21pc2UgaXMgcmV0dXJuZWQsXG4gICAqIGlmIHRoZSBkaXJlY3QgcGFyYW1ldGVyIGlzIHNwZWNpZmllZCB0aGUgZW50cnkgaXMgcmV0dXJuZWQgZGlyZWN0bHkgb3IgdW5kZWZpbmVkIGlmIHRoZVxuICAgKiBlbnRyeSBpcyBub3QgaW4gY2FjaGUuXG4gICAqIEBzZWUge0BsaW5rIHN0b3JlL0VudHJ5U3RvcmUjZ2V0RW50cnlVUkkgZ2V0RW50cnlVUkl9IGZvciBoZWxwIHRvIGNvbnN0cnVjdCBlbnRyeSBVUklzLlxuICAgKiBAc2VlIHtAbGluayBzdG9yZS9Db250ZXh0I2dldEVudHJ5QnlJZH0gZm9yIGxvYWRpbmcgZW50cmllcyByZWxhdGl2ZSB0byBhIGNvbnRleHQuXG4gICAqL1xuICBnZXRFbnRyeShlbnRyeVVSSSwgb3B0aW9uYWxMb2FkUGFyYW1zID0ge30pIHtcbiAgICBjb25zdCBmb3JjZUxvYWQgPSBvcHRpb25hbExvYWRQYXJhbXMgPyBvcHRpb25hbExvYWRQYXJhbXMuZm9yY2VMb2FkID09PSB0cnVlIDogZmFsc2U7XG4gICAgY29uc3QgZSA9IHRoaXMuX2NhY2hlLmdldChlbnRyeVVSSSk7XG4gICAgbGV0IGFzeW5jQ29udGV4dCA9ICdnZXRFbnRyeSc7XG4gICAgaWYgKG9wdGlvbmFsTG9hZFBhcmFtcyAhPSBudWxsKSB7XG4gICAgICBpZiAob3B0aW9uYWxMb2FkUGFyYW1zLmFzeW5jQ29udGV4dCkge1xuICAgICAgICBhc3luY0NvbnRleHQgPSBvcHRpb25hbExvYWRQYXJhbXMuYXN5bmNDb250ZXh0O1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbmFsTG9hZFBhcmFtcy5kaXJlY3QgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGU7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrUmVzb3VyY2VMb2FkZWQgPSAoZW50cnkpID0+IHtcbiAgICAgIGlmIChvcHRpb25hbExvYWRQYXJhbXMgIT0gbnVsbCAmJiBvcHRpb25hbExvYWRQYXJhbXMubG9hZFJlc291cmNlXG4gICAgICAgICYmIGVudHJ5LmdldFJlc291cmNlKCkgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZW50cnkuZ2V0UmVzb3VyY2UoKS50aGVuKCgpID0+IGVudHJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9O1xuICAgIGlmIChlICYmICFmb3JjZUxvYWQpIHtcbiAgICAgIGlmICgoZS5pc0xpc3QoKSB8fCBlLmlzR3JvdXAoKSkgJiYgb3B0aW9uYWxMb2FkUGFyYW1zICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IGUuZ2V0UmVzb3VyY2UodHJ1ZSk7IC8vIERpcmVjdCBhY2Nlc3Mgd29ya3MgZm9yIGxpc3RzIGFuZCBncm91cHMuXG4gICAgICAgIGxpc3Quc2V0TGltaXQob3B0aW9uYWxMb2FkUGFyYW1zLmxpbWl0KTtcbiAgICAgICAgbGlzdC5zZXRTb3J0KG9wdGlvbmFsTG9hZFBhcmFtcy5zb3J0KTtcbiAgICAgIH1cblxuICAgICAgLy8gV2lsbCBvbmx5IHJlZnJlc2ggaWYgbmVlZGVkLCBhIHByb21pc2UgaXMgcmV0dXJuZWQgaW4gYW55IGNhc2VcbiAgICAgIHJldHVybiB0aGlzLmhhbmRsZUFzeW5jKGUucmVmcmVzaCgpLnRoZW4oY2hlY2tSZXNvdXJjZUxvYWRlZCksIGFzeW5jQ29udGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGNvbnN0IGVudHJ5TG9hZFVSSSA9IGZhY3RvcnkuZ2V0RW50cnlMb2FkVVJJKGVudHJ5VVJJLCBvcHRpb25hbExvYWRQYXJhbXMpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZUFzeW5jKHRoaXMuX3Jlc3QuZ2V0KGVudHJ5TG9hZFVSSSkudGhlbigoZGF0YSkgPT4ge1xuICAgICAgLy8gVGhlIGVudHJ5LCB3aWxsIGFsd2F5cyBiZSB0aGVyZS5cbiAgICAgIGNvbnN0IGVudHJ5ID0gZmFjdG9yeS51cGRhdGVPckNyZWF0ZShlbnRyeVVSSSwgZGF0YSwgc2VsZik7XG4gICAgICByZXR1cm4gY2hlY2tSZXNvdXJjZUxvYWRlZChlbnRyeSk7XG4gICAgfSwgKGVycikgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgZmV0Y2hpbmcgZW50cnkuICR7ZXJyfWApO1xuICAgIH0pLCBhc3luY0NvbnRleHQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBlbnRyaWVzIGZyb20gYSBsaXN0LiBPbmUgd2F5IHRvIHNlZSBpdCBpcyB0aGF0IHRoaXMgaXMgYSBjb252ZW5pZW5jZSBtZXRob2RcbiAgICogdGhhdCByZXRyaWV2ZXMgYSBsaXN0IGVudHJ5LCBpdHMgbWVtYmVyIGVudHJpZXMgYW5kIHJldHVybnMgdGhvc2UgaW4gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeVVSSSAtIFVSSSBvZiB0aGUgbGlzdCBlbnRyeSB0byBsb2FkIGVudHJpZXMgZnJvbS5cbiAgICogQHBhcmFtIHtPYmplY3R9IHNvcnQgLSBzYW1lIHNvcnQgb2JqZWN0IGFzIHByb3ZpZGVkIGluIHRoZSBvcHRpb25hbExvYWRQYXJhbXMgdG9cbiAgICoge0BzZWUgc3RvcmUvRW50cnlTdG9yZSNnZXRFbnRyeSBnZXRFbnRyeX0gbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdH0gbGltaXQgLSBzYW1lIGxpbWl0IGFzIHByb3ZpZGVkIGluIHRoZSBvcHRpb25hbExvYWRQYXJhbXMgdG9cbiAgICoge0BzZWUgc3RvcmUvRW50cnlTdG9yZSNnZXRFbnRyeSBnZXRFbnRyeX0gbWV0aG9kLlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IHBhZ2UgLSB1bmxlc3MgbGltaXQgaXMgc2V0IHRvIC0xIChubyBwYWdpbmF0aW9uKSB3ZSBuZWVkIHRvIHNwZWNpZnkgd2hpY2hcbiAgICogcGFnZSB0byBsb2FkLCBmaXJzdCBwYWdlIGlzIDAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxzdG9yZS9FbnRyeVtdPn0gdXBvbiBzdWNjZXNzIHRoZSBwcm9taXNlIHJldHVybnMgYW4gYXJyYXkgb2YgZW50cmllcy5cbiAgICovXG4gIGdldExpc3RFbnRyaWVzKGVudHJ5VVJJLCBzb3J0LCBsaW1pdCwgcGFnZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBvcCA9IHt9O1xuICAgICAgaWYgKHNvcnQgIT0gbnVsbCkge1xuICAgICAgICBvcC5zb3J0ID0gc29ydDtcbiAgICAgIH1cbiAgICAgIGlmIChsaW1pdCAlIDEgPT09IDApIHtcbiAgICAgICAgb3AubGltaXQgPSBsaW1pdDtcbiAgICAgIH1cbiAgICAgIGlmIChwYWdlICUgMSA9PT0gMCkge1xuICAgICAgICBpZiAobGltaXQgJSAxID09PSAwKSB7XG4gICAgICAgICAgb3Aub2Zmc2V0ID0gbGltaXQgKiBwYWdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9wLm9mZnNldCA9IGZhY3RvcnkuZ2V0RGVmYXVsdExpbWl0KCkgKiBwYWdlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVudHJ5U3RvcmUoKS5nZXRFbnRyeShlbnRyeVVSSSwgb3ApXG4gICAgICAgIC50aGVuKChlbnRyeSkgPT4ge1xuICAgICAgICAgIGNvbnN0IGxpc3QgPSBlbnRyeS5nZXRSZXNvdXJjZSh0cnVlKTtcbiAgICAgICAgICBsaXN0LmdldEVudHJpZXMocGFnZSkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9LCByZWplY3QpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIENvbnRleHQgaW5zdGFuY2UgdmlhIGl0cyBpZC4gTm90ZSB0aGF0IHRoaXMgbWV0aG9kIHJldHVybnMgZGlyZWN0bHkgd2l0aG91dFxuICAgKiBjaGVja2luZyB3aXRoIHRoZSBFbnRyeVN0b3JlIHJlcG9zaXRvcnkgdGhhdCB0aGUgY29udGV4dCBleGlzdHMuIEhlbmNlIHN1Y2Nlc3NpdmVcbiAgICogb3BlcmF0aW9ucyB2aWEgdGhpcyBjb250ZXh0IGluc3RhbmNlIG1heSBmYWlsIGlmIHRoZSBjb250ZXh0IGRvZXMgbm90IGV4aXN0IGluIHRoZVxuICAgKiBFbnRyeVN0b3JlXG4gICAqIHJlcG9zaXRvcnkuXG4gICAqXG4gICAqIE5vdGUgdGhhdCBpbiBFbnRyeVN0b3JlIGV2ZXJ5dGhpbmcgaXMgY29ubmVjdGVkIHRvIGVudHJpZXMuIEhlbmNlIGEgY29udGV4dCBpcyBub3RoaW5nIGVsc2VcbiAgICogdGhhbiBhIHNwZWNpYWwga2luZCBvZiByZXNvdXJjZSBtYWludGFpbmVkIGJ5IGFuIGVudHJ5LiBUaGlzIGVudHJ5IHByb3ZpZGVzIG1ldGFkYXRhIGFib3V0XG4gICAqIHRoZSBjb250ZXh0IGFzIHdlbGwgYXMgdGhlIGRlZmF1bHQgb3duZXJzaGlwIGFuZCBhY2Nlc3MgY29udHJvbCB0aGF0IGFwcGxpZXMgdG8gYWxsIGVudHJpZXNcbiAgICogaW5zaWRlIG9mIHRoaXMgY29udGV4dC5cbiAgICpcbiAgICogVG8gZ2V0IGEgaG9sZCBvZiB0aGUgY29udGV4dHMgb3duIGVudHJ5IHVzZSB0aGUge0BsaW5rIHN0b3JlL1Jlc291cmNlI2dldEVudHJ5fVxuICAgKiBtZXRob2Qgb24gdGhlIGNvbnRleHQgKGluaGVyaXRlZCBmcm9tIHRoZSBnZW5lcmljIHtAbGluayBzdG9yZS9SZXNvdXJjZX0gY2xhc3MuXG4gICAqXG4gICAqIEFkdmFuY2VkOiBFbnRyeXMgY29ycmVzcG9uZGluZyB0byBjb250ZXh0cyBhcmUgc3RvcmVkIGluIHRoZSBzcGVjaWFsIF9jb250ZXh0c1xuICAgKiBjb250ZXh0IHdoaWNoLCBzaW5jZSBpdCBpcyBhIGNvbnRleHQsIGNvbnRhaW5zIGl0cyBvd24gZW50cnkuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSBpZGVudGlmaWVyIGZvciB0aGUgY29udGV4dCAobm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIGFzIHRoZVxuICAgKiBhbGlhcy9uYW1lIGZvciB0aGUgY29udGV4dClcbiAgICogQHJldHVybiB7c3RvcmUvQ29udGV4dH1cbiAgICovXG4gIGdldENvbnRleHRCeUlkKGNvbnRleHRJZCkge1xuICAgIHJldHVybiBmYWN0b3J5LmdldENvbnRleHQodGhpcywgYCR7dGhpcy5fYmFzZVVSSX1fY29udGV4dHMvZW50cnkvJHtjb250ZXh0SWR9YCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgQ29udGV4dCBpbnN0YW5jZSB2aWEgaXRzIGVudHJ5J3MgVVJJLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gY29udGV4dEVudHJ5VVJJIC0gVVJJIHRvIHRoZSBjb250ZXh0J3MgZW50cnksIGUuZy4gYmFzZS9fY29udGV4dHMvZW50cnkvMS5cbiAgICogQHJldHVybnMge3N0b3JlL0NvbnRleHR9XG4gICAqIEBzZWUge0BsaW5rIHN0b3JlL0VudHJ5U3RvcmUjZ2V0Q29udGV4dEJ5SWQgZ2V0Q29udGV4dEJ5SWR9XG4gICAqL1xuICBnZXRDb250ZXh0KGNvbnRleHRFbnRyeVVSSSkge1xuICAgIHJldHVybiBmYWN0b3J5LmdldENvbnRleHQodGhpcywgY29udGV4dEVudHJ5VVJJKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBwYWdpbmF0ZWQgbGlzdCBvZiBhbGwgY29udGV4dHMgaW4gdGhlIEVudHJ5U3RvcmUgcmVwb3NpdG9yeS5cbiAgICogQHJldHVybiB7c3RvcmUvTGlzdH0gLSB0aGUgbGlzdCBjb250YWlucyBlbnRyaWVzIHdoaWNoIGhhdmUgY29udGV4dHMgYXMgcmVzb3VyY2VzLlxuICAgKi9cbiAgZ2V0Q29udGV4dExpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3U29sclF1ZXJ5KCkuZ3JhcGhUeXBlKHR5cGVzLkdUX0NPTlRFWFQpLmxpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgYSBwYWdpbmF0ZWQgbGlzdCBvZiBhbGwgdXNlcnMgYW5kIGdyb3VwcyBpbiB0aGUgRW50cnlTdG9yZSByZXBvc2l0b3J5XG4gICAqIEByZXR1cm4ge3N0b3JlL0xpc3R9IHRoZSBsaXN0IGNvbnRhaW5zIGVudHJpZXMgdGhhdCBoYXZlIHByaW5jaXBhbHMgYXMgcmVzb3VyY2VzLlxuICAgKiBAdG9kbyBNYXkgaW5jbHVkZSBmb2xkZXJzIGFuZCBvdGhlciBlbnRyaWVzIGFzIHdlbGwuLi5cbiAgICovXG4gIGdldFByaW5jaXBhbExpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMubmV3U29sclF1ZXJ5KCkuZ3JhcGhUeXBlKFt0eXBlcy5HVF9VU0VSLCB0eXBlcy5HVF9HUk9VUF0pLmxpc3QoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGVudHJ5IGFjY29yZGluZyB0byBpbmZvcm1hdGlvbiBpbiB0aGUgcHJvdmlkZWQge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5fS5cbiAgICogVGhlIGluZm9ybWF0aW9uIHNwZWNpZmllcyB0aGUgdHlwZSBvZiBlbnRyeSwgd2hpY2ggY29udGV4dCBpdCBzaG91bGQgcmVzaWRlIGluLFxuICAgKiBpbml0aWFsIG1ldGFkYXRhIGV0Yy4gVGhpcyBtZXRob2QgaXMgc2VsZG9tIGNhbGxlZCBleHBsaWNpdGx5LCBpbnN0ZWFkIGl0IGlzIGNhbGxlZFxuICAgKiBpbmRpcmVjdGx5IHZpYSB0aGUge0BsaW5rIHN0b3JlL1Byb3RvdHlwZUVudHJ5I2NvbW1pdH0gbWV0aG9kLiBFLmcuOlxuICAgKlxuICAgKiAgICAgY29udGV4dC5uZXdFbnRyeSgpLmNvbW1pdCgpLnRoZW4oZnVuY3Rpb24obmV3bHlDcmVhdGVkRW50cnkpIHsuLi59XG4gICAqXG4gICAqIEBwYXJhbSB7c3RvcmUvUHJvdG90eXBlRW50cnl9IHByb3RvdHlwZUVudHJ5IC0gaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVudHJ5IHRvIGNyZWF0ZS5cbiAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICogQHNlZSBzdG9yZS9Qcm90b3R5cGVFbnRyeSNjb21taXRcbiAgICogQHNlZSBzdG9yZS9FbnRyeVN0b3JlI25ld0NvbnRleHRcbiAgICogQHNlZSBzdG9yZS9FbnRyeVN0b3JlI25ld1VzZXJcbiAgICogQHNlZSBzdG9yZS9FbnRyeVN0b3JlI25ld0dyb3VwXG4gICAqIEBzZWUgc3RvcmUvQ29udGV4dCNuZXdFbnRyeVxuICAgKiBAc2VlIHN0b3JlL0NvbnRleHQjbmV3TGlua1xuICAgKiBAc2VlIHN0b3JlL0NvbnRleHQjbmV3TGlua1JlZlxuICAgKiBAc2VlIHN0b3JlL0NvbnRleHQjbmV3UmVmXG4gICAqIEBzZWUgc3RvcmUvQ29udGV4dCNuZXdMaXN0XG4gICAqIEBzZWUgc3RvcmUvQ29udGV4dCNuZXdHcmFwaFxuICAgKiBAc2VlIHN0b3JlL0NvbnRleHQjbmV3U3RyaW5nXG4gICAqL1xuICBjcmVhdGVFbnRyeShwcm90b3R5cGVFbnRyeSkge1xuICAgIGNvbnN0IHBvc3RVUkkgPSBmYWN0b3J5LmdldEVudHJ5Q3JlYXRlVVJJKHByb3RvdHlwZUVudHJ5LCBwcm90b3R5cGVFbnRyeS5nZXRQYXJlbnRMaXN0KCkpO1xuICAgIGNvbnN0IHBvc3RQYXJhbXMgPSBmYWN0b3J5LmdldEVudHJ5Q3JlYXRlUG9zdERhdGEocHJvdG90eXBlRW50cnkpO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZUFzeW5jKHRoaXMuX3Jlc3QuY3JlYXRlKHBvc3RVUkksIHBvc3RQYXJhbXMpLnRoZW4oKGV1cmkpID0+IHtcbiAgICAgIC8vIHZhciBldXJpID0gZmFjdG9yeS5nZXRVUklGcm9tQ3JlYXRlZChkYXRhLCBwcm90b3R5cGVFbnRyeS5nZXRDb250ZXh0KCkpO1xuICAgICAgY29uc3QgcGxpc3QgPSBwcm90b3R5cGVFbnRyeS5nZXRQYXJlbnRMaXN0KCk7XG4gICAgICBpZiAocGxpc3QgIT0gbnVsbCkge1xuICAgICAgICBjb25zdCByZXMgPSBwbGlzdC5nZXRSZXNvdXJjZSh0cnVlKTtcbiAgICAgICAgaWYgKHJlcyAhPSBudWxsICYmIHJlcy5uZWVkUmVmcmVzaCkge1xuICAgICAgICAgIHBsaXN0LmdldFJlc291cmNlKHRydWUpLm5lZWRSZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmdldEVudHJ5KGV1cmkpO1xuICAgIH0pLCAnY3JlYXRlRW50cnknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIFByb3RvdHlwZUVudHJ5IGZvciBjcmVhdGluZyBhIG5ldyBjb250ZXh0LlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGNvbnRleHROYW1lIC0gb3B0aW9uYWwgbmFtZSBmb3IgdGhlIGNvbnRleHQsIGNhbiBiZSBjaGFuZ2VkIGxhdGVyLFxuICAgKiBtdXN0IGJlIHVuaXF1ZSBpbiB0aGUgX3ByaW5jaXBhbHMgY29udGV4dFxuICAgKiBAcGFyYW0ge3N0cmluZz19IGlkIC0gb3B0aW9uYWwgcmVxdWVzdGVkIGlkZW50aWZpZXIgKGVudHJ5SWQpIGZvciB0aGUgY29udGV4dCxcbiAgICogY2Fubm90IGJlIGNoYW5nZWQgbGF0ZXIsIG11c3QgYmUgdW5pcXVlIGluIHRoZSBfcHJpbmNpcGFscyBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX1cbiAgICovXG4gIG5ld0NvbnRleHQoY29udGV4dE5hbWUsIGlkKSB7XG4gICAgY29uc3QgX2NvbnRleHRzID0gZmFjdG9yeS5nZXRDb250ZXh0KHRoaXMsIGAke3RoaXMuX2Jhc2VVUkl9X2NvbnRleHRzL2VudHJ5L19jb250ZXh0c2ApO1xuICAgIGNvbnN0IHByb3RvdHlwZUVudHJ5ID0gbmV3IFByb3RvdHlwZUVudHJ5KF9jb250ZXh0cywgaWQpLnNldEdyYXBoVHlwZSh0eXBlcy5HVF9DT05URVhUKTtcbiAgICBpZiAoY29udGV4dE5hbWUgIT0gbnVsbCkge1xuICAgICAgY29uc3QgZWkgPSBwcm90b3R5cGVFbnRyeS5nZXRFbnRyeUluZm8oKTtcbiAgICAgIGNvbnN0IHJlc291cmNlID0gbmV3IFJlc291cmNlKGVpLmdldEVudHJ5VVJJKCksIGVpLmdldFJlc291cmNlVVJJKCksIHRoaXMpO1xuICAgICAgcmVzb3VyY2UuX3VwZGF0ZSh7IG5hbWU6IGNvbnRleHROYW1lIH0pO1xuICAgICAgcHJvdG90eXBlRW50cnkuX3Jlc291cmNlID0gcmVzb3VyY2U7XG4gICAgfVxuICAgIHJldHVybiBwcm90b3R5cGVFbnRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKi9cbiAgY3JlYXRlR3JvdXBBbmRDb250ZXh0KG5hbWUpIHtcbiAgICBsZXQgdXJpID0gYCR7dGhpcy5fYmFzZVVSSX1fcHJpbmNpcGFscy9ncm91cHNgO1xuICAgIGlmIChuYW1lICE9IG51bGwpIHtcbiAgICAgIHVyaSArPSBgP25hbWU9JHtlbmNvZGVVUklDb21wb25lbnQobmFtZSl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlQXN5bmModGhpcy5fcmVzdC5jcmVhdGUodXJpKS50aGVuKGxvY2F0aW9uID0+IHRoaXMuZ2V0RW50cnkobG9jYXRpb24pKSwgJ2NyZWF0ZUdyb3VwQW5kQ29udGV4dCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGEgUHJvdG90eXBlRW50cnkgZm9yIGNyZWF0aW5nIGEgbmV3IHVzZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdXNlcm5hbWUgLSB0aGUgbmFtZSB0aGUgdXNlciB3aWxsIHVzZSB0byBhdXRoZW50aWNhdGUgaGltc2VsZlxuICAgKiBAcGFyYW0ge3N0cmluZz19IHBhc3N3b3JkIC0gdGhlIHBhc3N3b3JkIHRoZSB1c2VyIHdpbGwgdXNlIHRvIGF1dGhlbnRpY2F0ZSBoaW1zZWxmXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaG9tZUNvbnRleHQgLSBhIHNwZWNpZmljIGNvbnRleHQgdGhlIHVzZXIgd2lsbCBjb25zaWRlciBoaXMgb3duIGhvbWVcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBpZCAtIHJlcXVlc3RlZCBpZGVudGlmaWVyIGZvciB0aGUgdXNlclxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9XG4gICAqL1xuICBuZXdVc2VyKHVzZXJuYW1lLCBwYXNzd29yZCwgaG9tZUNvbnRleHQsIGlkKSB7XG4gICAgY29uc3QgX3ByaW5jaXBhbHMgPSBmYWN0b3J5LmdldENvbnRleHQodGhpcywgYCR7dGhpcy5fYmFzZVVSSX1fY29udGV4dHMvZW50cnkvX3ByaW5jaXBhbHNgKTtcbiAgICBjb25zdCBwcm90b3R5cGVFbnRyeSA9IG5ldyBQcm90b3R5cGVFbnRyeShfcHJpbmNpcGFscywgaWQpLnNldEdyYXBoVHlwZSh0eXBlcy5HVF9VU0VSKTtcbiAgICBjb25zdCBlbnRyeUluZm8gPSBwcm90b3R5cGVFbnRyeS5nZXRFbnRyeUluZm8oKTtcbiAgICBjb25zdCBkYXRhID0ge307XG4gICAgaWYgKHVzZXJuYW1lICE9IG51bGwpIHtcbiAgICAgIGRhdGEubmFtZSA9IHVzZXJuYW1lO1xuICAgIH1cbiAgICBpZiAocGFzc3dvcmQgIT0gbnVsbCkge1xuICAgICAgZGF0YS5wYXNzd29yZCA9IHBhc3N3b3JkO1xuICAgIH1cbiAgICBpZiAoaG9tZUNvbnRleHQgIT0gbnVsbCkge1xuICAgICAgZGF0YS5ob21lY29udGV4dCA9IGhvbWVDb250ZXh0O1xuICAgIH1cbiAgICBwcm90b3R5cGVFbnRyeS5fcmVzb3VyY2UgPSBuZXcgVXNlcihlbnRyeUluZm8uZ2V0RW50cnlVUkkoKSwgZW50cnlJbmZvLmdldFJlc291cmNlVVJJKCksIHRoaXMsIGRhdGEpO1xuICAgIHJldHVybiBwcm90b3R5cGVFbnRyeTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IGdyb3VwTmFtZSAtIG9wdGlvbmFsIG5hbWUgZm9yIHRoZSBncm91cCwgY2FuIGJlIGNoYW5nZWQgbGF0ZXIsXG4gICAqIG11c3QgYmUgdW5pcXVlIGluIHRoZSBfcHJpbmNpcGFscyBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaWQgLSBvcHRpb25hbCByZXF1ZXN0ZWQgaWRlbnRpZmllciAoZW50cnlJZCkgZm9yIHRoZSBncm91cCxcbiAgICogY2Fubm90IGJlIGNoYW5nZWQgbGF0ZXIsIG11c3QgYmUgdW5pcXVlIGluIHRoZSBfcHJpbmNpcGFscyBjb250ZXh0XG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX1cbiAgICovXG4gIG5ld0dyb3VwKGdyb3VwTmFtZSwgaWQpIHtcbiAgICBjb25zdCBfcHJpbmNpcGFscyA9IGZhY3RvcnkuZ2V0Q29udGV4dCh0aGlzLCBgJHt0aGlzLl9iYXNlVVJJfV9jb250ZXh0cy9lbnRyeS9fcHJpbmNpcGFsc2ApO1xuICAgIGNvbnN0IHByb3RvdHlwZUVudHJ5ID0gbmV3IFByb3RvdHlwZUVudHJ5KF9wcmluY2lwYWxzLCBpZCkuc2V0R3JhcGhUeXBlKHR5cGVzLkdUX0dST1VQKTtcbiAgICBpZiAoZ3JvdXBOYW1lICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGVpID0gcHJvdG90eXBlRW50cnkuZ2V0RW50cnlJbmZvKCk7XG4gICAgICBjb25zdCByZXNvdXJjZSA9IG5ldyBSZXNvdXJjZShlaS5nZXRFbnRyeVVSSSgpLCBlaS5nZXRSZXNvdXJjZVVSSSgpLCB0aGlzKTtcbiAgICAgIHJlc291cmNlLl91cGRhdGUoeyBuYW1lOiBncm91cE5hbWUgfSk7XG4gICAgICBwcm90b3R5cGVFbnRyeS5fcmVzb3VyY2UgPSByZXNvdXJjZTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3RvdHlwZUVudHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgYW4gZW50cnkgZnJvbSBvbmUgbGlzdCB0byBhbm90aGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5fSBlbnRyeSAtIGVudHJ5IHRvIG1vdmVcbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeX0gZnJvbUxpc3QgLSBzb3VyY2UgbGlzdCB3aGVyZSB0aGUgZW50cnkgaXMgY3VycmVudGx5IHJlc2lkaW5nLlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5fSB0b0xpc3QgLSBkZXN0aW5hdGlvbiBsaXN0IHdoZXJlIHRoZSBlbnRyeSBpcyBzdXBwb3NlZCB0byBlbmQgdXAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgbW92ZUVudHJ5KGVudHJ5LCBmcm9tTGlzdCwgdG9MaXN0KSB7XG4gICAgY29uc3QgdXJpID0gZmFjdG9yeS5nZXRNb3ZlVVJJKGVudHJ5LCBmcm9tTGlzdCwgdG9MaXN0LCB0aGlzLl9iYXNlVVJJKTtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGVBc3luYyh0aGlzLmdldFJFU1QoKS5wb3N0KHVyaSwgJycpLCAnbW92ZUVudHJ5Jyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgZGF0YSB2aWEgdGhlIEVudHJ5U3RvcmUgcmVwb3NpdG9yeSdzIG93biBwcm94eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaSBpbmRpY2F0ZXMgdGhlIHJlc291cmNlIHRvIGxvYWQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXRIaW50IGluZGljYXRlcyB0aGF0IHlvdSB3YW50IGRhdGEgYmFjayBpbiB0aGUgZm9ybWF0IHNwZWNpZmllZFxuICAgKiAoZS5nLiBieSBzcGVjaWZpeWluZyBhIHN1aXRhYmxlIGFjY2VwdCBoZWFkZXIpLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGxvYWRWaWFQcm94eSh1cmksIGZvcm1hdEhpbnQpIHtcbiAgICBjb25zdCB1cmwgPSBmYWN0b3J5LmdldFByb3h5VVJJKHRoaXMuX2Jhc2VVUkksIHVyaSk7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlQXN5bmModGhpcy5nZXRSRVNUKCkuZ2V0KHVybCwgZm9ybWF0SGludCwgdHJ1ZSksICdsb2FkVmlhUHJveHknKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgYSBmaWxlIHRvIHRoZSBzZXJ2ZXIgYW5kIGdldHMgdGhlIHJlc3VsdCBiYWNrIGltbWVkaWF0ZWx5LlxuICAgKiBTaW5jZSBicm93c2VyIGVudmlyb25tZW50cyBjYW5ub3QgYWNjZXNzIHRoZSBsb2NhbCBmaWxlc3lzdGVtLCB0aGUgb25seSB3YXkgdG8gZ2V0IHRoZVxuICAgKiBjb250ZW50cyBvZiBhIGZpbGUgaXMgdG8gXCJ1cGxvYWRcIiBpdCBhbmQgZ2V0IHRoZSBjb250ZW50cyBiYWNrIGZyb20gdGhlIHNlcnZlci5cbiAgICogRW50cnlTdG9yZSBwcm92aWRlcyB0aGUgXCJlY2hvXCIgcmVzb3VyY2UgdG8gcHJvdmlkZSB0aGlzIHdvcmthcm91bmQuXG4gICAqXG4gICAqIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCBhIGZpbGUgaXMgcmVwcmVzZW50ZWQgdmlhIGFuIGlucHV0IGVsZW1lbnQgd2hpY2ggcmVmZXJlbmNlc1xuICAgKiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCB2aWEgaXRzIHZhbHVlIGF0dHJpYnV0ZS4gRS5nLjpcbiAgICpcbiAgICogICAgICAgPGlucHV0IHR5cGU9XCJmaWxlXCIgbmFtZT1cInVwbG9hZEZpbGVcIi8+XG4gICAqXG4gICAqIER1cmluZyB0aGUgdXBsb2FkaW5nIHByb2Nlc3MgdGhlIGlucHV0IHRhZyB3aWxsIGJlIG1vdmVkIHRlbXBvcmFyaWx5IGluIHRoZSBET00gdHJlZSxcbiAgICogaXQgd2lsbCBiZSByZXN0b3JlZCB0byBpdHMgb3JpZ2luYWwgcG9zaXRpb24gYWZ0ZXJ3YXJkcyAoYm90aCB1cG9uIHN1Y2Nlc3MgYW5kIGZhaWx1cmUpLlxuICAgKlxuICAgKiBAcGFyYW0ge25vZGV9IGRhdGEgLSBpbnB1dCBlbGVtZW50IGNvcnJlc3BvbmRpbmcgdG8gdGhlIGZpbGUgdG8gdXBsb2FkIChlY2hvKS5cbiAgICogQHJldHVybnMge3hoclByb21pc2V9XG4gICAqL1xuICBlY2hvRmlsZShkYXRhKSB7XG4gICAgLy8gbm9pbnNwZWN0aW9uIEFtZE1vZHVsZXNEZXBlbmRlbmNpZXNcbiAgICBpZiAoIShkYXRhIGluc3RhbmNlb2YgTm9kZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnQgbmVlZHMgdG8gYmUgYW4gaW5wdXQgZWxlbWVudC4nKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubmFtZSA9PSBudWxsIHx8IGRhdGEubmFtZSA9PT0gJycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbHVyZSwgY2Fubm90IHVwbG9hZCByZXNvdXJjZSBmcm9tIGlucHV0IGVsZW1lbnQgdW5sZXNzIGEgbmFtZScgK1xuICAgICAgICAnIGF0dHJpYnV0ZSBpcyBwcm92aWRlZC4nKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPIEVudHJ5U3RvcmUgc2hvdWxkIHJldHVybiB0aGUgYWN0dWFsIHJlc3BvbnNlIHdpdGhvdXQgSFRNTCB3cmFwcGluZ1xuICAgIHJldHVybiB0aGlzLmhhbmRsZUFzeW5jKHRoaXMuZ2V0UkVTVCgpLnB1dEZpbGUoYCR7dGhpcy5nZXRCYXNlVVJJKCl9ZWNob2AsIGRhdGEsICd0ZXh0JylcbiAgICAgIC50aGVuKChyYXdEYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gcmF3RGF0YS50ZXh0O1xuICAgICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgICBjb25zdCBpZHggPSByZXNwb25zZS5pbmRleE9mKCdcXG4nKTsgLy8gdGhpcyBjaGVja3MgaWZcbiAgICAgICAgICBjb25zdCBzdGF0dXMgPSBwYXJzZUludChyZXNwb25zZS5zdWJzdHIoMCwgaWR4KS5zcGxpdCgnOicpWzFdLCAxMCk7XG4gICAgICAgICAgaWYgKHN0YXR1cyAhPT0gMjAwKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYEhUVFAgc3RhdHVzIGNvZGU6ICR7c3RhdHVzfWApO1xuICAgICAgICAgICAgZXJyLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBjb25zdCB0ZXh0QXJlYVZhbHVlID0gcmVzcG9uc2Uuc3Vic3RyKGlkeCArIDEpLnJlcGxhY2UoJzwvdGV4dGFyZWE+JywgJycpOyAvLyBUT0RPIHJlbW92ZSB3aGVuIEVudHJ5U3RvcmUgaXMgZml4ZWRcblxuICAgICAgICAgIHJldHVybiBoZS5kZWNvZGUodGV4dEFyZWFWYWx1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVzcG9uc2U7IC8vIGVtcHR5XG4gICAgICB9KSwgJ2VjaG9GaWxlJyk7XG4gIH1cblxuICAvKipcbiAgICogUGVyZm9ybWluZyBzZWFyY2hlcyBhZ2FpbnN0IGFuIEVudHJ5U3RvcmUgcmVwb3NpdG9yeSBpcyBhY2hpZXZlZCBieSBjcmVhdGluZyBhXG4gICAqIHtAbGluayBzdG9yZS9TZWFyY2hMaXN0fSB3aGljaCBpcyBzaW1pbGFyIHRvIGEgcmVndWxhciB7QGxpbmsgc3RvcmUvTGlzdH0uXG4gICAqIEZyb20gdGhpcyBsaXN0IGl0IGlzIHBvc3NpYmxlIHRvIGdldCBwYWdpbmF0ZWQgcmVzdWx0cyBpbiBmb3JtIG9mIG1hdGNoaW5nIGVudHJpZXMuXG4gICAqIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgICAgdmFyIHBlcnNvblR5cGUgPSBcImh0dHA6Ly94bWxucy5jb20vZm9hZi8wLjEvUGVyc29uXCI7XG4gICAqICAgICB2YXIgc2VhcmNoTGlzdCA9IGVudHJ5c3RvcmUubmV3U29sclF1ZXJ5KCkucmRmVHlwZShwZXJzb25UeXBlKS5saXN0KCk7XG4gICAqICAgICBzZWFyY2hMaXN0LnNldExpbWl0KDIwKS5nZXRFbnRyaWVzKCkudGhlbihmdW5jdGlvbihyZXN1bHRzKSB7Li4ufSk7XG4gICAqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBuZXdTb2xyUXVlcnkoKSB7XG4gICAgcmV0dXJuIG5ldyBTb2xyUXVlcnkodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayAjbmV3U29sclF1ZXJ5fSBpbnN0ZWFkLlxuICAgKi9cbiAgY3JlYXRlU2VhcmNoTGlzdChxdWVyeSkge1xuICAgIHJldHVybiBmYWN0b3J5LmNyZWF0ZVNlYXJjaExpc3QodGhpcywgcXVlcnkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gbWV0YWRhdGEgVVJJIGZyb20gdGhlIGlkIGZvciB0aGUgY29udGV4dCBhbmQgdGhlIHNwZWNpZmljIGVudHJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY29udGV4dElkIC0gYW4gaWRlbnRpZmllciBmb3IgdGhlIGNvbnRleHQgdGhlIGVudHJ5IGJlbG9uZ3MgdG9cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5SWQgLSBhbiBpZGVudGlmaWVyIGZvciB0aGUgZW50cnlcbiAgICogQHJldHVybnMge1N0cmluZ30gLSBhbiBlbnRyeSBVUklcbiAgICovXG4gIGdldE1ldGFkYXRhVVJJKGNvbnRleHRJZCwgZW50cnlJZCkge1xuICAgIHJldHVybiBmYWN0b3J5LmdldE1ldGFkYXRhVVJJKHRoaXMsIGNvbnRleHRJZCwgZW50cnlJZCk7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhbiBlbnRyeSBVUkkgZnJvbSB0aGUgaWQgZm9yIHRoZSBjb250ZXh0IGFuZCB0aGUgc3BlY2lmaWMgZW50cnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZXh0SWQgLSBhbiBpZGVudGlmaWVyIGZvciB0aGUgY29udGV4dCB0aGUgZW50cnkgYmVsb25ncyB0b1xuICAgKiBAcGFyYW0ge3N0cmluZ30gZW50cnlJZCAtIGFuIGlkZW50aWZpZXIgZm9yIHRoZSBlbnRyeVxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIGFuIGVudHJ5IFVSSVxuICAgKi9cbiAgZ2V0RW50cnlVUkkoY29udGV4dElkLCBlbnRyeUlkKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZ2V0RW50cnlVUkkodGhpcywgY29udGV4dElkLCBlbnRyeUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGFuIGVudHJ5IFVSSSBmcm9tIGEgbm9ybWFsIHJlcG9zaXRvcnkgVVJJLCBlLmcuIGFueSBVUkkgZnJvbSB3aGljaCBpcyBwb3NzaWJsZVxuICAgKiB0byBkZWR1Y2UgYSBjb250ZXh0SWQgYW5kIGFuIGVudHJ5SWQuIEVxdWl2YWxlbnQgdG8gY2FsbGluZzpcbiAgICogZXMuZ2V0RW50cnlVUkkoZXMuZ2V0Q29udGV4dElkKHVyaSksIGVzLmdldEVudHJ5SWQodXJpKSlcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVyaSAtIGEgVVJJIGZvciB0aGUgZW50cnksIGNhbiBiZSBhIGVudHJ5VVJJIChvYnZpb3VzbHkpLCByZXNvdXJjZVVSSVxuICAgKiAoaWYgbG9jYWwpLCBtZXRhZGF0YVVSSSwgb3IgcmVsYXRpb25zVVJJLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAtIGFuIGVudHJ5IFVSSVxuICAgKi9cbiAgZ2V0RW50cnlVUklGcm9tVVJJKHVyaSkge1xuICAgIHJldHVybiBmYWN0b3J5LmdldEVudHJ5VVJJRnJvbVVSSSh0aGlzLCB1cmkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYW4gZW50cnkgcmVzb3VyY2UgVVJJIChsb2NhbCBVUkksIG5vdCBhIGxpbmsgb2J2aW91c2x5KSBmcm9tIHRoZSBpZCBmb3IgdGhlXG4gICAqIGNvbnRleHQgYW5kIHRoZSBzcGVjaWZpYyBlbnRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIGFuIGlkZW50aWZpZXIgZm9yIHRoZSBjb250ZXh0IHRoZSByZXNvdXJjZSBiZWxvbmdzIHRvXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeUlkIC0gYW4gaWRlbnRpZmllciBmb3IgdGhlIGVudHJ5IHRoZSByZXNvdXJjZSBiZWxvbmdzIHRvXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IGEgcmVzb3VyY2UgVVJJXG4gICAqL1xuICBnZXRSZXNvdXJjZVVSSShjb250ZXh0SWQsIGVudHJ5SWQpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5nZXRSZXNvdXJjZVVSSSh0aGlzLCBjb250ZXh0SWQsIGVudHJ5SWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIFVSSSBvZiB0aGUgRW50cnlTdG9yZSByZXBvc2l0b3J5IHdlIGhhdmUgY29ubmVjdGVkIHRvLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0QmFzZVVSSSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmFzZVVSSTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgZW50cnkgaWQgb2YgdGhpcyBlbnRyeSwgcmVzb3VyY2Ugb3IgbWV0YWRhdGEgdXJpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRFbnRyeUlkKHVyaSkge1xuICAgIHJldHVybiBmYWN0b3J5LmdldEVudHJ5SWQodXJpLCB0aGlzLmdldEJhc2VVUkkoKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbnRleHQgaWQgb2YgdGhpcyBlbnRyeSwgcmVzb3VyY2Ugb3IgbWV0YWRhdGEgdXJpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRDb250ZXh0SWQodXJpKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZ2V0Q29udGV4dElkKHVyaSwgdGhpcy5nZXRCYXNlVVJJKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqICBUbyBnZXQgc3RhdHVzIHJlc291cmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgZ2V0U3RhdHVzKCkge1xuICAgIGNvbnN0IHVyaSA9IGAke3RoaXMuX2Jhc2VVUkl9bWFuYWdlbWVudC9zdGF0dXM/ZXh0ZW5kZWRgO1xuICAgIHJldHVybiB0aGlzLmhhbmRsZUFzeW5jKHRoaXMuZ2V0UkVTVCgpLmdldCh1cmkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgY2FjaGUgd2hlcmUgYWxsIGVudHJpZXMgYXJlIGNhY2hlZCBhZnRlciBsb2FkaW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvQ2FjaGV9XG4gICAqL1xuICBnZXRDYWNoZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FjaGU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGxvYWRpbmcgbWVjaGFuaXNtIGFyZSBwZXJmb3JtZWQgdmlhIFJFU1QgY2FsbHMsIHRoaXMgUkVTVCBtb2R1bGUgY2FuIGJlXG4gICAqIHVzZWQgZm9yIGRvaW5nIG1hbnVhbCBsb29rdXBzIG91dHNpZGUgb2YgdGhlIHNjb3BlIG9mIHRoaXMgQVBJLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUmVzdH1cbiAgICovXG4gIGdldFJFU1QoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc3Q7XG4gIH1cblxuICAvLz0gPT09PT09PT09PT09PU5vbi1wdWJsaWMgbWV0aG9kcz09PT09PT09PT09PT09XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBnZXRDYWNoZWRDb250ZXh0c0lkeCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGV4dHM7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZXMgaW5mb3JtYXRpb24gYWJvdXQgdmVyc2lvbiBvZiBFbnRyeVN0b3JlIHJlcG9zaXRvcnksIHRoZSBqYXZhc2NyaXB0IEFQSSxcbiAgICogc3RhdHVzIG9mIHNlcnZpY2VzIGV0Yy5cbiAgICogQHRvZG8gTmVlZHMgc3VwcG9ydCBmcm9tIEVudHJ5U3RvcmUgUkVTVCBBUElcbiAgICogQHRvZG8gRG9jdW1lbnQgcHJvbWlzZVxuICAgKi9cbiAgc3RhdGljIGluZm8oKSB7XG4gICAgY29uc3QgcGFja2FnZUpTT04gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKTtcbiAgICByZXR1cm4geyB2ZXJzaW9uOiBwYWNrYWdlSlNPTi52ZXJzaW9uIH07XG4gIH1cbn07XG4iLCIvKipcbiAqIEVudHJ5U3RvcmVVdGlsIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25hbGl0eSBmb3Igd29ya2luZyB3aXRoIGVudHJpZXMuXG4gKiBAZXhwb3J0cyBzdG9yZS9FbnRyeVN0b3JlVXRpbFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbnRyeVN0b3JlVXRpbCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5U3RvcmV9IGVudHJ5c3RvcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudHJ5c3RvcmUpIHtcbiAgICB0aGlzLl9lbnRyeXN0b3JlID0gZW50cnlzdG9yZTtcbiAgICB0aGlzLl9wcmVsb2FkSWR4ID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeVN0b3JlfVxuICAgKi9cbiAgZ2V0RW50cnlTdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlzdG9yZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcmVsb2FkIGVudHJpZXMgb2YgYSBzcGVjaWZpYyB0eXBlLlxuICAgKiBOb3Qgc3RyaWN0bHkgbmVlZGVkLCB1c2VkIGZvciBvcHRpbWl6YXRpb24gcmVhc29ucy5cbiAgICogVXAgdG8gYSBtYXhpbXVtIG9mIDEwMCBlbnRyaWVzIGFyZSBwcmVsb2FkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvZlR5cGVcbiAgICogQHBhcmFtIHtzdG9yZS9Db250ZXh0fSBjb250ZXh0IGlmIHByb3ZpZGVkIGxpbWl0cyB0aGUgcHJlbG9hZCB0byBhIHNwZWNpZmljIGNvbnRleHQuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeX1cbiAgICovXG4gIHByZWxvYWRFbnRyaWVzKG9mVHlwZSwgY29udGV4dCkge1xuICAgIGxldCBwcmVsb2FkRm9yVHlwZSA9IHRoaXMuX3ByZWxvYWRJZHguZ2V0KG9mVHlwZSk7XG4gICAgbGV0IHByb21pc2U7XG4gICAgaWYgKHByZWxvYWRGb3JUeXBlKSB7XG4gICAgICBpZiAoY29udGV4dCkge1xuICAgICAgICBwcm9taXNlID0gcHJlbG9hZEZvclR5cGVbY29udGV4dC5nZXRFbnRyeVVSSSgpXTtcbiAgICAgICAgaWYgKHByb21pc2UpIHtcbiAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcmVsb2FkRm9yVHlwZS5ub0NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHByZWxvYWRGb3JUeXBlLm5vQ29udGV4dDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcHJlbG9hZEZvclR5cGUgPSB7fTtcbiAgICAgIHRoaXMuX3ByZWxvYWRJZHguc2V0KG9mVHlwZSwgcHJlbG9hZEZvclR5cGUpO1xuICAgIH1cblxuICAgIGNvbnN0IHNlYXJjaE9iaiA9IHRoaXMuX2VudHJ5c3RvcmUubmV3U29sclF1ZXJ5KCkucmVzb3VyY2VUeXBlKG9mVHlwZSkubGltaXQoMTAwKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgc2VhcmNoT2JqLmNvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3QgPSBzZWFyY2hPYmoubGlzdCgpO1xuICAgIHByb21pc2UgPSBsaXN0LmdldEVudHJpZXMoMCk7XG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIHByZWxvYWRGb3JUeXBlW2NvbnRleHQuZ2V0RW50cnlVUkkoKV0gPSBwcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcmVsb2FkRm9yVHlwZS5ub0NvbnRleHQgPSBwcm9taXNlO1xuICAgIH1cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG4gIGNsZWFyUHJlbG9hZEVudHJpZXNEdXBsaWNhdGVDaGVjayhvZlR5cGUsIGluQ29udGV4dCkge1xuICAgIGlmIChvZlR5cGUpIHtcbiAgICAgIGNvbnN0IHByZWxvYWRGb3JUeXBlID0gdGhpcy5fcHJlbG9hZElkeC5nZXQob2ZUeXBlKTtcbiAgICAgIGlmIChwcmVsb2FkRm9yVHlwZSAmJiBpbkNvbnRleHQpIHtcbiAgICAgICAgZGVsZXRlIHByZWxvYWRGb3JUeXBlW2luQ29udGV4dC5nZXRFbnRyeVVSSSgpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3ByZWxvYWRJZHguZGVsZXRlKG9mVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3ByZWxvYWRJZHggPSBuZXcgTWFwKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhbiBlbnRyeSBmb3IgYSByZXNvdXJjZSBVUkksIG5vdGUgdGhhdCBpZiB0aGVyZSBhcmUgc2V2ZXJhbCBlbnRyaWVzIHRoYXQgYWxsXG4gICAqIGhhdmUgdGhlIHNhbWUgcmVzb3VyY2UgVVJJIGl0IGlzIHVuY2xlYXIgd2hpY2ggb2YgdGhlc2UgZW50cmllcyB0aGF0IGFyZSByZXR1cm5lZC5cbiAgICogSGVuY2UsIG9ubHkgdXNlIHRoaXMgZnVuY3Rpb24gaWYgeW91IGV4cGVjdCB0aGVyZSB0byBiZSBhIHNpbmdsZSBlbnRyeSBwZXIgcmVzb3VyY2UgVVJJLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VVUkkgaXMgdGhlIFVSSSBmb3IgdGhlIHJlc291cmNlLlxuICAgKiBAcGFyYW0ge3N0b3JlL0NvbnRleHQ9fSBjb250ZXh0IG9ubHkgbG9vayBmb3IgZW50cmllcyBpbiB0aGlzIGNvbnRleHQsIG1heSBiZSBsZWZ0IG91dC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzeW5jQ2FsbFR5cGUgdGhlIGNhbGxUeXBlIHVzZWQgd2hlbiBtYWtpbmcgdGhlIHNlYXJjaC5cbiAgICogQHJldHVybnMge1Byb21pc2UuPHN0b3JlL0VudHJ5Pn1cbiAgICogQGFzeW5jXG4gICAqIEB0aHJvd3NcbiAgICovXG4gIGFzeW5jIGdldEVudHJ5QnlSZXNvdXJjZVVSSShyZXNvdXJjZVVSSSwgY29udGV4dCwgYXN5bmNDYWxsVHlwZSkge1xuICAgIGNvbnN0IGNhY2hlID0gdGhpcy5fZW50cnlzdG9yZS5nZXRDYWNoZSgpO1xuICAgIGNvbnN0IGVudHJpZXNTZXQgPSBjYWNoZS5nZXRCeVJlc291cmNlVVJJKHJlc291cmNlVVJJKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzU2V0KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgaWYgKGVudHJ5LmdldENvbnRleHQoKS5nZXRJZCgpID09PSBjb250ZXh0LmdldElkKCkpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuX2VudHJ5c3RvcmUubmV3U29sclF1ZXJ5KCkucmVzb3VyY2UocmVzb3VyY2VVUkkpLmxpbWl0KDEpO1xuICAgIGlmIChjb250ZXh0KSB7XG4gICAgICBxdWVyeS5jb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgICBjb25zdCBlbnRyeUFyciA9IGF3YWl0IHF1ZXJ5Lmxpc3QoYXN5bmNDYWxsVHlwZSkuZ2V0RW50cmllcygwKTtcbiAgICBpZiAoZW50cnlBcnIubGVuZ3RoID4gMCkge1xuICAgICAgcmV0dXJuIGVudHJ5QXJyWzBdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGVudHJpZXMgZm9yIHJlc291cmNlIHdpdGggVVJJOiAke3Jlc291cmNlVVJJfWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZXNvdXJjZVVSSSBpcyB0aGUgVVJJIGZvciB0aGUgcmVzb3VyY2UuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeX1cbiAgICovXG4gIGdldEVudHJ5TGlzdEJ5UmVzb3VyY2VVUkkocmVzb3VyY2VVUkkpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlzdG9yZS5uZXdTb2xyUXVlcnkoKS5yZXNvdXJjZShyZXNvdXJjZVVSSSkubGlzdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEF0dGVtcHRpbmcgdG8gZmluZCBhIHVuaXF1ZSBlbnRyeSBmb3IgYSBzcGVjaWZpYyB0eXBlLFxuICAgKiBpZiBtdWx0aXBsZSBlbnRyaWVzIGV4aXN0cyB3aXRoIHRoZSBzYW1lIHR5cGUgdGhlIHJldHVybmVkIHByb21pc2UgZmFpbHMuXG4gICAqIFlvdSBtYXkgcmVzdHJpY3QgdG8gYSBzcGVjaWZpYyBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVVSSSBpcyB0aGUgcmRmOnR5cGUgVVJJIGZvciB0aGUgZW50cnkgdG8gbWF0Y2guXG4gICAqIEBwYXJhbSB7c3RvcmUvQ29udGV4dH0gY29udGV4dCByZXN0cmljdCB0byBmaW5kaW5nIHRoZSBlbnRyeSBpbiB0aGlzIGNvbnRleHRcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFzeW5jQ2FsbFR5cGUgdGhlIGNhbGxUeXBlIHVzZWQgd2hlbiBtYWtpbmcgdGhlIHNlYXJjaC5cbiAgICogQHJldHVybnMge1Byb21pc2UuPHN0b3JlL0VudHJ5Pn1cbiAgICogQGFzeW5jXG4gICAqIEB0aHJvd3NcbiAgICovXG4gIGFzeW5jIGdldEVudHJ5QnlUeXBlKHR5cGVVUkksIGNvbnRleHQsIGFzeW5jQ2FsbFR5cGUpIHtcbiAgICBjb25zdCBxdWVyeSA9IHRoaXMuX2VudHJ5c3RvcmUubmV3U29sclF1ZXJ5KCkucmRmVHlwZSh0eXBlVVJJKS5saW1pdCgyKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgcXVlcnkuY29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZW50cnlBcnIgPSBhd2FpdCBxdWVyeS5saXN0KGFzeW5jQ2FsbFR5cGUpLmdldEVudHJpZXMoMCk7XG4gICAgaWYgKGVudHJ5QXJyLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGVudHJ5QXJyWzBdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1dyb25nIG51bWJlciBvZiBlbnRyaWVzIGluIGNvbnRleHQgLyByZXBvc2l0b3J5Jyk7XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdGluZyB0byBmaW5kIG9uZSBlbnRyeSBmb3IgYSBzcGVjaWZpYyBncmFwaCB0eXBlLFxuICAgKiBpZiBtdWx0aXBsZSBlbnRyaWVzIGV4aXN0cyB3aXRoIHRoZSBzYW1lIHR5cGUgdGhlIHJldHVybmVkIHByb21pc2UgZmFpbHMuXG4gICAqIFlvdSBtYXkgcmVzdHJpY3QgdG8gYSBzcGVjaWZpYyBjb250ZXh0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZ3JhcGhUeXBlIGlzIHRoZSBncmFwaCB0eXBlIGZvciB0aGUgZW50cnkgdG8gbWF0Y2gsIGUuZy4gdXNlXG4gICAqIHtAc2VlIHN0b3JlL3R5cGVzI0dUX1VTRVJ9LlxuICAgKiBAcGFyYW0ge3N0b3JlL0NvbnRleHR9IGNvbnRleHQgcmVzdHJpY3QgdG8gZmluZGluZyB0aGUgZW50cnkgaW4gdGhpcyBjb250ZXh0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhc3luY0NhbGxUeXBlIHRoZSBjYWxsVHlwZSB1c2VkIHdoZW4gbWFraW5nIHRoZSBzZWFyY2guXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxzdG9yZS9FbnRyeT59XG4gICAqIEBhc3luY1xuICAgKiBAdGhyb3dzXG4gICAqL1xuICBhc3luYyBnZXRFbnRyeUJ5R3JhcGhUeXBlKGdyYXBoVHlwZSwgY29udGV4dCwgYXN5bmNDYWxsVHlwZSkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gdGhpcy5fZW50cnlzdG9yZS5uZXdTb2xyUXVlcnkoKS5ncmFwaFR5cGUoZ3JhcGhUeXBlKS5saW1pdCgyKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgcXVlcnkuY29udGV4dChjb250ZXh0KTtcbiAgICB9XG4gICAgY29uc3QgZW50cnlBcnIgPSBhd2FpdCBxdWVyeS5saXN0KGFzeW5jQ2FsbFR5cGUpLmdldEVudHJpZXMoMCk7XG4gICAgaWYgKGVudHJ5QXJyLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBlbnRyeUFyclswXTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKGBObyBlbnRyaWVzIGluICR7Y29udGV4dCA/ICdjb250ZXh0JyA6ICdyZXBvc2l0b3J5J30gY29udGV4dCB3aXRoIGdyYXBoVHlwZSAke2dyYXBoVHlwZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGFsbCBlbnRyaWVzIG1hdGNoZWQgYnkgYSBzZWFyY2ggaW4gYSBzZXJpYWwgbWFubmVyLFxuICAgKiBhbHNvIGVtcHRpZXMgdGhlIGNhY2hlIGZyb20gbG9hZGVkIGVudHJpZXMgc28gaXQgc2hvdWxkIG5vdCBvdmVyZmxvd1xuICAgKiBpZiB0aGUgc2VhcmNobGlzdCBpcyBiaWcuXG4gICAqXG4gICAqIFRoZSByZW1vdmFsIGlzIGFjY29tcGxpc2hlZCBieSBmaXJzdCBpdGVyYXRpbmcgdGhyb3VnaCB0aGUgc2VhcmNobGlzdCBhbmQgY29sbGVjdGluZ1xuICAgKiB1cmlzIHRvIGFsbCBlbnRyaWVzIHRoYXQgc2hvdWxkIGJlIHJlbW92ZWQuIEFmdGVyIHRoYXQgdGhlIGVudHJpZXMgYXJlIHJlbW92ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RvcmUvU2VhcmNoTGlzdH0gbGlzdFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIGFzeW5jIHJlbW92ZUFsbChsaXN0KSB7XG4gICAgY29uc3QgdXJpcyA9IFtdO1xuICAgIGNvbnN0IGVzID0gdGhpcy5fZW50cnlzdG9yZTtcbiAgICBjb25zdCBjYWNoZSA9IGVzLmdldENhY2hlKCk7XG4gICAgY29uc3QgcmVzdCA9IGVzLmdldFJFU1QoKTtcblxuICAgIGNvbnN0IGRlbGV0ZU5leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICBpZiAodXJpcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHVyaSA9IHVyaXMucG9wKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgcmVzdC5kZWwodXJpKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYENvdWxkIG5vdCByZW1vdmUgZW50cnkgd2l0aCB1cmk6ICR7dXJpfSBjb250aW51aW5nIGFueXdheS5gKTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGVOZXh0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG5cbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBsaXN0LmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICB1cmlzLnB1c2goZW50cnkuZ2V0VVJJKCkpO1xuICAgICAgY2FjaGUudW5DYWNoZShlbnRyeSk7IC8vIEB0b2RvIEB2YWxlbnRpbm8gcGVyaGFwcyB0aGV5IGFyZSByZW1vdmVkIGZyb20gY2FjaGUgdG9vIGVhcmx5LiBNb3ZlIHRvIGRlbGV0ZU5leHQ/XG4gICAgfSk7XG5cbiAgICBkZWxldGVOZXh0KHJlc3VsdCk7XG4gIH1cbn1cblxuIiwiaW1wb3J0IHhtbGRvbSBmcm9tICd4bWxkb20nO1xuaW1wb3J0IGZhY3RvcnkgZnJvbSAnLi9mYWN0b3J5JztcbmltcG9ydCBSZXNvdXJjZSBmcm9tICcuL1Jlc291cmNlJztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vdXRpbHMnO1xuXG4vKipcbiAqIEZpbGUgcmVzb3VyY2VzIGFyZSByZXNvdXJjZXMgbG9jYXRlZCBpbiB0aGUgRW50cnlzdG9yZSByZXBvc2l0b3J5IHRoYXQgaGF2ZSBhIGdyYXBoIHR5cGUgb2ZcbiAqIG5vbmUsIGUuZy4gbm9uZSBvZiB0aGUgc3BlY2lhbCBjYXNlcyBmb3Igd2hpY2ggdGhlcmUgYXJlIHNwZWNpYWwgdHJlYXRtZW50IGluIEVudHJ5U3RvcmUuXG4gKlxuICogQGV4cG9ydHMgc3RvcmUvRmlsZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGaWxlUmVzb3VyY2UgZXh0ZW5kcyBSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBQdXNoZXMgYSBmaWxlIHRvIHRoZSBzZXJ2ZXIgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAqIEluIGEgYnJvd3NlciBlbnZpcm9ubWVudCBhIGZpbGUgaXMgcmVwcmVzZW50ZWQgdmlhIGFuIGlucHV0IHRhZyB3aGljaCByZWZlcmVuY2VzXG4gICAqIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkIHZpYSBpdHMgdmFsdWUgYXR0cmlidXRlLiBFLmcuOlxuICAgKlxuICAgKiAgICAgICA8aW5wdXQgdHlwZT1cImZpbGVcIiBuYW1lPVwidXBsb2FkRmlsZVwiLz5cbiAgICpcbiAgICogRHVyaW5nIHRoZSB1cGxvYWRpbmcgcHJvY2VzcyB0aGUgaW5wdXQgdGFnIHdpbGwgYmUgbW92ZWQgdGVtcG9yYXJpbHkgaW4gdGhlIERPTSB0cmVlLFxuICAgKiBpdCB3aWxsIGJlIHJlc3RvcmVkIHRvIGl0cyBvcmlnaW5hbCBwb3NpdGlvbiBhZnRlcndhcmRzIChib3RoIHVwb24gc3VjY2VzcyBhbmQgZmFpbHVyZSkuXG4gICAqXG4gICAqIEluIGEgbm9kZWpzIGVudmlyb25tZW50cyB0aGUgZmlsZSBpcyBsZXZlcmFnZWQgYXMgYSBzdHJlYW0sIGkuZS46XG4gICAqIHJlcy5wdXRGaWxlKGZzLmNyZWF0ZVJlYWRTdHJlYW0oJ2ZpbGUudHh0JykpO1xuICAgKlxuICAgKiBAcGFyYW0ge25vZGV8ZmlsZUhhbmRsZX0gZGF0YSAtIGlucHV0IHRhZyBvciBmaWxlIGhhbmRsZSB0aGF0IGNvcnJlc3BvbmRzIHRvIGEgZmlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCAtIGluZGljYXRlcyB0aGUgbWltZXR5cGUgb2YgdGhlIGRhdGFcbiAgICogQHRvZG8gZml4LWlmLW1vZGlmaWVkLXNpbmNlXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgcHV0RmlsZShkYXRhLCBmb3JtYXQpIHtcbiAgICBsZXQgdXJsO1xuICAgIC8vIG5vaW5zcGVjdGlvbiBBbWRNb2R1bGVzRGVwZW5kZW5jaWVzXG4gICAgaWYgKGlzQnJvd3NlcigpICYmIGRhdGEgaW5zdGFuY2VvZiBOb2RlKSB7XG4gICAgICBpZiAoZGF0YS5uYW1lID09IG51bGwgfHwgZGF0YS5uYW1lID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZhaWx1cmUsIGNhbm5vdCB1cGxvYWQgcmVzb3VyY2UgZnJvbSBpbnB1dCBlbGVtZW50IHVubGVzcyBhIG5hbWUnICtcbiAgICAgICAgICAnIGF0dHJpYnV0ZSBpcyBwcm92aWRlZC4nKTtcbiAgICAgIH1cbiAgICAgIHVybCA9IGZhY3RvcnkuZ2V0UHV0RmlsZVVSSSh0aGlzLmdldFJlc291cmNlVVJJKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cmwgPSB0aGlzLmdldFJlc291cmNlVVJJKCk7XG4gICAgfVxuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG4gICAgcmV0dXJuIGVzLmhhbmRsZUFzeW5jKGVzLmdldFJFU1QoKS5wdXRGaWxlKHVybCwgZGF0YSwgZm9ybWF0KS50aGVuKChyZXMpID0+IHtcbiAgICAgIHRoaXMuZ2V0RW50cnkodHJ1ZSkuc2V0UmVmcmVzaE5lZWRlZCgpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KSwgJ3B1dEZpbGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgZGF0YSB0byB0aGUgc2VydmVyIGZvciB0aGlzIHJlc291cmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZGF0YSAtIHRvIGJlIHN0b3JlZCBhcyBhIGZpbGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBmb3JtYXQgLSB0aGUgZm9ybWF0IG9mIHRoZSBkYXRhIGFzIGEgbWltZXR5cGUuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgcHV0KGRhdGEsIGZvcm1hdCA9ICdhcHBsaWNhdGlvbi9qc29uJykge1xuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG4gICAgcmV0dXJuIGVzLmhhbmRsZUFzeW5jKGVzLmdldFJFU1QoKS5wdXQodGhpcy5nZXRSZXNvdXJjZVVSSSgpLCBkYXRhLCBudWxsLCBmb3JtYXQpLCAncHV0RmlsZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1c2hlcyB0ZXh0IGNvbnRlbnQgdG8gdGhlIHNlcnZlciBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSB0byBiZSBzdG9yZWQgYXMgYSBmaWxlLCBmb3JtYXQgd2lsbCBiZSBzZXQgdG8gdGV4dC9wbGFpbi5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBwdXRUZXh0KHRleHQpIHtcbiAgICByZXR1cm4gdGhpcy5wdXQodGV4dCwgJ3RleHQvcGxhaW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgSlNPTiBjb250ZW50IHRvIHRoZSBzZXJ2ZXIgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmogLSB0byBiZSBzdG9yZWQgYXMgYSBqc29uIG9iamVjdCwgZm9ybWF0IHdpbGwgYmUgc2V0IHRvIGFwcGxpY2F0aW9uL2pzb24uXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgcHV0SlNPTihvYmopIHtcbiAgICByZXR1cm4gdGhpcy5wdXQoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIHhtbCBjb250ZW50IHRvIHRoZSBzZXJ2ZXIgZm9yIHRoaXMgcmVzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfERvY3VtZW50fSB4bWwgLSB0byBiZSBzdG9yZWQgYXMgYSB4bWwgb2JqZWN0LCBmb3JtYXQgd2lsbCBiZSBzZXQgdG9cbiAgICogYXBwbGljYXRpb24vanNvbi5cbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqIEB0b2RvIG5vdCBmaW5pc2hlZCBvciB0ZXN0ZWRcbiAgICovXG4gIHB1dFhNTCh4bWwpIHtcbiAgICBsZXQgX3htbCA9IHhtbDtcbiAgICBjb25zdCBYTUxTZXJpYWxpemVyID0gaXNCcm93c2VyKCkgPyB3aW5kb3cuWE1MU2VyaWFsaXplciA6IHhtbGRvbS5YTUxTZXJpYWxpemVyO1xuXG4gICAgaWYgKCFpc0Jyb3dzZXIoKSB8fCBfeG1sIGluc3RhbmNlb2YgRG9jdW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEdlY2tvLSBhbmQgV2Via2l0LWJhc2VkIGJyb3dzZXJzIChGaXJlZm94LCBDaHJvbWUpLCBPcGVyYS5cbiAgICAgICAgX3htbCA9IChuZXcgWE1MU2VyaWFsaXplcigpKS5zZXJpYWxpemVUb1N0cmluZyhfeG1sKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBJbnRlcm5ldCBFeHBsb3Jlci5cbiAgICAgICAgICBfeG1sID0gX3htbC54bWw7XG4gICAgICAgIH0gY2F0Y2ggKGVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdYbWxzZXJpYWxpemVyIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKHR5cGVvZiBfeG1sKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBmb3JtYXQgb2YgcGFyYW1ldGVyIHhtbCB0byBtZXRob2QgcHV0QXNYTUwnKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHV0KF94bWwsICd0ZXh0L3htbCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm5zIHt4aHJQcm9taXNlfSB3aGljaCBmb3JtYXQgdGhlIHJlc291cmNlIGlzIHJldHVybmVkIGluIHRoZSBwcm9taXNlIChzdHJpbmcsIGpzb24gb3JcbiAgICogeG1sKSBkZXBlbmRzIG9uIHdoYXQgaXMgc3BlY2lmaWVkIGluIHRoZSBtaW1ldHlwZS4gWG1sIGlzIG9ubHkgcmV0dXJuZWQgaW4gYSBicm93c2VyXG4gICAqIGVudmlyb25tZW50LCBpZiBub3QgaW4gYSBicm93c2VyIGEgc3RyaW5nIGlzIHJldHVybmVkLlxuICAgKi9cbiAgZ2V0KCkge1xuICAgIGNvbnN0IGZvcm1hdCA9IHRoaXMuZ2V0RW50cnkodHJ1ZSkuZ2V0RW50cnlJbmZvKCkuZ2V0Rm9ybWF0KCk7XG4gICAgY29uc3QgZXMgPSB0aGlzLmdldEVudHJ5U3RvcmUoKTtcbiAgICByZXR1cm4gZXMuaGFuZGxlQXN5bmMoZXMuZ2V0UkVTVCgpLmdldCh0aGlzLmdldFJlc291cmNlVVJJKCksIGZvcm1hdCksICdnZXRGaWxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2V9IGlnbm9yZXMgd2hhdCBpcyBzcGVjaWZpZWQgaW4gdGhlIG1pbWV0eXBlIGFuZCByZXR1cm5zIHRoZSByZXNvdXJjZVxuICAgKiBhcyBhIHN0cmluZyBpbiB0aGUgcHJvbWlzZS5cbiAgICovXG4gIGdldFRleHQoKSB7XG4gICAgY29uc3QgZXMgPSB0aGlzLmdldEVudHJ5U3RvcmUoKTtcbiAgICByZXR1cm4gZXMuaGFuZGxlQXN5bmModGhpcy5nZXRFbnRyeVN0b3JlKCkuZ2V0UkVTVCgpLmdldCh0aGlzLmdldFJlc291cmNlVVJJKCksICd0ZXh0L3BsYWluJywgdHJ1ZSksICdnZXRGaWxlJyk7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge1Byb21pc2V9IGlnbm9yZXMgd2hhdCBpcyBzcGVjaWZpZWQgaW4gdGhlIG1pbWV0eXBlIGFuZCByZXR1cm5zIHRoZSByZXNvdXJjZVxuICAgKiBhcyBhIGphdmFzY3JpcHQgb2JqZWN0IGluIHRoZSBwcm9taXNlLlxuICAgKi9cbiAgZ2V0SlNPTigpIHtcbiAgICBjb25zdCBlcyA9IHRoaXMuZ2V0RW50cnlTdG9yZSgpO1xuICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhlcy5nZXRSRVNUKCkuZ2V0KHRoaXMuZ2V0UmVzb3VyY2VVUkkoKSwgJ2FwcGxpY2F0aW9uL2pzb24nKSwgJ2dldEZpbGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX0gaWdub3JlcyB3aGF0IGlzIHNwZWNpZmllZCBpbiB0aGUgbWltZXR5cGUgYW5kIHJldHVybnMgdGhlIHJlc291cmNlXG4gICAqIGluIHRoZSBwcm9taXNlIGFzIGEgWE1MIERvY3VtZW50IG9yIGEgc3RyaW5nIChkZXBlbmRpbmcgb24gaWYgeW91IGFyZSBpbiBicm93c2VyIG9yIG5vdCkuXG4gICAqL1xuICBnZXRYTUwoKSB7XG4gICAgY29uc3QgZXMgPSB0aGlzLmdldEVudHJ5U3RvcmUoKTtcbiAgICByZXR1cm4gZXMuaGFuZGxlQXN5bmMoZXMuZ2V0UkVTVCgpLmdldCh0aGlzLmdldFJlc291cmNlVVJJKCksICd0ZXh0L3htbCcpLCAnZ2V0RmlsZScpO1xuICB9XG59XG4iLCJpbXBvcnQgeyBHcmFwaCB9IGZyb20gJ3JkZmpzb24nO1xuaW1wb3J0IFJlc291cmNlIGZyb20gJy4vUmVzb3VyY2UnO1xuXG4vKipcbiAqIEdyYXBoIGlzIGEgcmVzb3VyY2UgZm9yIGhhbmRsaW5nIFJERiBncmFwaHMgcmVseWluZyBvbiB0aGUge0BsaW5rIHJkZmpzb24vR3JhcGh9IEFQSS5cbiAqXG4gKiBAZXhwb3J0cyBzdG9yZS9HcmFwaFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBHcmFwaFJlc291cmNlIGV4dGVuZHMgUmVzb3VyY2Uge1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudHJ5VVJJIC0gVVJJIHRvIGFuIGVudHJ5IHdoZXJlIHRoaXMgcmVzb3VyY2UgaXMgY29udGFpbmVkLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzb3VyY2VVUkkgLSBVUkkgdG8gdGhlIHJlc291cmNlLlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5U3RvcmV9IGVudHJ5U3RvcmUgLSB0aGUgQVBJJ3MgcmVwb3NpdG9yeSBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtyZGZqc29uL0dyYXBoIHwgT2JqZWN0fSBkYXRhIC0gaXMgYW4gUkRGIGdyYXBoIG9mIHNvbWUgc29ydFxuICAgKi9cbiAgY29uc3RydWN0b3IoZW50cnlVUkksIHJlc291cmNlVVJJLCBlbnRyeVN0b3JlLCBkYXRhKSB7XG4gICAgc3VwZXIoZW50cnlVUkksIHJlc291cmNlVVJJLCBlbnRyeVN0b3JlKTsgLy8gQ2FsbCB0aGUgc3VwZXIgY29uc3RydWN0b3IuXG4gICAgdGhpcy5fZ3JhcGggPSBkYXRhICYmIGRhdGEuX2dyYXBoID8gZGF0YSA6IG5ldyBHcmFwaChkYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHJkZiBHcmFwaC4gVGhlIHJldHVybmVkIGdyYXBoIGlzIG5vdCBhIGNvcHksIHN1YnNlcXVlbnQgZ2V0R3JhcGggY2FsbHMgd2lsbCByZXR1cm5cbiAgICogdGhlIHNhbWUgaW5zdGFuY2UgYXMgbG9uZyBhcyB0aGUgZW50cnkgaGFzIG5vdCBiZWVuIHJlZnJlc2hlZCBvciBhIG5ldyBpbnN0YW5jZSBzZXQgdmlhXG4gICAqIHtAbGluayBzdG9yZS9HcmFwaCNzZXRHcmFwaCBzZXRHcmFwaH0uXG4gICAqXG4gICAqIEByZXR1cm5zIHtyZGZqc29uL0dyYXBofSB3aWxsIG5ldmVyIGJlIG51bGwgb3IgdW5kZWZpbmVkLCBhbHRob3VnaCB0aGUgZ3JhcGggbWF5IGJlIGVtcHR5LlxuICAgKi9cbiAgZ2V0R3JhcGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgcmRmIEdyYXBoLiBUbyB1cGRhdGUgdGhlIGdyYXBoIGluIHRoZSByZXBvc2l0b3J5IGNhbGwgdGhlXG4gICAqIHtAbGluayBzdG9yZS9FbnRyeVN0b3JlI2NvbW1pdCBjb21taXR9LlxuICAgKlxuICAgKiBAcGFyYW0ge3JkZmpzb24vR3JhcGh9IGdyYXBoIC0gdGhlIG5ldyBncmFwaCwgaWYgbnVsbCBvciB1bmRlZmluZWQgYSBuZXcgZW1wdHkgZ3JhcGggd2lsbFxuICAgKiBiZSBzZXQuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9HcmFwaH0gLSB0byBhbGxvdyBjaGFpbmluZyB3aXRoIGNvbW1pdC5cbiAgICovXG4gIHNldEdyYXBoKGdyYXBoKSB7XG4gICAgdGhpcy5fZ3JhcGggPSBncmFwaCB8fCBuZXcgR3JhcGgoKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgdGhlIGN1cnJlbnQgZ3JhcGggYmFjayB0byByZXBvc2l0b3J5LlxuICAgKlxuICAgKiBAdG9kbyBmaXggaWZNb2RpZmllZFNpbmNlLlxuICAgKiBAcGFyYW0ge3JkZmpzb24vR3JhcGh9IGdyYXBoXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgY29tbWl0KCkge1xuICAgIHJldHVybiB0aGlzLl9lbnRyeVN0b3JlLmhhbmRsZUFzeW5jKHRoaXMuX2VudHJ5U3RvcmUuZ2V0UkVTVCgpLnB1dCh0aGlzLl9yZXNvdXJjZVVSSSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX2dyYXBoLmV4cG9ydFJERkpTT04oKSkpLCAnY29tbWl0R3JhcGgnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlcyBhIEpTT04gcmVwcmVzZW50YXRpb24gb2YgdGhlIGdyYXBoIGFzIHJkZi9qc29uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9ncmFwaC5leHBvcnRSREZKU09OKCk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGUoZGF0YSkge1xuICAgIHRoaXMuX2dyYXBoID0gbmV3IEdyYXBoKGRhdGEpO1xuICB9XG59XG4iLCJpbXBvcnQgTGlzdCBmcm9tICcuL0xpc3QnO1xuaW1wb3J0IHRlcm1zIGZyb20gJy4vdGVybXMnO1xuXG4vKipcbiAqIEdyb3VwIGlzIGEgc3ViY2xhc3Mgb2YgdGhlIExpc3QgcmVzb3VyY2UgYW5kIGNvbnRhaW5zIGEgbGlzdCBvZiB1c2Vycy5cbiAqIFRoZSBncm91cCByZXNvdXJjZSBVUkkgY2FuIGJlIHJlZmVycmVkIHRvIGZyb20gYWNjZXNzIGNvbnRyb2wgbGlzdHMuXG4gKlxuICogQGV4cG9ydHMgc3RvcmUvR3JvdXBcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgR3JvdXAgZXh0ZW5kcyBMaXN0IHtcbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgZ3JvdXAsIHRoaXMgaXMgYSBhIHVuaXF1ZSBuYW1lICh1c2VybmFtZSkgaW4gdGhlIGN1cnJlbnRcbiAgICogcmVwb3NpdG9yeSdzIF9wcmluY2lwYWxzIGNvbnRleHQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXROYW1lKCkge1xuICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBuYW1lIG9mIHRoZSBncm91cCwgaXQgd2lsbCBub3Qgc3VjY2VlZCBpZiBpdCBpcyBhbHJlYWR5IGluIHVzZSwgZm9yIGluc3RhbmNlIGJ5XG4gICAqIGFub3RoZXIgdXNlciBvciBncm91cC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBzZXROYW1lKG5hbWUpIHtcbiAgICBjb25zdCBvbGROYW1lID0gdGhpcy5fbmFtZTtcbiAgICB0aGlzLl9uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZS5oYW5kbGVBc3luYyh0aGlzLl9lbnRyeVN0b3JlLmdldFJFU1QoKS5wdXQoXG4gICAgICBgJHt0aGlzLmdldEVudHJ5VVJJKCl9L25hbWVgLCBKU09OLnN0cmluZ2lmeSh7IG5hbWUgfSkpXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZ2V0RW50cnkodHJ1ZSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LmdldEVudHJ5SW5mbygpLl9uYW1lID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgIHRoaXMuX25hbWUgPSBvbGROYW1lO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSksICdzZXRHcm91cE5hbWUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGhvbWUgY29udGV4dCBmb3IgdGhpcyB1c2VyLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIGEgY29udGV4dCBpZCAobm90IHRoZSBmdWxsIHJlc291cmNlIFVSSSkuXG4gICAqL1xuICBnZXRIb21lQ29udGV4dCgpIHtcbiAgICBjb25zdCBlcyA9IHRoaXMuZ2V0RW50cnlTdG9yZSgpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5nZXRFbnRyeSh0cnVlKTtcbiAgICBjb25zdCBjb250ZXh0UmVzb3VyY2VVUkkgPSBlbnRyeS5nZXRFbnRyeUluZm8oKS5nZXRHcmFwaCgpLmZpbmRGaXJzdFZhbHVlKFxuICAgICAgZW50cnkuZ2V0UmVzb3VyY2VVUkkoKSwgdGVybXMuaG9tZUNvbnRleHQpO1xuICAgIGlmIChjb250ZXh0UmVzb3VyY2VVUkkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVzLmdldEVudHJ5SWQoY29udGV4dFJlc291cmNlVVJJKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgaG9tZSBjb250ZXh0IGZvciB0aGlzIGdyb3VwLlxuICAgKiBOb3RlIHRoYXQgdGhlIGhvbWUgY29udGV4dCBpcyBzdG9yZWQgaW4gdGhlIGVudHJ5aW5mb3JtYXRpb24sIGhlbmNlLCBhbGwgb3RoZXIgY2hhbmdlcyBtYWRlXG4gICAqIHRvIHRoZSBlbnRyeWluZm9ybWF0aW9uIHdpbGwgYmUgc2F2ZWQgdW5sZXNzIHRoZSBkb05vdFB1c2hUb1JlcG9zaXRvcnkgZmxhZyBpcyBzZXQgdG8gdHJ1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIGEgY29udGV4dCBpZCAobm90IHRoZSBmdWxsIHJlc291cmNlIFVSSSkuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9Ob3RQdXNoVG9SZXBvc2l0b3J5IGlmIHRydWUgdGhlIGNoYW5nZXMgd2lsbCBiZSBtYWRlIGluIHRoZVxuICAgKiBlbnRyeWluZm9ybWF0aW9uIGJ1dCBpdCB3aWxsIG5vdCBiZSBwdXNoZWQgdG8gdGhlIHJlc3Bvc2l0b3J5LiBUbyBkbyB0aGlzIHlvdSBuZWVkIHRvIGdldFxuICAgKiBhIGhvbGQgb2YgdGhlIGVudHJ5aW5mb3JtYXRpb24gYW5kIGNhbGwgY29tbWl0LlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnlJbmZvPnx1bmRlZmluZWR9XG4gICAqL1xuICBzZXRIb21lQ29udGV4dChjb250ZXh0SWQsIGRvTm90UHVzaFRvUmVwb3NpdG9yeSkge1xuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG4gICAgY29uc3QgbmV3Q29udGV4dFVSSSA9IGVzLmdldFJlc291cmNlVVJJKCdfY29udGV4dHMnLCBjb250ZXh0SWQpO1xuICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5nZXRFbnRyeSh0cnVlKTtcbiAgICBjb25zdCBncmFwaCA9IGVudHJ5LmdldEVudHJ5SW5mbygpLmdldEdyYXBoKCk7XG4gICAgZ3JhcGguZmluZEFuZFJlbW92ZShlbnRyeS5nZXRSZXNvdXJjZVVSSSgpLCB0ZXJtcy5ob21lQ29udGV4dCk7XG4gICAgZ3JhcGguYWRkKGVudHJ5LmdldFJlc291cmNlVVJJKCksIHRlcm1zLmhvbWVDb250ZXh0LCB7IHR5cGU6ICd1cmknLCB2YWx1ZTogbmV3Q29udGV4dFVSSSB9KTtcbiAgICBpZiAoZG9Ob3RQdXNoVG9SZXBvc2l0b3J5ICE9PSB0cnVlKSB7XG4gICAgICByZXR1cm4gZW50cnkuZ2V0RW50cnlJbmZvKCkuY29tbWl0KCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogRGF0YSBjb250YWlucyBhbGxVbnNvcnRlZCBhcnJheSwgc2l6ZSwgYW5kIGNoaWxkcmVuLlxuICAgKiBAcGFyYW0gZGF0YVxuICAgKiBAcGFyYW0gY2hpbGRyZW5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF91cGRhdGUoZGF0YSwgY2hpbGRyZW4pIHtcbiAgICBzdXBlci5fdXBkYXRlKGRhdGEsIGNoaWxkcmVuKTtcbiAgICB0aGlzLl9uYW1lID0gZGF0YS5uYW1lO1xuICB9XG59XG4iLCJpbXBvcnQgUmVzb3VyY2UgZnJvbSAnLi9SZXNvdXJjZSc7XG5pbXBvcnQgZmFjdG9yeSBmcm9tICcuL2ZhY3RvcnknO1xuXG4vKipcbiAqIExpc3QgaXMgYSBjb250YWluZXIgZm9yIG90aGVyIGVudHJpZXMgaW4gdGhlIHNhbWUgY29udGV4dC5cbiAqIEEgc2luZ2xlIGVudHJ5IG1heSBhcHBlYXIgaW4gbXVsdGlwbGUgbGlzdHMgKG11bHRpcGxlIHBhcmVudCBsaXN0cykgdW5sZXNzIGlmIGl0IGlzXG4gKiBhIGxpc3QgaXRzZWxmLiBUbyBhdm9pZCBjaXJjdWxhciByZWZlcmVuY2VzIGxpc3QgZW50cmllcyBhcmUgb25seSBhbGxvd2VkIHRvIGFwcGVhclxuICogaW4gb25lIHBhcmVudCBsaXN0LlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL0xpc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTGlzdCBleHRlbmRzIFJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeVVSSSAtIFVSSSB0byBhbiBlbnRyeSB3aGVyZSB0aGlzIHJlc291cmNlIGlzIGNvbnRhaW5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlVVJJIC0gVVJJIHRvIHRoZSByZXNvdXJjZS5cbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeVN0b3JlfSBlbnRyeVN0b3JlIC0gdGhlIEFQSSdzIHJlcG9zaXRvcnkgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnRyeVVSSSwgcmVzb3VyY2VVUkksIGVudHJ5U3RvcmUpIHtcbiAgICBzdXBlcihlbnRyeVVSSSwgcmVzb3VyY2VVUkksIGVudHJ5U3RvcmUpO1xuICAgIHRoaXMuX2NhY2hlID0gZW50cnlTdG9yZS5nZXRDYWNoZSgpO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGVudHJ5IFVSSXNcbiAgICAgKiBAdHlwZSB7QXJyYXkuPHN0cmluZz59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9zb3J0ZWRDaGlsZHJlbiA9IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgbWF4IGFtb3VudCBvZiBlbnRyaWVzIHRvIGluY2x1ZGUgaW4gZWFjaCBwYWdlIGR1cmluZyBwYWdpbmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge2ludGVnZXJ9IGxpbWl0XG4gICAqIEByZXR1cm5zIHtzdG9yZS9MaXN0fSBhbGxvd3MgY2hhaW5pbmcgb2Ygc2V0LW9wZXJhdGlvbnMuXG4gICAqL1xuICBzZXRMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBtYXggYW1vdW50IG9mIGVudHJpZXMgdG8gaW5jbHVkZSBpbiBlYWNoIHBhZ2UgZHVyaW5nIHBhZ2luYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtpbnRlZ2VyfVxuICAgKi9cbiAgZ2V0TGltaXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xpbWl0IHx8IGZhY3RvcnkuZ2V0RGVmYXVsdExpbWl0KCk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgc29ydCBvcmRlciB3aGVuIGxvYWRpbmcgZW50cmllcyBjb250YWluZWQgaW4gdGhpcyBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc29ydFBhcmFtcyAtIHNhbWUgb2JqZWN0IHN0cnVjdHVyZSBhcyB0aGUgc29ydCBwYXJhbWV0ZXIgaW5cbiAgICogb3B0aW9uYWxMb2FkUGFyYW1ldGVycyBpbiB7QGxpbmsgc3RvcmUvRW50cnlTdG9yZSNnZXRFbnRyeX0gbWV0aG9kLlxuICAgKiBAcmV0dXJucyB7c3RvcmUvTGlzdH0gYWxsb3dzIGNoYWluaW5nIG9mIHNldC1vcGVyYXRpb25zLlxuICAgKi9cbiAgc2V0U29ydChzb3J0UGFyYW1zKSB7XG4gICAgdGhpcy5fY2xlYXJTb3J0ZWRFbnRyaWVzKCk7XG4gICAgdGhpcy5fc29ydFBhcmFtcyA9IHNvcnRQYXJhbXM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGFuIGFycmF5IG9mIGVudHJpZXMgY29udGFpbmVkIGluIHRoaXMgbGlzdCBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgcGFnZSBhbmRcbiAgICogcGFnaW5hdGlvbiBzZXR0aW5ncy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2UgLSB0aGUgcGFnZSB0byByZXF1ZXN0IGFuIGFycmF5IG9mIGVudHJpZXMgZm9yLFxuICAgKiBmaXJzdCBwYWdlIGlzIG51bWJlcmVkIDAuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxzdG9yZS9FbnRyeVtdPn0gdGhlIHByb21pc2Ugd2lsbCByZXR1cm4gYW4gZW50cnktYXJyYXkuXG4gICAqL1xuICBnZXRFbnRyaWVzKHBhZ2UgPSAwKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IHRoaXMuX2dldEVudHJpZXMocGFnZSk7XG4gICAgaWYgKHJlc3VsdHMgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZXN1bHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZvcmNlTG9hZEVudHJpZXMocGFnZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgYSBjYWxsYmFjayBvbiBlYWNoIGxpc3QgbWVtYmVycyBpbiB0aGUgb3JkZXIgcHJvdmlkZWQgYnkgdGhlIGxpc3QuXG4gICAqIElmIHRoZSBwcm92aWRlZCBmdW5jdGlvbiByZXR1cm4gZmFsc2UgZm9yIG9uZSBlbnRyeSB0aGUgaXRlcmF0aW9uIGlzIHN0b3BwZWQgYW5kXG4gICAqIHRoZSBmdW5jdGlvbiBpcyBub3QgY2FsbGVkIGZvciBjb25zZWN1dGl2ZSBlbnRyaWVzLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IGNhbGxlZCB3aXRoIHR3byBwYXJhbWV0ZXJzLCB0aGUgZmlyc3QgYSBib29sZWFuIHNheWluZyBpZiBhbGwgZW50cmllc1xuICAgKiB3aGVyZSBwYXNzZWQsIHRoZSBzZWNvbmQgYW4gaW5kZXggdGVsbGluZyBob3cgbWFueSBlbnRyaWVzIGl0ZXJhdGVkIG92ZXIuXG4gICAqL1xuICBmb3JFYWNoKGZ1bmMpIHtcbiAgICBsZXQgcGFnZSA9IDA7XG4gICAgbGV0IGlkeCA9IDA7XG4gICAgbGV0IGc7XG4gICAgbGV0IGg7XG4gICAgY29uc3QgbGltaXQgPSB0aGlzLmdldExpbWl0KCk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBjb25zdCBmID0gKGVudHJpZXMpID0+IHtcbiAgICAgIGNvbnN0IGVudHJpZXNMZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgICAgIGcgPSAocmVzKSA9PiB7XG4gICAgICAgIGlmIChyZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGgoKTtcbiAgICAgIH07XG4gICAgICBoID0gKCkgPT4ge1xuICAgICAgICBpZiAoZW50cmllcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGZ1bmMoZW50cmllcy5wb3AoKSwgaWR4KTtcbiAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gcmVzLnRoZW4oZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGcocmVzKTtcbiAgICAgIH07XG4gICAgICByZXR1cm4gaCgpLnRoZW4oKGNvbnQpID0+IHtcbiAgICAgICAgaWYgKGNvbnQgIT09IGZhbHNlICYmIGVudHJpZXNMZW5ndGggPT09IGxpbWl0KSB7XG4gICAgICAgICAgcGFnZSArPSAxO1xuICAgICAgICAgIHJldHVybiBzZWxmLmdldEVudHJpZXMocGFnZSkudGhlbihmKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGlkeCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cmllcygwKS50aGVuKGYpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYW4gZW50cnkgdG8gdGhpcyBsaXN0LCBvbiBzdWNjZXNzIHRoZSBMaXN0IGVudHJ5IHdpbGwgYmUgcmV0dXJuZWQgKHVwZGF0ZWQgd2l0aFxuICAgKiBsYXRlc3QgbW9kaWZpY2F0aW9uIGRhdGUpLiBUaGUgYWRkZWQgZW50cnkgd2lsbCBiZSBtYXJrZWQgYXMgaW4gbmVlZCBvZiBhXG4gICAqIHJlZnJlc2ggZHVlIHRvIHN0YWxlIGludi1yZWwgY2FjaGUuIEhvd2V2ZXIsc2luY2UgTGlzdCBlbnRyeSBpcyBsb2FkZWQgaXQgbWF5IGJlIHJlZnJlc2hlZFxuICAgKiBhbHJlYWR5IHdoZW4gbWV0aG9kIGlzIHJlc29sdmVkLCBpdCBkZXBlbmRzIGlmIGl0IGlzIGluIHRoZSBmaXJzdCBwYWdlIG9mIHRoZSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5fSBlbnRyeSAtIGVudHJ5IHRvIGFkZCB0byB0aGUgbGlzdC5cbiAgICogQHJldHVybnMge1Byb21pc2UuPHN0b3JlL0VudHJ5Pn1cbiAgICovXG4gIGFzeW5jIGFkZEVudHJ5KGVudHJ5KSB7XG4gICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMuZ2V0QWxsRW50cnlJZHMoKTtcbiAgICBlbnRyaWVzLnB1c2goZW50cnkuZ2V0SWQoKSk7XG4gICAgYXdhaXQgdGhpcy5zZXRBbGxFbnRyeUlkcyhlbnRyaWVzLCAnYWRkVG9MaXN0Jyk7XG4gICAgZW50cnkuc2V0UmVmcmVzaE5lZWRlZCgpO1xuICAgIHJldHVybiB0aGlzLmdldEVudHJ5KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbiBlbnRyeSBmcm9tIHRoaXMgbGlzdCwgb24gc3VjY2VzcyB0aGUgTGlzdCBlbnRyeSB3aWxsIGJlIHJldHVybmVkICh1cGRhdGVkIHdpdGhcbiAgICogbGF0ZXN0IG1vZGlmaWNhdGlvbiBkYXRlKS4gVGhlIHJlbW92ZWQgZW50cnkgd2lsbCBub3QgYmUgdXBkYXRlZCBidXQgbWFya2VkIGFzIGluIG5lZWRcbiAgICogb2YgYSByZWZyZXNoIGR1ZSB0byBzdGFsZSBpbnYtcmVsIGNhY2hlLiBIb3dldmVyLHNpbmNlIExpc3QgZW50cnkgaXMgbG9hZGVkIGl0IG1heSBiZVxuICAgKiByZWZyZXNoZWQgYWxyZWFkeSB3aGVuIG1ldGhvZCBpcyByZXNvbHZlZCwgaXQgZGVwZW5kcyBpZiBpdCBpcyBpbiB0aGUgZmlyc3QgcGFnZSBvZiB0aGUgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeX0gZW50cnkgLSBlbnRyeSB0byBiZSByZW1vdmVkIGZyb20gdGhlIGxpc3QuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlRW50cnkoZW50cnkpIHtcbiAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgdGhpcy5nZXRBbGxFbnRyeUlkcygpO1xuICAgIGVudHJpZXMuc3BsaWNlKGVudHJpZXMuaW5kZXhPZihlbnRyeS5nZXRJZCgpKSwgMSk7XG4gICAgYXdhaXQgdGhpcy5zZXRBbGxFbnRyeUlkcyhlbnRyaWVzLCAncmVtb3ZlRnJvbUxpc3QnKTtcbiAgICBlbnRyeS5zZXRSZWZyZXNoTmVlZGVkKCk7XG4gIH1cblxuICAvKipcbiAgICogV2lsbCB1bnNldCB0aGluZ3Mgc2luY2UgdGhlIGNhY2hlIGlzIHN0YWxlLi4uXG4gICAqL1xuICBuZWVkUmVmcmVzaCgpIHtcbiAgICBkZWxldGUgdGhpcy5fdW5zb3J0ZWRDaGlsZHJlbjtcbiAgICB0aGlzLl9zb3J0ZWRDaGlsZHJlbiA9IFtdO1xuICAgIGRlbGV0ZSB0aGlzLl9zaXplO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhIGxpc3Qgb2YgZW50cnkgaWRzIGNvbnRhaW5lZCBpbiB0aGlzIGxpc3QuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlLjxBcnJheS48c3RyaW5nPj59IHRoZSBwcm9taXNlIHdpbGwgZGVsaXZlciBhbiBhcnJheSBvZiBjaGlsZHJlbiBlbnRyaWVzIGluIHRoaXNcbiAgICogbGlzdCBhcyBpZHNcbiAgICogKHN0cmluZ3MsIG5vdCBmdWxsIFVSSXMpLlxuICAgKi9cbiAgZ2V0QWxsRW50cnlJZHMoKSB7XG4gICAgaWYgKHRoaXMuX3Vuc29ydGVkQ2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0aGlzLl91bnNvcnRlZENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0RW50cmllcygpLnRoZW4oKCkgPT4gdGhpcy5fdW5zb3J0ZWRDaGlsZHJlbik7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbGlzdCBvZiBlbnRyeSBpZHMgdG8gYmUgY29udGFpbmVkIGluIHRoaXMgbGlzdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmdbXX0gZW50cmllcyAtIGFycmF5IG9mIGVudHJ5IGlkcyAoYXMgc3RyaW5ncywgbm90IGZ1bGwgVVJJcykuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsVHlwZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnk+fVxuICAgKi9cbiAgc2V0QWxsRW50cnlJZHMoZW50cmllcywgY2FsbFR5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZS5oYW5kbGVBc3luYyhcbiAgICAgIHRoaXMuX2VudHJ5U3RvcmUuZ2V0UkVTVCgpLnB1dCh0aGlzLl9yZXNvdXJjZVVSSSwgSlNPTi5zdHJpbmdpZnkoZW50cmllcykpXG4gICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICB0aGlzLm5lZWRSZWZyZXNoKCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuX2VudHJ5U3RvcmUuZ2V0RW50cnkodGhpcy5nZXRFbnRyeVVSSSgpKS50aGVuKChvZW50cnkpID0+IHtcbiAgICAgICAgICAgIG9lbnRyeS5zZXRSZWZyZXNoTmVlZGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gb2VudHJ5O1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSwgY2FsbFR5cGUgfHwgJ3NldExpc3QnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgc2l6ZSBvZiBsaXN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgYW1vdW50IG9mIGVudHJpZXMgaW4gdGhlIGxpc3QsIC0xIGlmIHVua25vd24uXG4gICAqL1xuICBnZXRTaXplKCkge1xuICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2l6ZSA9PT0gJ251bWJlcicgPyB0aGlzLl9zaXplIDogLTE7XG4gIH1cblxuICAvLz0gPT09PT09PT1IZWxwZXIgbWV0aG9kcz09PT09PT09PT09PT09PVxuXG4gIF9jbGVhclNvcnRlZEVudHJpZXMoKSB7XG4gICAgdGhpcy5fc29ydGVkQ2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcGFnZVxuICAgKiBAcGFyYW0gY2FyZUFib3V0RnJlc2hcbiAgICogQHJldHVybiB7bnVsbHxBcnJheX1cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXRFbnRyaWVzKHBhZ2UgPSAwLCBjYXJlQWJvdXRGcmVzaCA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuX3NpemUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5nZXRMaW1pdCgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBhZ2UgKiBsaW1pdDtcblxuICAgIGxldCBuZWVkUmVmcmVzaCA9IGZhbHNlO1xuICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICBsZXQgZW50cnlVUkk7XG4gICAgZm9yIChsZXQgaSA9IG9mZnNldDsgaSA8IG9mZnNldCArIGxpbWl0ICYmIGkgPCB0aGlzLl9zaXplOyBpKyspIHtcbiAgICAgIGVudHJ5VVJJID0gdGhpcy5fc29ydGVkQ2hpbGRyZW5baV07XG4gICAgICBpZiAoZW50cnlVUkkpIHtcbiAgICAgICAgY29uc3QgZSA9IHRoaXMuX2VudHJ5U3RvcmUuZ2V0Q2FjaGUoKS5nZXQoZW50cnlVUkkpO1xuICAgICAgICBpZiAoY2FyZUFib3V0RnJlc2ggPT09IGZhbHNlIHx8IChlICE9IG51bGwgJiYgIWUubmVlZFJlZnJlc2goKSkpIHtcbiAgICAgICAgICByZXN1bHRzLnB1c2goZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVlZFJlZnJlc2ggPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZWVkUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmVlZFJlZnJlc2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gcGFnZVxuICAgKiBAcmV0dXJuIHsqfFByb21pc2U8QXJyYXkgfCBuZXZlcj59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZm9yY2VMb2FkRW50cmllcyhwYWdlID0gMCkge1xuICAgIGNvbnN0IGxpbWl0ID0gdGhpcy5nZXRMaW1pdCgpO1xuICAgIGNvbnN0IG9mZnNldCA9IHBhZ2UgKiBsaW1pdDtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZS5nZXRFbnRyeSh0aGlzLl9lbnRyeVVSSSwge1xuICAgICAgZm9yY2VMb2FkOiB0cnVlLFxuICAgICAgb2Zmc2V0LFxuICAgICAgbGltaXQsXG4gICAgICBzb3J0OiB0aGlzLl9zb3J0LFxuICAgICAgYXN5bmNDb250ZXh0OiAnbG9hZExpc3RFbnRyaWVzJyxcbiAgICB9KS50aGVuKCgpID0+IHRoaXMuX2dldEVudHJpZXMocGFnZSwgZmFsc2UpKTtcbiAgfVxuXG5cbiAgLyoqXG4gICAqIERhdGEgY29udGFpbnMgYWxsVW5zb3J0ZWQgYXJyYXksIHNpemUsIGFuZCBjaGlsZHJlbi5cbiAgICpcbiAgICogQHBhcmFtIGRhdGFcbiAgICogQHBhcmFtIGNoaWxkcmVuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdXBkYXRlKGRhdGEsIGNoaWxkcmVuKSB7XG4gICAgY29uc3Qgb2Zmc2V0ID0gZGF0YS5vZmZzZXQgfHwgMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9zb3J0ZWRDaGlsZHJlbltvZmZzZXQgKyBpXSA9IGNoaWxkcmVuW2ldLmdldFVSSSgpO1xuICAgIH1cbiAgICB0aGlzLl9zaXplID0gZGF0YS5zaXplIHx8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB0aGlzLl91bnNvcnRlZENoaWxkcmVuID0gZGF0YS5hbGxVbnNvcnRlZCB8fCBjaGlsZHJlbi5tYXAoZW50cnkgPT4gZW50cnkuZ2V0SWQoKSk7XG4gIH1cbn07XG4iLCJpbXBvcnQgR3JhcGhSZXNvdXJjZSBmcm9tICcuL0dyYXBoJztcbmltcG9ydCB0ZXJtcyBmcm9tICcuL3Rlcm1zJztcblxuLyoqXG4gKiBQaXBlbGluZSBpcyBhIEdyYXBoIHRoYXQgY29udGFpbnMgYW4gb3JkZXJlZCBsaXN0IG9mIHRyYW5zZm9ybXMsIGVhY2ggdHJhbnNmb3JtIGlzIG9mIGFcbiAqIHNwZWNpZmljIHR5cGUgYW5kIHRha2VzIGEgc2V0IG9mIGFyZ3VtZW50cy5cbiAqXG4gKiBAZXhwb3J0cyBzdG9yZS9QaXBlbGluZVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQaXBlbGluZSBleHRlbmRzIEdyYXBoUmVzb3VyY2Uge1xuICAvKipcbiAgICogVGhlIGRlc3RpbmF0aW9uIHdoZXJlIHRoZSByZXN1bHQgKGluIHRoZSBmb3JtIG9mIGEgc2luZ2xlIFJERiBncmFwaCkgc2hvdWxkXG4gICAqIGVuZCB1cCAod2l0aGluIHRoZSBzcGVjaWZpZWQgZW50cnkncyBncmFwaCByZXNvdXJjZSkuXG4gICAqIElmIGVtcHR5IHN0cmluZywgYSBuZXcgZW50cnkgd2lsbCBiZSBjcmVhdGVkIHRvIHN0b3JlIHRoZSByZXN1bHRzLlxuICAgKiBJZiB1bmRlZmluZWQsIHRoZSByZXN1bHQgd2lsbCBub3QgZ28gdG8gYSBzaW5nbGUgZGVzdGluYXRpb24sIHNlZSBnZXREZXRlY3REZXN0aW5hdGlvblxuICAgKiBpbnN0ZWFkLiBTb21lIHRyYW5zZm9ybSB0eXBlcyBkb2VzIG5vdCByZXNwZWN0IHRoZSBkZXN0aW5hdGlvbiwgZS5nLiBjdXJyZW50bHkgUk9XU1RPUkVcbiAgICogd2hpY2ggYWx3YXlzIGNyZWF0ZXMgYSBuZXcgZW50cnkgY29udGFpbmluZyB0aGUgcmVzdWx0cy5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ3x1bmRlZmluZWR9IGFuIGVudHJ5IFVSSSB3aGVyZSB0aGUgcmVzdWx0IHNob3VsZCBnbywgZW1wdHkgc3RyaW5nIGZvciBuZXdcbiAgICogZW50cmllcyBmb3IgZXZlcnkgZXhlY3V0aW9uIG9yIHVuZGVmaW5lZCBpZiBubyBkZXN0aW5hdGlvbiBoYXMgYmVlbiBzcGVjaWZpZWQuXG4gICAqL1xuICBnZXREZXN0aW5hdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUobnVsbCwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtRGVzdGluYXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBzZWUgc3RvcmUvUGlwZWxpbmUjZ2V0RGVzdGluYXRpb25cbiAgICogQHBhcmFtIHtTdHJpbmd9IGVudHJ5T3JFbnRyeVVSSSBlbnRyeSBVUkksIGVtcHR5IHN0cmluZyBmb3IgbmV3IGVudHJpZXMgZXZlcnkgdGltZSxcbiAgICogdXNlIHVuZGVmaW5lZCB0byByZW1vdmUgZGVzdGluYXRpb24gc2V0dGluZyBhbHRvZ2V0aGVyLlxuICAgKi9cbiAgc2V0RGVzdGluYXRpb24oZW50cnlPckVudHJ5VVJJKSB7XG4gICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZShudWxsLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1EZXN0aW5hdGlvbik7XG4gICAgY29uc3QgdXJpID0gdHlwZW9mIGVudHJ5T3JFbnRyeVVSSSA9PT0gJ29iamVjdCcgJiYgZW50cnlPckVudHJ5VVJJLmdldFVSSSA/XG4gICAgICBlbnRyeU9yRW50cnlVUkkuZ2V0VVJJKCkgOiBlbnRyeU9yRW50cnlVUkk7XG4gICAgdGhpcy5fZ3JhcGguYWRkKHRoaXMuX3Jlc291cmNlVVJJLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1EZXN0aW5hdGlvbiwgdXJpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXRlY3QgZGVzdGluYXRpb24gbWVhbnMgdGhhdCB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IHRyYW5zZm9ybSAoYSBncmFwaCkgc2hvdWxkIGJlIGF0dGVtcHRlZFxuICAgKiB0byBiZSBzcGxpdCBpbnRvIG11bHRpcGxlIGVudHJpZXMgYWNjb3JkaW5nIHRvIG1hcmtpbmdzIGluIHRoZSBncmFwaC5cbiAgICpcbiAgICogSS5lLiBpdCBkZXRlY3RzIGFuZCBhZGRzIGEgc2V0IG9mIGVudHJpZXMgZnJvbSB0aGUgZ3JhcGggdmlhIHRoZSBhbm9ueW1vdXMgY2xvc3VyZVxuICAgKiBhbGdvcml0aG0gc3RhcnRpbmcgZnJvbSBibGFuayBub2RlcyByZXNvdXJjZXNcbiAgICogd2l0aCBlaXRoZXIgb25lIG9mIHRoZSB0d28gZm9sbG93aW5nIHByb3BlcnRpZXMgdGhhdCBib3RoIGluZGljYXRlIHdoaWNoIGVudHJ5SWQgdG8gdXNlOjx1bD5cbiAgICogPGxpPmh0dHA6Ly9lbnRyeXN0b3JlLm9yZy90ZXJtcy9tZXJnZVJlc291cmNlSWQgb3IgdGhlPC9saT5cbiAgICogPGxpPmh0dHA6Ly9lbnRyeXN0b3JlLm9yZy90ZXJtcy9yZWZlcmVuY2VSZXNvdXJjZUlkPC9saT5cbiAgICogPC91bD5cbiAgICogVGhlIG1lcmdlUmVzb3VyY2VJZCBpbmRpY2F0ZXMgdGhhdCB0aGUgY29ycmVzcG9uZGluZyBlbnRyeSBzaG91bGQgYmUgbWVyZ2VkIG9yIGNyZWF0ZWQgaWYgaXRcbiAgICogZG9lcyBub3QgZXhpc3QuXG4gICAqIFRoZSByZWZlcmVuY2VSZXNvdXJjZUlkIG9ubHkgaW5kaWNhdGVzIHRoYXQgYW5vdGhlciBlbnRyeSAodmlhIGl0cyByZXNvdXJjZSBpZCkgc2hvdWxkIGJlXG4gICAqIHJlZmVyZW5jZWQgZnJvbVxuICAgKiB0aGUgZ3JhcGggKHdoaWNoIG1pZ2h0IGJlIGluc2lkZSBhbiBlbnRyeSBpbmRpY2F0ZWQgYnkgbWVyZ2VSZXNvdXJjZUlkKS5cbiAgICpcbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59IHRydWUgaWYgZGVzdGluYXRpb24gc2hvdWxkIGJlIGRldGVjdGVkLlxuICAgKi9cbiAgZ2V0RGV0ZWN0RGVzdGluYXRpb24oKSB7XG4gICAgY29uc3QgdmFsID0gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUobnVsbCwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtRGV0ZWN0RGVzdGluYXRpb24pO1xuICAgIGlmICh0eXBlb2YgdmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHZhbC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3RydWUnKSA9PT0gMDtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBzZWUgc3RvcmUvUGlwZWxpbmUjZ2V0RGV0ZWN0RGVzdGluYXRpb25cbiAgICogQHBhcmFtIHtib29sZWFufSBkZXRlY3QgaWYgdHJ1ZSBkZXRlY3Rpb24gb2YgZW50cnkgcmVmZXJlbmNlcyBpbiB0aGUgZ3JhcGggaXMgYXR0ZW1wdGVkLlxuICAgKi9cbiAgc2V0RGV0ZWN0RGVzdGluYXRpb24oZGV0ZWN0KSB7XG4gICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZShudWxsLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1EZXRlY3REZXN0aW5hdGlvbik7XG4gICAgaWYgKGRldGVjdCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5fZ3JhcGguYWRkKHRoaXMuX3Jlc291cmNlVVJJLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1EZXRlY3REZXN0aW5hdGlvbiwge1xuICAgICAgICB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiAndHJ1ZScsIGRhdGF0eXBlOiB0ZXJtcy54c2QuYm9vbGVhbixcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119IG9mIHRyYW5zZm9ybSBpZHMsIHR5cGljYWxseSBibGFuayBub2RlIGlkcywgaGVuY2UsIHRoZXkgYXJlIG5vdFxuICAgKiBwcmVzZXJ2ZWQgYmV0d2VlbiBzYXZlcyAvIGxvYWRzIHNvIHRha2UgY2FyZS5cbiAgICovXG4gIGdldFRyYW5zZm9ybXMoKSB7XG4gICAgY29uc3Qgc3RtdHMgPSB0aGlzLl9ncmFwaC5maW5kKG51bGwsIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYXJyID0gc3RtdHMubWFwKHN0bXQgPT4gc3RtdC5nZXRWYWx1ZSgpKTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICBhcnIuc29ydCgodHIxLCB0cjIpID0+IHtcbiAgICAgIGNvbnN0IHByMSA9IHNlbGYuZ2V0UHJpb3JpdHkodHIxKTtcbiAgICAgIGNvbnN0IHByMiA9IHNlbGYuZ2V0UHJpb3JpdHkodHIyKTtcbiAgICAgIHJldHVybiBwcjEgLSBwcjI7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFycjtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kcyBhIHRyYW5zZm9ybSB3aXRoIHRoZSBnaXZlbiB0eXBlIGFuZCByZXR1cm5zIGl0cyBpZC5cbiAgICpcbiAgICogQHBhcmFtIHRyYW5zZm9ybVR5cGUgdGhlIHRyYW5zZm9ybSB0eXBlIHRvIGxvb2sgZm9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSB0cmFuc2Zvcm0gaWQsIHVuZGVmaW5lZCBpZiBubyB0cmFuc2Zvcm0gd2FzIGZvdW5kIGZvciB0aGUgZ2l2ZW4gdHlwZVxuICAgKi9cbiAgZ2V0VHJhbnNmb3JtRm9yVHlwZSh0cmFuc2Zvcm1UeXBlKSB7XG4gICAgbGV0IHRyYW5zZm9ybUlkO1xuICAgIGNvbnN0IHRySWRzID0gdGhpcy5nZXRUcmFuc2Zvcm1zKCk7XG4gICAgdHJJZHMuZm9yRWFjaCgodHJJZCkgPT4ge1xuICAgICAgLy8gZ2V0IHRyYW5zZm9ybSB0eXBlIGFuZCBjaGVjayBmb3IgZmV0Y2ggYW5kIGdldCB1cmxcbiAgICAgIGlmICh0aGlzLmdldFRyYW5zZm9ybVR5cGUodHJJZCkgPT09IHRyYW5zZm9ybVR5cGUpIHtcbiAgICAgICAgdHJhbnNmb3JtSWQgPSB0cklkO1xuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgcmV0dXJuIHRyYW5zZm9ybUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBuZXcgdHJhbnNmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBvbmUgb2YgdGhlIFtnZXRUcmFuc2Zvcm1zXXtAbGluayBzdG9yZS9QaXBlbGluZSNnZXRUcmFuc2Zvcm1zfS5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFyZ3MgYSBoYXNoIG9mIGtleSB2YWx1ZSBwYWlycyBmb3IgdGhpcyB0cmFuc2Zvcm0uXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBuZXdseSB0cmFuc2Zvcm1zIGlkIChmb3IgdGhpcyBzZXNzaW9uLCBtYXkgY2hhbmdlIGFmdGVyIHNhdmUgLyBsb2FkXG4gICAqIHNvIHRha2UgY2FyZSkuXG4gICAqL1xuICBhZGRUcmFuc2Zvcm0odHlwZSwgYXJncykge1xuICAgIGNvbnN0IHRyYW5zZm9ybXMgPSB0aGlzLmdldFRyYW5zZm9ybXMoKTtcbiAgICBjb25zdCBwcmlvcml0eSA9IHRyYW5zZm9ybXMubGVuZ3RoID4gMCA/XG4gICAgICB0aGlzLmdldFByaW9yaXR5KHRyYW5zZm9ybXNbdHJhbnNmb3Jtcy5sZW5ndGggLSAxXSkgOiAwO1xuICAgIGNvbnN0IHN0bXQgPSB0aGlzLl9ncmFwaC5hZGQodGhpcy5fcmVzb3VyY2VVUkksIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgaWQgPSBzdG10LmdldFZhbHVlKCk7XG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1UeXBlKGlkLCB0eXBlKTtcbiAgICB0aGlzLnNldFByaW9yaXR5KGlkLCBwcmlvcml0eSArIDEpO1xuICAgIHRoaXMuc2V0VHJhbnNmb3JtQXJndW1lbnRzKGlkLCBhcmdzKTtcblxuICAgIHJldHVybiBpZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgdHJhbnNmb3JtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtSWQgdGhlIGJsYW5rIG5vZGUgb2YgYSBzcGVjaWZpYyB0cmFuc2Zvcm0gYXMgcmV0cmlldmVkIGJ5XG4gICAqIFtnZXRUcmFuc2Zvcm1zXXtAbGluayBzdG9yZS9QaXBlbGluZSNnZXRUcmFuc2Zvcm1zfS5cbiAgICogQHNlZSBzdG9yZS9QaXBlbGluZSNnZXRUcmFuc2Zvcm1zXG4gICAqL1xuICByZW1vdmVUcmFuc2Zvcm0odHJhbnNmb3JtSWQpIHtcbiAgICB0aGlzLnNldFRyYW5zZm9ybUFyZ3VtZW50cyh0cmFuc2Zvcm1JZCwge30pO1xuICAgIHRoaXMuX2dyYXBoLmZpbmRBbmRSZW1vdmUodHJhbnNmb3JtSWQpO1xuICAgIHRoaXMuX2dyYXBoLmZpbmRBbmRSZW1vdmUobnVsbCwgbnVsbCwgeyB0eXBlOiAnYm5vZGUnLCB2YWx1ZTogdHJhbnNmb3JtSWQgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hhbmdlcyB0aGUgb3JkZXIgb2YgdGhlIHRyYW5zZm9ybXMgYnkgY2hhbmdpbmcgdGhlaXIgcHJpb3JpdHkgcHJvcGVydGllcy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3Jtc1xuICAgKiBbZ2V0VHJhbnNmb3Jtc117QGxpbmsgc3RvcmUvUGlwZWxpbmUjZ2V0VHJhbnNmb3Jtc30uXG4gICAqIEBzZWUgc3RvcmUvUGlwZWxpbmUjZ2V0VHJhbnNmb3Jtc1xuICAgKi9cbiAgc2V0T3JkZXJPZlRyYW5zZm9ybXModHJhbnNmb3Jtcykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZSh0cmFuc2Zvcm1zW2ldLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1Qcmlvcml0eSk7XG4gICAgICB0aGlzLl9ncmFwaC5hZGQodHJhbnNmb3Jtc1tpXSwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtUHJpb3JpdHksIHtcbiAgICAgICAgdHlwZTogJ2xpdGVyYWwnLCB2YWx1ZTogYCR7aX1gLCBkYXRhdHlwZTogdGVybXMueHNkLmludGVnZXIsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybUlkIHRoZSBibGFuayBub2RlIG9mIGEgc3BlY2lmaWMgdHJhbnNmb3JtIGFzIHJldHJpZXZlZCBieVxuICAgKiBbZ2V0VHJhbnNmb3Jtc117QGxpbmsgc3RvcmUvUGlwZWxpbmUjZ2V0VHJhbnNmb3Jtc30uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBwcmlvcml0eSBhcyBhIGZsb2F0LlxuICAgKi9cbiAgZ2V0UHJpb3JpdHkodHJhbnNmb3JtSWQpIHtcbiAgICBsZXQgcHJpbyA9IHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRyYW5zZm9ybUlkLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1Qcmlvcml0eSk7XG4gICAgaWYgKHR5cGVvZiBwcmlvID09PSAnc3RyaW5nJykge1xuICAgICAgcHJpbyA9IHBhcnNlRmxvYXQocHJpbyk7XG4gICAgICBpZiAoIWlzTmFOKHByaW8pKSB7XG4gICAgICAgIHJldHVybiBwcmlvO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJdCBpcyByZWNvbW1lbmRlZCB0byB1c2Ugc2V0T3JkZXJPZlRyYW5zZm9ybXMgaW5zdGVhZC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybUlkIHRoZSBibGFuayBub2RlIG9mIGEgc3BlY2lmaWMgdHJhbnNmb3JtIGFzIHJldHJpZXZlZCBieVxuICAgKiBbZ2V0VHJhbnNmb3Jtc117QGxpbmsgc3RvcmUvUGlwZWxpbmUjZ2V0VHJhbnNmb3Jtc30uXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBwcmlvIHRoZSBwcmlvcml0eSBhcyBhIGZsb2F0LlxuICAgKiBAc2VlIHN0b3JlL1BpcGVsaW5lI3NldE9yZGVyT2ZUcmFuc2Zvcm1zXG4gICAqL1xuICBzZXRQcmlvcml0eSh0cmFuc2Zvcm1JZCwgcHJpbykge1xuICAgIHRoaXMuX2dyYXBoLmZpbmRBbmRSZW1vdmUodHJhbnNmb3JtSWQsIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybVByaW9yaXR5KTtcbiAgICB0aGlzLl9ncmFwaC5hZGQodHJhbnNmb3JtSWQsIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybVByaW9yaXR5LCB7XG4gICAgICB0eXBlOiAnbGl0ZXJhbCcsIHZhbHVlOiBgJHtwcmlvfWAsIGRhdGF0eXBlOiB0ZXJtcy54c2QuaW50ZWdlcixcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtSWQgdGhlIGJsYW5rIG5vZGUgb2YgYSBzcGVjaWZpYyB0cmFuc2Zvcm0gYXMgcmV0cmlldmVkIGJ5XG4gICAqIFtnZXRUcmFuc2Zvcm1zXXtAbGluayBzdG9yZS9QaXBlbGluZSNnZXRUcmFuc2Zvcm1zfS5cbiAgICogQHJldHVybnMge1N0cmluZ30gb25lIG9mIHRoZSB2YWx1ZXMgc3BlY2lmaWVkIGluIHtAbGluayBzdG9yZS9QaXBlbGluZSN0cmFuc2Zvcm1UeXBlc30uXG4gICAqL1xuICBnZXRUcmFuc2Zvcm1UeXBlKHRyYW5zZm9ybUlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dyYXBoLmZpbmRGaXJzdFZhbHVlKHRyYW5zZm9ybUlkLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1UeXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtSWQgdGhlIGJsYW5rIG5vZGUgb2YgYSBzcGVjaWZpYyB0cmFuc2Zvcm0gYXMgcmV0cmlldmVkIGJ5XG4gICAqIFtnZXRUcmFuc2Zvcm1zXXtAbGluayBzdG9yZS9QaXBlbGluZSNnZXRUcmFuc2Zvcm1zfS5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybVR5cGUgb25lIG9mIHRoZSBvcHRpb25zIGluIHtAbGluayBzdG9yZS9QaXBlbGluZSN0cmFuc2Zvcm1UeXBlc30uXG4gICAqL1xuICBzZXRUcmFuc2Zvcm1UeXBlKHRyYW5zZm9ybUlkLCB0cmFuc2Zvcm1UeXBlKSB7XG4gICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZSh0cmFuc2Zvcm1JZCwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtVHlwZSk7XG4gICAgdGhpcy5fZ3JhcGguYWRkTCh0cmFuc2Zvcm1JZCwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtVHlwZSwgdHJhbnNmb3JtVHlwZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zZm9ybUlkIHRoZSBibGFuayBub2RlIG9mIGEgc3BlY2lmaWMgdHJhbnNmb3JtIGFzIHJldHJpZXZlZFxuICAgKiBieSBbZ2V0VHJhbnNmb3Jtc117QGxpbmsgc3RvcmUvUGlwZWxpbmUjZ2V0VHJhbnNmb3Jtc30uICBJZiBubyBpZCBpcyBwcm92aWRlZFxuICAgKiBhcmd1bWVudHMgZnJvbSBhbGwgdHJhbnNmb3JtcyB3aWxsIGJlIHJldHVybmVkIGluIGEgc2luZ2xlIG1lcmdlZCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtPYmplY3R8dW5kZWZpbmVkfSB0aGUgYXJndW1lbnRzIGZvciBhIHRyYW5zZm9ybSAob3IgYWxsIHRyYW5zZm9ybXMpIGFzIGFuIG9iamVjdFxuICAgKiBoYXNoIHdpdGggcHJvcGVydHkgdmFsdWUgcGFpcnMuXG4gICAqL1xuICBnZXRUcmFuc2Zvcm1Bcmd1bWVudHModHJhbnNmb3JtSWQpIHtcbiAgICBsZXQgYXJncztcbiAgICBjb25zdCBzdG10cyA9IHRoaXMuX2dyYXBoLmZpbmQodHJhbnNmb3JtSWQsIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybUFyZ3VtZW50KTtcbiAgICBzdG10cy5mb3JFYWNoKChzdG10KSA9PiB7XG4gICAgICBjb25zdCBrZXkgPSB0aGlzLl9ncmFwaC5maW5kRmlyc3RWYWx1ZShzdG10LmdldFZhbHVlKCksXG4gICAgICAgIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybUFyZ3VtZW50S2V5KTtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ3JhcGguZmluZEZpcnN0VmFsdWUoc3RtdC5nZXRWYWx1ZSgpLFxuICAgICAgICB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1Bcmd1bWVudFZhbHVlKTtcbiAgICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuICAgICAgYXJnc1trZXldID0gdmFsdWU7XG4gICAgfSwgdGhpcyk7XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNmb3JtSWQgdGhlIGJsYW5rIG5vZGUgb2YgYSBzcGVjaWZpYyB0cmFuc2Zvcm0gYXMgcmV0cmlldmVkXG4gICAqIGJ5IFtnZXRUcmFuc2Zvcm1zXXtAbGluayBzdG9yZS9QaXBlbGluZSNnZXRUcmFuc2Zvcm1zfS5cbiAgICogQHJldHVybnMge0FycmF5fSBvZiBhcmd1bWVudHMnIGtleXNcbiAgICovXG4gIGdldFRyYW5zZm9ybUFyZ3VtZW50c0tleXModHJhbnNmb3JtSWQgPSBudWxsKSB7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIGlmICh0cmFuc2Zvcm1JZCkge1xuICAgICAgY29uc3Qgc3RtdHMgPSB0aGlzLl9ncmFwaC5maW5kKHRyYW5zZm9ybUlkLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1Bcmd1bWVudCk7XG4gICAgICBzdG10cy5mb3JFYWNoKChzdG10KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleXMgPSB0aGlzLl9ncmFwaC5maW5kKHN0bXQuZ2V0VmFsdWUoKSwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtQXJndW1lbnRLZXkpO1xuICAgICAgICBhcmdzLnB1c2goa2V5cy5tYXAoa2V5ID0+IGtleS5nZXRWYWx1ZSgpKSk7XG4gICAgICB9LCB0aGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgYXJndW1lbnRzIHdpdGggdGhvc2UgcHJvdmlkZWQuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0cmFuc2Zvcm1JZCB0aGUgYmxhbmsgbm9kZSBvZiBhIHNwZWNpZmljIHRyYW5zZm9ybSBhcyByZXRyaWV2ZWQgYnlcbiAgICogW2dldFRyYW5zZm9ybXNde0BsaW5rIHN0b3JlL1BpcGVsaW5lI2dldFRyYW5zZm9ybXN9LlxuICAgKiBAcGFyYW0ge09iamVjdH0gYXJncyB0aGUgYXJndW1lbnRzIGZvciB0aGUgdHJhbnNmb3JtIGFzIGFuIG9iamVjdCBoYXNoIHdpdGggcHJvcGVydHkgdmFsdWUgcGFpcnMuXG4gICAqL1xuICBzZXRUcmFuc2Zvcm1Bcmd1bWVudHModHJhbnNmb3JtSWQsIGFyZ3MpIHtcbiAgICBjb25zdCBzdG10cyA9IHRoaXMuX2dyYXBoLmZpbmQodHJhbnNmb3JtSWQsIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybUFyZ3VtZW50KTtcbiAgICBzdG10cy5mb3JFYWNoKChzdG10KSA9PiB7XG4gICAgICB0aGlzLl9ncmFwaC5maW5kQW5kUmVtb3ZlKHN0bXQuZ2V0VmFsdWUoKSwgdGVybXMucGlwZWxpbmUudHJhbnNmb3JtQXJndW1lbnRLZXkpO1xuICAgICAgdGhpcy5fZ3JhcGguZmluZEFuZFJlbW92ZShzdG10LmdldFZhbHVlKCksIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybUFyZ3VtZW50VmFsdWUpO1xuICAgICAgdGhpcy5fZ3JhcGgucmVtb3ZlKHN0bXQpO1xuICAgIH0sIHRoaXMpO1xuICAgIE9iamVjdC5rZXlzKGFyZ3MpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgY29uc3QgbmV3QXJnID0gdGhpcy5fZ3JhcGguYWRkKHRyYW5zZm9ybUlkLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1Bcmd1bWVudCk7XG4gICAgICB0aGlzLl9ncmFwaC5hZGRMKG5ld0FyZy5nZXRWYWx1ZSgpLCB0ZXJtcy5waXBlbGluZS50cmFuc2Zvcm1Bcmd1bWVudEtleSwga2V5KTtcbiAgICAgIHRoaXMuX2dyYXBoLmFkZEwobmV3QXJnLmdldFZhbHVlKCksIHRlcm1zLnBpcGVsaW5lLnRyYW5zZm9ybUFyZ3VtZW50VmFsdWUsIGFyZ3Nba2V5XSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgdHJhbnNmb3JtIGFyZ3VtZW50IHZhbHVlIGZvciBhIHNwZWNpZmljIHRyYW5zZm9ybSB0eXBlIGFuZCBwcm9wZXJ0eSAoa2V5KS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybVR5cGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByb3BlcnR5XG4gICAqIEByZXR1cm5zIHsqfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldFRyYW5zZm9ybVByb3BlcnR5KHRyYW5zZm9ybVR5cGUsIHByb3BlcnR5KSB7XG4gICAgY29uc3QgdGlkID0gdGhpcy5nZXRUcmFuc2Zvcm1Gb3JUeXBlKHRyYW5zZm9ybVR5cGUpO1xuICAgIGlmICh0aWQpIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuZ2V0VHJhbnNmb3JtQXJndW1lbnRzKHRpZCk7XG4gICAgICBpZiAob2JqICYmIHByb3BlcnR5IGluIG9iaikge1xuICAgICAgICByZXR1cm4gb2JqW3Byb3BlcnR5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIG9yIHVwZGF0ZXMgYW4gaW5kaXZpZHVhbCBwcm9wZXJ0eSAoa2V5LXZhbHVlIHBhaXIgaW4gYXJndW1lbnRzKSBvZiBhIHRyYW5zZm9ybS5cbiAgICogVGhlIHRyYW5zZm9ybSBpcyBpZGVudGlmaWVkIGVpdGhlciBleHBsaWNpdGx5IGJ5IGFuIGlkIG9yIHZpYSBhIHRyYW5zZm9ybVR5cGUgKGFzc3VtZWRcbiAgICogdW5pcXVlKS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRyYW5zZm9ybUlkT3JUeXBlIGNvcnJlc3BvbmRzIHRvIHRoZSB0cmFuc2Zvcm0gdG8gY2hhbmdlIHRoZSBwcm9wZXJ0eSBmb3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAgICovXG4gIHNldFRyYW5zZm9ybVByb3BlcnR5KHRyYW5zZm9ybUlkT3JUeXBlLCBrZXksIHZhbHVlKSB7XG4gICAgbGV0IG9iaiA9IHRoaXMuZ2V0VHJhbnNmb3JtQXJndW1lbnRzKHRyYW5zZm9ybUlkT3JUeXBlKTtcbiAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICB0aGlzLnNldFRyYW5zZm9ybUFyZ3VtZW50cyh0cmFuc2Zvcm1JZE9yVHlwZSwgb2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGlkID0gdGhpcy5nZXRUcmFuc2Zvcm1Gb3JUeXBlKHRyYW5zZm9ybUlkT3JUeXBlKTtcbiAgICAgIG9iaiA9IHRoaXMuZ2V0VHJhbnNmb3JtQXJndW1lbnRzKHRpZCk7XG4gICAgICBpZiAob2JqICE9IG51bGwpIHtcbiAgICAgICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRUcmFuc2Zvcm1Bcmd1bWVudHModGlkLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgcGlwZWxpbmUgd2l0aCB0aGUgZ2l2ZW4gc291cmNlIGVudHJ5IGFzIGlucHV0LCBpZiBub3QgcHJvdmlkZWQgdGhlIHBpcGVsaW5lXG4gICAqIHdpbGwgYmUgdXNlZCBhcyBzb3VyY2VlbnRyeS5cbiAgICpcbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeX0gc291cmNlRW50cnkgYW4gb3B0aW9uYWwgZW50cnkgY29udGFpbmluZyBzb21lIGRhdGEgdGhhdCBpcyB0byBiZVxuICAgKiB0cmFuc2Zvcm1lZCwgZS5nLiBjYW4gYmUgYSBDU1YgZmlsZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgdXNlZCBpbiB0aGUgZXhlY3V0aW9uIG9mIHRoZSBwaXBlbGluZSwgZS5nLlxuICAgKiBhY3Rpb24gKHdpdGggdmFsdWUgY3JlYXRlLCByZXBsYWNlIG9yIGFwcGVuZCkgYW5kIGRhdGFzZXRVUkwgcG9pbnRpbmcgdG8gdGhlIGV4aXN0aW5nXG4gICAqIGRhdGFzZXQgaW4gcm93c3RvcmUuXG4gICAqIEByZXR1cm5zIHtlbnRyeVVSSUFycmF5UHJvbWlzZX0gYW4gYXJyYXkgb2YgZW50cnkgVVJJcyB0aGF0IHdoZXJlIGNyZWF0ZWQvbW9kaWZpZWQgYnlcbiAgICogdGhpcyBleGVjdXRpb24uXG4gICAqL1xuICBleGVjdXRlKHNvdXJjZUVudHJ5LCBwYXJhbXMpIHtcbiAgICBsZXQgZXhlY3V0ZVVSSTtcbiAgICBjb25zdCBlcyA9IHRoaXMuZ2V0RW50cnlTdG9yZSgpO1xuICAgIGNvbnN0IF9wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgX3BhcmFtcy5waXBlbGluZSA9IHRoaXMuZ2V0RW50cnlVUkkoKTtcbiAgICBpZiAoc291cmNlRW50cnkgPT0gbnVsbCkge1xuICAgICAgZXhlY3V0ZVVSSSA9IGAke2VzLmdldEJhc2VVUkkoKSArIGVzLmdldENvbnRleHRJZCh0aGlzLmdldEVudHJ5VVJJKCkpfS9leGVjdXRlYDtcbiAgICB9IGVsc2Uge1xuICAgICAgX3BhcmFtcy5zb3VyY2UgPSBzb3VyY2VFbnRyeS5nZXRVUkkoKTtcbiAgICAgIGV4ZWN1dGVVUkkgPSBgJHtzb3VyY2VFbnRyeS5nZXRDb250ZXh0KCkuZ2V0UmVzb3VyY2VVUkkoKX0vZXhlY3V0ZWA7XG4gICAgfVxuICAgIHJldHVybiBlcy5oYW5kbGVBc3luYyhlcy5nZXRSRVNUKCkucG9zdChleGVjdXRlVVJJLCBKU09OLnN0cmluZ2lmeShfcGFyYW1zKSksICdleGVjdXRlJylcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJvZHkucmVzdWx0LCBlcnIgPT4ge1xuICAgICAgICB0aHJvdyBlcnJcbiAgICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEF2YWlsYWJsZSB0cmFuc2Zvcm1zICh0eXBlcykuXG4gKlxuICogQHR5cGUge3tUQUJVTEFSOiBzdHJpbmcsIFJPV1NUT1JFOiBzdHJpbmd9fVxuICovXG5QaXBlbGluZS5wcm90b3R5cGUudHJhbnNmb3JtVHlwZXMgPSB7XG4gIFRBQlVMQVI6ICd0YWJ1bGFyJyxcbiAgUk9XU1RPUkU6ICdyb3dzdG9yZScsXG4gIEVNUFRZOiAnZW1wdHknLFxuICBGRVRDSDogJ2ZldGNoJyxcbiAgVkFMSURBVEU6ICd2YWxpZGF0ZScsXG4gIE1FUkdFOiAnbWVyZ2UnLFxufTtcblxuIiwiaW1wb3J0IEVudHJ5IGZyb20gJy4vRW50cnknO1xuaW1wb3J0IEVudHJ5SW5mbyBmcm9tICcuL0VudHJ5SW5mbyc7XG5pbXBvcnQgdGVybXMgZnJvbSAnLi90ZXJtcyc7XG5cbi8qKlxuICogQSBQcm90b3R5cGVFbnRyeSBpcyB1c2VkIHRvIGNyZWF0ZSBuZXcgZW50cmllcyBieSBjb2xsZWN0aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBpbml0aWFsXG4gKiBzdGF0ZSBvZiB0aGUgZW50cnkgdG8gc2VuZCBhbG9uZyB0byB0aGUgcmVwb3NpdG9yeSB1cG9uIGNyZWF0aW9uLlxuICpcbiAqIEFsbCBhY2Nlc3MgYW5kIHV0aWxpdHkgbWV0aG9kcyBmcm9tIEVudHJ5IGlzIGp1c3QgaW5oZXJpdGVkLiBTb21lIG1ldGhvZHMgaGF2ZSBiZWVuIG1vdmVkIG92ZXJcbiAqIGZyb20gRW50cnlJbmZvcm1hdGlvbiB0byBhbGxvdyBlYXNpZXIgbWV0aG9kIGNoYWluaW5nLiBGaW5hbGx5IHNvbWUgaW5mb3JtYXRpb24gY2Fubm90IGJlXG4gKiBjaGFuZ2VkIGluIGFuIGVudHJ5LCBlLmcuIHRoZSBlbnRyeSwgZ3JhcGggYW5kIHJlc291cmNlIHR5cGVzLCBidXQgYXJlIGNydWNpYWwgYmVmb3JlIGNyZWF0aW9uLlxuICogSGVuY2UsIHNvbWUgbWV0aG9kcyBoYXZlIGJlZW4gaW50cm9kdWNlZCB0byBjb3ZlciBmb3IgdGhpcyBuZWVkLlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL1Byb3RvdHlwZUVudHJ5XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFByb3RvdHlwZUVudHJ5IGV4dGVuZHMgRW50cnkge1xuICAvKipcbiAgICogQHBhcmFtIHtzdG9yZS9Db250ZXh0fSBjb250ZXh0IHdoZXJlIHRoaXMgcHJvdG90eXBlRW50cnkgYmVsb25ncy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIC0gZW50cnkgaWRlbnRpZmllciwgaWYgbm90IHVuaXF1ZSBpbiB0aGUgY29udGV4dCB0aGUgc3Vic2VxdWVudCBjb21taXRcbiAgICogd2lsbCBmYWlsLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29udGV4dCwgaWQpIHtcbiAgICBjb25zdCBfaWQgPSBpZCB8fCAnX25ld0lkJztcbiAgICBjb25zdCBjcnUgPSBjb250ZXh0LmdldFJlc291cmNlVVJJKCk7XG4gICAgY29uc3QgZW50cnlJbmZvID0gbmV3IEVudHJ5SW5mbyhgJHtjcnV9L2VudHJ5LyR7X2lkfWAsIG51bGwsIGNvbnRleHQuZ2V0RW50cnlTdG9yZSgpKTtcbiAgICBpZiAoY29udGV4dC5nZXRJZCgpID09PSAnX2NvbnRleHRzJykge1xuICAgICAgZW50cnlJbmZvLl9yZXNvdXJjZVVSSSA9IGNvbnRleHQuZ2V0RW50cnlTdG9yZSgpLmdldEJhc2VVUkkoKSArIF9pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgZW50cnlJbmZvLl9yZXNvdXJjZVVSSSA9IGAke2NydX0vcmVzb3VyY2UvJHtfaWR9YDtcbiAgICB9XG4gICAgY29uc3Qgb2xkU2V0UmVzb3VyY2VVUkkgPSBlbnRyeUluZm8uc2V0UmVzb3VyY2VVUkk7XG4gICAgZW50cnlJbmZvLnNldFJlc291cmNlVVJJID0gZnVuY3Rpb24gKHVyaSkge1xuICAgICAgdGhpcy5fcmVzb3VyY2VVUkkgPSB1cmk7XG4gICAgICBvbGRTZXRSZXNvdXJjZVVSSS5jYWxsKHRoaXMsIHVyaSk7XG4gICAgfTtcbiAgICBlbnRyeUluZm8uZ2V0UmVzb3VyY2VVUkkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVzb3VyY2VVUkk7XG4gICAgfTtcblxuICAgIHN1cGVyKGNvbnRleHQsIGVudHJ5SW5mbyk7IC8vIENhbGwgdGhlIHN1cGVyIGNvbnN0cnVjdG9yLlxuICAgIGlmIChpZCAhPSBudWxsKSB7XG4gICAgICB0aGlzLnNwZWNpZmljSWQgPSBfaWQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERpcmVjdCBhY2Nlc3MgbWV0aG9kIGZvciB0aGUgcmVzb3VyY2UgaW5zdGFuY2UgZm9yIHByb3JvdHlwZUVudHJpZXMuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9SZXNvdXJjZX1cbiAgICovXG4gIGdldFJlc291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvdXJjZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2VzIHRoZSB7QGxpbmsgc3RvcmUvRW50cnlJbmZvI3NldEFDTCBzZXRBQ0x9IG1ldGhvZCBmcm9tIHtAbGluayBzdG9yZS9FbnRyeUluZm99XG4gICAqIG9uIFByb3RvdHlwZUVudHJ5XG4gICAqIGFuZCBtYWtlcyBpdCBjaGFpbmFibGUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX0gLSB0byBhbGxvdyB0aGUgbWV0aG9kIGNhbGwgdG8gYmUgY2hhaW5lZC5cbiAgICovXG4gIHNldEFDTCgpIHtcbiAgICBFbnRyeUluZm8ucHJvdG90eXBlLnNldEFDTC5hcHBseSh0aGlzLl9lbnRyeUluZm8sIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRXhwb3NlcyB0aGUge0BsaW5rIHN0b3JlL0VudHJ5SW5mbyNzZXRSZXNvdXJjZVVSSSBzZXRSZXNvdXJjZVVSSX0gbWV0aG9kIGZyb21cbiAgICoge0BsaW5rIHN0b3JlL0VudHJ5SW5mb30gb24gdGhpcyBjbGFzc1xuICAgKiBhbmQgbWFrZXMgaXQgY2hhaW5hYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9IC0gdG8gYWxsb3cgdGhlIG1ldGhvZCBjYWxsIHRvIGJlIGNoYWluZWQuXG4gICAqL1xuICBzZXRSZXNvdXJjZVVSSSgpIHtcbiAgICB0aGlzLl9lbnRyeUluZm8uc2V0UmVzb3VyY2VVUkkoLi4uYXJndW1lbnRzKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHBvc2VzIHRoZSB7QGxpbmsgc3RvcmUvRW50cnlJbmZvI3NldEV4dGVybmFsTWV0YWRhdGFVUkkgc2V0RXh0ZXJuYWxNZXRhZGF0YVVSSX0gbWV0aG9kXG4gICAqIGZyb20ge0BsaW5rIHN0b3JlL0VudHJ5SW5mb30gb24gdGhpcyBjbGFzc1xuICAgKiBhbmQgbWFrZXMgaXQgY2hhaW5hYmxlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9IC0gdG8gYWxsb3cgdGhlIG1ldGhvZCBjYWxsIHRvIGJlIGNoYWluZWQuXG4gICAqL1xuICBzZXRFeHRlcm5hbE1ldGFkYXRhVVJJKCkge1xuICAgIEVudHJ5SW5mby5wcm90b3R5cGUuc2V0RXh0ZXJuYWxNZXRhZGF0YVVSSS5hcHBseSh0aGlzLl9lbnRyeUluZm8sIGFyZ3VtZW50cyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgaXQgcG9zc2libGUgdG8gY2hhbmdlIHRoZSBFbnRyeVR5cGUgKHdoaWNoIGlzIG5vdCBhbGxvd2VkIG9uIGV4aXN0aW5nIGVudHJpZXMpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9IC0gdG8gYWxsb3cgdGhlIG1ldGhvZCBjYWxsIHRvIGJlIGNoYWluZWQuXG4gICAqL1xuICBzZXRFbnRyeVR5cGUoZXQpIHtcbiAgICBjb25zdCB1cmkgPSB0ZXJtcy5pbnZFbnRyeVR5cGVbZXRdO1xuICAgIGlmICh1cmkpIHtcbiAgICAgIHRoaXMuX2VudHJ5SW5mby5nZXRHcmFwaCgpLmNyZWF0ZSh0aGlzLl9lbnRyeUluZm8uZ2V0RW50cnlVUkkoKSwgdGVybXMucmRmLnR5cGUsIHtcbiAgICAgICAgdHlwZTogJ3VyaScsXG4gICAgICAgIHZhbHVlOiB1cmksXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWFrZXMgaXQgcG9zc2libGUgdG8gY2hhbmdlIHRoZSBHcmFwaFR5cGUgKHdoaWNoIGlzIG5vdCBhbGxvd2VkIG9uIGV4aXN0aW5nIGVudHJpZXMpLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RvcmUvUHJvdG90eXBlRW50cnl9IC0gdG8gYWxsb3cgdGhlIG1ldGhvZCBjYWxsIHRvIGJlIGNoYWluZWQuXG4gICAqL1xuICBzZXRHcmFwaFR5cGUoZ3QpIHtcbiAgICB0aGlzLl9ndCA9IGd0O1xuICAgIGNvbnN0IHVyaSA9IHRlcm1zLmludkdyYXBoVHlwZVtndF07XG4gICAgaWYgKHVyaSkge1xuICAgICAgdGhpcy5fZW50cnlJbmZvLmdldEdyYXBoKCkuY3JlYXRlKHRoaXMuX2VudHJ5SW5mby5nZXRSZXNvdXJjZVVSSSgpLCB0ZXJtcy5yZGYudHlwZSwge1xuICAgICAgICB0eXBlOiAndXJpJyxcbiAgICAgICAgdmFsdWU6IHVyaSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlcyBpdCBwb3NzaWJsZSB0byBjaGFuZ2UgdGhlIFJlc291cmNlVHlwZSAod2hpY2ggaXMgbm90IGFsbG93ZWQgb24gZXhpc3RpbmcgZW50cmllcykuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9Qcm90b3R5cGVFbnRyeX0gLSB0byBhbGxvdyB0aGUgbWV0aG9kIGNhbGwgdG8gYmUgY2hhaW5lZC5cbiAgICovXG4gIHNldFJlc291cmNlVHlwZShydCkge1xuICAgIGNvbnN0IHVyaSA9IHRlcm1zLmludlJlc291cmNlVHlwZVtydF07XG4gICAgaWYgKHVyaSkge1xuICAgICAgdGhpcy5fZW50cnlJbmZvLmdldEdyYXBoKCkuY3JlYXRlKHRoaXMuX2VudHJ5SW5mby5nZXRSZXNvdXJjZVVSSSgpLCB0ZXJtcy5yZGYudHlwZSwge1xuICAgICAgICB0eXBlOiAndXJpJyxcbiAgICAgICAgdmFsdWU6IHVyaSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGVuIGNyZWF0aW5nIG5ldyBlbnRyaWVzIGEgc2luZ2xlIHBhcmVudCBsaXN0IGNhbiBiZSBzcGVjaWZpZWQsIGhlbmNlIHdlIG5lZWQgYSB3YXkgdG8gc2V0XG4gICAqIGl0IGluIFByb3RvdHlwZUVudHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5fSBwYXJlbnRMaXN0RW50cnlcbiAgICogQHJldHVybnMge3N0b3JlL1Byb3RvdHlwZUVudHJ5fSAtIHRvIGFsbG93IHRoZSBtZXRob2QgY2FsbCB0byBiZSBjaGFpbmVkLlxuICAgKi9cbiAgc2V0UGFyZW50TGlzdChwYXJlbnRMaXN0RW50cnkpIHtcbiAgICB0aGlzLnBhcmVudExpc3RFbnRyeSA9IHBhcmVudExpc3RFbnRyeTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHBhcmVudCBsaXN0IChhcyBhbiBlbnRyeSkgZm9yIHRoaXMgUHJvdG90eXBlRW50cnkuXG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeX1cbiAgICovXG4gIGdldFBhcmVudExpc3QoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50TGlzdEVudHJ5O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc3VnZ2VzdGVkIGVudHJ5IGlkIGZvciB0aGlzIFByb3RvdHlwZUVudHJ5XG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRTcGVjaWZpY0lkKCkge1xuICAgIHJldHVybiB0aGlzLnNwZWNpZmljSWQ7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3dlZCBhcyBhIHdheSB0byBzYXZlIG1ldGFkYXRhIGZvciBhblxuICAgKiBlbnRyeSB0aGF0IGlzIGFzc3VtZWQgdG8gZXhpc3Qgd2l0aCBhIGdpdmVuIGVudHJ5IGlkLlxuICAgKiBAb3ZlcnJpZGVcbiAgICovXG4gIGNvbW1pdE1ldGFkYXRhKCkge1xuICAgIGlmICghdGhpcy5zcGVjaWZpY0lkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBlbnRyeUlkIG11c3QgaGF2ZSBiZWVuIHNwZWNpZmllZCBmb3IgYWxsb3dpbmcgbWV0YWRhdGEgdG8gYmUgc2F2ZWQuJyk7XG4gICAgfVxuICAgIGNvbnN0IGVzID0gdGhpcy5nZXRFbnRyeVN0b3JlKCk7XG5cbiAgICByZXR1cm4gZXMuaGFuZGxlQXN5bmMoZXMuZ2V0UkVTVCgpLnB1dCh0aGlzLmdldEVudHJ5SW5mbygpLmdldE1ldGFkYXRhVVJJKCksXG4gICAgICBKU09OLnN0cmluZ2lmeSh0aGlzLmdldE1ldGFkYXRhKCkuZXhwb3J0UkRGSlNPTigpKSksICdjb21taXRNZXRhZGF0YScpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFsbG93ZWQgYXMgYSB3YXkgdG8gc2F2ZSBjYWNoZWQgZXh0ZXJuYWwgbWV0YWRhdGEgZm9yIGFuIGVudHJ5IHRoYXQgaXMgYXNzdW1lZCB0b1xuICAgKiBleGlzdCB3aXRoIGEgZ2l2ZW4gZW50cnkgaWQuXG4gICAqIEBvdmVycmlkZVxuICAgKi9cbiAgY29tbWl0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSgpIHtcbiAgICBpZiAoIXRoaXMuc3BlY2lmaWNJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgZW50cnlJZCBtdXN0IGhhdmUgYmVlbiBzcGVjaWZpZWQgZm9yIGFsbG93aW5nIGNhY2hlZCBleHRlcm5hbCBtZXRhZGF0YSB0byBiZSBzYXZlZC4nKTtcbiAgICB9XG4gICAgY29uc3QgZXMgPSB0aGlzLmdldEVudHJ5U3RvcmUoKTtcbiAgICByZXR1cm4gZXMuaGFuZGxlQXN5bmMoZXMuZ2V0UkVTVCgpLnB1dCh0aGlzLmdldEVudHJ5SW5mbygpLmdldENhY2hlZEV4dGVybmFsTWV0YWRhdGFVUkkoKSxcbiAgICAgIEpTT04uc3RyaW5naWZ5KHRoaXMuX2NhY2hlZEV4dGVybmFsTWV0YWRhdGEuZXhwb3J0UkRGSlNPTigpKSksICdjb21taXRDYWNoZWRFeHRlcm5hbE1ldGFkYXRhJyk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIHtAbGluayBzdG9yZS9Qcm90b3R5cGVFbnRyeSNjb21taXQgY29tbWl0fSBpbnN0ZWFkLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48c3RvcmUvRW50cnk+fVxuICAgKi9cbiAgY3JlYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jb250ZXh0LmdldEVudHJ5U3RvcmUoKS5jcmVhdGVFbnRyeSh0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgZW50cnkgYWNjb3JkaW5nIHRvIHRoZSBpbmZvcm1hdGlvbiBzcGVjaWZpZWQgaW4gdGhlIHByb3RvdHlwZSBlbnRyeS5cbiAgICpcbiAgICogQHJldHVybnMge1Byb21pc2UuPHN0b3JlL0VudHJ5Pn1cbiAgICogQHNlZSBzdG9yZS9FbnRyeVN0b3JlI2NyZWF0ZUVudHJ5XG4gICAqL1xuICBjb21taXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZ2V0RW50cnlTdG9yZSgpLmNyZWF0ZUVudHJ5KHRoaXMpO1xuICB9XG59O1xuIiwiaW1wb3J0IGZhY3RvcnkgZnJvbSAnLi9mYWN0b3J5Jztcbi8qKlxuICogVGhpcyBpcyB0aGUgYmFzZSBjbGFzcyBmb3IgcmVzb3VyY2VzIGNvbnRhaW5lZCBieSBlbnRyaWVzLCBkbyBub3QgdXNlIGRpcmVjdGx5LFxuICogaW5zdGVhZCB1c2UgYSBzdWJjbGFzcy5cbiAqXG4gKiBAZXhwb3J0cyBzdG9yZS9SZXNvdXJjZVxuICogQHNlZSBzdWJjbGFzcyB7QGxpbmsgc3RvcmUvQ29udGV4dH1cbiAqIEBzZWUgc3ViY2xhc3Mge0BsaW5rIHN0b3JlL0xpc3R9XG4gKiBAc2VlIHN1YmNsYXNzIHtAbGluayBzdG9yZS9HcmFwaH1cbiAqIEBzZWUgc3ViY2xhc3Mge0BsaW5rIHN0b3JlL1N0cmluZ31cbiAqIEBzZWUgc3ViY2xhc3Mge0BsaW5rIHN0b3JlL0ZpbGV9XG4gKiBAc2VlIHN1YmNsYXNzIHtAbGluayBzdG9yZS9Vc2VyfVxuICogQHNlZSBzdWJjbGFzcyB7QGxpbmsgc3RvcmUvR3JvdXB9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeVVSSSAtIFVSSSB0byBhbiBlbnRyeSB3aGVyZSB0aGlzIHJlc291cmNlIGlzIGNvbnRhaW5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlVVJJIC0gVVJJIHRvIHRoZSByZXNvdXJjZS5cbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeVN0b3JlfSBlbnRyeVN0b3JlIC0gdGhlIEFQSSdzIHJlcG9zaXRvcnkgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnRyeVVSSSwgcmVzb3VyY2VVUkksIGVudHJ5U3RvcmUpIHtcbiAgICB0aGlzLl9lbnRyeVVSSSA9IGVudHJ5VVJJO1xuICAgIHRoaXMuX3Jlc291cmNlVVJJID0gcmVzb3VyY2VVUkk7XG4gICAgdGhpcy5fZW50cnlTdG9yZSA9IGVudHJ5U3RvcmU7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBBUEkncyByZXBvc2l0b3J5IGluc3RhbmNlXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdG9yZS9FbnRyeVN0b3JlfVxuICAgKi9cbiAgZ2V0RW50cnlTdG9yZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIGVudHJ5IHRoYXQgY29udGFpbnMgdGhpcyByZXNvdXJjZS4gQXNraW5nIGZvciB0aGUgZW50cnkgZGlyZWN0bHlcbiAgICogKGRpcmVjdD10cnVlLCByYXRoZXIgdGhhbiBnZXR0aW5nXG4gICAqIGl0IGFzeW5jaHJvbm91c2x5IHZpYSBhIHByb21pc2UpIHNob3VsZCB3b3JrIGZvciBhbGwgcmVzb3VyY2VzIGV4Y2VwdCBjb250ZXh0IHJlc291cmNlcy5cbiAgICpcbiAgICogPiBfKipBZHZhbmNlZCBleHBsYW5hdGlvbjoqKlxuICAgKiA+IENvbnRleHQgcmVzb3VyY2VzIGFyZSBvZnRlbiBjcmVhdGVkIG9wcG9ydHVuaXN0aWNhbGx5IGJ5IHRoZSBBUEkgd2l0aG91dCBhbHNvXG4gICAqID4gbG9hZGluZyB0aGUgY29udGV4dCBlbnRyeSBhbG9uZyB3aXRoIGl0LCBlLmcuIHdoZW4gbG9hZGluZyBlbnRyaWVzIGR1cmluZyBhIHNlYXJjaFxuICAgKiA+IG9wZXJhdGlvbi4gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbnRleHQgZW50cmllcyBhcmUgbm90IGxvYWRlZCBhbG9uZyB3aXRoIHRoZSBjb250ZXh0XG4gICAqID4gcmVzb3VyY2UgaXMgdGhhdCBzdWNoIGFuIGFwcHJvYWNoLCBkZXBlbmRpbmcgb24gdGhlIHVzZS1jYXNlLCBtYXkgbGVhZCB0byBkcmFtYXRpY1xuICAgKiA+IGluY3JlYXNlcyBpbiB0aGUgYW1vdW50IG9mIHJlcXVlc3RzIHRvIHRoZSByZXBvc2l0b3J5Ll9cbiAgICpcbiAgICogQHJldHVybiB7UHJvbWlzZS48c3RvcmUvRW50cnk+fHN0b3JlL0VudHJ5fSBpZiBkaXJlY3Q9dHJ1ZSBhbiBFbnRyeSBpcyByZXR1cm5lZCAob3IgdW5kZWZpbmVkIGlmIG5vdFxuICAgKiBpbiBjYWNoZSwgb25seSBoYXBwZW5zIHNvbWV0aW1lcyBmb3IgQ29udGV4dHMpIG90aGVyd2lzZSBhIHByb21pc2UgaXMgcmV0dXJuZWQgdGhhdCBvblxuICAgKiBzdWNjZXNzIHByb3ZpZGVzIHRoZSBlbnRyeSBmb3IgdGhpcyByZXNvdXJjZS5cbiAgICovXG4gIGdldEVudHJ5KGRpcmVjdCA9IGZhbHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5U3RvcmUuZ2V0RW50cnkodGhpcy5fZW50cnlVUkksIHsgZGlyZWN0IH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZXMgb3duIFVSSS5cbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldFJlc291cmNlVVJJKCkge1xuICAgIHJldHVybiB0aGlzLl9yZXNvdXJjZVVSSTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgVVJJIHRvIHRoZSBlbnRyeSBjb250YWluaW5nIHRoaXMgcmVzb3VyY2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRFbnRyeVVSSSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlVUkk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGlkIGZvciB0aGUgZW50cnkgY29udGFpbmluZyB0aGlzIHJlc291cmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGZhY3RvcnkuZ2V0RW50cnlJZCh0aGlzLl9lbnRyeVVSSSk7XG4gIH1cblxuICBfdXBkYXRlKGRhdGEpIHtcbiAgICB0aGlzLl9kYXRhID0gZGF0YTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxufVxuIiwiaW1wb3J0IG1kNSBmcm9tICdibHVlaW1wLW1kNSc7XG5pbXBvcnQgc3VwZXJhZ2VudCBmcm9tICdzdXBlcmFnZW50JztcbmltcG9ydCB4bWxkb20gZnJvbSAneG1sZG9tJztcbmltcG9ydCB7IGlzQnJvd3NlciB9IGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBqc29ucCA9IHJlcXVpcmUoJ3N1cGVyYWdlbnQtanNvbnAnKTtcblxuLyoqXG4gKiBDaGVjayBpZiByZXF1ZXN0cyB3aWxsIGJlIHRvIHRoZSBzYW1lIGRvbWFpbiwgaS5lLiBubyBDT1JTLlxuICogTXVzdCBiZSB1c2VkIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFyYW0gdXJsXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3Qgc2FtZU9yaWdpbiA9ICh1cmwpID0+IHtcbiAgY29uc3QgYTEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gIGNvbnN0IGEyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICBhMS5ocmVmID0gdXJsO1xuICBhMi5ocmVmID0gd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgcmV0dXJuIGExLmhvc3RuYW1lID09PSBhMi5ob3N0bmFtZVxuICAgICYmIGExLnBvcnQgPT09IGEyLnBvcnRcbiAgICAmJiBhMS5wcm90b2NvbCA9PT0gYTIucHJvdG9jb2xcbiAgICAmJiBhMi5wcm90b2NvbCAhPT0gJ2ZpbGU6Jztcbn07XG5cbi8qKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBnZXRQcmV2ZW50Q2FjaGVOdW1iZXIgPSAoKSA9PiBwYXJzZUludCgoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLCAxMCk7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBlbmNhcHN1bGF0ZXMgZnVuY3Rpb25hbGl0eSBmb3IgY29tbXVuaWNhdGluZyB3aXRoIHRoZSByZXBvc2l0b3J5IHZpYSBBamF4IGNhbGxzLlxuICogQXV0aGVudGljYXRpb24gaXMgZG9uZSB2aWEgY29va2llcyBhbmQgYWNjZXB0IGhlYWRlcnMgYXJlIGluIGdlbmVyYWwgc2V0IHRvXG4gKiBhcHBsaWNhdGlvbi9qc29uIGJlaGluZCB0aGUgc2NlbmVzLlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL1Jlc3RcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUmVzdCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMudGltZW91dCA9IDMwMDAwOyAvLyAzMCBzZWNvbmRzXG4gICAgdGhpcy5oZWFkZXJzID0ge1xuICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9VVRGLTgnLFxuICAgICAgJ1gtUmVxdWVzdGVkLVdpdGgnOiBudWxsLFxuICAgIH07XG5cbiAgICBjb25zdCByZXN0ID0gdGhpcztcblxuICAgIGlmIChpc0Jyb3dzZXIoKSkge1xuICAgICAgLyoqXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHVyaVxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGRhdGFcbiAgICAgICAqIEBwYXJhbSBmb3JtYXRcbiAgICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZHwqfVxuICAgICAgICovXG4gICAgICByZXN0LnB1dEZpbGUgPSAodXJpLCBkYXRhLCBmb3JtYXQgPSAnYXBwbGljYXRpb24vanNvbicpID0+IHtcbiAgICAgICAgaWYgKCFkYXRhLnZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHN0dWJGb3JtID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgIGNvbnN0IHsgZmlsZXMgfSA9IGRhdGE7XG5cbiAgICAgICAgQXJyYXkuZnJvbShmaWxlcykuZm9yRWFjaCgoZmlsZSwgaWR4KSA9PiB7XG4gICAgICAgICAgLy8gaXMgdGhlIGl0ZW0gYSBGaWxlP1xuICAgICAgICAgIGlmIChmaWxlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgc3R1YkZvcm0uYXBwZW5kKGlkeC50b1N0cmluZygpLCBmaWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdXBlcmFnZW50LnBvc3QodXJpKVxuICAgICAgICAgIC5xdWVyeSh7IHByZXZlbnRDYWNoZTogZ2V0UHJldmVudENhY2hlTnVtYmVyKCkgfSlcbiAgICAgICAgICAuYWNjZXB0KGZvcm1hdClcbiAgICAgICAgICAud2l0aENyZWRlbnRpYWxzKClcbiAgICAgICAgICAuc2VuZChzdHViRm9ybSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3JlZGVudGlhbHMgc2hvdWxkIGNvbnRhaW4gYXR0cmlidXRlcyBcInVzZXJcIiwgXCJwYXNzd29yZFwiLCBhbmQgXCJtYXhBZ2VcIi5cbiAgICogTWF4QWdlIGlzIHRoZSBhbW91bnQgb2Ygc2Vjb25kcyB0aGUgYXV0aG9yaXphdGlvbiBzaG91bGQgYmUgdmFsaWQuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgdGhlbmFibGUgb2JqZWN0XG4gICAqIEBhc3luY1xuICAgKi9cbiAgYXN5bmMgYXV0aChjcmVkZW50aWFscykge1xuICAgIGNvbnN0IHsgdXNlciwgcGFzc3dvcmQsIG1heEFnZSwgbG9nb3V0LCBiYXNlIH0gPSBjcmVkZW50aWFscztcbiAgICBkZWxldGUgdGhpcy5oZWFkZXJzLmNvb2tpZTtcblxuICAgIGlmIChsb2dvdXQgIT09IHRydWUpIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgIGF1dGhfdXNlcm5hbWU6IGVuY29kZVVSSUNvbXBvbmVudCh1c2VyKSxcbiAgICAgICAgYXV0aF9wYXNzd29yZDogZW5jb2RlVVJJQ29tcG9uZW50KHBhc3N3b3JkKSxcbiAgICAgICAgLy8gaW4gc2Vjb25kcywgODY0MDAgaXMgZGVmYXVsdCBhbmQgY29ycmVzcG9uZHMgdG8gYSBkYXkuXG4gICAgICAgIGF1dGhfbWF4YWdlOiBtYXhBZ2UgIT0gbnVsbCA/IG1heEFnZSA6IDYwNDgwMCxcbiAgICAgIH07XG4gICAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zdChgJHtiYXNlfWF1dGgvY29va2llYCwgZGF0YSwgbnVsbCwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgcXVlcnlTdHJpbmdEYXRhID0gT2JqZWN0LmVudHJpZXMoZGF0YSkucmVkdWNlKChhY2N1bSwgcHJvcCkgPT4gYCR7YWNjdW19JHtwcm9wLmpvaW4oJz0nKX0mYCwgJycpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3QoYCR7YmFzZX1hdXRoL2Nvb2tpZWAsIHF1ZXJ5U3RyaW5nRGF0YSwgbnVsbCwgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCcpO1xuICAgICAgY29uc3QgY29va2llcyA9IHJlc3BvbnNlLmhlYWRlcnNbJ3NldC1jb29raWUnXTtcbiAgICAgIGNvb2tpZXMuc29tZSgoYykgPT4ge1xuICAgICAgICBpZiAoYy5zdWJzdHJpbmcoMCwgMTEpID09PSAnYXV0aF90b2tlbj0nKSB7XG4gICAgICAgICAgdGhpcy5oZWFkZXJzLmNvb2tpZSA9IFtjXTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBsb2dvdXRSZXF1ZXN0UmVzdWx0ID0gc3VwZXJhZ2VudC5nZXQoYCR7YmFzZX1hdXRoL2xvZ291dGApXG4gICAgICAucXVlcnkoeyBwcmV2ZW50Q2FjaGU6IGdldFByZXZlbnRDYWNoZU51bWJlcigpIH0pXG4gICAgICAuYWNjZXB0KCdhcHBsaWNhdGlvbi9qc29uJylcbiAgICAgIC53aXRoQ3JlZGVudGlhbHMoKVxuICAgICAgLnRpbWVvdXQoeyByZXNwb25zZTogdGhpcy50aW1lb3V0IH0pO1xuXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5oZWFkZXJzKS5tYXAoa2V5VmFsID0+IGxvZ291dFJlcXVlc3RSZXN1bHQuc2V0KGtleVZhbFswXSwga2V5VmFsWzFdKSk7XG5cbiAgICByZXR1cm4gbG9nb3V0UmVxdWVzdFJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaGVzIGRhdGEgZnJvbSB0aGUgcHJvdmlkZWQgVVJJLlxuICAgKiBJZiBhIGNyb3NzLWRvbWFpbiBjYWxsIGlzIG1hZGUgYW5kIHdlIGFyZSBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQgYSBqc29ucCBjYWxsIGlzIG1hZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBVUkkgdG8gYSByZXNvdXJjZSB0byBmZXRjaC5cbiAgICogQHBhcmFtIHtzdHJpbmd8bnVsbH0gZm9ybWF0IC0gdGhlIGZvcm1hdCB0byByZXF1ZXN0IGFzIGEgbWltZXR5cGUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gbm9uSlNPTlAgLSBzdG9wIEpTT05QIGhhbmRsaW5nIChkZWZhdWx0IGZhbHNlKVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBIHRoZW5hYmxlIG9iamVjdFxuICAgKiBAYXN5bmNcbiAgICogQHRocm93c1xuICAgKi9cbiAgYXN5bmMgZ2V0KHVyaSwgZm9ybWF0ID0gbnVsbCwgbm9uSlNPTlAgPSBmYWxzZSkge1xuICAgIGNvbnN0IGxvY0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xuICAgIGRlbGV0ZSBsb2NIZWFkZXJzWydDb250ZW50LVR5cGUnXTtcblxuICAgIGxldCBfdXJpID0gdXJpO1xuICAgIGxldCBoYW5kbGVBcyA9ICdqc29uJztcbiAgICBpZiAoZm9ybWF0ICE9IG51bGwpIHtcbiAgICAgIGxvY0hlYWRlcnMuQWNjZXB0ID0gZm9ybWF0O1xuICAgICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgICAgY2FzZSAnYXBwbGljYXRpb24vanNvbic6IC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgaW4gdGhlIGhlYWRlcnMuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL3htbCc6XG4gICAgICAgIGNhc2UgJ3RleHQveG1sJzpcbiAgICAgICAgICBoYW5kbGVBcyA9ICd4bWwnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OiAvLyBBbGwgb3RoZXIgc2l0dWF0aW9ucywgaW5jbHVkaW5nIHRleHQvcGxhaW4uXG4gICAgICAgICAgaGFuZGxlQXMgPSAndGV4dCc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXNlIGpzb25wIGluc3RlYWQgb2YgQ09SUyBmb3IgR0VUIHJlcXVlc3RzIHdoZW4gZG9pbmcgY3Jvc3MtZG9tYWluIGNhbGxzLCBpdCBpcyBjaGVhcGVyXG4gICAgaWYgKGlzQnJvd3NlcigpICYmICFzYW1lT3JpZ2luKF91cmkpICYmICFub25KU09OUCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbWV0ZXIgPSBuZXcgUmVnRXhwKCdbPyZdZm9ybWF0PScpO1xuICAgICAgICBpZiAoIXF1ZXJ5UGFyYW1ldGVyLnRlc3QoX3VyaSkpIHtcbiAgICAgICAgICBfdXJpICs9IGAke191cmkuaW5jbHVkZXMoJz8nKSA/ICcmJyA6ICc/J31mb3JtYXQ9YXBwbGljYXRpb24vanNvbmA7XG4gICAgICAgIH1cblxuICAgICAgICBzdXBlcmFnZW50LmdldChfdXJpKVxuICAgICAgICAgIC51c2UoXG4gICAgICAgICAgICBqc29ucCh7XG4gICAgICAgICAgICAgIHRpbWVvdXQ6IDEwMDAwMDAsXG4gICAgICAgICAgICAgIC8vIEBzY2F6YW46IHN1cGVyYWdlbnQtanNvbnAncyByYW5kb20gbnVtYmVyIGdlbmVyYXRvciBpcyB3ZWFrLCBzbyB3ZSBjcmVhdGUgb3VyIG93blxuICAgICAgICAgICAgICBjYWxsYmFja05hbWU6IGBjYiR7bWQ1KF91cmkpLnNsaWNlKDAsIDcpfSR7Z2V0UHJldmVudENhY2hlTnVtYmVyKCl9YCxcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICkgLy8gTmVlZCB0aGlzIHRpbWVvdXQgdG8gcHJldmVudCBhIHN1cGVyYWdlbnRDYWxsYmFjayoqKiBub3QgZGVmaW5lZCBpc3N1ZSB3aXRoIHN1cGVyYWdlbnQtanNvbnA6IGh0dHBzOi8vZ2l0aHViLmNvbS9sYW1wL3N1cGVyYWdlbnQtanNvbnAvaXNzdWVzLzMxXG4gICAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoZGF0YS5ib2R5KTtcbiAgICAgICAgICB9LCByZWplY3QpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IEdFVFJlcXVlc3QgPSBzdXBlcmFnZW50LmdldChfdXJpKVxuICAgICAgLmFjY2VwdChoYW5kbGVBcylcbiAgICAgIC50aW1lb3V0KHtcbiAgICAgICAgcmVzcG9uc2U6IHRoaXMudGltZW91dCxcbiAgICAgIH0pXG4gICAgICAucXVlcnkoeyBwcmV2ZW50Q2FjaGU6IGdldFByZXZlbnRDYWNoZU51bWJlcigpIH0pXG4gICAgICAud2l0aENyZWRlbnRpYWxzKCk7XG5cbiAgICBpZiAoaGFuZGxlQXMgPT09ICd4bWwnKSB7XG4gICAgICBHRVRSZXF1ZXN0LnBhcnNlWydhcHBsaWNhdGlvbi94bWwnXSA9IChyZXMsIGNhbGxiYWNrKSA9PiB7XG4gICAgICAgIGNvbnN0IERPTVBhcnNlciA9IGlzQnJvd3NlcigpID8gd2luZG93LkRPTVBhcnNlciA6IHhtbGRvbS5ET01QYXJzZXI7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcblxuICAgICAgICBpZiAoaXNCcm93c2VyKCkpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZXMsICdhcHBsaWNhdGlvbi94bWwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdG9kbyBAdmFsZW50aW5vIGNoZWNrIGlmIGhlcmUgaXQgc2hvdWxkIGJlIGFuIGVsc2UgYW5kIGNhbGxiYWNrIG91dHNpZGUgdGhhdFxuXG4gICAgICAgIC8vIE5vZGUgaGFuZGxlcyB0aGUgcmV0dXJuIGFzIGEgY2FsbGJhY2tcbiAgICAgICAgcmVzLnRleHQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHJlcy50ZXh0LCAnYXBwbGljYXRpb24veG1sJyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG5cbiAgICAgICAgcmV0dXJuIHJlcy50ZXh0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICBPYmplY3QuZW50cmllcyhsb2NIZWFkZXJzKS5tYXAoa2V5VmFsID0+IEdFVFJlcXVlc3Quc2V0KGtleVZhbFswXSwga2V5VmFsWzFdKSk7XG5cbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IEdFVFJlcXVlc3Q7XG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDIwMCkge1xuICAgICAgaWYgKGhhbmRsZUFzID09PSAndGV4dCcgfHwgZm9ybWF0ID09PSAndGV4dC94bWwnKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS50ZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3BvbnNlLmJvZHk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2UgY291bGQgbm90IGJlIGxvYWRlZDogJHtyZXNwb25zZS50ZXh0fWApO1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc3RzIGRhdGEgdG8gdGhlIHByb3ZpZGVkIFVSSS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVyaSAtIGFuIFVSSSB0byBwb3N0IHRvLlxuICAgKiBAcGFyYW0ge1N0cmluZ3xPYmplY3R9IGRhdGEgLSB0aGUgZGF0YSB0byBwb3N0LiBJZiBhbiBvYmplY3QgdGhlIGRhdGEgaXMgc2VudCBhcyBmb3JtIGRhdGEuXG4gICAqIEBwYXJhbSB7RGF0ZT19IG1vZERhdGUgYSBkYXRlIHRvIHVzZSBmb3IgdGhlIEhUVFAgaWYtdW5tb2RpZmllZC1zaW5jZSBoZWFkZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZm9ybWF0IC0gaW5kaWNhdGVzIHRoZSBjb250ZW50LXR5cGUgb2YgdGhlIGRhdGEsIGRlZmF1bHQgaXNcbiAgICogYXBwbGljYXRpb24vanNvbiwgZXhjZXB0IGlmIHRoZSBkYXRhIGlzIGFuIG9iamVjdCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IGlzXG4gICAqIG11bHRpcGFydC9mb3JtLWRhdGEuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgdGhlbmFibGUgb2JqZWN0XG4gICAqL1xuICBwb3N0KHVyaSwgZGF0YSwgbW9kRGF0ZSwgZm9ybWF0KSB7XG4gICAgY29uc3QgbG9jSGVhZGVycyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGVhZGVycyk7XG4gICAgaWYgKG1vZERhdGUpIHtcbiAgICAgIGxvY0hlYWRlcnNbJ0lmLVVubW9kaWZpZWQtU2luY2UnXSA9IG1vZERhdGUudG9VVENTdHJpbmcoKTtcbiAgICB9Ly8gbXVsdGlwYXJ0L2Zvcm0tZGF0YVxuICAgIGlmIChmb3JtYXQpIHtcbiAgICAgIGxvY0hlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gZm9ybWF0O1xuICAgIH1cblxuICAgIGNvbnN0IFBPU1RSZXF1ZXN0ID0gc3VwZXJhZ2VudC5wb3N0KHVyaSlcbiAgICAgIC5xdWVyeSh7ICdyZXF1ZXN0LnByZXZlbnRDYWNoZSc6IGdldFByZXZlbnRDYWNoZU51bWJlcigpIH0pO1xuXG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIFBPU1RSZXF1ZXN0LnNlbmQoZGF0YSlcbiAgICAgIC8vIHNlcmlhbGl6ZSB0aGUgb2JqZWN0IGludG8gYSBmb3JtYXQgdGhhdCB0aGUgYmFja2VuZCBpcyB1c2VkIHRvIChubyBKU09OIHN0cmluZ3MpXG4gICAgICAgIC5zZXJpYWxpemUob2JqID0+IE9iamVjdC5lbnRyaWVzKG9iailcbiAgICAgICAgICAubWFwKGtleVZhbCA9PiBgJHtrZXlWYWxbMF19PSR7a2V5VmFsWzFdfSZgKVxuICAgICAgICAgIC5qb2luKCcnKSk7XG4gICAgfVxuXG4gICAgUE9TVFJlcXVlc3Qud2l0aENyZWRlbnRpYWxzKClcbiAgICAgIC50aW1lb3V0KHsgcmVzcG9uc2U6IHRoaXMudGltZW91dCB9KTtcblxuICAgIE9iamVjdC5lbnRyaWVzKGxvY0hlYWRlcnMpLm1hcChrZXlWYWwgPT4gUE9TVFJlcXVlc3Quc2V0KGtleVZhbFswXSwga2V5VmFsWzFdKSk7XG5cbiAgICByZXR1cm4gUE9TVFJlcXVlc3Q7XG4gIH1cblxuICAvKipcbiAgICogUG9zdHMgZGF0YSB0byBhIGZhY3RvcnkgcmVzb3VyY2Ugd2l0aCB0aGUgaW50ZW50IHRvIGNyZWF0ZSBhIG5ldyByZXNvdXJjZS5cbiAgICogVGhhdCBpcywgaXQgcG9zdHMgZGF0YSBhbmQgZXhwZWN0cyBhIExvY2F0aW9uIGhlYWRlciBiYWNrIHdpdGggaW5mb3JtYXRpb24gb24gdGhlIGNyZWF0ZWRcbiAgICogcmVzb3VyY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBmYWN0b3J5IHJlc291cmNlLCBtYXkgaW5jbHVkZSBwYXJhbWV0ZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xPYmplY3R9IGRhdGEgLSB0aGUgZGF0YSB0aGF0IGlzIHRvIGJlIHBvc3RlZCBhcyBhIHN0cmluZyxcbiAgICogaWYgYW4gb2JqZWN0IGlzIHByb3ZpZGVkIGl0IHdpbGwgYmUgc2VyaWFsaXplZCBhcyBqc29uLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48U3RyaW5nPn1cbiAgICovXG4gIGFzeW5jIGNyZWF0ZSh1cmksIGRhdGEpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdCh1cmksIGRhdGEpO1xuICAgIC8vIGxldCBsb2NhdGlvbiA9IHJlc3BvbnNlLmdldEhlYWRlcignTG9jYXRpb24nKTtcbiAgICBsZXQgeyBsb2NhdGlvbiB9ID0gcmVzcG9uc2UuaGVhZGVycztcbiAgICAvLyBJbiBzb21lIHdlaXJkIGNhc2VzLCBsaWtlIHdoZW4gbWFraW5nIHJlcXVlc3RzIGZyb20gZmlsZTovLy9cbiAgICAvLyB3ZSBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gaGVhZGVycy5cbiAgICBpZiAoIWxvY2F0aW9uICYmIHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IGlkeCA9IHVyaS5pbmRleE9mKCc/Jyk7XG4gICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBsb2NhdGlvbiA9IHVyaS5zdWJzdHIoMCwgdXJpLmluZGV4T2YoJz8nKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2NhdGlvbiA9IHVyaTtcbiAgICAgIH1cbiAgICAgIGxvY2F0aW9uICs9IGAvZW50cnkvJHtKU09OLnBhcnNlKHJlc3BvbnNlLmJvZHkpLmVudHJ5SWR9YDtcbiAgICB9XG5cbiAgICByZXR1cm4gbG9jYXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmVwbGFjZXMgYSByZXNvdXJjZSB3aXRoIGEgbmV3IHJlcHJlc2VudGF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpIHRoZSBhZGRyZXNzIHRvIHB1dCB0by5cbiAgICogQHBhcmFtIHtzdHJpbmd8T2JqZWN0fSBkYXRhIC0gdGhlIGRhdGEgdG8gcHV0LiBJZiBhbiBvYmplY3QgdGhlIGRhdGEgaXMgc2VudCBhcyBmb3JtIGRhdGEuXG4gICAqIEBwYXJhbSB7RGF0ZT19IG1vZERhdGUgYSBkYXRlIHRvIHVzZSBmb3IgdGhlIEhUVFAgaWYtdW5tb2RpZmllZC1zaW5jZSBoZWFkZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gZm9ybWF0IC0gaW5kaWNhdGVzIHRoZSBjb250ZW50LXR5cGUgb2YgdGhlIGRhdGEsIGRlZmF1bHQgaXNcbiAgICogYXBwbGljYXRpb24vanNvbiwgZXhjZXB0IGlmIHRoZSBkYXRhIGlzIGFuIG9iamVjdCBpbiB3aGljaCBjYXNlIHRoZSBkZWZhdWx0IGlzXG4gICAqIG11bHRpcGFydC9mb3JtLWRhdGEuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IEEgdGhlbmFibGUgb2JqZWN0XG4gICAqL1xuICBwdXQodXJpLCBkYXRhLCBtb2REYXRlLCBmb3JtYXQpIHtcbiAgICBjb25zdCBsb2NIZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKTtcbiAgICBpZiAobW9kRGF0ZSkge1xuICAgICAgbG9jSGVhZGVyc1snSWYtVW5tb2RpZmllZC1TaW5jZSddID0gbW9kRGF0ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICBsb2NIZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IGZvcm1hdDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgbG9jSGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7IC8vIEB0b2RvIHBlcmhhcHMgbm90IG5lZWRlZCwgdGhpcyBpcyBkZWZhdWx0XG4gICAgfVxuXG4gICAgY29uc3QgcHV0UmVxdWVzdCA9IHN1cGVyYWdlbnQucHV0KHVyaSlcbiAgICAgIC5xdWVyeSh7IHByZXZlbnRDYWNoZTogZ2V0UHJldmVudENhY2hlTnVtYmVyKCkgfSlcbiAgICAgIC5zZW5kKGRhdGEpXG4gICAgICAud2l0aENyZWRlbnRpYWxzKClcbiAgICAgIC50aW1lb3V0KHsgcmVzcG9uc2U6IHRoaXMudGltZW91dCB9KTtcblxuICAgIE9iamVjdC5lbnRyaWVzKGxvY0hlYWRlcnMpLm1hcChrZXlWYWwgPT4gcHV0UmVxdWVzdC5zZXQoa2V5VmFsWzBdLCBrZXlWYWxbMV0pKTtcblxuICAgIHJldHVybiBwdXRSZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIERlbGV0ZXMgYSByZXNvdXJjZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVyaSBvZiB0aGUgcmVzb3VyY2UgdGhhdCBpcyB0byBiZSBkZWxldGVkLlxuICAgKiBAcGFyYW0ge0RhdGU9fSBtb2REYXRlIGEgZGF0ZSB0byB1c2UgZm9yIHRoZSBIVFRQIGlmLXVubW9kaWZpZWQtc2luY2UgaGVhZGVyLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSBBIHRoZW5hYmxlIG9iamVjdFxuICAgKi9cbiAgZGVsKHVyaSwgbW9kRGF0ZSkge1xuICAgIGNvbnN0IGxvY0hlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmhlYWRlcnMpO1xuICAgIGRlbGV0ZSBsb2NIZWFkZXJzWydDb250ZW50LVR5cGUnXTtcbiAgICBpZiAobW9kRGF0ZSkge1xuICAgICAgbG9jSGVhZGVyc1snSWYtVW5tb2RpZmllZC1TaW5jZSddID0gbW9kRGF0ZS50b1VUQ1N0cmluZygpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlbGV0ZVJlcXVlc3QgPSBzdXBlcmFnZW50LmRlbCh1cmkpXG4gICAgICAucXVlcnkoeyBwcmV2ZW50Q2FjaGU6IGdldFByZXZlbnRDYWNoZU51bWJlcigpIH0pXG4gICAgICAud2l0aENyZWRlbnRpYWxzKClcbiAgICAgIC50aW1lb3V0KHsgcmVzcG9uc2U6IHRoaXMudGltZW91dCB9KTtcblxuICAgIE9iamVjdC5lbnRyaWVzKGxvY0hlYWRlcnMpLm1hcChrZXlWYWwgPT4gZGVsZXRlUmVxdWVzdC5zZXQoa2V5VmFsWzBdLCBrZXlWYWxbMV0pKTtcblxuICAgIHJldHVybiBkZWxldGVSZXF1ZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFBvc3QgYSBmaWxlIHRvIGEgVVJJLlxuICAgKiBJbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQgYSBmaWxlIGlzIHJlcHJlc2VudGVkIHZpYSBhbiBpbnB1dCB0YWcgd2hpY2ggcmVmZXJlbmNlc1xuICAgKiB0aGUgZmlsZSB0byBiZSB1cGxvYWRlZCB2aWEgaXRzIHZhbHVlIGF0dHJpYnV0ZS5cbiAgICogSW4gbm9kZSBlbnZpcm9ubWVudHMgdGhlIGZpbGUgaXMgcmVwcmVzZW50ZWQgYXMgYSBzdHJlYW0gY29uc3RydWN0ZWQgdmlhXG4gICAqIGZzLmNyZWF0ZVJlYWRTdHJlYW0oJ2ZpbGUudHh0JykuXG4gICAqXG4gICAqID4gXyoqVW5kZXIgdGhlIGhvb2QqKiB0aGUgdGFnIGlzIG1vdmVkIGludG8gYSBmb3JtIGluIGFuIGludmlzaWJsZSBpZnJhbWVcbiAgICogd2hpY2ggdGhlbiBpcyBzdWJtaXR0ZWQuIElmIHRoZXJlIGlzIGEgcmVzcG9uc2UgaXQgaXMgcHJvdmlkZWQgaW4gYSB0ZXh0YXJlYSB3aGljaFxuICAgKiBjYW4gYmUgbG9va2VkIGludG8gc2luY2Ugd2UgYXJlIG9uIHRoZSBzYW1lIGRvbWFpbi5fXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgdGhlIFVSSSB0byB3aGljaCB3ZSB3aWxsIHB1dCB0aGUgZmlsZS5cbiAgICogQHBhcmFtIHtkYXRhfSBkYXRhIC0gaW5wdXQgdGFnIG9yIHN0cmVhbSB0aGF0IG1heSBmb3IgaW5zdGFuY2UgY29ycmVzcG9uZCB0byBhIGZpbGVcbiAgICogaW4gYSBub2RlanMgc2V0dGluZy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGZvcm1hdCB0aGUgZm9ybWF0IHRvIGhhbmRsZSB0aGUgcmVzcG9uc2UgYXMsIGVpdGhlciB0ZXh0LCB4bWwsIGh0bWwgb3IganNvblxuICAgKiAoanNvbiBpcyBkZWZhdWx0KS5cbiAgICogQHJldHVybiB7UHJvbWlzZX0gQSB0aGVuYWJsZSBvYmplY3RcbiAgICovXG4gIHB1dEZpbGUodXJpLCBkYXRhLCBmb3JtYXQpIHtcbiAgICByZXR1cm4gdGhpcy5wb3N0KHVyaSwgZGF0YSwgbnVsbCwgZm9ybWF0KTtcbiAgfVxufVxuXG4iLCJpbXBvcnQgRW50cnlTdG9yZSBmcm9tICcuL0VudHJ5U3RvcmUnO1xuLy8gaW1wb3J0IExpc3QgZnJvbSAnLi9MaXN0JztcblxuLyoqXG4gKiBAZXhwb3J0cyBzdG9yZS9TZWFyY2hMaXN0XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNlYXJjaExpc3Qge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5U3RvcmV9IGVudHJ5U3RvcmVcbiAgICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWxsVHlwZSBwYXJhbWV0ZXIgcHJvdmlkZWQgdG8gYXN5bmNMaXN0ZW5lcnMgb24gcXVlcnkgZXhlY3V0aW9uLFxuICAgKiBhc3N1bWVkIHRvIGJlICdzZWFyY2gnIGlmIGxlZnQgb3V0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnRyeVN0b3JlLCBxdWVyeSwgY2FsbFR5cGUpIHtcbiAgICB0aGlzLl9lbnRyeVN0b3JlID0gZW50cnlTdG9yZTtcbiAgICB0aGlzLl9xdWVyeSA9IHF1ZXJ5O1xuICAgIHRoaXMuX2NhbGxUeXBlID0gY2FsbFR5cGUgfHwgJ3NlYXJjaCc7XG4gICAgdGhpcy5fc29ydGVkQ2hpbGRyZW4gPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiB0aGUgcXVlcnkgaW5zdGFuY2UsIGUuZy4gYW4gaW5zdGFuY2Ugb2Ygc3RvcmUvU29sclF1ZXJ5LCBhc3NvY2lhdGVkIHdpdGggdGhpcyBTZWFyY2hMaXN0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UXVlcnkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXJ5O1xuICB9XG5cbiAgc2V0TGltaXQobGltaXQpIHtcbiAgICB0aGlzLl9xdWVyeS5saW1pdChsaW1pdCk7XG4gIH1cblxuICBnZXRMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcXVlcnkuZ2V0TGltaXQoKSB8fCBmYWN0b3J5LmdldERlZmF1bHRMaW1pdCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGZhY2V0cywgZWFjaCBmYWNldCBpcyBhbiBvYmplY3Qgd2hpY2ggY29udGFpbnMgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAqXG4gICAqICBuYW1lICAgICAgIC0gdGhlIHNvbHIgc2VhcmNoIGZpZWxkIHRoaXMgZmFjZXQgY29ycmVzcG9uZHMgdG9cbiAgICogIHZhbHVlQ291bnQgLSB0aGUgbnVtYmVyIG9mIHZhbHVlcyB0aGlzIGZhY2V0IG1hdGNoZXNcbiAgICogIHZhbHVlcyAgICAgLSBhbiBhcnJheSBvZiB2YWx1ZXMgbWF0Y2hpbmcgdGhpcyBmYWNldCwgd2l0aCBuYW1lIGFuZCBjb3VudCBlYWNoLlxuICAgKlxuICAgKiBJbiBhZGRpdGlvbiwgd2hlbiBhc2tpbmcgZm9yIGZhY2V0cyBmb3IgYXJiaXRyYXJ5IHByZWRpY2F0ZXMgdGhlcmUgaXMgdHdvIGFkZGl0aW9uYWwgZmllbGRzOlxuICAgKlxuICAgKiAgcHJlZGljYXRlIC0gdGhlIGZ1bGwgVVJJIG9mIHRoZSBwcmVkaWNhdGUgdGhpcyBmYWNldCBjb3JyZXNwb25kcyB0b1xuICAgKiAgdHlwZSAtIHRoZSB0eXBlIG9mIHRoZSBmYWNldCB2YWx1ZXMsIGN1cnJlbnRseSBvbmx5IGxpdGVyYWwsIHVyaSBhbmQgaW50ZWdlciBhcmUgc3VwcG9ydGVkXG4gICAqXG4gICAqIE5vdGUgdGhhdCB5b3UgY2FuIGFzayBmb3IgZmFjZXRzIGZvciBzb2xyIGZpZWxkcyBsaWtlIFwidGFnc1wiLCBpbiB0aGlzIGNhc2UgdGhlIGFib3ZlIHR3b1xuICAgKiBmaWVsZHMgd2lsbCBiZSBub3QgYmUgcHJlc2VudCBhcyB0aGUgXCJ0YWdzXCIgc29sciBmaWVsZCBjb3JyZXNwb25kcyB0byBhIG1peCBvZiBkaWZmZXJlbnRcbiAgICogcHJlZGljYXRlcyBhbmQgcG9zc2libHkgZGlmZmVyZW50IHR5cGVzLlxuICAgKlxuICAgKiBIZXJlIGlzIGFuIGV4YW1wbGUgb2YgYSBmYWNldCBmb3IgZGNhdDprZXl3b3JkOlxuICAgKiB7XG4gICAqICAgbmFtZTogIFwibWV0YWRhdGEucHJlZGljYXRlLmxpdGVyYWxfcy5hNjQyNDEzM1wiLFxuICAgKiAgIHByZWRpY2F0ZTogXCJodHRwOi8vd3d3LnczLm9yZy9ucy9kY2F0I2tleXdvcmRcIixcbiAgICogICB0eXBlOiBcImxpdGVyYWxcIixcbiAgICogICB2YWx1ZUNvdW50OiAzLFxuICAgKiAgIHZhbHVlczogW1xuICAgKiAgICAgIHtuYW1lOiBcImVsZWt0cmljdGV0XCIsIGNvdW50OiAxfSxcbiAgICogICAgICB7bmFtZTogXCJmaW5hbnNcIiwgY291bnQ6IDF9LFxuICAgKiAgICAgIHtuYW1lOiBcInNrYXR0XCIsIGNvdW50OiAxfVxuICAgKiAgIF1cbiAgICogfVxuICAgKlxuICAgKiBAcmV0dXJuIHtBcnJheX0gbmV2ZXIgbnVsbCBvciB1bmRlZmluZWQsIG1heSBiZSBhbiBhcnJheSBvZiBsZW5ndGggMCB0aG91Z2guXG4gICAqL1xuICBnZXRGYWNldHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmFjZXRzO1xuICB9XG5cbiAgc2V0RmFjZXRzKGZhY2V0RmllbGRzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGZhY2V0RmllbGRzKSB8fCBmYWNldEZpZWxkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMuZmFjZXRzID0gW107XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmFjZXRzID0gZmFjZXRGaWVsZHM7XG4gICAgICBjb25zdCBmMnAgPSB0aGlzLl9xdWVyeS5mYWNldDJwcmVkaWNhdGU7XG4gICAgICBmYWNldEZpZWxkcy5mb3JFYWNoKChmZikgPT4ge1xuICAgICAgICBpZiAoZjJwICYmIGYycFtmZi5uYW1lXSkge1xuICAgICAgICAgIGZmLnByZWRpY2F0ZSA9IGYycFtmZi5uYW1lXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmYubmFtZS5zdGFydHNXaXRoKCdtZXRhZGF0YS5wcmVkaWNhdGUnKSkge1xuICAgICAgICAgIGZmLnR5cGUgPSBmZi5uYW1lLnNwbGl0KCcuJylbMl07XG4gICAgICAgIH0gZWxzZSBpZiAoZmYubmFtZS5zdGFydHNXaXRoKCdyZWxhdGVkLm1ldGFkYXRhLnByZWRpY2F0ZScpKSB7XG4gICAgICAgICAgZmYudHlwZSA9IGZmLm5hbWUuc3BsaXQoJy4nKVszXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbcGFnZT0wXVxuICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZvcmNlTG9hZEVudHJpZXMocGFnZSA9IDApIHtcbiAgICBjb25zdCBvZmZzZXQgPSBwYWdlICogdGhpcy5nZXRMaW1pdCgpO1xuICAgIHRoaXMuX3F1ZXJ5Lm9mZnNldChvZmZzZXQpO1xuICAgIHJldHVybiB0aGlzLl9lbnRyeVN0b3JlLmhhbmRsZUFzeW5jKHRoaXMuX2VudHJ5U3RvcmUuZ2V0UkVTVCgpLmdldCh0aGlzLl9xdWVyeS5nZXRRdWVyeSh0aGlzLl9lbnRyeVN0b3JlKSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0RmFjZXRzKGRhdGEuZmFjZXRGaWVsZHMpO1xuICAgICAgICByZXR1cm4gZXMuZ2V0RmFjdG9yeSgpLmV4dHJhY3RTZWFyY2hSZXN1bHRzKGRhdGEsIHRoaXMsIHRoaXMuX2VudHJ5U3RvcmUpO1xuICAgICAgfSksIHRoaXMuX2NhbGxUeXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBzaXplIG9mIGxpc3QuXG4gKlxuICogQHJldHVybnMge251bWJlcn0gdGhlIGFtb3VudCBvZiBlbnRyaWVzIGluIHRoZSBsaXN0LCAtMSBpZiB1bmtub3duLlxuICovXG4vLyBTZWFyY2hMaXN0LnByb3RvdHlwZS5nZXRTaXplID0gTGlzdC5wcm90b3R5cGUuZ2V0U2l6ZTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgYW4gYXJyYXkgb2YgZW50cmllcyBjb250YWluZWQgaW4gdGhpcyBsaXN0IGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGFuZFxuICogcGFnaW5hdGlvbiBzZXR0aW5ncy5cbiAqXG4gKiBAcGFyYW0ge2ludGVnZXJ9IHBhZ2UgLSB0aGUgcGFnZSB0byByZXF1ZXN0IGFuIGFycmF5IG9mIGVudHJpZXMgZm9yLCBmaXJzdCBwYWdlIGlzIG51bWJlcmVkIDAuXG4gKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPEVudHJ5Pj59IHRoZSBwcm9taXNlIHdpbGwgcmV0dXJuIGFuIGVudHJ5LWFycmF5LlxuICogQG1ldGhvZFxuICovXG4vLyBTZWFyY2hMaXN0LnByb3RvdHlwZS5nZXRFbnRyaWVzID0gTGlzdC5wcm90b3R5cGUuZ2V0RW50cmllcztcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGNhbGxiYWNrIG9uIGVhY2ggbGlzdCBtZW1iZXJzIGluIHRoZSBvcmRlciBwcm92aWRlZCBieSB0aGUgc29sci1zZWFyY2guXG4gKiBJZiB0aGUgcHJvdmlkZWQgZnVuY3Rpb24gcmV0dXJuIGZhbHNlIGZvciBvbmUgZW50cnkgdGhlIGl0ZXJhdGlvbiBpcyBzdG9wcGVkIGFuZFxuICogdGhlIGZ1bmN0aW9uIGlzIG5vdCBjYWxsZWQgZm9yIGNvbnNlY3V0aXZlIG1hdGNoZWQgZW50cmllcy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jXG4gKi9cbi8vIFNlYXJjaExpc3QucHJvdG90eXBlLmZvckVhY2ggPSBMaXN0LnByb3RvdHlwZS5mb3JFYWNoO1xuLy8gU2VhcmNoTGlzdC5wcm90b3R5cGUuX2dldEVudHJpZXMgPSBMaXN0LnByb3RvdHlwZS5fZ2V0RW50cmllcztcbi8vIFNlYXJjaExpc3QucHJvdG90eXBlLl91cGRhdGUgPSBMaXN0LnByb3RvdHlwZS5fdXBkYXRlO1xuXG4vLyBleHBvcnQgZGVmYXVsdCBTZWFyY2hMaXN0O1xuIiwiaW1wb3J0IG1kNSBmcm9tICdibHVlaW1wLW1kNSc7XG5pbXBvcnQgeyBuYW1lc3BhY2VzIH0gZnJvbSAncmRmanNvbic7XG5pbXBvcnQgQ29udGV4dCBmcm9tICcuL0NvbnRleHQnO1xuaW1wb3J0IEVudHJ5U3RvcmUgZnJvbSAnLi9FbnRyeVN0b3JlJztcbmltcG9ydCBTZWFyY2hMaXN0IGZyb20gJy4vU2VhcmNoTGlzdCc7XG5cbmNvbnN0IGVuY29kZVN0ciA9IHN0ciA9PiBlbmNvZGVVUklDb21wb25lbnQoc3RyLnJlcGxhY2UoLzovZywgJ1xcXFw6JylcbiAgLnJlcGxhY2UoL1xcKC9nLCAnXFxcXCgnKS5yZXBsYWNlKC9cXCkvZywgJ1xcXFwpJykpO1xuY29uc3Qgc2hvcnRlbiA9IHByZWRpY2F0ZSA9PiBtZDUobmFtZXNwYWNlcy5leHBhbmQocHJlZGljYXRlKSkuc3Vic3RyKDAsIDgpO1xuY29uc3QgbmdyYW1MaW1pdCA9IDE1O1xuY29uc3QgaXNOZ3JhbSA9IGtleSA9PiBrZXkuaW5kZXhPZigndGl0bGUnKSA9PT0gMFxuICB8fCBrZXkuaW5kZXhPZigndGFnLmxpdGVyYWwnKSA9PT0gMFxuICB8fCAoa2V5LmluZGV4T2YoJ21ldGFkYXRhLnByZWRpY2F0ZS5saXRlcmFsJykgPT09IDAgJiZcbiAgICBrZXkuaW5kZXhPZignbWV0YWRhdGEucHJlZGljYXRlLmxpdGVyYWxfJykgIT09IDApXG4gIHx8IChrZXkuaW5kZXhPZigncmVsYXRlZC5tZXRhZGF0YS5wcmVkaWNhdGUubGl0ZXJhbCcpID09PSAwICYmXG4gICAga2V5LmluZGV4T2YoJ3JlbGF0ZWQubWV0YWRhdGEucHJlZGljYXRlLmxpdGVyYWxfJykgIT09IDApO1xuY29uc3QgaXNFeGFjdE1hdGNoID0ga2V5ID0+IGtleS5pbmRleE9mKCdwcmVkaWNhdGUubGl0ZXJhbF9zJykgPiAwIHx8IGtleS5pbmRleE9mKCdwcmVkaWNhdGUubGl0ZXJhbCcpID09PSAtMTtcbi8qKlxuICogRW1wdHkgc3BhY2VzIGluIHNlYXJjaCB0ZXJtIHNob3VsZCBiZSBpbnRlcnByZXRlZCBhcyBBTkQgaW5zdGVhZCBvZiB0aGUgZGVmYXVsdCBPUi5cbiAqIEluIGFkZGl0aW9uLCBmaWVsZHMgaW5kZXhlZCBhcyB0ZXh0X25ncmFtIHdpbGwgaGF2ZSB0byBiZSBzaG9ydGVuZWQgdG8gdGhlIG5ncmFtIG1heCBsaW1pdFxuICogYXMgdGhleSB3aWxsIG5vdCBtYXRjaCBvdGhlcndpc2UuXG4gKlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIHRlcm1cbiAqIEBwYXJhbSBpc0ZhY2V0XG4gKiBAcmV0dXJuIHsqfVxuICovXG5jb25zdCBzb2xyRnJpZW5kbHkgPSAoa2V5LCB0ZXJtLCBpc0ZhY2V0KSA9PiB7XG4gIGxldCBhbmQgPSB0ZXJtLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csICcgJyk7XG4gIGlmIChpc05ncmFtKGtleSkgJiYgaXNGYWNldCAhPT0gdHJ1ZSkge1xuICAgIGFuZCA9IGFuZC5zcGxpdCgnICcpLm1hcCh0ID0+ICh0Lmxlbmd0aCA8IG5ncmFtTGltaXQgPyBlbmNvZGVTdHIodCkgOlxuICAgICAgZW5jb2RlU3RyKHQuc3Vic3RyKDAsIG5ncmFtTGltaXQpKSkpO1xuICB9IGVsc2UgaWYgKGlzRXhhY3RNYXRjaChrZXkpKSB7XG4gICAgaWYgKGFuZC5pbmRleE9mKCcgJykgPT09IC0xKSB7XG4gICAgICBhbmQgPSBbZW5jb2RlU3RyKGFuZCldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhbmQgPSBbYFwiJHtlbmNvZGVTdHIoYW5kKX1cImBdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhbmQgPSBhbmQuc3BsaXQoJyAnKS5tYXAodCA9PiBlbmNvZGVTdHIodCkpO1xuICB9XG4gIHJldHVybiBhbmQubGVuZ3RoID09PSAxID8gYW5kWzBdIDogYCgke2FuZC5qb2luKCcrQU5EKycpfSlgO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHN0cnVjdFxuICogQHBhcmFtIGlzQW5kXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGJ1aWxkUXVlcnkgPSAoc3RydWN0LCBpc0FuZCkgPT4ge1xuICBjb25zdCB0ZXJtcyA9IFtdO1xuICBPYmplY3Qua2V5cyhzdHJ1Y3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgIGxldCB2YWwgPSBzdHJ1Y3Rba2V5XTtcbiAgICB2YWwgPSBBcnJheS5pc0FycmF5KHZhbCkgPyB2YWwubWFwKHYgPT4gbmFtZXNwYWNlcy5leHBhbmQodikpIDogbmFtZXNwYWNlcy5leHBhbmQodmFsKTtcbiAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgY2FzZSAnb3InOlxuICAgICAgICB0ZXJtcy5wdXNoKGJ1aWxkUXVlcnkodmFsLCBmYWxzZSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2FuZCc6XG4gICAgICAgIHRlcm1zLnB1c2goYnVpbGRRdWVyeSh2YWwsIHRydWUpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICB0ZXJtcy5wdXNoKGAke2tleX06JHtzb2xyRnJpZW5kbHkoa2V5LCB2YWwpfWApO1xuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgIGNvbnN0IG9yID0gW107XG4gICAgICAgICAgdmFsLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICAgIG9yLnB1c2goYCR7a2V5fToke3NvbHJGcmllbmRseShrZXksIG8pfWApO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChvci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0ZXJtcy5wdXNoKGAoJHtvci5qb2luKCcrT1IrJyl9KWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXJtcy5wdXNoKGAke29yLmpvaW4oJytPUisnKX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAvLyBUT0RPXG4gICAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBpZiAodGVybXMubGVuZ3RoID4gMSkge1xuICAgIHJldHVybiBgKCR7dGVybXMuam9pbihpc0FuZCA/ICcrQU5EKycgOiAnK09SKycpfSlgO1xuICB9XG4gIHJldHVybiB0ZXJtcy5qb2luKGAke2lzQW5kID8gJytBTkQrJyA6ICcrT1IrJ31gKTtcbn07XG5cbi8qKlxuICogVGhlIFNvbHJRdWVyeSBjbGFzcyBwcm92aWRlcyBhIHdheSB0byBjcmVhdGUgYSBxdWVyeSBieSBjaGFpbmluZyBtZXRob2QgY2FsbHMgYWNjb3JkaW5nIHRvXG4gKiB0aGUgYnVpbGRlciBwYXR0ZXJuLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgICAgY29uc3Qgc3EgPSBlcy5uZXdTb2xyUXVlcnkoKS50aXRsZShcInNvbWUgdGl0bGVcIikudHlwZShcImh0dHA6Ly9leGFtcGxlLmNvbS9QZXJzb25cIilcbiAqXG4gKiBUaGUgZXhhbXBsZSB5aWVsZHMgYSBzZWFyY2ggZm9yIGVudHJpZXMgdGhhdCBoYXZlIGEgdGl0bGUgdGhhdCBjb250YWlucyBcInNvbWUgdGl0bGVcIlxuICogYW5kIGEgcmRmOnR5cGUgb2YgXCJodHRwOi8vZXhhbXBsZS5jb20vUGVyc29uXCIgZXhwcmVzc2VkIGluIHRoZSBtZXRhZGF0YS5cbiAqIFRvIGV4ZWN1dGUgdGhlIHF1ZXJ5IHlvdSBjYW4gZWl0aGVyIGFzayBmb3IgYSB7QGxpbmsgc3RvcmUvU2VhcmNoTGlzdH0gYW5kIHRoZW4gY2FsbFxuICogZ2V0RW50cmllcyAob3IgZm9yRWFjaCk6XG4gKlxuICogICAgIGNvbnN0IHNsID0gc3EubGlzdCgpO1xuICogICAgIHNsLmdldEVudHJpZXMoKS50aGVuKChlbnRyeUFycikgPT4gey8vIERvIHNvbWV0aGluZyB9KVxuICpcbiAqIE9yIHlvdSB1c2UgdGhlIGFiYnJldmlhdGVkIHZlcnNpb24gd2hlcmUgeW91IGp1c3QgY2FsbCBnZXRFbnRyaWVzIGRpcmVjdGx5IChvciBmb3JFYWNoKVxuICogb24gdGhlIFNvbHJRdWVyeTpcbiAqXG4gKiAgICAgc3EuZ2V0RW50cmllcygpXG4gKlxuICogVGhlIG1ham9yaXR5IG9mIHRoZSBtZXRob2RzIHdvcmsgdGhlIHNhbWUgd2F5LCB0aGF0IGlzIHRoZXkgdGFrZSB0d28gdmFsdWVzLCBhIHZhbHVlIGFuZCBhXG4gKiBwb3NzaWJsZSBuZWdhdGlvbiBmbGFnLiBUaGUgdmFsdWUgY2FuIGJlIGFuIGFycmF5IGNvcnJlc3BvbmRpbmcgdG8gYSBkaXNqdW5jdGlvbiBhbmQgaWYgdGhlXG4gKiBmbGFnIGlzIHNldCB0cnVlIHRoZSBzZWFyY2ggc3RyaW5nIHdpbGwgYmUgY29uc3RydWN0ZWQgdG8gc2VhcmNoIGZvciB0aGUgbmVnYXRpb24gb2YgdGhlXG4gKiBwcm92aWRlZCB2YWx1ZS4gRm9yIGV4YW1wbGUsIGlmIGEgZ3JhcGggdHlwZSBpbiB0aGUgZm9ybSBvZiBhbiBhcnJheSBjb250YWluaW5nIExpc3QgYW5kIFVzZXJcbiAqIGlzIHByb3ZpZGVkIHRvZ2V0aGVyIHdpdGggYSBuZWdhdGlvbiBib29sZWFuIHNldCB0byB0cnVlLCB0aGUgcXVlcnkgd2lsbCBzZWFyY2ggZm9yIGFueXRoaW5nXG4gKiBidXQgbGlzdHMgYW5kIHVzZXJzOlxuICpcbiAqICAgICBzcS5ncmFwaFR5cGUoW3R5cGVzLkdUX0xJU1QsIHR5cGVzLkdUX1VTRVJdLCB0cnVlKVxuICpcbiAqIFN1cHBvcnRlZCBtZXRob2RzIG9uIHRoZSBzb2xyIG9iamVjdCBjb3JyZXNwb25kIGluIGxhcmdlIHRvIHRoZSBhdmFpbGFibGUgc29sciBmaWVsZHNcbiAqIGRvY3VtZW50ZWQgYXQsIHNvbWUgbWV0aG9kIG5hbWVzIGFyZSBkaWZmZXJlbnQgdG8gYXZvaWQgZG90czpcbiAqIHtAbGluayBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2VudHJ5c3RvcmUvd2lraS9Lbm93bGVkZ2VCYXNlU2VhcmNofVxuICpcbiAqIFRoZXJlIGlzIGFsc28gYSBzcGVjaWFsIG1ldGhvZCAoe0BsaW5rIHN0b3JlL1NvbHJRdWVyeSNnZXRRdWVyeSBnZXRRdWVyeX0pIGZvciBnZXR0aW5nIHRoZVxuICogcXVlcnkgYXMgYSBzdHJpbmcgdGhhdCBpcyB1c2VkIGJ5IEVudHJ5U3RvcmUgQVBJIGJlaGluZCB0aGUgc2NlbmVzLCB5b3UgY2FuIHNhZmVseSBpZ25vcmVcbiAqIHRoaXMgbWV0aG9kLlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL1NvbHJRdWVyeVxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTb2xyUXVlcnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0b3JlL0VudHJ5U3RvcmV9IGVudHJ5c3RvcmVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGVudHJ5c3RvcmUpIHtcbiAgICB0aGlzLl9lbnRyeXN0b3JlID0gZW50cnlzdG9yZTtcbiAgICB0aGlzLnByb3BlcnRpZXMgPSBbXTtcbiAgICB0aGlzLnJlbGF0ZWRQcm9wZXJ0aWVzID0gW107XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgKj59XG4gICAgICovXG4gICAgdGhpcy5wYXJhbXMgPSBuZXcgTWFwKCk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAdHlwZSB7TWFwPHN0cmluZywgYW55Pn1cbiAgICAgKi9cbiAgICB0aGlzLm1vZGlmaWVycyA9IG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTZXQ8T2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2FuZCA9IG5ldyBTZXQoKTtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEB0eXBlIHtTZXQ8T2JqZWN0Pn1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX29yID0gbmV3IFNldCgpO1xuICAgIHRoaXMuZmFjZXRwcmVkaWNhdGVzID0ge307XG4gICAgdGhpcy5yZWxhdGVkRmFjZXRwcmVkaWNhdGVzID0ge307XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9xKGtleSwgdmFsLCBtb2RpZmllciA9IG51bGwpIHtcbiAgICB0aGlzLnBhcmFtcy5zZXQoa2V5LCB2YWwpO1xuICAgIGlmIChtb2RpZmllciA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5tb2RpZmllcnMuc2V0KGtleSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGFsbCB0aXRsZXMgaW4gYWxsIGxhbmd1YWdlcywgbXVsdGl2YWx1ZWQsIGNhbm5vdCBiZSBzb3J0ZWQgb24uXG4gICAqIEluY2x1ZGVzIGRjOnRpdGxlLCBkY3Rlcm1zOnRpdGxlLCBza29zOnByZWZMYWJlbCwgc2tvczphbHRMYWJlbCwgc2tvczpoaWRkZW5MYWJlbCxcbiAgICogcmRmczpsYWJlbCwgZm9hZjpuYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHRpdGxlKHZhbCwgbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcSgndGl0bGUnLCB2YWwsIG1vZGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGFsbCBkZXNjcmlwdGlvbnMgaW4gYWxsIGxhbmd1YWdlcywgbXVsdGl2YWx1ZWQsIGNhbm5vdCBiZSBzb3J0ZWQgb24uXG4gICAqIEluY2x1ZGVzIGRjOmRlc2NyaXB0aW9uLCBkY3Rlcm1zOmRlc2NyaXB0aW9uLCByZGZzOmNvbW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBkZXNjcmlwdGlvbih2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ2Rlc2NyaXB0aW9uJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBhbGwgdGFncyBsaXRlcmFscyBpbiBhbGwgbGFuZ3VhZ2VzLCBtdWx0aXZhbHVlZCwgY2Fubm90IGJlIHNvcnRlZCBvbi5cbiAgICogSW5jbHVkZXMgZGM6c3ViamVjdCwgZGN0ZXJtczpzdWJqZWN0LCBkY2F0OmtleXdvcmQgYW5kIGxvbTprZXl3b3JkXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB2YWxcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgdGFnTGl0ZXJhbCh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ3RhZy5saXRlcmFsJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBhbGwgdGFnIFVSSXMsIG11bHRpdmFsdWVkLCBjYW5ub3QgYmUgc29ydGVkIG9uLlxuICAgKiBJbmNsdWRlcyBkYzpzdWJqZWN0LCBkY3Rlcm1zOnN1YmplY3RcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICB0YWdVUkkodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCd0YWcudXJpJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyB0aGUgbGFuZ3VhZ2UgKGFzIGEgbGl0ZXJhbCkgb2YgdGhlIHJlc291cmNlLCBzaW5nbGUgdmFsdWUsIGNhbiBiZSB1c2VkIGZvciBzb3J0aW5nP1xuICAgKiBJbmNsdWRlcyBkYzpsYW5ndWFnZSwgZGN0ZXJtczpsYW5ndWFnZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGxhbmcodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdsYW5nJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyB0aXRsZSwgZGVzY3JpcHRpb24gYW5kIHRhZ3MsIG11bHRpdmFsdWUsIGNhbm5vdCBiZSBzb3J0ZWQgb24uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB2YWxcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgYWxsKHZhbCwgbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcSgnYWxsJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBhbGwgVVJJcyBpbiBzdWJqZWN0IHBvc2l0aW9uIGluIHRoZSBtZXRhZGF0YSwgZXhjZXB0IHRoZSByZXNvdXJjZVVSSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBzdWJqZWN0KHZhbCwgbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcSgnbWV0YWRhdGEuc3ViamVjdCcsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgYWxsIFVSSXMgaW4gcHJlZGljYXRlIHBvc2l0aW9uIGluIHRoZSBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBwcmVkaWNhdGUodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdtZXRhZGF0YS5wcmVkaWNhdGUnLCB2YWwsIG1vZGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGFsbCBsaXRlcmFscyBpbiBvYmplY3QgcG9zaXRpb24gaW4gdGhlIG1ldGFkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIG9iamVjdExpdGVyYWwodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdtZXRhZGF0YS5vYmplY3QubGl0ZXJhbCcsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgYWxsIFVSSXMgaW4gb2JqZWN0IHBvc2l0aW9uIGluIHRoZSBtZXRhZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBvYmplY3RVcmkodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdtZXRhZGF0YS5vYmplY3QudXJpJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyB0aGUgcmVzb3VyY2VVUkkgb2YgdGhlIGVudHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHJlc291cmNlKHZhbCwgbW9kaWZpZXIgPSBudWxsKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ3Jlc291cmNlJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyB0aGUgZW50cnlVUkkgb2YgdGhlIGVudHJ5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHVyaSh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ3VyaScsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgYWxsIHR5cGVzIG9mIHRoZSByZXNvdXJjZVVSSSwgaS5lLlxuICAgKiBhbGwgVVJJcyBwb2ludGVkIHRvIHZpYSByZGY6dHlwZSBmcm9tIHRoZSByZXNvdXJjZVVSSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHJkZlR5cGVcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgcmRmVHlwZShyZGZUeXBlLCBtb2RpZmllciA9IG51bGwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZGZUeXBlKSkge1xuICAgICAgcmV0dXJuIHRoaXMuX3EoJ3JkZlR5cGUnLCByZGZUeXBlLm1hcCh0ID0+IG5hbWVzcGFjZXMuZXhwYW5kKHQpKSwgbW9kaWZpZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcSgncmRmVHlwZScsIG5hbWVzcGFjZXMuZXhwYW5kKHJkZlR5cGUpLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBhbGwgY3JlYXRvcnMgKGluIHRoZSBlbnRyeSBpbmZvcm1hdGlvbiBncmFwaCkgZXhwcmVzc2VkIHZpYSB0aGVpciByZXNvdXJjZVVSSXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB2YWxcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgY3JlYXRvcih2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ2NyZWF0b3InLCB2YWwsIG1vZGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGFsbCBjb250cmlidXRvcnMgKGluIHRoZSBlbnRyeSBpbmZvcm1hdGlvbiBncmFwaCkgZXhwcmVzc2VkIHZpYSB0aGVpciByZXNvdXJjZVVSSXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB2YWxcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgY29udHJpYnV0b3JzKHZhbCwgbW9kaWZpZXIpIHtcbiAgICByZXR1cm4gdGhpcy5fcSgnY29udHJpYnV0b3JzJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBvbmx5IGVudHJpZXMgdGhhdCBhcmUgcGFydCBvZiB0aGUgZ2l2ZW4gbGlzdHMsIGlkZW50aWZpZWQgdmlhIHRoZWlyIHJlc291cmNlVVJJcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBsaXN0cyh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ2xpc3RzJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBlbnRyaWVzIHRoYXQgYXJlIGNyZWF0ZWQgYXQgdGhlIHNwZWNpZmljIGRhdGUsIG1vc3QgdXNlZnVsIGZvciBzb3J0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGNyZWF0ZWQodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdjcmVhdGVkJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBlbnRyaWVzIHRoYXQgYXJlIG1vZGlmaWVkIGF0IHRoZSBzcGVjaWZpYyBkYXRlLCBtb3N0IHVzZWZ1bCBmb3Igc29ydGluZy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBtb2RpZmllZCh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ21vZGlmaWVkJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBlbnRyaWVzIHdpdGggdGhlIGdpdmVuIGVudHJ5IHR5cGUsIHVzZSB0aGUgdmFsdWVzIGluIHtAbGluayBzdG9yZS90eXBlc30sIGUuZy5cbiAgICogc3EuZW50cnlUeXBlKHR5cGVzLkVUX0xJTkspLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGVudHJ5VHlwZSh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ2VudHJ5VHlwZScsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgZW50cmllcyB3aXRoIHRoZSBnaXZlbiBncmFwaCB0eXBlLCB1c2UgdGhlIHZhbHVlcyBpbiB7QGxpbmsgc3RvcmUvdHlwZXN9LCBlLmcuXG4gICAqIHNxLmVudHJ5VHlwZSh0eXBlcy5HVF9VU0VSKS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBncmFwaFR5cGUodmFsLCBtb2RpZmllciA9IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5fcSgnZ3JhcGhUeXBlJywgdmFsLCBtb2RpZmllcik7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBlbnRyaWVzIHdpdGggdGhlIGdpdmVuIHJlc291cmNlIHR5cGUsIHVzZSB0aGUgdmFsdWVzIGluIHtAbGluayBzdG9yZS90eXBlc30sIGUuZy5cbiAgICogc3EuZW50cnlUeXBlKHR5cGVzLlJUX0lORk9STUFUSU9OUkVTT1VSQ0UpLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHJlc291cmNlVHlwZSh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ3Jlc291cmNlVHlwZScsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgb25seSBwdWJsaWMgZW50cmllcy4gV2FybmluZywgaW5kaXZpZHVhbCBlbnRyeXMgcHVibGljIGZsYWcgaXMgaW5oZXJpdGVkIGZyb21cbiAgICogc3Vycm91bmRpbmcgY29udGV4dCBhbmQgaWYgdGhlIGNvbnRleHQgQUNMIGlzIHVwZGF0ZWQgdGhlIGVudHJ5cyBhcmUgbm90IHJlaW5kZXhlZFxuICAgKiBhdXRvbWF0aWNhbGx5LiBIZW5jZSwgdGhpcyBmbGFnIG1heSBiZSBpbmNvcnJlY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZX0gaXNQdWJsaWNcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgcHVibGljUmVhZChpc1B1YmxpYyA9IHRydWUpIHtcbiAgICByZXR1cm4gdGhpcy5fcSgncHVibGljJywgaXNQdWJsaWMgPT09IHRydWUgPyAndHJ1ZScgOiAnZmFsc2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIG9ubHkgZW50cmllcyB3aXRoIGV4cGxpY2l0bHkgQUNMIHN0YXRpbmcgdXNlcihzKSBoYXMgYWRtaW4gcmlnaHRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSB2YWxcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgYWRtaW4odmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdhY2wuYWRtaW4nLCB2YWwsIG1vZGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIG9ubHkgZW50cmllcyB3aXRoIGV4cGxpY2l0bHkgQUNMIHN0YXRpbmcgdXNlcihzKSBoYXMgbWV0YWRhdGEgcmVhZCByaWdodHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBtZXRhZGF0YVJlYWQodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdhY2wubWV0YWRhdGEucicsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgb25seSBlbnRyaWVzIHdpdGggZXhwbGljaXRseSBBQ0wgc3RhdGluZyB1c2VyKHMpIGhhcyBtZXRhZGF0YSB3cml0ZSAoYW5kIHJlYWQpIHJpZ2h0c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIG1ldGFkYXRhV3JpdGUodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdhY2wubWV0YWRhdGEucncnLCB2YWwsIG1vZGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIG9ubHkgZW50cmllcyB3aXRoIGV4cGxpY2l0bHkgQUNMIHN0YXRpbmcgdXNlcihzKSBoYXMgcmVzb3VyY2UgcmVhZCByaWdodHNcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IHZhbFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICByZXNvdXJjZVJlYWQodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdhY2wucmVzb3VyY2UucicsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgb25seSBlbnRyaWVzIHdpdGggZXhwbGljaXRseSBBQ0wgc3RhdGluZyB1c2VyKHMpIGhhcyByZXNvdXJjZSB3cml0ZSAoYW5kIHJlYWQpIHJpZ2h0c1xuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHJlc291cmNlV3JpdGUodmFsLCBtb2RpZmllcikge1xuICAgIHJldHVybiB0aGlzLl9xKCdhY2wucmVzb3VyY2UucncnLCB2YWwsIG1vZGlmaWVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXRjaGVzIGVudHJpZXMgd2l0aCB3aXRoIHNwZWNpZmljIHN0YXR1cyAoZXhwcmVzc2VkIGluIGVudHJ5IGluZm9ybWF0aW9uIGdyYXBoKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xhcnJheX0gdmFsXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHN0YXR1cyh2YWwsIG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3EoJ3N0YXR1cycsIHZhbCwgbW9kaWZpZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgb25seSBlbnRyaWVzIHdpdGhpbiBzcGVjaWZpZWQgY29udGV4dChzKVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ3xzdG9yZS9Db250ZXh0fSBjb250ZXh0IGVpdGhlciBhIGNvbnRleHRJZCwgdGhlIHJlc291cmNlVVJJIGZvciBhXG4gICArICAgICAqIGNvbnRleHQsIGEgc3RvcmUvQ29udGV4dCBpbnN0YW5jZSBvciBhbiBhcnJheSBjb250YWluaW5nIGFueSBvZiB0aG9zZS4gSW4gY2FzZSBvZiBhXG4gICArICAgICAqIHN0cmluZywgZWl0aGVyIGRpcmVjdGx5IG9yIHdpdGhpbiB0aGUgYXJyYXkgYW5kIGl0IHN0YXJ0cyB3aXRoICdodHRwJyBpdCBpcyBhc3N1bWVkIGl0IGlzXG4gICArICAgICAqIHRoZSByZXNvdXJjZVVSSSBvZiB0aGUgY29udGV4dCwgb3RoZXJ3aXNlIHRoZSBjb250ZXh0IGlzIGFzc3VtZWQgdG8gYmUgYSBjb250ZXh0SWQuXG4gICAqIEBwYXJhbSB7dHJ1ZXxmYWxzZXxzdHJpbmd9IG1vZGlmaWVyXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGNvbnRleHQoY29udGV4dCwgbW9kaWZpZXIgPSBudWxsKSB7XG4gICAgY29uc3QgZiA9IChjKSA9PiB7XG4gICAgICBpZiAoYyAmJiBjLmdldFJlc291cmNlVVJJKSB7XG4gICAgICAgIHJldHVybiBjLmdldFJlc291cmNlVVJJKCk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJyAmJiBjICE9PSAnJykge1xuICAgICAgICBpZiAoYy5pbmRleE9mKCdodHRwJykgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gYztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW50cnlzdG9yZS5nZXRDb250ZXh0QnlJZChjKS5nZXRSZXNvdXJjZVVSSSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRleHQpKSB7XG4gICAgICBjb25zdCByZXNvdXJjZVVSSUFyciA9IGNvbnRleHQubWFwKGYpLmZpbHRlcih2ID0+IHYgIT09IG51bGwpO1xuICAgICAgaWYgKHJlc291cmNlVVJJQXJyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fcSgnY29udGV4dCcsIHJlc291cmNlVVJJQXJyLCBtb2RpZmllcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHJlc291cmNlVVJJID0gZihjb250ZXh0KTtcbiAgICAgIGlmIChyZXNvdXJjZVVSSSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcSgnY29udGV4dCcsIHJlc291cmNlVVJJLCBtb2RpZmllcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHJvdmlkZSBhIHF1ZXJ5IGluIHRoZSBmb3JtIG9mIGFuIG9iamVjdCBzdHJ1Y3R1cmUgd2hlcmUgdGhlIHRvcGxldmVsIGF0dHJpYnV0ZXNcbiAgICogYXJlIGRpc2p1bmN0aXZlIChPUjplZCB0b2dldGhlcikuIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSB3aWxsIHF1ZXJ5IGZvciB0aGluZ3MgdGhhdFxuICAgKiBhcmUgdHlwZWQgYXMgdmVkZ2V0YWJsZXMgQU5EIGhhdmUgdGhlIHdvcmQgJ3RvbWF0bycgaW4gZWl0aGVyIHRoZSB0aXRsZSBPUiBkZXNjcmlwdGlvbjpcbiAgICogcXVlcnkucmRmVHlwZSgnZXg6VmVkZ2V0YWJsZSkub3Ioe1xuICAgKiAgIHRpdGxlOiAndG9tYXRvJyxcbiAgICogICBkZXNjcmlwdGlvbjogJ3RvbWF0bydcbiAgICogfSk7XG4gICAqXG4gICAqIE5vdGUsIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QgKCdvcicpIGRvZXMgbm90IHJlZmVycyB0byBob3cgdGhlIG9iamVjdCBzdHJ1Y3R1cmUgaXNcbiAgICogY29tYmluZWQgd2l0aCB0aGUgcmVzdCBvZiB0aGUgcXVlcnksIG9ubHkgaG93IHRoZSBpbm5lciBwYXJ0cyBvZiB0aGUgb2JqZWN0IHN0cnVjdHVyZVxuICAgKiBpcyBjb21iaW5lZC4gVG8gY2hhbmdlIHRoZSB0b3BsZXZlbCBiZWhhdmlvdXIgb2YgdGhlIHF1ZXJ5IGZyb20gYW4gYW5kIHRvIGFuIG9yLFxuICAgKiB1c2UgdGhlIGRpc2p1bmN0aXZlIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHN0cnVjdHVyZVxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBvcihzdHJ1Y3R1cmUpIHtcbiAgICB0aGlzLl9vci5hZGQoc3RydWN0dXJlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgcXVlcnkgaW4gdGhlIGZvcm0gb2YgYW4gb2JqZWN0IHN0cnVjdHVyZSB3aGVyZSB0aGUgdG9wbGV2ZWwgYXR0cmlidXRlc1xuICAgKiBhcmUgY29uanVuY3RpdmUgKEFORDplZCB0b2dldGhlcikuIFRoZSBmb2xsb3dpbmcgZXhhbXBsZSB3aWxsIHF1ZXJ5IGZvciB0aGluZ3MgdGhhdFxuICAgKiBhcmUgdHlwZWQgYXMgdmVkZ2V0YWJsZXMgT1IgdHlwZWQgYXMgZnJ1aXQgQU5EIGhhcyBhIHRpdGxlIHRoYXQgY29udGFpbnMgdGhlIHdvcmQgJ29yYW5nZSc6XG4gICAqIHF1ZXJ5LmRpc2p1bmN0aXZlKCkucmRmVHlwZSgnZXg6VmVkZ2V0YWJsZSkuYW5kKHtcbiAgICogICByZGZUeXBlOiAnZXg6RnJ1aXQnLFxuICAgKiAgIHRpdGxlOiAnT3JhbmdlJyxcbiAgICogfSk7XG4gICAqXG4gICAqIE5vdGUsIHRoZSBuYW1lIG9mIHRoZSBtZXRob2QgKCdhbmQnKSBkb2VzIG5vdCByZWZlcnMgdG8gaG93IHRoZSBvYmplY3Qgc3RydWN0dXJlIGlzXG4gICAqIGNvbWJpbmVkIHdpdGggdGhlIHJlc3Qgb2YgdGhlIHF1ZXJ5LCBvbmx5IGhvdyB0aGUgaW5uZXIgcGFydHMgb2YgdGhlIG9iamVjdCBzdHJ1Y3R1cmVcbiAgICogaXMgY29tYmluZWQuIEluIHRoaXMgZXhhbXBsZSB3ZSBoYXZlIGNoYW5nZSB0aGUgdG9wbGV2ZWwgYmVoYXZpb3VyIG9mIHRoZSBxdWVyeSB0b1xuICAgKiBiZWNvbWUgZGlzanVuY3RpdmUgKGJlaW5nIE9SOmVkIHRvZ2V0aGVyKSwgdGhpcyBpcyB0byBtYWtlIHRoZSBxdWVyeSBtb3JlIHJlcHJlc2VudGF0aXZlXG4gICAqIHNpbmNlIHRoZXJlIGlzIG5vIG5lZWQgZm9yIHRoZSBncm91cGluZyBvZiB0aGUgb2JqZWN0IHN0cnVjdHVyZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdHJ1Y3R1cmVcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgYW5kKHN0cnVjdHVyZSkge1xuICAgIHRoaXMuX2FuZC5hZGQoc3RydWN0dXJlKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgLy9lc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgdGl0bGVfbGFuZyh0aXRsZSwgbGFuZ3VhZ2UpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBJZiBhIHRpdGxlIGhhcyBhIGxhbmd1YWdlIHNldCwgYSBkeW5hbWljIGZpZWxkIGlzIGNyZWF0ZWQgd2l0aCB0aGUgcGF0dGVybiBcInRpdGxlLmVuXCIsXG4gICAqIHdpdGhvdXQgbXVsdGkgdmFsdWUgc3VwcG9ydC4gVGhpcyBpcyB1c2VkIGluIHRoZSBjb250ZXh0IG9mIHNvcnRpbmcuXG4gICAqIEBwYXJhbSB0aXRsZSB7U3RyaW5nfSB0aGUgdGl0bGUgdG8gc2VhcmNoIGZvclxuICAgKiBAcGFyYW0gbGFuZ3VhZ2Uge1N0cmluZ30gdGhlIGxhbmd1YWdlIG9mIHRoZSB0aXRsZSBmb3IgaW5zdGFuY2UgXCJlblwiLlxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICB0aXRsZVdpdGhMYW5ndWFnZSh0aXRsZSwgbGFuZ3VhZ2UpIHtcbiAgICB0aGlzLl90aXRsZV9sYW5nID0geyB2YWx1ZTogdGl0bGUsIGxhbmd1YWdlIH07XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBzcGVjaWZpYyBwcm9wZXJ0eSB2YWx1ZSBjb21iaW5hdGlvbnMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IG9iamVjdFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcGFyYW0ge3RleHR8c3RyaW5nfSBbaW5kZXhUeXBlPW5ncmFtXSAnbmdyYW0nIGNvcnJlc3BvbmRzIHRvIHBhcnRpYWwgc3RyaW5nXG4gICAqIG1hdGNoaW5nLCBzdHJpbmcgY29ycmVzcG9uZHMgdG8gZXhhY3Qgc3RyaW5nIG1hdGNoaW5nIGFuZCB0ZXh0IGNvcnJlc3BvbmRzIHRvIHdvcmQgbWF0Y2hpbmcuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlbGF0ZWQ9ZmFsc2VdIHdpbGwgc2VhcmNoIGluIHJlbGF0ZWQgcHJvcGVydGllcyBpZiB0cnVlLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGxpdGVyYWxQcm9wZXJ0eShwcmVkaWNhdGUsIG9iamVjdCwgbW9kaWZpZXIsIGluZGV4VHlwZSA9ICduZ3JhbScsIHJlbGF0ZWQgPSBmYWxzZSkge1xuICAgIGNvbnN0IGtleSA9IHNob3J0ZW4ocHJlZGljYXRlKTtcbiAgICBsZXQgbm9kZXR5cGU7XG4gICAgc3dpdGNoIChpbmRleFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RleHQnOlxuICAgICAgICBub2RldHlwZSA9ICdsaXRlcmFsX3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgIG5vZGV0eXBlID0gJ2xpdGVyYWxfcyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbmdyYW0nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgbm9kZXR5cGUgPSAnbGl0ZXJhbCc7XG4gICAgfVxuICAgIChyZWxhdGVkID8gdGhpcy5yZWxhdGVkUHJvcGVydGllcyA6IHRoaXMucHJvcGVydGllcykucHVzaCh7XG4gICAgICBtZDU6IGtleSxcbiAgICAgIHByZWQ6IHByZWRpY2F0ZSxcbiAgICAgIG9iamVjdCxcbiAgICAgIG1vZGlmaWVyLFxuICAgICAgbm9kZXR5cGUsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogTWF0Y2hlcyBzcGVjaWZpYyBwcm9wZXJ0eSB2YWx1ZSBjb21iaW5hdGlvbnMgd2hlbiB0aGUgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAgICogTm90ZSB0aGF0IHRoZSBpbnRlZ2VyIHZhbHVlcyBhcmUgc2luZ2xlIHZhbHVlIHBlciBwcm9wZXJ0eSBhbmQgY2FuIGJlIHVzZWQgZm9yIHNvcnRpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd8YXJyYXl9IG9iamVjdFxuICAgKiBAcGFyYW0ge3RydWV8ZmFsc2V8c3RyaW5nfSBtb2RpZmllclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IHJlbGF0ZWQgLSB3aWxsIHNlYXJjaCBpbiByZWxhdGVkIHByb3BlcnRpZXMgaWYgdHJ1ZSwgZGVmYXVsdCBpcyBmYWxzZVxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBpbnRlZ2VyUHJvcGVydHkocHJlZGljYXRlLCBvYmplY3QsIG1vZGlmaWVyLCByZWxhdGVkID0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXkgPSBzaG9ydGVuKHByZWRpY2F0ZSk7XG4gICAgKHJlbGF0ZWQgPyB0aGlzLnJlbGF0ZWRQcm9wZXJ0aWVzIDogdGhpcy5wcm9wZXJ0aWVzKS5wdXNoKHtcbiAgICAgIG1kNToga2V5LFxuICAgICAgcHJlZDogcHJlZGljYXRlLFxuICAgICAgb2JqZWN0LFxuICAgICAgbW9kaWZpZXIsXG4gICAgICBub2RldHlwZTogJ2ludGVnZXInLFxuICAgIH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIE1hdGNoZXMgc3BlY2lmaWMgcHJvcGVydHkgdmFsdWUgY29tYmluYXRpb25zIHdoZW4gdGhlIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAqIE5vdGUgdGhhdCB0aGUgaW50ZWdlciB2YWx1ZXMgYXJlIHNpbmdsZSB2YWx1ZSBwZXIgcHJvcGVydHkgYW5kIGNhbiBiZSB1c2VkIGZvciBzb3J0aW5nLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJlZGljYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfGFycmF5fSBvYmplY3RcbiAgICogQHBhcmFtIHt0cnVlfGZhbHNlfHN0cmluZ30gbW9kaWZpZXJcbiAgICogQHBhcmFtIHtib29sZWFufSByZWxhdGVkIC0gd2lsbCBzZWFyY2ggaW4gcmVsYXRlZCBwcm9wZXJ0aWVzIGlmIHRydWUsIGRlZmF1bHQgaXMgZmFsc2VcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgdXJpUHJvcGVydHkocHJlZGljYXRlLCBvYmplY3QsIG1vZGlmaWVyLCByZWxhdGVkID0gZmFsc2UpIHtcbiAgICBjb25zdCBrZXkgPSBzaG9ydGVuKHByZWRpY2F0ZSk7XG5cbiAgICAocmVsYXRlZCA/IHRoaXMucmVsYXRlZFByb3BlcnRpZXMgOiB0aGlzLnByb3BlcnRpZXMpLnB1c2goe1xuICAgICAgbWQ1OiBrZXksXG4gICAgICBwcmVkOiBwcmVkaWNhdGUsXG4gICAgICBvYmplY3Q6IEFycmF5LmlzQXJyYXkob2JqZWN0KSA/IG9iamVjdC5tYXAobyA9PiBuYW1lc3BhY2VzLmV4cGFuZChvKSkgOlxuICAgICAgICBuYW1lc3BhY2VzLmV4cGFuZChvYmplY3QpLFxuICAgICAgbW9kaWZpZXIsXG4gICAgICBub2RldHlwZTogJ3VyaScsXG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgcGFnaW5hdGlvbiBsaW1pdC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBsaW1pdFxuICAgKiBAcmV0dXJuIHtzdG9yZS9Tb2xyUXVlcnl9XG4gICAqL1xuICBsaW1pdChsaW1pdCkge1xuICAgIHRoaXMuX2xpbWl0ID0gbGltaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcGFnaW5hdGlvbiBsaW1pdCBpZiBpdCBzZXQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ3xudW1iZXJ9XG4gICAqL1xuICBnZXRMaW1pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbGltaXQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHBhcmFtZXRlciBcInNvcnRcIiBjYW4gYmUgdXNlZCBmb3IgU29sci1zdHlsZSBzb3J0aW5nLCBlLmcuIFwic29ydD10aXRsZSthc2MsbW9kaWZpZWQrZGVzY1wiLlxuICAgKiBUaGUgZGVmYXVsdCBzb3J0aW5nIHZhbHVlIGlzIHRvIHNvcnQgYWZ0ZXIgdGhlIHNjb3JlIChyZWxldmFuY3kpIGFuZCB0aGUgbW9kaWZpY2F0aW9uIGRhdGUuXG4gICAqIEFsbCBzdHJpbmcgYW5kIG5vbi1tdWx0aSB2YWx1ZSBmaWVsZHMgY2FuIGJlIHVzZWQgZm9yIHNvcnRpbmcsIHRoaXMgYmFzaWNhbGx5IGV4Y2x1ZGVzIHRpdGxlLFxuICAgKiBkZXNjcmlwdGlvbiBhbmQga2V5d29yZHMsXG4gICAqIGJ1dCBhbGxvd3Mgc29ydGluZyBhZnRlciBlLmcuIHRpdGxlLmVuLlxuICAgKiBJZiBubyBzb3J0IGlzIGV4cGxpY2l0bHkgZ2l2ZW4gdGhlIGRlZmF1bHQgc29ydCBzdHJpbmcgdXNlZCBpcyBcInNjb3JlK2FzY1wiLlxuICAgKiBAcGFyYW0gc29ydCB7U3RyaW5nfSBhIGxpc3Qgb2YgZmllbGRzIHRvZ2V0aGVyIHdpdGggJythc2MnIG9yICcrZGVzYycsIGZpcnN0IGZpZWxkIGhhcyB0aGVcbiAgICogaGlnaGVzdCBwcmlvcml0eSB3aGVuIHNvcnRpbmcuXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHNvcnQoc29ydCkge1xuICAgIHRoaXMuX3NvcnQgPSBzb3J0O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhbiBleHBsaWNpdCBvZmZzZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gb2Zmc2V0XG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIG9mZnNldChvZmZzZXQpIHtcbiAgICB0aGlzLl9vZmZzZXQgPSBvZmZzZXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGZhY2V0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVsYXRlZD1mYWxzZV1cbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgZmFjZXQoZmFjZXQsIHByZWRpY2F0ZSwgcmVsYXRlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5mYWNldHMgPSB0aGlzLmZhY2V0cyB8fCBbXTtcbiAgICBpZiAocHJlZGljYXRlKSB7XG4gICAgICB0aGlzLmZhY2V0MnByZWRpY2F0ZSA9IHRoaXMuZmFjZXQycHJlZGljYXRlIHx8IHt9O1xuICAgICAgdGhpcy5mYWNldDJwcmVkaWNhdGVbZmFjZXRdID0gbmFtZXNwYWNlcy5leHBhbmQocHJlZGljYXRlKTtcbiAgICAgIGlmIChyZWxhdGVkKSB7XG4gICAgICAgIHRoaXMucmVsYXRlZEZhY2V0cHJlZGljYXRlc1twcmVkaWNhdGVdID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZmFjZXRwcmVkaWNhdGVzW3ByZWRpY2F0ZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZhY2V0cy5wdXNoKGZhY2V0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGluY2x1ZGUgbGl0ZXJhbCBmYWNldHMgZm9yIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZWRpY2F0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWxhdGVkPWZhbHNlXSB3aGV0aGVyIHRoZSBmYWNldCBpcyBvbiB0aGUgcmVsYXRlZCBwcmVkaWNhdGVzLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGxpdGVyYWxGYWNldChwcmVkaWNhdGUsIHJlbGF0ZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZmFjZXQoYCR7cmVsYXRlZCA/ICdyZWxhdGVkLicgOiAnJ31tZXRhZGF0YS5wcmVkaWNhdGUubGl0ZXJhbF9zLiR7c2hvcnRlbihwcmVkaWNhdGUpfWAsIHByZWRpY2F0ZSwgcmVsYXRlZCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCB0byBpbmNsdWRlIFVSSSBmYWNldHMgZm9yIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZWRpY2F0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWxhdGVkPWZhbHNlXSB3aGV0aGVyIHRoZSBmYWNldCBpcyBvbiB0aGUgcmVsYXRlZCBwcmVkaWNhdGVzLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIHVyaUZhY2V0KHByZWRpY2F0ZSwgcmVsYXRlZCA9IGZhbHNlKSB7XG4gICAgdGhpcy5mYWNldChgJHtyZWxhdGVkID8gJ3JlbGF0ZWQuJyA6ICcnfW1ldGFkYXRhLnByZWRpY2F0ZS51cmkuJHtzaG9ydGVuKHByZWRpY2F0ZSl9YCwgcHJlZGljYXRlLCByZWxhdGVkKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXF1ZXN0IHRvIGluY2x1ZGUgaW50ZWdlciBmYWNldHMgZm9yIHRoZSBnaXZlbiBwcmVkaWNhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHByZWRpY2F0ZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWxhdGVkPWZhbHNlXSB3aGV0aGVyIHRoZSBmYWNldCBpcyBvbiB0aGUgcmVsYXRlZCBwcmVkaWNhdGVzLCBkZWZhdWx0IGlzIGZhbHNlXG4gICAqIEByZXR1cm4ge3N0b3JlL1NvbHJRdWVyeX1cbiAgICovXG4gIGludGVnZXJGYWNldChwcmVkaWNhdGUsIHJlbGF0ZWQgPSBmYWxzZSkge1xuICAgIHRoaXMuZmFjZXQoYCR7cmVsYXRlZCA/ICdyZWxhdGVkLicgOiAnJ31tZXRhZGF0YS5wcmVkaWNhdGUuaW50ZWdlci4ke3Nob3J0ZW4ocHJlZGljYXRlKX1gLCBwcmVkaWNhdGUsIHJlbGF0ZWQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFRlbGwgdGhlIHF1ZXJ5IGNvbnN0cnVjdGlvbiB0byBtYWtlIHRoZSBmaWVsZHMgYWRkZWQgdmlhIHRoZSBwcm9wZXJ0eSBtZXRob2RzXG4gICAqICh1cmlQcm9wZXJ0eSwgbGl0ZXJhbFByb3BlcnR5IGFuZCBpbnRlZ2VyUHJvcGVydHkpIHRvIGJlIGRpc2p1bmN0aXZlIHJhdGhlciB0aGFuXG4gICAqIGNvbmp1bmN0aXZlLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogICAgIGVzLm5ld1NvbHJRdWVyeSgpLmRpc2p1bmN0aXZlUHJvcGVydGllcygpLmxpdGVyYWxQcm9wZXJ0eShcImRjdGVybXM6dGl0bGVcIiwgXCJiYW5hbmFcIilcbiAgICogICAgICAgICAgLnVyaVByb3BlcnR5KFwiZGN0ZXJtczpzdWJqZWN0XCIsIFwiZXg6QmFuYW5hXCIpO1xuICAgKlxuICAgKiBXaWxsIHNlYXJjaCBmb3IgZW50cmllcyB0aGF0IGhhdmUgZWl0aGVyIGEgXCJiYW5hbmFcIiBpbiB0aGUgdGl0bGUgb3IgYSByZWxhdGlvbiB0b1xuICAgKiBleDpCYW5hbmEgdmlhIGRjdGVybXM6c3ViamVjdC4gVGhlIGRlZmF1bHQsIHdpdGhvdXQgZGlzanVuY3RpdmVQcm9wZXJ0aWVzIGJlaW5nIGNhbGxlZFxuICAgKiBpcyB0byBjcmVhdGUgYSBjb25qdW5jdGlvbiwgaS5lLiBBTkQgdGhlbSB0b2dldGhlci5cbiAgICpcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgZGlzanVuY3RpdmVQcm9wZXJ0aWVzKCkge1xuICAgIHRoaXMuZGlzanVuY3RpdmVQcm9wZXJ0aWVzID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBUZWxsIHRoZSBxdWVyeSBjb25zdHJ1Y3Rpb24gdG8gbWFrZSB0b3AgbGV2ZWwgZmllbGRzIGRpc2p1bmN0aXZlIHJhdGhlciB0aGFuXG4gICAqIGNvbmp1bmN0aXZlLiBGb3IgZXhhbXBsZVxuICAgKlxuICAgKiAgICAgZXMubmV3U29sclF1ZXJ5KCkuZGlzanVuY3RpdmUoKS50aXRsZShcImJhbmFuYVwiKS5kZXNjcmlwdGlvbihcInRvbWF0b1wiKVxuICAgKlxuICAgKiBXaWxsIHNlYXJjaCBmb3IgZW50cmllcyB0aGF0IGhhdmUgZWl0aGVyIGEgXCJiYW5hbmFcIiBpbiB0aGUgdGl0bGUgb3IgXCJ0b21hdG9cIiBpbiB0aGVcbiAgICogZGVzY3JpcHRpb24gcmF0aGVyIHRoYW4gZW50cmllcyB0aGF0IGhhdmUgYm90aCB3aGljaCBpcyB0aGUgZGVmYXVsdC5cbiAgICpcbiAgICogQHJldHVybiB7c3RvcmUvU29sclF1ZXJ5fVxuICAgKi9cbiAgZGlzanVuY3RpdmUoKSB7XG4gICAgdGhpcy5kaXNqdW5jdGl2ZSA9IHRydWU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29uc3RydWN0IGEgU2VhcmNoTGlzdCBmcm8gdGhpcyBTb2xyUXVlcnkuXG4gICAqXG4gICAqIEBwYXJhbSBhc3luY0NhbGxUeXBlXG4gICAqIEByZXR1cm5zIHtzdG9yZS9TZWFyY2hMaXN0fVxuICAgKi9cbiAgbGlzdChhc3luY0NhbGxUeXBlKSB7XG4gICAgcmV0dXJuIG5ldyBTZWFyY2hMaXN0KHRoaXMuX2VudHJ5c3RvcmUsIHRoaXMsIGFzeW5jQ2FsbFR5cGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByb2R1Y2VzIHRoZSBhY3R1YWwgcXVlcnkgdG8gdGhlIEVudHJ5U3RvcmUgQVBJLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqIEBwcm90ZWN0ZWRcbiAgICovXG4gIGdldFF1ZXJ5KCkge1xuICAgIGNvbnN0IGFuZCA9IFtdO1xuICAgIGlmICh0aGlzLl90aXRsZV9sYW5nICE9IG51bGwpIHtcbiAgICAgIGFuZC5wdXNoKGB0aXRsZS4ke3RoaXMuX3RpdGxlX2xhbmcubGFuZ306JHtzb2xyRnJpZW5kbHkodGhpcy5fdGl0bGVfbGFuZy5sYW5nLFxuICAgICAgICB0aGlzLl90aXRsZV9sYW5nLnZhbHVlKX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLnBhcmFtcy5mb3JFYWNoKCh2LCBrZXkpID0+IHtcbiAgICAgIGNvbnN0IG1vZGlmaWVyID0gdGhpcy5tb2RpZmllcnMuZ2V0KGtleSk7XG4gICAgICBpZiAoKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgJiYgdiAhPT0gJycpIHtcbiAgICAgICAgaWYgKG1vZGlmaWVyID09PSB0cnVlIHx8IG1vZGlmaWVyID09PSAnbm90Jykge1xuICAgICAgICAgIGFuZC5wdXNoKGBOT1QoJHtrZXl9OiR7c29sckZyaWVuZGx5KGtleSwgdil9KWApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFuZC5wdXNoKGAke2tleX06JHtzb2xyRnJpZW5kbHkoa2V5LCB2KX1gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHYpICYmIHYubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBvciA9IFtdO1xuICAgICAgICB2LmZvckVhY2goKG92KSA9PiB7XG4gICAgICAgICAgaWYgKCh0eXBlb2Ygb3YgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgb3IucHVzaChgJHtrZXl9OiR7c29sckZyaWVuZGx5KGtleSwgb3YpfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtb2RpZmllciA9PT0gdHJ1ZSB8fCBtb2RpZmllciA9PT0gJ25vdCcpIHtcbiAgICAgICAgICBhbmQucHVzaChgTk9UKCR7b3Iuam9pbignK09SKycpfSlgKTtcbiAgICAgICAgfSBlbHNlIGlmIChtb2RpZmllciA9PT0gJ2FuZCcpIHtcbiAgICAgICAgICBhbmQucHVzaChgKCR7b3Iuam9pbignK0FORCsnKX0pYCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYW5kLnB1c2goYCgke29yLmpvaW4oJytPUisnKX0pYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmICh0aGlzLnJlbGF0ZWRQcm9wZXJ0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IG9yID0gW107XG4gICAgICB0aGlzLnJlbGF0ZWRQcm9wZXJ0aWVzLmZvckVhY2goKHByb3ApID0+IHtcbiAgICAgICAgY29uc3Qgb2JqID0gcHJvcC5vYmplY3Q7XG4gICAgICAgIGNvbnN0IGtleSA9IGByZWxhdGVkLm1ldGFkYXRhLnByZWRpY2F0ZS4ke3Byb3Aubm9kZXR5cGV9LiR7cHJvcC5tZDV9YDtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgb3IucHVzaChgJHtrZXl9OiR7c29sckZyaWVuZGx5KGtleSwgb2JqLCB0aGlzLnJlbGF0ZWRGYWNldHByZWRpY2F0ZXNbcHJvcC5wcmVkXSl9YCk7XG4gICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopICYmIG9iai5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgb2JqLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICAgIG9yLnB1c2goYCR7a2V5fToke3NvbHJGcmllbmRseShrZXksIG8sIHRoaXMucmVsYXRlZEZhY2V0cHJlZGljYXRlc1twcm9wLnByZWRdKX1gKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBhbmQucHVzaChgKCR7b3Iuam9pbignK09SKycpfSlgKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGlzanVuY3RpdmVQcm9wZXJ0aWVzIHx8IHRoaXMuZGlzanVuY3RpdmUpIHtcbiAgICAgIGNvbnN0IG9yID0gW107XG4gICAgICB0aGlzLnByb3BlcnRpZXMuZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgICAgICBjb25zdCBvYmogPSBwcm9wLm9iamVjdDtcbiAgICAgICAgY29uc3Qga2V5ID0gYG1ldGFkYXRhLnByZWRpY2F0ZS4ke3Byb3Aubm9kZXR5cGV9LiR7cHJvcC5tZDV9YDtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgb3IucHVzaChgJHtrZXl9OiR7c29sckZyaWVuZGx5KGtleSwgb2JqLCB0aGlzLmZhY2V0cHJlZGljYXRlc1twcm9wLnByZWRdKX1gKTtcbiAgICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiYgb2JqLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvYmouZm9yRWFjaCgobykgPT4ge1xuICAgICAgICAgICAgb3IucHVzaChgJHtrZXl9OiR7c29sckZyaWVuZGx5KGtleSwgbywgdGhpcy5mYWNldHByZWRpY2F0ZXNbcHJvcC5wcmVkXSl9YCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKG9yLmxlbmd0aCA+IDApIHtcbiAgICAgICAgYW5kLnB1c2goYCgke29yLmpvaW4oJytPUisnKX0pYCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJvcGVydGllcy5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHByb3Aub2JqZWN0O1xuICAgICAgICBjb25zdCBrZXkgPSBgbWV0YWRhdGEucHJlZGljYXRlLiR7cHJvcC5ub2RldHlwZX0uJHtwcm9wLm1kNX1gO1xuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAocHJvcC5tb2RpZmllciA9PT0gdHJ1ZSB8fCBwcm9wLm1vZGlmaWVyID09PSAnbm90Jykge1xuICAgICAgICAgICAgYW5kLnB1c2goYE5PVCgke2tleX06JHtzb2xyRnJpZW5kbHkoa2V5LCBvYmosIHRoaXMuZmFjZXRwcmVkaWNhdGVzW3Byb3AucHJlZF0pfSlgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5kLnB1c2goYCR7a2V5fToke3NvbHJGcmllbmRseShrZXksIG9iaiwgdGhpcy5mYWNldHByZWRpY2F0ZXNbcHJvcC5wcmVkXSl9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGNvbnN0IG9yID0gW107XG4gICAgICAgICAgb2JqLmZvckVhY2goKG8pID0+IHtcbiAgICAgICAgICAgIG9yLnB1c2goYCR7a2V5fToke3NvbHJGcmllbmRseShrZXksIG8sIHRoaXMuZmFjZXRwcmVkaWNhdGVzW3Byb3AucHJlZF0pfWApO1xuICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgIGlmIChwcm9wLm1vZGlmaWVyID09PSB0cnVlIHx8IHByb3AubW9kaWZpZXIgPT09ICdub3QnKSB7XG4gICAgICAgICAgICBhbmQucHVzaChgTk9UKCR7b3Iuam9pbignK09SKycpfSlgKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3AubW9kaWZpZXIgPT09ICdhbmQnKSB7XG4gICAgICAgICAgICBhbmQucHVzaChgKCR7b3Iuam9pbignK0FORCsnKX0pYCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFuZC5wdXNoKGAoJHtvci5qb2luKCcrT1IrJyl9KWApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSwgdGhpcyk7XG4gICAgfVxuICAgIHRoaXMuX2FuZC5mb3JFYWNoKChzdHJ1Y3QpID0+IHtcbiAgICAgIGFuZC5wdXNoKGJ1aWxkUXVlcnkoc3RydWN0LCB0cnVlKSk7XG4gICAgfSk7XG4gICAgdGhpcy5fb3IuZm9yRWFjaCgoc3RydWN0KSA9PiB7XG4gICAgICBhbmQucHVzaChidWlsZFF1ZXJ5KHN0cnVjdCwgZmFsc2UpKTtcbiAgICB9KTtcblxuICAgIGxldCB0cmFpbCA9ICcnO1xuICAgIGlmICh0aGlzLl9saW1pdCAhPSBudWxsKSB7XG4gICAgICB0cmFpbCA9IGAmbGltaXQ9JHt0aGlzLl9saW1pdH1gO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb2Zmc2V0KSB7XG4gICAgICB0cmFpbCA9IGAke3RyYWlsfSZvZmZzZXQ9JHt0aGlzLl9vZmZzZXR9YDtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3NvcnQpIHtcbiAgICAgIHRyYWlsID0gYCR7dHJhaWx9JnNvcnQ9JHt0aGlzLl9zb3J0IHx8ICdzY29yZSthc2MnfWA7XG4gICAgfVxuICAgIGlmICh0aGlzLmZhY2V0cykge1xuICAgICAgdHJhaWwgKz0gYCZmYWNldEZpZWxkcz0ke3RoaXMuZmFjZXRzLmpvaW4oJywnKX1gO1xuICAgIH1cbiAgICByZXR1cm4gYCR7dGhpcy5fZW50cnlzdG9yZS5nZXRCYXNlVVJJKCl9c2VhcmNoP3R5cGU9c29sciZxdWVyeT0ke2FuZC5qb2luKHRoaXMuZGlzanVuY3RpdmUgPyAnK09SJyA6ICcrQU5EKycpfSR7dHJhaWx9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gcGFnZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZS48QXJyYXkuPEVudHJ5Pj59IHRoZSBwcm9taXNlIHdpbGwgcmV0dXJuIGFuIGVudHJ5LWFycmF5LlxuICAgKiBAc2VlIHtzdG9yZS9MaXN0LmdldEVudHJpZXN9XG4gICAqL1xuICBnZXRFbnRyaWVzKHBhZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0KCkuZ2V0RW50cmllcyhwYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gZnVuY1xuICAgKiBAcmV0dXJuIHtwcm9taXNlfVxuICAgKiBAc2VlIHtzdG9yZS9MaXN0LmZvckVhY2h9XG4gICAqL1xuICBmb3JFYWNoKGZ1bmMpIHtcbiAgICByZXR1cm4gdGhpcy5saXN0KCkuZm9yRWFjaChmdW5jKTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlc291cmNlIGZyb20gJy4vUmVzb3VyY2UnO1xuXG4vKipcbiAqIFN0cmluZyBpcyBhIHJlc291cmNlIGZvciBoYW5kbGluZyBzaW1wbGUgc3RyaW5ncyBvZiBkYXRhLlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL1N0cmluZ1xuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTdHJpbmdSZXNvdXJjZSBleHRlbmRzIFJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeVVSSSAtIFVSSSB0byBhbiBlbnRyeSB3aGVyZSB0aGlzIHJlc291cmNlIGlzIGNvbnRhaW5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlVVJJIC0gVVJJIHRvIHRoZSByZXNvdXJjZS5cbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeVN0b3JlfSBlbnRyeVN0b3JlIC0gdGhlIEFQSSdzIHJlcG9zaXRvcnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gdGhlIGFjdHVhbCBzdHJpbmcsIG1heSB0aGUgZW1wdHkgc3RyaW5nLCBidXQgbm90IG51bGwgb3IgdW5kZWZpbmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZW50cnlVUkksIHJlc291cmNlVVJJLCBlbnRyeVN0b3JlLCBkYXRhKSB7XG4gICAgc3VwZXIoZW50cnlVUkksIHJlc291cmNlVVJJLCBlbnRyeVN0b3JlKTsgLy8gQ2FsbCB0aGUgc3VwZXIgY29uc3RydWN0b3IuXG4gICAgdGhpcy5fZGF0YSA9IGRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybnMge3N0cmluZ30gbWF5IGJlIGFuIGVtcHR5IHN0cmluZywgbmV2ZXIgbnVsbCBvciB1bmRlZmluZWQuXG4gICAqL1xuICBnZXRTdHJpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGE7XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IHN0cmluZywgZG9lcyBub3Qgc2F2ZSBpdCB0byB0aGUgcmVwb3NpdG9yeSwgdXNlIGNvbW1pdCBmb3IgdGhhdC4gRS5nLlxuICAgKlxuICAgKiAgICAgc3RyaW5ncmVzb3VyY2Uuc2V0U3RyaW5nKFwiTmV3IHZhbHVlXCIpLmNvbW1pdCgpLnRoZW4oZnVuY3Rpb24oKSB7Li4ufSk7XG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgLSB0aGUgbmV3IHN0cmluZ1xuICAgKiBAcmV0dXJucyB7c3RvcmUvU3RyaW5nUmVzb3VyY2V9IGFsbG93cyBjaGFpbmluZyB3aXRoIGNvbW1pdC5cbiAgICogQHNlZSBzdG9yZS9TdHJpbmcjY29tbWl0XG4gICAqL1xuICBzZXRTdHJpbmcoc3RyaW5nKSB7XG4gICAgdGhpcy5fZGF0YSA9IHN0cmluZyB8fCAnJztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQdXNoZXMgdGhlIHN0cmluZyBiYWNrIHRvIHRoZSByZXBvc2l0b3J5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICogQHNlZSBzdG9yZS9TdHJpbmcjc2V0U3RyaW5nXG4gICAqL1xuICBjb21taXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5U3RvcmUuaGFuZGxlQXN5bmMoZXMuZ2V0UkVTVCgpLnB1dCh0aGlzLl9yZXNvdXJjZVVSSSwgdGhpcy5fZGF0YSksICdjb21taXRTdHJpbmcnKTtcbiAgfVxuXG4gIGdldFNvdXJjZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YTtcbiAgfVxufVxuIiwiaW1wb3J0IFJlc291cmNlIGZyb20gJy4vUmVzb3VyY2UnO1xuXG4vKipcbiAqIFVzZXIgaW5zdGFuY2VzIGFyZSByZXNvdXJjZXMgY29ycmVzcG9uZGluZyB0byB1c2VycyB0aGF0IGNhbiBiZSBhdXRoZW50aWNhdGVkIHRvIGFjY2Vzc1xuICogdGhlIEVudHJ5U3RvcmUgcmVwb3NpdG9yeS4gVGhlIHVzZXIgcmVzb3VyY2UgVVJJIGNhbiBiZSByZWZlcnJlZCB0byBmcm9tIGFjY2VzcyBjb250cm9sIGxpc3RzLlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL1VzZXJcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVXNlciBleHRlbmRzIFJlc291cmNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbnRyeVVSSSAtIFVSSSB0byBhbiBlbnRyeSB3aGVyZSB0aGlzIHJlc291cmNlIGlzIGNvbnRhaW5lZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlc291cmNlVVJJIC0gVVJJIHRvIHRoZSByZXNvdXJjZS5cbiAgICogQHBhcmFtIHtzdG9yZS9FbnRyeVN0b3JlfSBlbnRyeVN0b3JlIC0gdGhlIEFQSSdzIHJlcG9zaXRvcnkgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhIC0gaW5mb3JtYXRpb24gYWJvdXQgdGhlIHVzZXIsIGUuZy4gb2JqZWN0IHdpdGggbmFtZSBhbmQgaG9tZWNvbnRleHQuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbnRyeVVSSSwgcmVzb3VyY2VVUkksIGVudHJ5U3RvcmUsIGRhdGEpIHtcbiAgICBzdXBlcihlbnRyeVVSSSwgcmVzb3VyY2VVUkksIGVudHJ5U3RvcmUpO1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgbmFtZSBvZiB0aGUgdXNlciwgdGhpcyBpcyBhIGEgdW5pcXVlIG5hbWUgKHVzZXJuYW1lKSBpbiB0aGUgY3VycmVudCByZXBvc2l0b3J5J3NcbiAgICogX3ByaW5jaXBhbHMgY29udGV4dC5cbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIGdldE5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEubmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgbmFtZSAodXNlcm5hbWUpLCBpdCB3aWxsIG5vdCBzdWNjZWVkIGlmIGl0IGlzIGFscmVhZHkgaW4gdXNlLCBmb3IgaW5zdGFuY2UgYnlcbiAgICogYW5vdGhlciB1c2VyIG9yIGdyb3VwLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHNldE5hbWUobmFtZSkge1xuICAgIGNvbnN0IG9sZE5hbWUgPSB0aGlzLl9kYXRhLm5hbWU7XG4gICAgdGhpcy5fZGF0YS5uYW1lID0gbmFtZTtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZS5oYW5kbGVBc3luYyhlcy5nZXRSRVNUKCkucHV0KHRoaXMuX3Jlc291cmNlVVJJLCBKU09OLnN0cmluZ2lmeSh7IG5hbWUgfSkpXG4gICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZ2V0RW50cnkodHJ1ZSk7XG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIGVudHJ5LmdldEVudHJ5SW5mbygpLl9uYW1lID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgIH0sIChlKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGEubmFtZSA9IG9sZE5hbWU7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KSwgJ3NldFVzZXJOYW1lJyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2Ugb2YgdGhlIHVzZXIuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YS5sYW5ndWFnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2Ugb2YgYSB1c2VyLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBzZXRMYW5ndWFnZShsYW5ndWFnZSkge1xuICAgIGNvbnN0IG9sZExhbmcgPSB0aGlzLl9kYXRhLmxhbmd1YWdlO1xuICAgIHRoaXMuX2RhdGEubGFuZ3VhZ2UgPSBsYW5ndWFnZTtcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZS5oYW5kbGVBc3luYyh0aGlzLl9lbnRyeVN0b3JlLmdldFJFU1QoKS5wdXQodGhpcy5fcmVzb3VyY2VVUkksIEpTT04uc3RyaW5naWZ5KHsgbGFuZ3VhZ2UgfSkpXG4gICAgICAudGhlbihkYXRhID0+IGRhdGEsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGEubGFuZ3VhZ2UgPSBvbGRMYW5nO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSksICdzZXRVc2VyTGFuZ3VhZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgYSBuZXcgcGFzc3dvcmQgZm9yIHRoZSB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgLSBhIG5ldyBwYXNzd29yZCwgc2hvdWxkIGJlIGF0IGxlYXN0IDggY2hhcmFjdGVycyBsb25nLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHNldFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5U3RvcmUuaGFuZGxlQXN5bmModGhpcy5fZW50cnlTdG9yZS5nZXRSRVNUKCkucHV0KHRoaXMuX3Jlc291cmNlVVJJLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBwYXNzd29yZCB9KSksICdzZXRVc2VyUGFzc3dvcmQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiB0aGUgdXNlciBpcyBkaXNhYmxlZC4gRGlzYWJsZWQgdXNlcnMgY2Fubm90IHNpZ24gaW4sIGFsdGhvdWdoIHRoZXkgc3RpbGwgZXhpc3RcbiAgICogZm9yIGxvb2t1cCwgZS5nLiB3aGVuIHByZXNlbnRpbmcgY3JlYXRvcnMgYW5kIGNvbnRyaWJ1dG9ycy5cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICBpc0Rpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmRpc2FibGVkID09PSB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgdXNlciB0byBiZSBkaXNhYmxlZCBvciBub3QuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gZGlzYWJsZWRcbiAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIGlmIChkaXNhYmxlZCA9PT0gdGhpcy5pc0Rpc2FibGVkKCkpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgfVxuICAgIGNvbnN0IG9sZERpc2FibGVkID0gdGhpcy5fZGF0YS5kaXNhYmxlZCA9PT0gdHJ1ZTtcbiAgICB0aGlzLl9kYXRhLmRpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5U3RvcmUuaGFuZGxlQXN5bmModGhpcy5fZW50cnlTdG9yZS5nZXRSRVNUKCkucHV0KHRoaXMuX3Jlc291cmNlVVJJLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBkaXNhYmxlZCB9KSlcbiAgICAgIC50aGVuKChkYXRhKSA9PiB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gdGhpcy5nZXRFbnRyeSh0cnVlKTtcbiAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgZW50cnkuZ2V0RW50cnlJbmZvKCkuX2Rpc2FibGVkID0gZGlzYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9LCAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRhLmRpc2FibGVkID0gb2xkRGlzYWJsZWQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KSwgJ3NldFVzZXJEaXNhYmxlZCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgaG9tZSBjb250ZXh0IGZvciB0aGlzIHVzZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gYSBjb250ZXh0IGlkIChub3QgdGhlIGZ1bGwgcmVzb3VyY2UgVVJJKS5cbiAgICovXG4gIGdldEhvbWVDb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmhvbWVjb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBhIG5ldyBob21lIGNvbnRleHQgZm9yIHRoaXMgdXNlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHRJZCAtIGEgY29udGV4dCBpZCAobm90IHRoZSBmdWxsIHJlc291cmNlIFVSSSkuXG4gICAqIEByZXR1cm5zIHtQcm9taXNlfVxuICAgKi9cbiAgc2V0SG9tZUNvbnRleHQoY29udGV4dElkKSB7XG4gICAgY29uc3Qgb2xkSG9tZUNvbnRleHQgPSB0aGlzLl9kYXRhLmhvbWVjb250ZXh0O1xuICAgIHRoaXMuX2RhdGEuaG9tZWNvbnRleHQgPSBjb250ZXh0SWQ7XG4gICAgcmV0dXJuIHRoaXMuX2VudHJ5U3RvcmUuaGFuZGxlQXN5bmModGhpcy5fZW50cnlTdG9yZS5nZXRSRVNUKCkucHV0KHRoaXMuX3Jlc291cmNlVVJJLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoeyBob21lY29udGV4dDogY29udGV4dElkIH0pKVxuICAgICAgLnRoZW4oZGF0YSA9PiBkYXRhLCAoZSkgPT4ge1xuICAgICAgICB0aGlzLl9kYXRhLmhvbWVjb250ZXh0ID0gb2xkSG9tZUNvbnRleHQ7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KSwgJ3NldFVzZXJIb21lQ29udGV4dCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjdXN0b20gcHJvcGVydGllcy5cbiAgICpcbiAgICogQHJldHVybnMge29iamVjdH0gLSBrZXkgdmFsdWUgcGFpcnMgb2YgY3VzdG9tIHByb3BlcnRpZXMuXG4gICAqL1xuICBnZXRDdXN0b21Qcm9wZXJ0aWVzKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmN1c3RvbVByb3BlcnRpZXMgfHwge307XG4gIH1cblxuICAvKipcbiAgICogU2V0IGEgbmV3IGhvbWUgY29udGV4dCBmb3IgdGhpcyB1c2VyLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY3VzdG9tUHJvcGVydGllc1xuICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICovXG4gIHNldEN1c3RvbVByb3BlcnRpZXMoY3VzdG9tUHJvcGVydGllcykge1xuICAgIGNvbnN0IG9sZEN1c3RvbVByb3BlcnRpZXMgPSB0aGlzLl9kYXRhLmN1c3RvbVByb3BlcnRpZXM7XG4gICAgdGhpcy5fZGF0YS5jdXN0b21Qcm9wZXJ0aWVzID0gY3VzdG9tUHJvcGVydGllcztcbiAgICByZXR1cm4gdGhpcy5fZW50cnlTdG9yZS5oYW5kbGVBc3luYyh0aGlzLl9lbnRyeVN0b3JlLmdldFJFU1QoKS5wdXQodGhpcy5fcmVzb3VyY2VVUkksXG4gICAgICBKU09OLnN0cmluZ2lmeSh7IGN1c3RvbVByb3BlcnRpZXMgfSkpXG4gICAgICAudGhlbihkYXRhID0+IGRhdGEsIChlKSA9PiB7XG4gICAgICAgIHRoaXMuX2RhdGEuY3VzdG9tUHJvcGVydGllcyA9IG9sZEN1c3RvbVByb3BlcnRpZXM7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9KSwgJ3NldFVzZXJDdXN0b21Qcm9wZXJ0aWVzJyk7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0U291cmNlKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG59XG4iLCJpbXBvcnQgeyBHcmFwaCB9IGZyb20gJ3JkZmpzb24nO1xuaW1wb3J0IENvbnRleHQgZnJvbSAnLi9Db250ZXh0JztcbmltcG9ydCBFbnRyeSBmcm9tICcuL0VudHJ5JztcbmltcG9ydCBFbnRyeUluZm8gZnJvbSAnLi9FbnRyeUluZm8nO1xuaW1wb3J0IEZpbGVSZXNvdXJjZSBmcm9tICcuL0ZpbGUnO1xuaW1wb3J0IEdyYXBoUmVzb3VyY2UgZnJvbSAnLi9HcmFwaCc7XG5pbXBvcnQgR3JvdXAgZnJvbSAnLi9Hcm91cCc7XG5pbXBvcnQgTGlzdCBmcm9tICcuL0xpc3QnO1xuaW1wb3J0IFBpcGVsaW5lIGZyb20gJy4vUGlwZWxpbmUnO1xuaW1wb3J0IFNlYXJjaExpc3QgZnJvbSAnLi9TZWFyY2hMaXN0JztcbmltcG9ydCBTdHJpbmdSZXNvdXJjZSBmcm9tICcuL1N0cmluZyc7XG5pbXBvcnQgdHlwZXMgZnJvbSAnLi90eXBlcyc7XG5pbXBvcnQgVXNlciBmcm9tICcuL1VzZXInO1xuXG4vKipcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyB0aGF0IGVuY2Fwc3VsYXRlcyBFbnRyeVN0b3JlcyBSRVNUIGxheWVyIGZyb20gdGhlIHJlc3RcbiAqIG9mIHRoZSBjb2RlLiBJdCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGludGVybmFsbHkgYnkgdGhlIEVudHJ5U3RvcmUuanMgQVBJLFxuICogbm90IGJ5IGFwcGxpY2F0aW9uIGRldmVsb3BlcnMuXG4gKlxuICogSGVuY2UsICoqeW91IHNob3VsZCBhdm9pZCB1c2luZyBmYWN0b3J5IG1ldGhvZHMgZGlyZWN0bHkgaW4gYXBwbGljYXRpb24gY29kZSBhcyB0aGVyZSBhcmVcbiAqIG1vc3QgcHJvYmFibHkgb3RoZXIgd2F5cyB0byBhY2hpZXZlIHRoZSBzYW1lIHRoaW5nLiBNb3N0IGxpa2VseSBieSB1c2luZyBtZXRob2QgaW5cbiAqIHtAbGluayBzdG9yZS9FbnRyeVN0b3JlfSEqKlxuICpcbiAqIFRoZSB1dGlsaXR5IG1ldGhvZHMgYXJlIGN1cnJlbnRseSBub3QgdmlzaWJsZSBhcyB0aGV5IGFyZSBub3QgZG9jdW1lbnRlZCB5ZXQuXG4gKiAoVGhlIG1ldGhvZHMgY2Fubm90IGJlIG1hcmtlZCBhcyBwcml2YXRlIGFzIHRoZXkgbmVlZCB0byBiZSB1c2VkIHRocm91Z2hvdXQgdGhlIEFQSS4pXG4gKlxuICogQGV4cG9ydHMgc3RvcmUvZmFjdG9yeVxuICogQG5hbWVzcGFjZVxuICovXG5cbmxldCBzb3J0T2JqID0geyBzb3J0Qnk6ICd0aXRsZScsIHByaW86ICdMaXN0JyB9O1xubGV0IGRlZmF1bHRMaW1pdCA9IDUwO1xuXG5jb25zdCBnZXRDb250ZXh0Rm9yRW50cnkgPSAoZW50cnlVUkksIGVudHJ5U3RvcmUpID0+IHtcbiAgY29uc3QgYmFzZVVSSSA9IGVudHJ5U3RvcmUuZ2V0QmFzZVVSSSgpO1xuICBjb25zdCBjb250ZXh0SWQgPSBlbnRyeVVSSS5zdWJzdHIoYmFzZVVSSS5sZW5ndGgsIGVudHJ5VVJJLmluZGV4T2YoJy8nLCBiYXNlVVJJLmxlbmd0aClcbiAgICAtIGJhc2VVUkkubGVuZ3RoKTtcbiAgY29uc3QgY29udGV4dHMgPSBlbnRyeVN0b3JlLmdldENhY2hlZENvbnRleHRzSWR4KCk7XG4gIGxldCBjb250ZXh0ID0gY29udGV4dHNbY29udGV4dElkXTtcbiAgaWYgKCFjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IG5ldyBDb250ZXh0KGAke2Jhc2VVUkl9X2NvbnRleHRzL2VudHJ5LyR7Y29udGV4dElkfWAsIGJhc2VVUklcbiAgICAgICsgY29udGV4dElkLCBlbnRyeVN0b3JlKTtcbiAgICBjb250ZXh0c1tjb250ZXh0SWRdID0gY29udGV4dDtcbiAgfVxuICByZXR1cm4gY29udGV4dDtcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVJpZ2h0cyA9IChyaWdodHMpID0+IHtcbiAgY29uc3QgbyA9IHt9O1xuICBjb25zdCByID0gcmlnaHRzIHx8IFtdO1xuICBmb3IgKGxldCBuID0gMDsgbiA8IHIubGVuZ3RoOyBuKyspIHtcbiAgICBvW3Jbbl1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gbztcbn07XG5cbmNvbnN0IGZpeE5hbWVBbmREaXNhYmxlZCA9IChyZXNPYmosIGRhdGEpID0+IHtcbiAgY29uc3QgeyByZXNvdXJjZSB9ID0gZGF0YTtcbiAgLy8gU3BlY2lhbCBjYXNlIG9mIHNlYXJjaGVzIGFuZCBzaW1pbGFyIHdoZW4gbmFtZSBpcyBwcm92aWRlZCBidXQgbm90IGZ1bGwgcmVzb3VyY2UuXG4gIGlmIChyZXNPYmogIT0gbnVsbCkge1xuICAgIGlmIChyZXNvdXJjZSAmJiB0eXBlb2YgcmVzb3VyY2UubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyZXNPYmogaW5zdGFuY2VvZiBVc2VyKSB7XG4gICAgICAgIHJlc09iai5fZGF0YSA9IHJlc09iai5fZGF0YSB8fCB7fTtcbiAgICAgICAgcmVzT2JqLl9kYXRhLm5hbWUgPSByZXNvdXJjZS5uYW1lO1xuICAgICAgfSBlbHNlIHsgLy8gQ29udGV4dCBhbmQgR3JvdXBcbiAgICAgICAgcmVzT2JqLl9uYW1lID0gcmVzb3VyY2UubmFtZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHJlc09iaiBpbnN0YW5jZW9mIFVzZXIpIHtcbiAgICAgIHJlc09iai5fZGF0YSA9IHJlc09iai5fZGF0YSB8fCB7fTtcbiAgICAgIGlmIChyZXNvdXJjZSAmJiB0eXBlb2YgcmVzb3VyY2UuZGlzYWJsZWQgPT09ICdib29sZWFuJykge1xuICAgICAgICByZXNPYmouX2RhdGEuZGlzYWJsZWQgPSByZXNvdXJjZS5kaXNhYmxlZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0IF91cGRhdGVPckNyZWF0ZVJlc291cmNlID0gKGVudHJ5LCBkYXRhLCBmb3JjZSkgPT4ge1xuICBjb25zdCBfZGF0YSA9IGRhdGEgfHwge307XG4gIGxldCByZXNvdXJjZSA9IGVudHJ5LmdldFJlc291cmNlKHRydWUpO1xuICBjb25zdCB1cmkgPSBlbnRyeS5nZXRVUkkoKTtcbiAgY29uc3QgcnVyaSA9IGVudHJ5LmdldFJlc291cmNlVVJJKCk7XG4gIGNvbnN0IGNydXJpID0gZW50cnkuZ2V0Q29udGV4dCgpLmdldFJlc291cmNlVVJJKCk7XG4gIGNvbnN0IGVzID0gZW50cnkuZ2V0RW50cnlTdG9yZSgpO1xuICBjb25zdCBlaSA9IGVudHJ5LmdldEVudHJ5SW5mbygpO1xuICBpZiAoIXJlc291cmNlICYmIGVpLmdldEVudHJ5VHlwZSgpID09PSB0eXBlcy5FVF9MT0NBTFxuICAgICYmIGVpLmdldFJlc291cmNlVHlwZSgpID09PSB0eXBlcy5SVF9JTkZPUk1BVElPTlJFU09VUkNFKSB7XG4gICAgc3dpdGNoIChlbnRyeS5nZXRFbnRyeUluZm8oKS5nZXRHcmFwaFR5cGUoKSkge1xuICAgICAgY2FzZSB0eXBlcy5HVF9DT05URVhUOiAvLyBTeW5jaHJvbm91cyByZXNvdXJjZSwgYXN5bmNocm9ub3VzIG1ldGhvZHMuXG4gICAgICAgIC8vIER1bW15IFVSTCB0byBmaW5kIHRoZSByaWdodCBjb250ZXh0LlxuICAgICAgICByZXNvdXJjZSA9IGdldENvbnRleHRGb3JFbnRyeShgJHtlcy5nZXRCYXNlVVJJKCkgKyBlbnRyeS5nZXRJZCgpfS9gLFxuICAgICAgICAgIGVudHJ5LmdldEVudHJ5U3RvcmUoKSk7XG4gICAgICAgIHJlc291cmNlLl91cGRhdGUoX2RhdGEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdHlwZXMuR1RfTElTVDogLy8gU3luY2hyb25vdXMgcmVzb3VyY2UsIGFzeW5jaHJvbm91cyBtZXRob2RzLlxuICAgICAgY2FzZSB0eXBlcy5HVF9HUk9VUDogLy8gU3luY2hyb25vdXMgcmVzb3VyY2UsIGFzeW5jaHJvbm91cyBtZXRob2RzLlxuICAgICAgICBpZiAoZW50cnkuaXNHcm91cCgpKSB7XG4gICAgICAgICAgcmVzb3VyY2UgPSBuZXcgR3JvdXAodXJpLCBydXJpLCBlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb3VyY2UgPSBuZXcgTGlzdCh1cmksIHJ1cmksIGVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2RhdGEucmVzb3VyY2UgJiYgX2RhdGEucmVzb3VyY2UuY2hpbGRyZW4pIHtcbiAgICAgICAgICByZXNvdXJjZS5fdXBkYXRlKF9kYXRhLnJlc291cmNlLCBfZGF0YS5yZXNvdXJjZS5jaGlsZHJlbi5tYXAoY2hpbGQgPT5cbiAgICAgICAgICAgIHVwZGF0ZU9yQ3JlYXRlKGAke2NydXJpfS9lbnRyeS8ke2NoaWxkLmVudHJ5SWR9YCwgY2hpbGQsIGVzKSkpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0eXBlcy5HVF9VU0VSOiAvLyBBc3luY2hyb25vdXMgcmVzb3VyY2UsIHN5bmNocm9ub3VzIGdldHRlcnMuXG4gICAgICAgIGlmIChmb3JjZSB8fCBfZGF0YS5yZXNvdXJjZSAhPSBudWxsKSB7XG4gICAgICAgICAgcmVzb3VyY2UgPSBuZXcgVXNlcih1cmksIHJ1cmksIGVzLCBfZGF0YS5yZXNvdXJjZSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHR5cGVzLkdUX1NUUklORzpcbiAgICAgICAgaWYgKGZvcmNlIHx8IF9kYXRhLnJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXNvdXJjZSA9IG5ldyBTdHJpbmdSZXNvdXJjZSh1cmksIHJ1cmksIGVzLCBfZGF0YS5yZXNvdXJjZSB8fCAnJyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHR5cGVzLkdUX0dSQVBIOiAvLyBTeW5jIG9yIEFzeW5jP1xuICAgICAgICBpZiAoZm9yY2UgfHwgX2RhdGEucmVzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIHJlc291cmNlID0gbmV3IEdyYXBoUmVzb3VyY2UodXJpLCBydXJpLCBlcywgX2RhdGEucmVzb3VyY2UgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0eXBlcy5HVF9QSVBFTElORTogLy8gU3luYyBvciBBc3luYz9cbiAgICAgICAgaWYgKGZvcmNlIHx8IF9kYXRhLnJlc291cmNlICE9IG51bGwpIHtcbiAgICAgICAgICByZXNvdXJjZSA9IG5ldyBQaXBlbGluZSh1cmksIHJ1cmksIGVzLCBfZGF0YS5yZXNvdXJjZSB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHR5cGVzLkdUX1BJUEVMSU5FUkVTVUxUOiAvLyBJZiBsb2NhbCwgUGlwZWxpbmVyZXN1bHQgcmVzb3VyY2UgaXMgYSBmaWxlLlxuICAgICAgY2FzZSB0eXBlcy5HVF9OT05FOiAvLyBVcGxvYWRlZCBmaWxlLlxuICAgICAgICByZXNvdXJjZSA9IG5ldyBGaWxlUmVzb3VyY2UodXJpLCBydXJpLCBlcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gICAgZW50cnkuX3Jlc291cmNlID0gcmVzb3VyY2U7XG4gICAgZml4TmFtZUFuZERpc2FibGVkKHJlc291cmNlLCBfZGF0YSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHJlc291cmNlID09IG51bGwgfHwgX2RhdGEucmVzb3VyY2UgPT0gbnVsbCkge1xuICAgIGZpeE5hbWVBbmREaXNhYmxlZChyZXNvdXJjZSwgX2RhdGEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChyZXNvdXJjZS5fdXBkYXRlKSB7XG4gICAgaWYgKGVudHJ5LmlzTGlzdCgpIHx8IGVudHJ5LmlzR3JvdXAoKSkge1xuICAgICAgaWYgKF9kYXRhLnJlc291cmNlICYmIF9kYXRhLnJlc291cmNlLmNoaWxkcmVuKSB7XG4gICAgICAgIHJlc291cmNlLl91cGRhdGUoX2RhdGEucmVzb3VyY2UsIF9kYXRhLnJlc291cmNlLmNoaWxkcmVuLm1hcChjaGlsZCA9PlxuICAgICAgICAgIHVwZGF0ZU9yQ3JlYXRlKGAke2NydXJpfS9lbnRyeS8ke2NoaWxkLmVudHJ5SWR9YCxcbiAgICAgICAgICAgIGNoaWxkLCBlbnRyeS5nZXRFbnRyeVN0b3JlKCkpKSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc291cmNlLl91cGRhdGUoX2RhdGEucmVzb3VyY2UpO1xuICAgIH1cbiAgfVxufTtcblxuY29uc3QgX3VwZGF0ZUVudHJ5ID0gKGVudHJ5LCBkYXRhKSA9PiB7XG4gIGVudHJ5Ll9tZXRhZGF0YSA9IGRhdGEubWV0YWRhdGEgPyBuZXcgR3JhcGgoZGF0YS5tZXRhZGF0YSkgOiBudWxsO1xuICBlbnRyeS5fY2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSA9IGRhdGFbJ2NhY2hlZC1leHRlcm5hbC1tZXRhZGF0YSddID8gbmV3IEdyYXBoKGRhdGFbJ2NhY2hlZC1leHRlcm5hbC1tZXRhZGF0YSddKSA6IG51bGw7XG4gIGVudHJ5Ll9pbmZlcnJlZE1ldGFkYXRhID0gZGF0YS5pbmZlcnJlZCA/IG5ldyBHcmFwaChkYXRhLmluZmVycmVkKSA6IG51bGw7XG4gIGVudHJ5Ll9leHRyYWN0ZWRNZXRhZGF0YSA9IGRhdGFbJ2V4dHJhY3RlZC1tZXRhZGF0YSddID8gbmV3IEdyYXBoKGRhdGFbJ2V4dHJhY3RlZC1tZXRhZGF0YSddKSA6IG51bGw7XG4gIGVudHJ5Ll9yZWxhdGlvbiA9IGRhdGEucmVsYXRpb25zID8gbmV3IEdyYXBoKGRhdGEucmVsYXRpb25zKSA6IG5ldyBHcmFwaCgpO1xuICBlbnRyeS5fcmlnaHRzID0gdHJhbnNmb3JtUmlnaHRzKGRhdGEucmlnaHRzKTtcbiAgLy8gU29tZXRpbWVzIHdlIGdldCB0aGUgbmFtZSB0aGF0IGlzIHJlYWxseSBwYXJ0IG9mIHRoZSByZXNvdXJjZSB3aXRob3V0IGdldHRpbmcgdGhlIGZ1bGxcbiAgLy8gcmVzb3VyY2UsIGluIHRoaXMgY2FzZSB3ZSBzdG9yZSB0aGlzIGluIHRoZSBlbnRyeWluZm8uXG4gIGlmIChkYXRhLm5hbWUgfHwgKGRhdGEucmVzb3VyY2UgJiYgZGF0YS5yZXNvdXJjZS5uYW1lKSkge1xuICAgIGNvbnN0IGVpID0gZW50cnkuZ2V0RW50cnlJbmZvKCk7XG4gICAgLy8gZWkuX2FsaWFzID0gZGF0YS5hbGlhcztcbiAgICBlaS5fbmFtZSA9IGRhdGEubmFtZSB8fCBkYXRhLnJlc291cmNlLm5hbWU7XG4gIH1cbiAgLy8gU29tZXRpbWVzIHdlIGdldCB0aGUgZGlzYWJsZWQgc3RhdGUgdGhhdCBpcyByZWFsbHkgcGFydCBvZiB0aGUgcmVzb3VyY2VcbiAgLy8gd2l0aG91dCBnZXR0aW5nIHRoZSBmdWxsIHJlc291cmNlLCBpbiB0aGlzIGNhc2Ugd2Ugc3RvcmUgdGhpcyBpbiB0aGUgZW50cnlpbmZvLlxuICBpZiAoZGF0YS5kaXNhYmxlZCB8fCAoZGF0YS5yZXNvdXJjZSAmJiBkYXRhLnJlc291cmNlLmRpc2FibGVkKSkge1xuICAgIGNvbnN0IGVpID0gZW50cnkuZ2V0RW50cnlJbmZvKCk7XG4gICAgZWkuX2Rpc2FibGVkID0gZGF0YS5kaXNhYmxlZCB8fCBkYXRhLnJlc291cmNlLmRpc2FibGVkO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBlbnRyeVN0b3JlXG4gKiBAcGFyYW0gY29udGV4dEVudHJ5VVJJXG4gKiBAcmV0dXJuIHtzdG9yZS9Db250ZXh0fVxuICovXG5jb25zdCBnZXRDb250ZXh0ID0gKGVudHJ5U3RvcmUsIGNvbnRleHRFbnRyeVVSSSkgPT4ge1xuICBjb25zdCBiYXNlVVJJID0gZW50cnlTdG9yZS5nZXRCYXNlVVJJKCk7XG4gIGNvbnN0IGNvbnRleHRzQmFzZVVSSSA9IGAke2Jhc2VVUkl9X2NvbnRleHRzL2VudHJ5L2A7XG4gIGNvbnN0IGNvbnRleHRJZCA9IGNvbnRleHRFbnRyeVVSSS5zdWJzdHIoY29udGV4dHNCYXNlVVJJLmxlbmd0aCk7XG4gIGNvbnN0IGNvbnRleHRzID0gZW50cnlTdG9yZS5nZXRDYWNoZWRDb250ZXh0c0lkeCgpO1xuICBsZXQgY29udGV4dCA9IGNvbnRleHRzW2NvbnRleHRJZF07XG4gIGlmICghY29udGV4dCkge1xuICAgIGNvbnRleHQgPSBuZXcgQ29udGV4dChjb250ZXh0RW50cnlVUkksIGJhc2VVUkkgKyBjb250ZXh0SWQsIGVudHJ5U3RvcmUpO1xuICAgIGNvbnRleHRzW2NvbnRleHRJZF0gPSBjb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGVudHJ5U3RvcmVcbiAqIEBwYXJhbSBlbnRyeVVSSVxuICogQHJldHVybiB7TGlzdH1cbiAqL1xuY29uc3QgZ2V0TGlzdCA9IChlbnRyeVN0b3JlLCBlbnRyeVVSSSkgPT4ge1xuICBjb25zdCBjYWNoZSA9IGVudHJ5U3RvcmUuZ2V0Q2FjaGUoKTtcbiAgbGV0IGVudHJ5ID0gY2FjaGUuZ2V0KGVudHJ5VVJJKTtcbiAgaWYgKCFlbnRyeSkgeyAgLy8gSWYgbm8gZW50cnkgaXMgaW4gY2FjaGUsIGNyZWF0ZSBhbiBlbXB0eSBlbnRyeVxuICAgIC8vIEFzc3VtaW5nIHRoZXJlIGlzIGFuIGluZm8gb2JqZWN0Li4uIFRPRE8gY2hlY2sgc28gbm90IGluZm9fc3R1YiByZW1haW5zIGluIHJlc3QgbGF5ZXIuXG4gICAgY29uc3QgZW50cnlJbmZvID0gbmV3IEVudHJ5SW5mbyhlbnRyeVVSSSwgbmV3IEdyYXBoKCksIGVudHJ5U3RvcmUpO1xuICAgIGNvbnN0IGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yRW50cnkoZW50cnlVUkksIGVudHJ5U3RvcmUpO1xuICAgIGVudHJ5ID0gbmV3IEVudHJ5KGNvbnRleHQsIGVudHJ5SW5mbyk7XG4gICAgY29uc3QgcmVzb3VyY2VVUkkgPSBlbnRyeVVSSS5yZXBsYWNlKCcvZW50cnkvJywgJy9yZXNvdXJjZS8nKTtcbiAgICBlbnRyeS5fcmVzb3VyY2UgPSBuZXcgTGlzdChlbnRyeVVSSSwgcmVzb3VyY2VVUkksIGVudHJ5U3RvcmUpO1xuICAgIGNhY2hlLmNhY2hlKGVudHJ5LCB0cnVlKTsgLy8gQWRkIHRvIGNhY2hlIHNpbGVudGx5XG4gICAgZW50cnkuc2V0UmVmcmVzaE5lZWRlZCh0cnVlKTsgIC8vIE1ha2Ugc3VyZSBpdCBuZWVkcyB0byBiZSB1cGRhdGVkIGJlZm9yZSBhY2Nlc3NlZFxuICB9XG4gIC8vIFJldHVybmluZyBvbmx5IHRoZSBsaXN0IHdoaWNoIGhhcyBubyByZWZlcmVuY2UgdG8gdGhlIGVudHJ5IGlzb2xhdGVzIHRoZSBlbnRyeSBmcm9tXG4gIC8vIGJlaW5nIGFjY2Vzc2VkIGJlZm9yZSByZWZyZXNoZWQuXG4gIHJldHVybiBlbnRyeS5fcmVzb3VyY2U7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cnlVUklcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gZW50cnlTdG9yZVxuICogQHJldHVybiB7RW50cnl9XG4gKi9cbmNvbnN0IHVwZGF0ZU9yQ3JlYXRlID0gKGVudHJ5VVJJLCBkYXRhLCBlbnRyeVN0b3JlKSA9PiB7XG4gIGNvbnN0IGNhY2hlID0gZW50cnlTdG9yZS5nZXRDYWNoZSgpO1xuICBsZXQgZW50cnkgPSBjYWNoZS5nZXQoZW50cnlVUkkpO1xuICBpZiAoZW50cnkpIHtcbiAgICBlbnRyeS5nZXRFbnRyeUluZm8oKS5zZXRHcmFwaChuZXcgR3JhcGgoZGF0YS5pbmZvKSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXNzdW1pbmcgdGhlcmUgaXMgYW4gaW5mbyBvYmplY3QuLi4gVE9ETyBjaGVjayBzbyBub3QgaW5mb19zdHViIHJlbWFpbnMgaW4gcmVzdCBsYXllci5cbiAgICBjb25zdCBlbnRyeUluZm8gPSBuZXcgRW50cnlJbmZvKGVudHJ5VVJJLCBuZXcgR3JhcGgoZGF0YS5pbmZvKSwgZW50cnlTdG9yZSk7XG4gICAgY29uc3QgY29udGV4dCA9IGdldENvbnRleHRGb3JFbnRyeShlbnRyeVVSSSwgZW50cnlTdG9yZSk7XG4gICAgZW50cnkgPSBuZXcgRW50cnkoY29udGV4dCwgZW50cnlJbmZvKTtcbiAgfVxuICBfdXBkYXRlRW50cnkoZW50cnksIGRhdGEpO1xuICBfdXBkYXRlT3JDcmVhdGVSZXNvdXJjZShlbnRyeSwgZGF0YSk7XG4gIGNhY2hlLmNhY2hlKGVudHJ5KTsgLy8gQWRkIHRvIG9yIHJlZnJlc2ggdGhlIGNhY2hlLlxuICByZXR1cm4gZW50cnk7XG59O1xuXG4vKipcbiAqXG4gKiBAdHlwZSB7X3VwZGF0ZU9yQ3JlYXRlUmVzb3VyY2V9XG4gKi9cbmNvbnN0IHVwZGF0ZU9yQ3JlYXRlUmVzb3VyY2UgPSBfdXBkYXRlT3JDcmVhdGVSZXNvdXJjZTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHtFbnRyeX0gZW50cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gKi9cbmNvbnN0IHVwZGF0ZSA9IChlbnRyeSwgZGF0YSkgPT4ge1xuICBlbnRyeS5nZXRFbnRyeUluZm8oKS5zZXRHcmFwaChuZXcgR3JhcGgoZGF0YS5pbmZvKSk7XG4gIF91cGRhdGVPckNyZWF0ZVJlc291cmNlKGVudHJ5LCBkYXRhKTtcbiAgX3VwZGF0ZUVudHJ5KGVudHJ5LCBkYXRhKTtcbiAgZW50cnkuZ2V0RW50cnlTdG9yZSgpLmdldENhY2hlKCkuY2FjaGUoZW50cnkpOyAvLyBBZGQgdG8gb3IgcmVmcmVzaCB0aGUgY2FjaGUuXG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cnlTdG9yZVxuICogQHBhcmFtIHF1ZXJ5XG4gKiBAcmV0dXJuIHtTZWFyY2hMaXN0fVxuICovXG5jb25zdCBjcmVhdGVTZWFyY2hMaXN0ID0gKGVudHJ5U3RvcmUsIHF1ZXJ5KSA9PiBuZXcgU2VhcmNoTGlzdChlbnRyeVN0b3JlLCBxdWVyeSk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gbGlzdFxuICogQHBhcmFtIGVudHJ5U3RvcmVcbiAqIEByZXR1cm4ge0FycmF5LjxFbnRyeT59XG4gKi9cbmNvbnN0IGV4dHJhY3RTZWFyY2hSZXN1bHRzID0gKGRhdGEsIGxpc3QsIGVudHJ5U3RvcmUpID0+IHtcbiAgLy8gVXBkYXRlIG9yIGNyZWF0ZSBhbGwgZW50cmllcyByZWNlaXZlZFxuICAvLyBUT0RPIGNoYW5nZSByZXN0IGFwaSBzbyBvZmZzZXQgaXMgaW5zaWRlIG9mIHJlc291cmNlLlxuICBkYXRhLnJlc291cmNlLm9mZnNldCA9IGRhdGEucmVzb3VyY2Uub2Zmc2V0IHx8IGRhdGEub2Zmc2V0O1xuICAvLyBUT0RPIGNoYW5nZSByZXN0IGFwaSBzbyBzaXplIGlzIGluc2lkZSBvZiByZXNvdXJjZS5cbiAgZGF0YS5yZXNvdXJjZS5zaXplID0gZGF0YS5yZXNvdXJjZS5zaXplIHx8IGRhdGEucmVzdWx0cztcbiAgY29uc3QgYmFzZVVSSSA9IGVudHJ5U3RvcmUuZ2V0QmFzZVVSSSgpO1xuICBjb25zdCBlbnRyaWVzID0gZGF0YS5yZXNvdXJjZS5jaGlsZHJlbi5tYXAoY2hpbGQgPT4gdXBkYXRlT3JDcmVhdGUoXG4gICAgYCR7YmFzZVVSSSArIGNoaWxkLmNvbnRleHRJZH0vZW50cnkvJHtjaGlsZC5lbnRyeUlkfWAsIGNoaWxkLCBlbnRyeVN0b3JlKSk7XG4gIGxpc3QuX3VwZGF0ZShkYXRhLnJlc291cmNlLCBlbnRyaWVzKTtcbiAgcmV0dXJuIGVudHJpZXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cnlVUklcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YVVSSSA9IGVudHJ5VVJJID0+IGVudHJ5VVJJLnJlcGxhY2UoJy9lbnRyeS8nLCAnL2NhY2hlZC1leHRlcm5hbC1tZXRhZGF0YS8nKTtcblxuLyoqXG4gKiBAZGVwcmVjYXRlZCBpbiBmYXZvciBvZiB7QGxpbmsgc3RvcmUvZmFjdG9yeSNnZXRFbnRyeUlkfVxuICovXG5jb25zdCBnZXRJZCA9IHVyaSA9PiB1cmkuc3Vic3RyKHVyaS5sYXN0SW5kZXhPZignLycpICsgMSk7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB1cmlcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5jb25zdCBnZXRFbnRyeUlkID0gKHVyaSwgYmFzZSkgPT4ge1xuICBsZXQgX3VyaSA9IHVyaTtcbiAgaWYgKGJhc2UpIHtcbiAgICBfdXJpID0gX3VyaS5zdWJzdHIoYmFzZS5sZW5ndGggLSAxKTsgLy8gaW5jbHVkZSB0aGUgLyBiZWZvcmUuXG4gIH1cbiAgY29uc3QgcmVzID0gX3VyaS5tYXRjaCgvXFwvKFteL10rKVxcLyhlbnRyeXxyZXNvdXJjZXxtZXRhZGF0YXxyZWxhdGlvbilcXC8oW14/L10rKShcXD8uKik/JC8pO1xuICBpZiAocmVzKSB7XG4gICAgcmV0dXJuIHJlc1szXTtcbiAgfSBlbHNlIGlmIChfdXJpLmxhc3RJbmRleE9mKCcvJykgPT09IDApIHtcbiAgICByZXR1cm4gX3VyaS5zdWJzdHIoMSk7XG4gIH0gZWxzZSBpZiAoIWJhc2UpIHtcbiAgICByZXR1cm4gX3VyaS5zdWJzdHIoX3VyaS5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB1cmlcbiAqIEBwYXJhbSBiYXNlXG4gKiBAcmV0dXJuIHtzdHJpbmd8dW5kZWZpbmVkfVxuICovXG5jb25zdCBnZXRDb250ZXh0SWQgPSAodXJpLCBiYXNlKSA9PiB7XG4gIGxldCBfdXJpID0gdXJpO1xuICBpZiAoYmFzZSkge1xuICAgIF91cmkgPSBfdXJpLnN1YnN0cihiYXNlLmxlbmd0aCAtIDEpOyAvLyBpbmNsdWRlIHRoZSAvIGJlZm9yZS5cbiAgfVxuICBjb25zdCByZXMgPSBfdXJpLm1hdGNoKC9cXC8oW14vXSspXFwvKGVudHJ5fHJlc291cmNlfG1ldGFkYXRhfHJlbGF0aW9uKVxcLyhbXj8vXSspKFxcPy4qKT8kLyk7XG4gIGlmIChyZXMpIHtcbiAgICByZXR1cm4gcmVzWzFdO1xuICB9IGVsc2UgaWYgKF91cmkuaW5kZXhPZignLycpID09PSAtMSB8fCAhYmFzZSkge1xuICAgIHJldHVybiAnX2NvbnRleHRzJztcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGVudHJ5U3RvcmVcbiAqIEBwYXJhbSB1cmlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgZ2V0RW50cnlVUklGcm9tVVJJID0gKGVudHJ5U3RvcmUsIHVyaSkgPT4ge1xuICBjb25zdCBiYXNlID0gZW50cnlTdG9yZS5nZXRCYXNlVVJJKCk7XG4gIHJldHVybiBgJHtiYXNlICsgZ2V0Q29udGV4dElkKHVyaSwgYmFzZSl9L2VudHJ5LyR7Z2V0RW50cnlJZCh1cmksIGJhc2UpfWA7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cnlTdG9yZVxuICogQHBhcmFtIGNvbnRleHRJZFxuICogQHBhcmFtIGVudHJ5SWRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgZ2V0RW50cnlVUkkgPSAoZW50cnlTdG9yZSwgY29udGV4dElkLCBlbnRyeUlkKSA9PiBgJHtlbnRyeVN0b3JlLmdldEJhc2VVUkkoKX0ke2NvbnRleHRJZH0vZW50cnkvJHtlbnRyeUlkfWA7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBlbnRyeVN0b3JlXG4gKiBAcGFyYW0gdXJpXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldE1ldGFkYXRhVVJJRnJvbVVSSSA9IChlbnRyeVN0b3JlLCB1cmkpID0+IHtcbiAgY29uc3QgYmFzZSA9IGVudHJ5U3RvcmUuZ2V0QmFzZVVSSSgpO1xuICByZXR1cm4gYCR7YmFzZSArIGdldENvbnRleHRJZCh1cmksIGJhc2UpfS9tZXRhZGF0YS8ke2dldEVudHJ5SWQodXJpLCBiYXNlKX1gO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIGVudHJ5U3RvcmVcbiAqIEBwYXJhbSBjb250ZXh0SWRcbiAqIEBwYXJhbSBlbnRyeUlkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldE1ldGFkYXRhVVJJID0gKGVudHJ5U3RvcmUsIGNvbnRleHRJZCwgZW50cnlJZCkgPT5cbiAgYCR7ZW50cnlTdG9yZS5nZXRCYXNlVVJJKCl9JHtjb250ZXh0SWR9L2VudHJ5LyR7ZW50cnlJZH1gO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cnlTdG9yZVxuICogQHBhcmFtIGNvbnRleHRJZFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBnZXRSZXNvdXJjZUJhc2UgPSAoZW50cnlTdG9yZSwgY29udGV4dElkKSA9PlxuICBgJHtlbnRyeVN0b3JlLmdldEJhc2VVUkkoKSArIGNvbnRleHRJZH0vcmVzb3VyY2UvYDtcblxuLyoqXG4gKlxuICogQHBhcmFtIGVudHJ5U3RvcmVcbiAqIEBwYXJhbSBjb250ZXh0SWRcbiAqIEBwYXJhbSBlbnRyeUlkXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldFJlc291cmNlVVJJID0gKGVudHJ5U3RvcmUsIGNvbnRleHRJZCwgZW50cnlJZCkgPT4ge1xuICBpZiAoY29udGV4dElkID09PSAnX2NvbnRleHRzJykge1xuICAgIHJldHVybiBlbnRyeVN0b3JlLmdldEJhc2VVUkkoKSArIGVudHJ5SWQ7XG4gIH1cbiAgcmV0dXJuIGAke2VudHJ5U3RvcmUuZ2V0QmFzZVVSSSgpICsgY29udGV4dElkfS9yZXNvdXJjZS8ke2VudHJ5SWR9YDtcbn07XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBkYXRhXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBnZXRVUklGcm9tQ3JlYXRlZCA9IChkYXRhLCBjb250ZXh0KSA9PlxuICBgJHtjb250ZXh0LmdldFJlc291cmNlVVJJKCl9L2VudHJ5LyR7ZGF0YS5lbnRyeUlkfWA7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBlbnRyeVVSSVxuICogQHBhcmFtIHBhcmFtc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5jb25zdCBnZXRFbnRyeUxvYWRVUkkgPSAoZW50cnlVUkksIHBhcmFtcykgPT4ge1xuICBjb25zdCBfcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBsZXQgc3RyTCA9ICcnO1xuICBpZiAoX3BhcmFtcy5saW1pdCA+IDAgfHwgX3BhcmFtcy5saW1pdCA9PT0gLTEpIHtcbiAgICBzdHJMID0gYCZsaW1pdD0ke19wYXJhbXMubGltaXR9YDtcbiAgfSBlbHNlIHtcbiAgICBzdHJMID0gYCZsaW1pdD0ke2RlZmF1bHRMaW1pdH1gO1xuICB9XG4gIGNvbnN0IHN0ck8gPSBfcGFyYW1zLm9mZnNldCA9PSBudWxsIHx8IF9wYXJhbXMub2Zmc2V0ID09PSAwID8gJycgOiBgJm9mZnNldD0ke19wYXJhbXMub2Zmc2V0fWA7XG4gIGNvbnN0IHNvcnQgPSBfcGFyYW1zLnNvcnQgPT0gbnVsbCA/IHNvcnRPYmogOiBfcGFyYW1zLnNvcnQ7XG4gIGxldCBzdHJTb3J0ID0gJyc7XG4gIGxldCBzdHJEZXNjID0gJyc7XG4gIGxldCBzdHJQcmlvID0gJyc7XG4gIGlmIChzb3J0ICE9IG51bGwpIHtcbiAgICBzdHJTb3J0ID0gc29ydC5zb3J0QnkgPT0gbnVsbCA/ICcnIDogYCZzb3J0PSR7c29ydC5zb3J0Qnl9YDtcbiAgICBzdHJEZXNjID0gc29ydC5kZXNjZW5kaW5nID09PSB0cnVlID8gJyZvcmRlcj1kZXNjJyA6ICcnO1xuICAgIHN0clByaW8gPSBzb3J0LnByaW8gPT0gbnVsbCA/ICcnIDogYCZwcmlvPSR7c29ydC5wcmlvfWA7XG4gICAgLy8gVE9ETyBsYW5nIHJlbWFpbnMuXG4gIH1cbiAgcmV0dXJuIGAke2VudHJ5VVJJfT9pbmNsdWRlQWxsJHtzdHJMfSR7c3RyT30ke3N0clNvcnR9JHtzdHJEZXNjfSR7c3RyUHJpb31gO1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHByb3RvdHlwZUVudHJ5XG4gKiBAcGFyYW0gcGFyZW50TGlzdEVudHJ5XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldEVudHJ5Q3JlYXRlVVJJID0gKHByb3RvdHlwZUVudHJ5LCBwYXJlbnRMaXN0RW50cnkpID0+IHtcbiAgbGV0IHVyaSA9IGAke3Byb3RvdHlwZUVudHJ5LmdldENvbnRleHQoKS5nZXRSZXNvdXJjZVVSSSgpfT9gO1xuICBpZiAocHJvdG90eXBlRW50cnkpIHtcbiAgICBjb25zdCBlaSA9IHByb3RvdHlwZUVudHJ5LmdldEVudHJ5SW5mbygpO1xuICAgIGlmIChwcm90b3R5cGVFbnRyeS5nZXRTcGVjaWZpY0lkKCkgIT0gbnVsbCkge1xuICAgICAgdXJpID0gYCR7dXJpfWlkPSR7cHJvdG90eXBlRW50cnkuZ2V0U3BlY2lmaWNJZCgpfSZgO1xuICAgIH1cbiAgICBpZiAocHJvdG90eXBlRW50cnkuaXNMaW5rKCkpIHtcbiAgICAgIHVyaSA9IGAke3VyaX1yZXNvdXJjZT0ke2VuY29kZVVSSUNvbXBvbmVudChwcm90b3R5cGVFbnRyeS5nZXRSZXNvdXJjZVVSSSgpKX0mYDtcbiAgICB9XG4gICAgaWYgKHByb3RvdHlwZUVudHJ5LmlzUmVmZXJlbmNlKCkgfHwgcHJvdG90eXBlRW50cnkuaXNMaW5rUmVmZXJlbmNlKCkpIHsgLy8gZXh0ZXJuYWwgbWV0YWRhdGFcbiAgICAgIHVyaSA9IGAke3VyaX1yZXNvdXJjZT0ke2VuY29kZVVSSUNvbXBvbmVudChwcm90b3R5cGVFbnRyeS5nZXRSZXNvdXJjZVVSSSgpKX0mYDtcbiAgICAgIHVyaSA9IGAke3VyaX1jYWNoZWQtZXh0ZXJuYWwtbWV0YWRhdGE9JHtlbmNvZGVVUklDb21wb25lbnQoZWkuZ2V0RXh0ZXJuYWxNZXRhZGF0YVVSSSgpKX0mYDtcbiAgICB9XG4gICAgaWYgKGVpLmdldEVudHJ5VHlwZSgpICE9PSB0eXBlcy5FVF9MT0NBTCkgeyAvLyBsb2NhbCwgbGluaywgbGlua3JlZmVyZW5jZSwgcmVmZXJlbmNlXG4gICAgICB1cmkgPSBgJHt1cml9ZW50cnl0eXBlPSR7ZWkuZ2V0RW50cnlUeXBlKCkudG9Mb3dlckNhc2UoKX0mYDtcbiAgICB9XG4gICAgLy8gaW5mb3JtYXRpb25yZXNvdXJjZSwgbmFtZWRyZXNvdXJjZVxuICAgIGlmIChlaS5nZXRSZXNvdXJjZVR5cGUoKSAhPT0gdHlwZXMuUlRfSU5GT1JNQVRJT05SRVNPVVJDRSkge1xuICAgICAgLy8gVE9ETyBCdWcgaW4gUkVTVCBsYXllciwgc2hvdWxkIGJlIHJlc291cmNldHlwZSwgaXMgbm93IGluZm9ybWF0aW9ucmVzb3VyY2UgaW5uc3RlYWRcbiAgICAgIHVyaSA9IGAke3VyaX1pbmZvcm1hdGlvbnJlc291cmNlPWZhbHNlJmA7XG4gICAgfVxuICAgIGlmIChlaS5nZXRHcmFwaFR5cGUoKSAhPT0gdHlwZXMuR1RfTk9ORSkge1xuICAgICAgdXJpID0gYCR7dXJpfWdyYXBodHlwZT0ke2VpLmdldEdyYXBoVHlwZSgpLnRvTG93ZXJDYXNlKCl9JmA7XG4gICAgfVxuICB9XG4gIGlmIChwYXJlbnRMaXN0RW50cnkpIHtcbiAgICB1cmkgPSBgJHt1cml9bGlzdD0ke3BhcmVudExpc3RFbnRyeS5nZXRSZXNvdXJjZVVSSSgpfSZgO1xuICB9XG5cbiAgcmV0dXJuIHVyaS5zbGljZSgwLCAtMSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvdG90eXBlRW50cnlcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgZ2V0RW50cnlDcmVhdGVQb3N0RGF0YSA9IChwcm90b3R5cGVFbnRyeSkgPT4ge1xuICBjb25zdCBwb3N0RGF0YSA9IHt9O1xuICBsZXQgZW1wdHkgPSB0cnVlO1xuICBjb25zdCBtZCA9IHByb3RvdHlwZUVudHJ5LmdldE1ldGFkYXRhKCk7XG4gIGlmIChtZCAhPSBudWxsICYmICFtZC5pc0VtcHR5KCkpIHtcbiAgICBwb3N0RGF0YS5tZXRhZGF0YSA9IG1kLmV4cG9ydFJERkpTT04oKTtcbiAgICBlbXB0eSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IHJlID0gcHJvdG90eXBlRW50cnkuZ2V0UmVzb3VyY2UodHJ1ZSk7XG4gIGlmIChyZSAhPSBudWxsICYmIHJlLmdldFNvdXJjZSAhPSBudWxsKSB7XG4gICAgcG9zdERhdGEucmVzb3VyY2UgPSByZS5nZXRTb3VyY2UoKTtcbiAgICBlbXB0eSA9IGZhbHNlO1xuICB9XG4gIGNvbnN0IGVpID0gcHJvdG90eXBlRW50cnkuZ2V0RW50cnlJbmZvKCkuZ2V0R3JhcGgoKTtcbiAgaWYgKGVpICE9IG51bGwgJiYgIWVpLmlzRW1wdHkoKSkge1xuICAgIHBvc3REYXRhLmluZm8gPSBlaS5leHBvcnRSREZKU09OKCk7XG4gICAgZW1wdHkgPSBmYWxzZTtcbiAgfVxuICBjb25zdCBjYWNoZWRFeHRlcm5hbE1ldGFkYXRhID0gcHJvdG90eXBlRW50cnkuZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSgpO1xuICBpZiAoY2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSAhPSBudWxsICYmICFjYWNoZWRFeHRlcm5hbE1ldGFkYXRhLmlzRW1wdHkoKSkge1xuICAgIHBvc3REYXRhWydjYWNoZWQtZXh0ZXJuYWwtbWV0YWRhdGEnXSA9IGNhY2hlZEV4dGVybmFsTWV0YWRhdGEuZXhwb3J0UkRGSlNPTigpO1xuICAgIGVtcHR5ID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVtcHR5ID8gJycgOiBKU09OLnN0cmluZ2lmeShwb3N0RGF0YSk7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gZW50cnlcbiAqIEBwYXJhbSBmcm9tTGlzdEVudHJ5XG4gKiBAcGFyYW0gdG9MaXN0RW50cnlcbiAqIEBwYXJhbSBiYXNlVVJJXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldE1vdmVVUkkgPSAoZW50cnksIGZyb21MaXN0RW50cnksIHRvTGlzdEVudHJ5LCBiYXNlVVJJKSA9PiB7XG4gIGNvbnN0IGVudHJ5VVJJID0gZW50cnkuZ2V0VVJJKCkuc3Vic3RyKGJhc2VVUkkubGVuZ3RoKTsgLy8gT25seSBzZW5kIHNvbWV0aGluZyBsaWtlIDMvZW50cnkvMlxuICBjb25zdCBmdXJpID0gZnJvbUxpc3RFbnRyeS5nZXRSZXNvdXJjZVVSSSgpLnN1YnN0cihiYXNlVVJJLmxlbmd0aCk7XG4gIHJldHVybiBgJHt0b0xpc3RFbnRyeS5nZXRSZXNvdXJjZVVSSSgpfT9tb3ZlRW50cnk9JHtlbnRyeVVSSX0mZnJvbUxpc3Q9JHtmdXJpfWA7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gYmFzZVVSSVxuICogQHBhcmFtIHVyaVxuICogQHBhcmFtIGZvcm1hdEhpbnRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuY29uc3QgZ2V0UHJveHlVUkkgPSAoYmFzZVVSSSwgdXJpLCBmb3JtYXRIaW50KSA9PiB7XG4gIGxldCB1cmwgPSBgJHtiYXNlVVJJfXByb3h5P3VybD0ke2VuY29kZVVSSUNvbXBvbmVudCh1cmkpfWA7XG4gIGlmIChmb3JtYXRIaW50ICE9IG51bGwpIHtcbiAgICB1cmwgKz0gYCZmcm9tRm9ybWF0PSR7Zm9ybWF0SGludH1gO1xuICB9XG4gIHJldHVybiB1cmw7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gdXJpXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmNvbnN0IGdldFB1dEZpbGVVUkkgPSB1cmkgPT5cbiAgYCR7dXJpICsgKHVyaS5pbmRleE9mKCc/JykgPCAwID8gJz8nIDogJyYnKX1tZXRob2Q9cHV0JnRleHRhcmVhPXRydWVgO1xuXG4vKipcbiAqIEBwYXJhbSBzb3J0T2JqZWN0XG4gKi9cbmNvbnN0IHNldFNvcnQgPSAoc29ydE9iamVjdCkgPT4ge1xuICBzb3J0T2JqID0gc29ydE9iamVjdDtcbn07XG5cbi8qKlxuICogQHJldHVybiB7e3NvcnRCeTogc3RyaW5nLCBwcmlvOiBzdHJpbmd9fVxuICovXG5jb25zdCBnZXRTb3J0ID0gKCkgPT4gc29ydE9iajtcblxuLyoqXG4gKlxuICogQHJldHVybiB7bnVtYmVyfVxuICovXG5jb25zdCBnZXREZWZhdWx0TGltaXQgPSAoKSA9PiBkZWZhdWx0TGltaXQ7XG5cbi8qKlxuICpcbiAqIEBwYXJhbSBsaW1pdFxuICovXG5jb25zdCBzZXREZWZhdWx0TGltaXQgPSAobGltaXQpID0+IHtcbiAgZGVmYXVsdExpbWl0ID0gbGltaXQ7XG59O1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIGdldENvbnRleHQsXG4gIGdldExpc3QsXG4gIHVwZGF0ZU9yQ3JlYXRlLFxuICB1cGRhdGVPckNyZWF0ZVJlc291cmNlLFxuICB1cGRhdGUsXG4gIGNyZWF0ZVNlYXJjaExpc3QsXG4gIGV4dHJhY3RTZWFyY2hSZXN1bHRzLFxuICBnZXRDYWNoZWRFeHRlcm5hbE1ldGFkYXRhVVJJLFxuICBnZXRJZCxcbiAgZ2V0RW50cnlJZCxcbiAgZ2V0Q29udGV4dElkLFxuICBnZXRFbnRyeVVSSUZyb21VUkksXG4gIGdldEVudHJ5VVJJLFxuICBnZXRNZXRhZGF0YVVSSUZyb21VUkksXG4gIGdldE1ldGFkYXRhVVJJLFxuICBnZXRSZXNvdXJjZUJhc2UsXG4gIGdldFJlc291cmNlVVJJLFxuICBnZXRVUklGcm9tQ3JlYXRlZCxcbiAgZ2V0RW50cnlMb2FkVVJJLFxuICBnZXRFbnRyeUNyZWF0ZVVSSSxcbiAgZ2V0RW50cnlDcmVhdGVQb3N0RGF0YSxcbiAgZ2V0TW92ZVVSSSxcbiAgZ2V0UHJveHlVUkksXG4gIGdldFB1dEZpbGVVUkksXG4gIHNldFNvcnQsXG4gIGdldFNvcnQsXG4gIGdldERlZmF1bHRMaW1pdCxcbiAgc2V0RGVmYXVsdExpbWl0LFxufTtcbiIsImltcG9ydCB7IHByaW50IH0gZnJvbSAncmRmanNvbic7XG5cbi8qKlxuICogQSBtb2R1bGUgdGhhdCBjb250YWluIHV0aWxpdHkgbWV0aG9kcyBmb3IgZ2VuZXJhdGluZyBodG1sIGZvciBlbnRyaWVzLlxuICpcbiAqIEBleHBvcnRzIHN0b3JlL2h0bWxcbiAqIEBuYW1lc3BhY2VcbiAqL1xuY29uc3QgaHRtbCA9IHt9O1xuLy8gVGhlIGFib3ZlIGNvbnN0cnVjdGlvbiBzZWVtIHRvIGJlIG5lZWRlZCBiZWNhdXNlIG9mIGpzZG9jMyBpc3N1ZXMgd2l0aCBub3QgZGV0ZWN0aW5nIHRoZVxuLy8gZXhwb3J0cyB2YXJpYWJsZS5cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSB0YWJsZSB3aXRoIGNvbHVtbnMgc3ViamVjdCwgcHJlZGljYXRlLCBhbmQgb2JqZWN0LlxuICogQHBhcmFtIHtzdG9yZS9FbnRyeX0gZW50cnkgdG8gZXhwb3NlIG1ldGFkYXRhIGZvclxuICogQHJldHVybnMge3N0cmluZ30gcmVuZGVyZWQgaHRtbCBhcyBhIHN0cmluZ1xuICovXG5odG1sLm1ldGFkYXRhVGFibGUgPSAoZW50cnkpID0+IHtcbiAgY29uc3QgZGVsZWdhdGVzID0gcHJpbnQucHJldHR5VHJlZShlbnRyeS5nZXRNZXRhZGF0YSgpLCBlbnRyeS5nZXRSZXNvdXJjZVVSSSgpKTtcbiAgY29uc3QgYXJyID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgZGVsZWdhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgZCA9IGRlbGVnYXRlc1tpXTtcbiAgICBjb25zdCBzdCA9IGQuc3RtdDtcbiAgICBhcnIucHVzaChgJHsnPHRyPicgK1xuICAgICAgXCI8dGQgY2xhc3M9J3JkZl9zdWJqZWN0Jz5cIn0ke3N0LmlzU3ViamVjdEJsYW5rKCkgPyBkLnMgOlxuICAgICAgYDxhIGhyZWY9JyR7c3QuZ2V0U3ViamVjdCgpfSc+JHtkLnN9PC9hPmB9PC90ZD5gICtcbiAgICAgIGA8dGQgY2xhc3M9J3JkZl9wcmVkaWNhdGUnPjxhIGhyZWY9JyR7c3QuZ2V0UHJlZGljYXRlKCl9Jz4ke2QucH08L2E+PC90ZD5gICtcbiAgICAgIGA8dGQgY2xhc3M9J3JkZl9vYmplY3QnPiR7c3QuZ2V0VHlwZSgpID09PSAndXJpJyA/IGA8YSBocmVmPScke3N0LmdldFZhbHVlKCl9Jz4ke2Qub308L2E+YCA6XG4gICAgICAgIGQub308L3RkPjwvdHI+YCk7XG4gIH1cbiAgcmV0dXJuIGFyci5qb2luKCdcXG4nKTtcbn07XG5cbmNvbnN0IF9pbmQgPSB7fTtcbmNvbnN0IGluZGVudGVyID0gZnVuY3Rpb24gKGluZGVudCkge1xuICBpZiAoIV9pbmRbaW5kZW50XSkge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGluZGVudDsgaSsrKSB7XG4gICAgICBzdHIgKz0gXCI8c3BhbiBjbGFzcz0ncmRmX2luZGVudCc+PC9zcGFuPlwiO1xuICAgIH1cbiAgICBfaW5kW2luZGVudF0gPSBzdHI7XG4gIH1cbiAgcmV0dXJuIF9pbmRbaW5kZW50XTtcbn07XG5cbi8qKlxuICogUHJpbnRzIG9uZSBsZXZlbCBvZiB0cmlwbGVzIGZyb20gYSBzdWJqZWN0IHdoZXJlIFVSSXMgYXJlIG5hbWVzcGFjZWQuXG4gKlxuICogQHBhcmFtIHtyZGZqc29uL0dyYXBofSBncmFwaCB0aGUgZ3JhcGggY29udGFpbmluZyB0aGUgbWV0YWRhdGFcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdWJqZWN0IFVSSSB0byBhIHJlc291cmNlIHRvIHN0YXJ0IGZyb21cbiAqIEByZXR1cm5zIHtzdHJpbmd9IHN0cmluZyB3aXRoIHRoZSB0cmlwbGVzIHJlbmRlcmVkIGFzIEhUTUwuXG4gKi9cbmh0bWwubWV0YWRhdGFJbmRlbnQgPSBmdW5jdGlvbiAoZ3JhcGgsIHN1YmplY3QpIHtcbiAgY29uc3QgZGVsZWdhdGVzID0gcHJpbnQucHJldHR5VHJlZShncmFwaCwgc3ViamVjdCk7XG4gIGNvbnN0IGFyciA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbGVnYXRlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGQgPSBkZWxlZ2F0ZXNbaV07XG4gICAgY29uc3Qgc3QgPSBkLnN0bXQ7XG4gICAgYXJyLnB1c2goYDxkaXYgY2xhc3M9J3JkZl9zdGF0ZW1lbnQnPiR7aW5kZW50ZXIoZC5pbmRlbnQpfTxzcGFuIGNsYXNzPSdyZGZfc3ViamVjdCc+JHtcbiAgICAgICAgc3QuaXNTdWJqZWN0QmxhbmsoKSA/IGQucyA6IGA8YSBocmVmPScke3N0LmdldFN1YmplY3QoKX0nPiR7ZC5zfTwvYT5gfTwvc3Bhbj5gICtcbiAgICAgIGA8c3BhbiBjbGFzcz0ncmRmX3ByZWRpY2F0ZSc+PGEgaHJlZj0nJHtzdC5nZXRQcmVkaWNhdGUoKX0nPiR7ZC5wfTwvYT48L3NwYW4+YCArXG4gICAgICBgPHNwYW4gY2xhc3M9J3JkZl9vYmplY3QnPiR7c3QuZ2V0VHlwZSgpID09PSAndXJpJyA/XG4gICAgICAgIGA8YSBocmVmPScke3N0LmdldFZhbHVlKCl9Jz4ke2Qub308L2E+YCA6IGQub308L3NwYW4+PC9kaXY+YCk7XG4gIH1cbiAgcmV0dXJuIGFyci5qb2luKCdcXG4nKTtcbn07XG5cbi8qKlxuICogUHJpbnRzIHRoZSB0aHJlZSB0eXBlcyBvZiB0aGUgZW50cnksIGkuZS4gZW50cnksIHJlc291cmNlIGFuZCBncmFwaHR5cGUuXG4gKiBAcGFyYW0ge3N0b3JlL0VudHJ5SW5mb30gZW50cnlJbmZvXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5odG1sLmVudHJ5SW5mbyA9IGVudHJ5SW5mbyA9PlxuICBgPHNwYW4gY2xhc3M9J2luZm8gZW50cnl0eXBlJz48bGFiZWw+RW50cnlUeXBlOjwvbGFiZWw+ICR7ZW50cnlJbmZvLmdldEVudHJ5VHlwZSgpfTwvc3Bhbj5gICtcbiAgYDxzcGFuIGNsYXNzPSdpbmZvIHJlc291cmNlVHlwZSc+PGxhYmVsPlJlc291cmNlVHlwZTo8L2xhYmVsPiAke2VudHJ5SW5mby5nZXRSZXNvdXJjZVR5cGUoKVxuICAgIH08L3NwYW4+YCArXG4gIGA8c3BhbiBjbGFzcz0naW5mbyBncmFwaFR5cGUnPjxsYWJlbD5HcmFwaFR5cGU6PC9sYWJlbD4gJHtlbnRyeUluZm8uZ2V0R3JhcGhUeXBlKCl9PC9zcGFuPmA7XG5cbi8qKlxuICogUHJpbnRzIGluZm9ybWF0aW9uIGFib3V0IHRoZSBlbnRyeSwgaW5jbHVkaW5nIGVudHJ5aW5mbywgbWV0YWRhdGEsIGNhY2hlZCBleHRlcm5hbCBtZXRhZGF0YVxuICogYXMgd2VsbCBhcyB3aGljaCBjb250ZXh0IHRoZSBlbnRyeSBiZWxvbmdzIHRvLlxuICpcbiAqIEBwYXJhbSB7c3RvcmUvRW50cnl9IGVudHJ5XG4gKiBAcmV0dXJucyB7c3RyaW5nfSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZW50cnkgYXMgYSBIVE1MIHN0cmluZy5cbiAqL1xuaHRtbC5wcmludCA9IChlbnRyeSkgPT4ge1xuICBjb25zdCBzdHJzID0gW2Ake1wiPGRpdiBjbGFzcz0nZW50cnknPlwiICtcbiAgXCI8aDM+Q29udGV4dDogPGEgY2xhc3M9J2NvbnRleHRVUkknIGhyZWY9J1wifSR7ZW50cnkuZ2V0Q29udGV4dCgpLmdldEVudHJ5VVJJKCl9Jz4ke2VudHJ5LmdldENvbnRleHQoKS5nZXRJZCgpfTwvYT4gPHNwYW4+PC9zcGFuPiBgICtcbiAgYEVudHJ5OiA8YSBjbGFzcz0nZW50cnlVUkknIGhyZWY9JyR7ZW50cnkuZ2V0VVJJKCl9Jz4ke2VudHJ5LmdldElkKCl9PC9hPjwvaDM+YCArXG4gICc8ZGl2PicgK1xuICBgPGRpdiBjbGFzcz0nZW50cnlJbmZvJz4ke2h0bWwuZW50cnlJbmZvKGVudHJ5LmdldEVudHJ5SW5mbygpKX08L2Rpdj5gXTtcbiAgY29uc3QgbWQgPSBlbnRyeS5nZXRNZXRhZGF0YSgpO1xuICBpZiAobWQgJiYgIW1kLmlzRW1wdHkoKSkge1xuICAgIHN0cnMucHVzaChgPGg0PkxvY2FsIG1ldGFkYXRhOjwvaDQ+PGRpdiBjbGFzcz0nbWV0YWRhdGEnPiR7aHRtbC5tZXRhZGF0YUluZGVudChtZCwgZW50cnkuZ2V0UmVzb3VyY2VVUkkoKSl9PC9kaXY+YCk7XG4gIH1cbiAgY29uc3QgZW1kID0gZW50cnkuZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YSgpO1xuICBpZiAoZW1kICYmICFlbWQuaXNFbXB0eSgpKSB7XG4gICAgc3Rycy5wdXNoKGA8aDQ+Q2FjaGVkIGV4dGVybmFsIG1ldGFkYXRhOjwvaDQ+PGRpdiBjbGFzcz0nbWV0YWRhdGEnPiR7aHRtbC5tZXRhZGF0YUluZGVudChlbWQsIGVudHJ5LmdldFJlc291cmNlVVJJKCkpfTwvZGl2PmApO1xuICB9XG4gIHN0cnMucHVzaCgnPC9kaXY+PC9kaXY+Jyk7XG4gIHJldHVybiBzdHJzLmpvaW4oJycpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgaHRtbDtcbiIsImltcG9ydCAnY29yZS1qcy9zdGFibGUnO1xuaW1wb3J0ICdyZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUnO1xuXG4vKlxuICogVGhlIGV4cG9zZWQgRW50cnlTdG9yZSBBUElcbiAqL1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBmYWN0b3J5IH0gZnJvbSAnLi9mYWN0b3J5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgaHRtbCB9IGZyb20gJy4vaHRtbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHByb21pc2VVdGlsIH0gZnJvbSAnLi9wcm9taXNlVXRpbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHJlc3QgfSBmcm9tICcuL1Jlc3QnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzb2xyIH0gZnJvbSAnLi9Tb2xyUXVlcnknO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB0eXBlcyB9IGZyb20gJy4vdHlwZXMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBBdXRoIH0gZnJvbSAnLi9BdXRoJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ2FjaGUgfSBmcm9tICcuL0NhY2hlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgQ29udGV4dCB9IGZyb20gJy4vQ29udGV4dCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVudHJ5IH0gZnJvbSAnLi9FbnRyeSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVudHJ5SW5mbyB9IGZyb20gJy4vRW50cnlJbmZvJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgRW50cnlTdG9yZSB9IGZyb20gJy4vRW50cnlTdG9yZSc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEVudHJ5U3RvcmVVdGlsIH0gZnJvbSAnLi9FbnRyeVN0b3JlVXRpbCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIEZpbGUgfSBmcm9tICcuL0ZpbGUnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcmFwaCB9IGZyb20gJy4vR3JhcGgnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBHcm91cCB9IGZyb20gJy4vR3JvdXAnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBMaXN0IH0gZnJvbSAnLi9MaXN0JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUGlwZWxpbmUgfSBmcm9tICcuL1BpcGVsaW5lJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUHJvdG90eXBlRW50cnkgfSBmcm9tICcuL1Byb3RvdHlwZUVudHJ5JztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgUmVzb3VyY2UgfSBmcm9tICcuL1Jlc291cmNlJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgU2VhcmNoTGlzdCB9IGZyb20gJy4vU2VhcmNoTGlzdCc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIFN0cmluZyB9IGZyb20gJy4vU3RyaW5nJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgVXNlciB9IGZyb20gJy4vVXNlcic7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHRlcm1zIH0gZnJvbSAnLi90ZXJtcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHV0aWxzIH0gZnJvbSAnLi91dGlscyc7XG5leHBvcnQgeyBuYW1lc3BhY2VzIH0gZnJvbSAncmRmanNvbic7IC8vIEB0b2RvIEB2YWxlbnRpbm8gbm90IGlkZWFsXG4iLCIvKipcbiAqIFRoaXMgbW9kdWxlIGNvbnRhaW5zIHV0aWxpdHkgbWV0aG9kcyBmb3IgcHJvbWlzZXMuXG4gKlxuICogQGV4cG9ydHMgc3RvcmUvcHJvbWlzZVV0aWxcbiAqIEBuYW1lc3BhY2VcbiAqL1xuY29uc3QgcHJvbWlzZVV0aWwgPSB7fTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXMgZm9yRWFjaCByZWx5aW5nIG9uIHByb21pc2VzIHRoYXQgd29ya3MgaW4gc2VyaWFsIHJhdGhlciB0aGFuIHBhcmFsbGVsbC5cbiAqIEl0IGludm9rZXMgYSBmdW5jdGlvbiBvbiBlYWNoIGl0ZW0gb25seSBhZnRlciB0aGUgcHJvbWlzZSBmcm9tIHRoZSBwcmV2aW91cyBpdGVtXG4gKiBpbiB0aGUgYXJyYXkgaGFzIHN1Y2NlZWRlZC5cbiAqIElmIG9uZSBvZiB0aGUgcHJvbWlzZXMgZmFpbHMgdGhlIGZvckVhY2ggcHJvbWlzZSBmYWlscyBhbHRvZ2hldGVyLlxuICogVGhlIHJlc3VsdCBpcyBwcm92aWRlZCBpbiBhbiBhcnJheSBpZiB0aGUgaXRlbXMgaXMgYW4gYXJyYXkuXG4gKiBJbiB0aGUgY2FzZSB3aGVyZSB0aGUgaXRlbXMgaXMgYW4gb2JqZWN0IHRoZSBzYW1lIG9iamVjdCBpcyByZXR1cm5lZFxuICogYnV0IHdpdGggdGhlIHZhbHVlcyByZXBsYWNlZCB3aXRoIHRoZSByZXN1bHQgb2YgdGhlIHByb21pc2UuXG4gKiAoVGhlIGZ1bmN0aW9uIGlzIGFwcGxpZWQgdG8gdGhlIHZhbHVlIG9mIGVhY2gga2V5IGluIHRoZSBpdGVtcyBvYmplY3QuKVxuICpcbiAqIEBwYXJhbSB7YXJyYXl8b2JqZWN0fSBpdGVtc1xuICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyBhIGZ1bmN0aW9uIHRoYXQgaXMgYXBwbGllZCB0byBlYWNoIGl0ZW0gYW5kIG11c3QgcmV0dXJuIGEgcHJvbWlzZVxuICogQHJldHVybnMge1Byb21pc2V9XG4gKi9cbnByb21pc2VVdGlsLmZvckVhY2ggPSAoaXRlbXMsIGZ1bmMpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgbGV0IGFycjtcbiAgbGV0IGN1cnNvcjtcbiAgY29uc3Qgb25GYWlsdXJlID0gKGVycikgPT4ge1xuICAgIHJlamVjdChlcnIpO1xuICB9O1xuICBpZiAoQXJyYXkuaXNBcnJheShpdGVtcykpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgYXJyID0gaXRlbXMuc2xpY2UoKTtcbiAgICBjdXJzb3IgPSAocmVzdWx0KSA9PiB7XG4gICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgIGlmIChhcnIubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZVV0aWwudG9Qcm9taXNlKGZ1bmMoYXJyLnNoaWZ0KCkpKS50aGVuKGN1cnNvciwgb25GYWlsdXJlKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgaWYgKGFyci5sZW5ndGggPT09IDApIHtcbiAgICAgIHJlc29sdmUocmVzdWx0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb21pc2VVdGlsLnRvUHJvbWlzZShmdW5jKGFyci5zaGlmdCgpKSkudGhlbihjdXJzb3IsIG9uRmFpbHVyZSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtcyA9PT0gJ29iamVjdCcpIHtcbiAgICBhcnIgPSBPYmplY3Qua2V5cyhpdGVtcyk7XG4gICAgbGV0IGl0ZW1LZXk7XG4gICAgY29uc3Qgb25TdWNjZXNzID0gKHJlc3VsdCkgPT4ge1xuICAgICAgaXRlbXNbaXRlbUtleV0gPSByZXN1bHQ7XG4gICAgICBjdXJzb3IoKTtcbiAgICB9O1xuICAgIGN1cnNvciA9ICgpID0+IHtcbiAgICAgIGlmIChhcnIubGVuZ3RoID4gMCkge1xuICAgICAgICBpdGVtS2V5ID0gYXJyLnNoaWZ0KCk7XG4gICAgICAgIHByb21pc2VVdGlsLnRvUHJvbWlzZShmdW5jKGl0ZW1zW2l0ZW1LZXldKSkudGhlbihvblN1Y2Nlc3MsIG9uRmFpbHVyZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXNvbHZlKGl0ZW1zKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGN1cnNvcigpO1xuICB9XG59KTtcblxuLyoqXG4gKiBNYWtlcyBzdXJlIGEgdmFsdWUgaXMgYSBwcm9taXNlLCBpZiBuZWVkZWQgd3JhcHMgaXQgYXMgYSBwcm9taXNlLlxuICogSWYgdGhlIHZhbHVlIHRoZSBmYWxzZSBib29sZWFuIGl0IGlzIGludGVycHJldGVkIGFzIGEgcmVqZWN0LlxuICpcbiAqIEBwYXJhbSB7YW55fFByb21pc2V9IHZhbHVlIHRoZSB2YWx1ZSB0byB3cmFwIGluIGEgcHJvbWlzZSwgaWYgaXQgYWxyZWFkeSBpcyBhIHByb21pc2UgaXQgaXMgcmV0dXJuZWQuXG4gKiBAcmV0dXJuIHtQcm9taXNlfVxuICovXG5wcm9taXNlVXRpbC50b1Byb21pc2UgPSAodmFsdWUpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xuICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIFVzZSBzZXRUaW1lb3V0IHdpdGggcHJvbWlzZS4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBkbyB0aGluZ3MgbGlrZVxuICogUHJvbWlzZS5hbGwoXG4gKiAgcHJvbWlzZTEsXG4gKiAgcHJvbWlzZVV0aWwuZGVsYXkoMTAwMCksXG4gKiBdKTtcbiAqIEBwYXJhbSBtaWxsaXNlY3NcbiAqIEByZXR1cm5zIHtQcm9taXNlPGFueT59XG4gKi9cbnByb21pc2VVdGlsLmRlbGF5ID0gbWlsbGlzZWNzID0+IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtaWxsaXNlY3MpKTtcblxuZXhwb3J0IGRlZmF1bHQgcHJvbWlzZVV0aWw7XG5cbiIsImltcG9ydCB7IG5hbWVzcGFjZXMgfSBmcm9tICdyZGZqc29uJztcbmltcG9ydCB0eXBlcyBmcm9tICcuL3R5cGVzJztcblxuY29uc3QgaW52ID0gKG9iaikgPT4ge1xuICBjb25zdCBpb2JqID0ge307XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgaW9ialtvYmpba2V5XV0gPSBrZXk7XG4gIH0pO1xuICByZXR1cm4gaW9iajtcbn07XG5cbi8vIE5hbWVzcGFjZXNcbmNvbnN0IG5zID0gJ2h0dHA6Ly9lbnRyeXN0b3JlLm9yZy90ZXJtcy8nO1xuY29uc3QgcmRmbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyc7XG5jb25zdCB4c2RucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAxL1hNTFNjaGVtYSMnO1xubmFtZXNwYWNlcy5hZGQoJ3Byb3YnLCAnaHR0cDovL3d3dy53My5vcmcvbnMvcHJvdiMnKTtcbm5hbWVzcGFjZXMuYWRkKCdzdG9yZScsIG5zKTtcbm5hbWVzcGFjZXMuYWRkKCdzdG9yZXByJywgJ2h0dHA6Ly9lbnRyeXN0b3JlLm9yZy90ZXJtcy9waXBlbGluZXJlc3VsdCMnKTtcblxuY29uc3QgdGVybXMgPSB7XG4gIGhvbWVDb250ZXh0OiBgJHtuc31ob21lQ29udGV4dGAsXG4gIHJlc291cmNlOiBgJHtuc31yZXNvdXJjZWAsXG4gIG1ldGFkYXRhOiBgJHtuc31tZXRhZGF0YWAsXG4gIGV4dGVybmFsTWV0YWRhdGE6IGAke25zfWV4dGVybmFsTWV0YWRhdGFgLFxuICByZWFzb25pbmdGYWN0czogYCR7bnN9cmVhc29uaW5nRmFjdHNgLFxuICBzdGF0dXM6IHtcbiAgICBwcm9wZXJ0eTogYCR7bnN9c3RhdHVzYCxcbiAgICBJblByb2dyZXNzOiBgJHtuc31JblByb2dyZXNzYCxcbiAgICBQZW5kaW5nOiBgJHtuc31QZW5kaW5nYCxcbiAgICBTdWNjZWVkZWQ6IGAke25zfVN1Y2Nlc3NgLFxuICAgIEZhaWxlZDogYCR7bnN9RmFpbGVkYCxcbiAgfSxcbiAgcmRmOiB7XG4gICAgdHlwZTogYCR7cmRmbnN9dHlwZWAsXG4gIH0sXG4gIHBpcGVsaW5lOiB7XG4gICAgcGlwZWxpbmU6IGAke25zfXBpcGVsaW5lYCxcbiAgICBwaXBlbGluZURhdGE6IGAke25zfXBpcGVsaW5lRGF0YWAsXG4gICAgdHJhbnNmb3JtOiBgJHtuc310cmFuc2Zvcm1gLFxuICAgIHRyYW5zZm9ybVByaW9yaXR5OiBgJHtuc310cmFuc2Zvcm1Qcmlvcml0eWAsXG4gICAgdHJhbnNmb3JtVHlwZTogYCR7bnN9dHJhbnNmb3JtVHlwZWAsXG4gICAgdHJhbnNmb3JtQXJndW1lbnQ6IGAke25zfXRyYW5zZm9ybUFyZ3VtZW50YCxcbiAgICB0cmFuc2Zvcm1Bcmd1bWVudEtleTogYCR7bnN9dHJhbnNmb3JtQXJndW1lbnRLZXlgLFxuICAgIHRyYW5zZm9ybUFyZ3VtZW50VmFsdWU6IGAke25zfXRyYW5zZm9ybUFyZ3VtZW50VmFsdWVgLFxuICAgIHRyYW5zZm9ybURlc3RpbmF0aW9uOiBgJHtuc310cmFuc2Zvcm1EZXN0aW5hdGlvbmAsXG4gICAgdHJhbnNmb3JtRGV0ZWN0RGVzdGluYXRpb246IGAke25zfXRyYW5zZm9ybURldGVjdERlc3RpbmF0aW9uYCxcbiAgfSxcbiAgYWNsOiB7XG4gICAgcmVhZDogYCR7bnN9cmVhZGAsXG4gICAgd3JpdGU6IGAke25zfXdyaXRlYCxcbiAgfSxcbiAgeHNkOiB7XG4gICAgaW50ZWdlcjogYCR7eHNkbnN9aW50ZWdlcmAsXG4gICAgZmxvYXQ6IGAke3hzZG5zfWZsb2F0YCxcbiAgICBib29sZWFuOiBgJHt4c2Ruc31ib29sZWFuYCxcbiAgfSxcbn07XG5cbi8vIEVudHJ5VHlwZVxuY29uc3QgZXQgPSB7fTtcbmV0W2Ake25zfUxvY2FsYF0gPSB0eXBlcy5FVF9MT0NBTDtcbmV0W2Ake25zfUxpbmtgXSA9IHR5cGVzLkVUX0xJTks7XG5ldFtgJHtuc31MaW5rUmVmZXJlbmNlYF0gPSB0eXBlcy5FVF9MSU5LUkVGO1xuZXRbYCR7bnN9UmVmZXJlbmNlYF0gPSB0eXBlcy5FVF9SRUY7XG5ldC5kZWZhdWx0ID0gdHlwZXMuRVRfTE9DQUw7ICAgLy8gVGhlIGRlZmF1bHQgb3B0aW9uXG50ZXJtcy5lbnRyeVR5cGUgPSBldDtcbnRlcm1zLmludkVudHJ5VHlwZSA9IGludihldCk7XG5cbi8vIEdyYXBoVHlwZVxuY29uc3QgZ3QgPSB7fTtcbmd0W2Ake25zfU5vbmVgXSA9IHR5cGVzLkdUX05PTkU7XG5ndFtgJHtuc31Db250ZXh0YF0gPSB0eXBlcy5HVF9DT05URVhUO1xuZ3RbYCR7bnN9U3lzdGVtQ29udGV4dGBdID0gdHlwZXMuR1RfU1lTVEVNQ09OVEVYVDtcbmd0W2Ake25zfVVzZXJgXSA9IHR5cGVzLkdUX1VTRVI7XG5ndFtgJHtuc31Hcm91cGBdID0gdHlwZXMuR1RfR1JPVVA7XG5ndFtgJHtuc31MaXN0YF0gPSB0eXBlcy5HVF9MSVNUO1xuZ3RbYCR7bnN9UmVzdWx0TGlzdGBdID0gdHlwZXMuR1RfUkVTVUxUTElTVDtcbmd0W2Ake25zfUdyYXBoYF0gPSB0eXBlcy5HVF9HUkFQSDtcbmd0W2Ake25zfVBpcGVsaW5lYF0gPSB0eXBlcy5HVF9QSVBFTElORTtcbmd0W2Ake25zfVBpcGVsaW5lUmVzdWx0YF0gPSB0eXBlcy5HVF9QSVBFTElORVJFU1VMVDtcbmd0W2Ake25zfVN0cmluZ2BdID0gdHlwZXMuR1RfU1RSSU5HO1xuZ3QuZGVmYXVsdCA9IHR5cGVzLkdUX05PTkU7IC8vIFRoZSBkZWZhdWx0IG9wdGlvblxudGVybXMuZ3JhcGhUeXBlID0gZ3Q7XG50ZXJtcy5pbnZHcmFwaFR5cGUgPSBpbnYoZ3QpO1xuXG4vLyBSZXNvdXJjZVR5cGVcbmNvbnN0IHJ0ID0ge307XG5ydFtgJHtuc31JbmZvcm1hdGlvblJlc291cmNlYF0gPSB0eXBlcy5SVF9JTkZPUk1BVElPTlJFU09VUkNFO1xucnRbYCR7bnN9UmVzb2x2YWJsZUluZm9ybWF0aW9uUmVzb3VyY2VgXSA9IHR5cGVzLlJUX1JFU09MVkFCTEVJTkZPUk1BVElPTlJFU09VUkNFO1xucnRbYCR7bnN9TmFtZWRSZXNvdXJjZWBdID0gdHlwZXMuUlRfTkFNRURSRVNPVVJDRTtcbnJ0W2Ake25zfVVua25vd25gXSA9IHR5cGVzLlJUX1VOS05PV047XG5ydC5kZWZhdWx0ID0gdHlwZXMuUlRfSU5GT1JNQVRJT05SRVNPVVJDRTsgLy8gVGhlIGRlZmF1bHQgb3B0aW9uXG50ZXJtcy5yZXNvdXJjZVR5cGUgPSBydDtcbnRlcm1zLmludlJlc291cmNlVHlwZSA9IGludihydCk7XG5cbmV4cG9ydCBkZWZhdWx0IHRlcm1zO1xuIiwiLyoqXG4gICAqIFR5cGVzIGlzIGEgbW9kdWxlIGNvbnRhaW5pbmcgdGhlIHRocmVlIGRpZmZlcmVudCB0eXBlczogR3JhcGhUeXBlLCBFbnRyeVR5cGUgYW5kXG4gICAqIFJlc291cmNlVHlwZSBzaG9ydGVuZWQgR1QsIEVUIGFuZCBSVC5cbiAgICpcbiAgICogQGV4cG9ydHMge3N0b3JlL3R5cGVzfVxuICAgKi9cbmNvbnN0IHR5cGVzID0ge1xuICAvKipcbiAgICogTG9jYWwgZW50cnl0eXBlIGltcGxpZXMgdGhhdCB0aGUgcmVzb3VyY2UgaXMgbWFpbnRhaW5lZCBpbiB0aGUgcmVwb3NpdG9yeS5cbiAgICogSXQgY2FuIGJlIGFuIHVwbG9hZGVkIGZpbGUsIGEgbGlzdCwgYSBncm91cCwgYSB1c2VyIGV0Yy4gVGhlIG5hdHVyZSBvZiB0aGUgcmVzb3VyY2VcbiAgICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgZ3JhcGh0eXBlLlxuICAgKlxuICAgKiBAY29uc3RcbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc0xvY2FsXG4gICAqL1xuICBFVF9MT0NBTDogJ0xvY2FsJyxcblxuICAvKipcbiAgICogTGluayBFbnRyeVR5cGUgaW1wbGllcyB0aGF0IHRoZSByZXNvdXJjZSBpcyBub3QgbWFpbnRhaW5lZCBpbiB0aGUgcmVwb3NpdG9yeSwgcmF0aGVyIHRoZVxuICAgKiBlbnRyeSBvbmx5IHByb3ZpZGVzIGEgbGluayB0byB0aGUgcmVzb3VyY2UuXG4gICAqIFRoZSBtZXRhZGF0YSBpcyBzdGlsbCBtYWludGFpbmVkIGluIHRoZSByZXBvc2l0b3J5IHRob3VnaC5cbiAgICpcbiAgICogQGNvbnN0XG4gICAqIEBzZWUgc3RvcmUvRW50cnkjaXNMaW5rXG4gICAqL1xuICBFVF9MSU5LOiAnTGluaycsXG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gbGluaywgb25seSB0aGUgbWV0YWRhdGEgaXMgYWxzbyBleHRlcm5hbCB0byB0aGUgcmVwb3NpdG9yeS5cbiAgICogSW4gbWFueSBjYXNlcyBpdCBpcyBwb3NzaWJsZSB0byBhY2Nlc3MgYSBsb2NhbGx5IGNhY2hlZCB2ZXJzaW9uIG9mIHRoZSBleHRlcm5hbFxuICAgKiBtZXRhZGF0YSB0aG91Z2guXG4gICAqIEBzZWUgc3RvcmUvRW50cnkjZ2V0Q2FjaGVkRXh0ZXJuYWxNZXRhZGF0YVxuICAgKiBAc2VlIHN0b3JlL0VudHJ5I2lzUmVmZXJlbmNlXG4gICAqL1xuICBFVF9SRUY6ICdSZWZlcmVuY2UnLFxuXG4gIC8qKlxuICAgKiBTaW1pbGFyIHRvIGxpbmsgYW5kIHJlZmVyZW5jZSwgb25seSB0aGVyZSBpcyBib3RoIGxvY2FsIG1ldGFkYXRhIGFuZCBleHRlcm5hbCBtZXRhZGF0YS5cbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc0xpbmtSZWZlcmVuY2VcbiAgICovXG4gIEVUX0xJTktSRUY6ICdMaW5rcmVmZXJlbmNlJyxcblxuICAvKipcbiAgICogTm8gZ3JhcGggdHlwZSBzcGVjaWZpZWQgbWVhbnMgdGhhdCBubyBrbm93bGVkZ2Ugb2YgdGhlIHJlc291cmNlcyBjaGFyYWN0ZXIgaXMga25vd24uXG4gICAqIEhlbmNlLCBubyBzcGVjaWFsIHRyZWF0bWVudCBvZiB0aGUgcmVzb3VyY2UgaXMgZXhwZWN0ZWQuXG4gICAqIFRoaXMgaXMgY29tbW9uIHdoZW4gaGFuZGxpbmcgcmVndWxhciBmaWxlcywgd2ViIHJlc291cmNlcyBvciBhYnN0cmFjdCBlbnRpdGllcy5cbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc05vbmVcbiAgICovXG4gIEdUX05PTkU6ICdOb25lJyxcblxuICAvKipcbiAgICogVGhlIHJlc291cmNlIGlzIGEgY29udGV4dCwgaS5lLiBhIGNvbnRhaW5lciBmb3Igb3RoZXIgZW50cmllcy5cbiAgICpcbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc0NvbnRleHRcbiAgICogQHNlZSBzdG9yZS9Db250ZXh0XG4gICAqL1xuICBHVF9DT05URVhUOiAnQ29udGV4dCcsXG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBpcyBvbmUgb2YgdGhlIHNwZWNpYWwgY29udGV4dCBvZiB0aGlzIHJlcG9zaXRvcnksIGUuZy4gX2NvbnRleHRzIG9yIF9wcmluY2lwYWxzLlxuICAgKiBAc2VlIHN0b3JlL0VudHJ5I2lzU3lzdGVtQ29udGV4dFxuICAgKi9cbiAgR1RfU1lTVEVNQ09OVEVYVDogJ1N5c3RlbWNvbnRleHQnLFxuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgaXMgYSB1c2VyLlxuICAgKlxuICAgKiBAc2VlIHN0b3JlL0VudHJ5I2lzVXNlclxuICAgKiBAc2VlIHN0b3JlL1VzZXJcbiAgICovXG4gIEdUX1VTRVI6ICdVc2VyJyxcblxuICAvKipcbiAgICogVGhlIHJlc291cmNlIGlzIGEgZ3JvdXAuXG4gICAqXG4gICAqIEBzZWUgc3RvcmUvRW50cnkjaXNHcm91cFxuICAgKiBAc2VlIHN0b3JlL0dyb3VwXG4gICAqL1xuICBHVF9HUk9VUDogJ0dyb3VwJyxcblxuICAvKipcbiAgICogVGhlIHJlc291cmNlIGlzIGEgbGlzdC5cbiAgICpcbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc0xpc3RcbiAgICogQHNlZSBzdG9yZS9MaXN0XG4gICAqL1xuICBHVF9MSVNUOiAnTGlzdCcsXG5cbiAgLyoqXG4gICAqIEB0b2RvIHJlbWFpbnMgdG8gYmUgc3VwcG9ydGVkIGluIHRoaXMgQVBJXG4gICAqIEBzZWUgc3RvcmUvRW50cnkjaXNSZXN1bHRMaXN0XG4gICAqL1xuICBHVF9SRVNVTFRMSVNUOiAnUmVzdWx0bGlzdCcsXG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBpcyBhIFJERiBncmFwaC5cbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc0dyYXBoXG4gICAqIEBzZWUgc3RvcmUvR3JhcGhcbiAgICovXG4gIEdUX0dSQVBIOiAnR3JhcGgnLFxuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgaXMgYSBzdHJpbmcuXG4gICAqIEBzZWUgc3RvcmUvRW50cnkjaXNTdHJpbmdcbiAgICogQHNlZSBzdG9yZS9TdHJpbmdcbiAgICovXG4gIEdUX1NUUklORzogJ1N0cmluZycsXG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBpcyBhIHBpcGVsaW5lLCBlLmcuIGFuIGVudHJ5IHRoYXQgY2FuIHNvbWVob3cgYmUgZXhlY3V0ZWQgb24gdGhlIHNlcnZlciBzaWRlLlxuICAgKiBAc2VlIHN0b3JlL0VudHJ5I2lzUGlwZWxpbmVcbiAgICogQHNlZSBzdG9yZS9QaXBlbGluZVxuICAgKi9cbiAgR1RfUElQRUxJTkU6ICdQaXBlbGluZScsXG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBpcyBhIHBpcGVsaW5lcmVzdWx0LCBlLmcuIHRoZSByZXN1bHQgb2YgdGhlIGV4ZWN1dGlvbiBvZiBhIHBpcGVsaW5lXG4gICAqIG9uIHRoZSBzZXJ2ZXIgc2lkZS5cbiAgICogQHNlZSBzdG9yZS9FbnRyeSNpc1BpcGVsaW5lUmVzdWx0XG4gICAqIEBzZWUgc3RvcmUvUGlwZWxpbmVcbiAgICovXG4gIEdUX1BJUEVMSU5FUkVTVUxUOiAnUGlwZWxpbmVSZXN1bHQnLFxuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgaXMgYXZhaWxhYmxlIGFzIGEgZGlnaXRhbCByZXByZXNlbnRhdGlvbiBvZiBzb21lIHNvcnQuXG4gICAqIE9wcG9zaXRlIHRvIHJlc291cmNlcyB0aGF0IGhhdmUgbm8gcmVwcmVzZW50YXRpb24sIHJlZmVycmVkIHRvIGFzXG4gICAqIHtAbGluayBzdG9yZS90eXBlcy5OQU1FRFJFU09VUkNFIG5hbWVkfS5cbiAgICovXG4gIFJUX0lORk9STUFUSU9OUkVTT1VSQ0U6ICdJbmZvcm1hdGlvbicsXG5cbiAgLyoqXG4gICAqIFRoZSByZXNvdXJjZSBpcyByZXNvbHZhYmxlIHRvIGFub3RoZXIgYWRkcmVzcy5cbiAgICogQHRvZG8gdGhlIEFQSSBoYXMgbGl0dGxlIHN1cHBvcnQgZm9yIHRoaXMgdHlwZSBjdXJyZW50bHkuXG4gICAqL1xuICBSVF9SRVNPTFZBQkxFSU5GT1JNQVRJT05SRVNPVVJDRTogJ1Jlc29sdmFibGUnLFxuXG4gIC8qKlxuICAgKiBUaGUgcmVzb3VyY2UgaXMgbm90IGF2YWlsYWJsZSBkaWdpdGFsbHksIGkuZS4gaXQgaGFzIG5vdyBkaWdpdGFsIHJlcHJlc2VudGF0aW9uIHRoYXRcbiAgICogY2FuIGJlIHRyYW5zZmVycmVkIG92ZXIgYSBuZXR3b3JrLlxuICAgKi9cbiAgUlRfTkFNRURSRVNPVVJDRTogJ05hbWVkJyxcblxuICAvKipcbiAgICogSXQgaXMgdW5rbm93biBpZiB0aGUgcmVzb3VyY2UgaGFzIGEgcmVwcmVzZW50YXRpb24gb3Igbm90LCB0eXBpY2FsbHkgdGhpcyBpcyB0aGUgY2FzZSB3aGVuXG4gICAqIGxhcmdlIGFtb3VudHMgb2YgcmVzb3VyY2VzIGFyZSBoYXJ2ZXN0ZWQgZnJvbSBhbm90aGVyIHN5c3RlbSBhbmQgaXQgaXMgbm90IGZlYXNpYmxlIHRvIHRyeVxuICAgKiB0byBsb2FkIHRoZW0gdG8gY2hlY2sgd2VhdGhlciB0aGV5IGhhdmUgYSBkaWdpdGFsIHJlcHJlc2VudGF0aW9uIG9yIG5vdC4gQXQgbGVhc3QgdGhlIGNoZWNrXG4gICAqIGNhbm5vdCBiZSBkb25lIGluaXRpYWxseSBhbmQgdGhlcmVmb3JlIHRoZSB0eXBlIGlzIHNldCB0byB1bmtub3duLlxuICAgKi9cbiAgUlRfVU5LTk9XTjogJ1Vua25vd24nLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgdHlwZXM7XG4iLCJcbmNvbnN0IHV0aWxzID0ge307XG5cbnV0aWxzLmdldFJlbGF0ZWRUb0VudHJ5VVJJcyA9IChmcm9tRW50cnkpID0+IHtcbiAgY29uc3QgZXMgPSBmcm9tRW50cnkuZ2V0RW50cnlTdG9yZSgpO1xuICBjb25zdCBiYXNlID0gZnJvbUVudHJ5LmdldEVudHJ5U3RvcmUoKS5nZXRCYXNlVVJJKCk7XG4gIGNvbnN0IHJlbGF0ZWRFbnRyeVVSSXMgPSBbXTtcbiAgZnJvbUVudHJ5LmdldE1ldGFkYXRhKCkuZmluZCgpLmZvckVhY2goKHN0bXQpID0+IHtcbiAgICBpZiAoc3RtdC5nZXRUeXBlKCkgPT09ICd1cmknKSB7XG4gICAgICBjb25zdCBvYmogPSBzdG10LmdldFZhbHVlKCk7XG4gICAgICBpZiAob2JqLmluZGV4T2YoYmFzZSkgPT09IDApIHtcbiAgICAgICAgY29uc3QgdXJpID0gZXMuZ2V0RW50cnlVUkkoZXMuZ2V0Q29udGV4dElkKG9iaiksIGVzLmdldEVudHJ5SWQob2JqKSk7XG4gICAgICAgIHJlbGF0ZWRFbnRyeVVSSXMucHVzaCh1cmkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiByZWxhdGVkRW50cnlVUklzO1xufTtcblxudXRpbHMuZ2V0UmVsYXRlZFRvRW50cmllcyA9IChmcm9tRW50cnkpID0+IHtcbiAgY29uc3QgZXMgPSBmcm9tRW50cnkuZ2V0RW50cnlTdG9yZSgpO1xuICByZXR1cm4gUHJvbWlzZS5hbGwodXRpbHMuZ2V0UmVsYXRlZFRvRW50cnlVUklzKGZyb21FbnRyeSkubWFwKHVyaSA9PiBlcy5nZXRFbnRyeSh1cmkpKSk7XG59O1xuXG51dGlscy5yZW1vdmUgPSAoZW50cnkpID0+IHtcbiAgY29uc3QgZXMgPSBlbnRyeS5nZXRFbnRyeVN0b3JlKCk7XG4gIGNvbnN0IGNhY2hlID0gZXMuZ2V0Q2FjaGUoKTtcbiAgY29uc3QgcmVmU3RtdHMgPSBlbnRyeS5nZXRSZWZlcnJlcnNHcmFwaCgpLmZpbmQoKTtcbiAgY29uc3QgZW50cnlQcm9taXNlcyA9IHJlZlN0bXRzLm1hcCgoc3RtdCkgPT4ge1xuICAgIGNvbnN0IHN1YmogPSBzdG10LmdldFN1YmplY3QoKTtcbiAgICBjb25zdCBldXJpID0gZXMuZ2V0RW50cnlVUkkoZXMuZ2V0Q29udGV4dElkKHN1YmopLCBlcy5nZXRFbnRyeUlkKHN1YmopKTtcbiAgICByZXR1cm4gZXMuZ2V0RW50cnkoZXVyaSk7XG4gIH0pO1xuICByZXR1cm4gZW50cnkuZGVsKCkudGhlbigoKSA9PiBQcm9taXNlLmFsbChlbnRyeVByb21pc2VzKS50aGVuKChhcnIpID0+IHtcbiAgICBjb25zdCBwcm9taXNlcyA9IHJlZlN0bXRzLm1hcCgoc3RtdCwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBtZCA9IGFycltpZHhdLmdldE1ldGFkYXRhKCk7XG4gICAgICBtZC5yZW1vdmUoc3RtdCk7XG4gICAgICByZXR1cm4gYXJyW2lkeF0uY29tbWl0TWV0YWRhdGEoKTtcbiAgICB9KTtcbiAgICBjb25zdCB1cmlzID0gdXRpbHMuZ2V0UmVsYXRlZFRvRW50cnlVUklzKGVudHJ5KTtcbiAgICB1cmlzLmZvckVhY2goKHVyaSkgPT4ge1xuICAgICAgY29uc3QgZSA9IGNhY2hlLmdldCh1cmkpO1xuICAgICAgaWYgKGUgIT0gbnVsbCkge1xuICAgICAgICBlLnNldFJlZnJlc2hOZWVkZWQoKTtcbiAgICAgICAgcHJvbWlzZXMucHVzaChlLnJlZnJlc2goKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgfSkpO1xufTtcblxudXRpbHMuYWRkUmVsYXRpb24gPSAoZnJvbUVudHJ5LCBwcm9wZXJ0eSwgdG9FbnRyeSkgPT4ge1xuICBmcm9tRW50cnkuZ2V0TWV0YWRhdGEoKS5hZGQoZnJvbUVudHJ5LmdldFJlc291cmNlVVJJKCksIHByb3BlcnR5LCB0b0VudHJ5LmdldFJlc291cmNlVVJJKCkpO1xuICByZXR1cm4gZnJvbUVudHJ5LmNvbW1pdE1ldGFkYXRhKCkudGhlbigoKSA9PiB7XG4gICAgdG9FbnRyeS5zZXRSZWZyZXNoTmVlZGVkKCk7XG4gICAgcmV0dXJuIHRvRW50cnkucmVmcmVzaCgpO1xuICB9KTtcbn07XG5cbnV0aWxzLnJlbW92ZVJlbGF0aW9uID0gKGZyb21FbnRyeSwgcHJvcGVydHksIHRvRW50cnkpID0+IHtcbiAgZnJvbUVudHJ5LmdldE1ldGFkYXRhKCkucmVtb3ZlKGZyb21FbnRyeS5nZXRSZXNvdXJjZVVSSSgpLCBwcm9wZXJ0eSwgeyB0eXBlOiAndXJpJywgdmFsdWU6IHRvRW50cnkuZ2V0UmVzb3VyY2VVUkkoKSB9KTtcbiAgcmV0dXJuIGZyb21FbnRyeS5jb21taXRNZXRhZGF0YSgpLnRoZW4oKCkgPT4ge1xuICAgIHRvRW50cnkuc2V0UmVmcmVzaE5lZWRlZCgpO1xuICAgIHJldHVybiB0b0VudHJ5LnJlZnJlc2goKTtcbiAgfSk7XG59O1xuXG4vLyBSZWxpZXMgb24gdGhlcmUgbm90IGJlaW5nIGEgd2luZG93LmRvY3VtZW50IGluIE5vZGVcbi8vIEJhc2VkIG9mZiBvZjogaHR0cHM6Ly9naXRodWIuY29tL2ZsZXhkaW5lc2gvYnJvd3Nlci1vci1ub2RlL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xuY29uc3QgaXNCcm93c2VyID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG51dGlscy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5jb25zdCBpc05vZGUgPSAoKSA9PiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgIT09ICd1bmRlZmluZWQnO1xudXRpbHMuaXNOb2RlID0gaXNOb2RlO1xuY29uc3QgaXNJRSA9ICgpID0+IHdpbmRvdyAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvTVNJRS8pICE9PSBudWxsO1xudXRpbHMuaXNJRSA9IGlzSUU7XG5cbmV4cG9ydCB7XG4gIHV0aWxzLFxuICBpc0Jyb3dzZXIsXG4gIGlzTm9kZSxcbiAgaXNJRSxcbn07XG5leHBvcnQgZGVmYXVsdCB1dGlscztcbiJdLCJzb3VyY2VSb290IjoiIn0=